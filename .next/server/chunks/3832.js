exports.id = 3832;
exports.ids = [3832];
exports.modules = {

/***/ 33783:
/***/ ((module) => {

/**
 * Contains all configured adapters for the given environment.
 *
 * @type {Array}
 * @public
 */ var adapters = [];
/**
 * Contains all modifier functions.
 *
 * @typs {Array}
 * @public
 */ var modifiers = [];
/**
 * Our default logger.
 *
 * @public
 */ var logger = function devnull() {};
/**
 * Register a new adapter that will used to find environments.
 *
 * @param {Function} adapter A function that will return the possible env.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */ function use(adapter) {
    if (~adapters.indexOf(adapter)) return false;
    adapters.push(adapter);
    return true;
}
/**
 * Assign a new log method.
 *
 * @param {Function} custom The log method.
 * @public
 */ function set(custom) {
    logger = custom;
}
/**
 * Check if the namespace is allowed by any of our adapters.
 *
 * @param {String} namespace The namespace that needs to be enabled
 * @returns {Boolean|Promise} Indication if the namespace is enabled by our adapters.
 * @public
 */ function enabled(namespace) {
    var async = [];
    for(var i = 0; i < adapters.length; i++){
        if (adapters[i].async) {
            async.push(adapters[i]);
            continue;
        }
        if (adapters[i](namespace)) return true;
    }
    if (!async.length) return false;
    //
    // Now that we know that we Async functions, we know we run in an ES6
    // environment and can use all the API's that they offer, in this case
    // we want to return a Promise so that we can `await` in React-Native
    // for an async adapter.
    //
    return new Promise(function pinky(resolve) {
        Promise.all(async.map(function prebind(fn) {
            return fn(namespace);
        })).then(function resolved(values) {
            resolve(values.some(Boolean));
        });
    });
}
/**
 * Add a new message modifier to the debugger.
 *
 * @param {Function} fn Modification function.
 * @returns {Boolean} Indication of a successful add.
 * @public
 */ function modify(fn) {
    if (~modifiers.indexOf(fn)) return false;
    modifiers.push(fn);
    return true;
}
/**
 * Write data to the supplied logger.
 *
 * @param {Object} meta Meta information about the log.
 * @param {Array} args Arguments for console.log.
 * @public
 */ function write() {
    logger.apply(logger, arguments);
}
/**
 * Process the message with the modifiers.
 *
 * @param {Mixed} message The message to be transformed by modifers.
 * @returns {String} Transformed message.
 * @public
 */ function process(message) {
    for(var i = 0; i < modifiers.length; i++){
        message = modifiers[i].apply(modifiers[i], arguments);
    }
    return message;
}
/**
 * Introduce options to the logger function.
 *
 * @param {Function} fn Calback function.
 * @param {Object} options Properties to introduce on fn.
 * @returns {Function} The passed function
 * @public
 */ function introduce(fn, options) {
    var has = Object.prototype.hasOwnProperty;
    for(var key in options){
        if (has.call(options, key)) {
            fn[key] = options[key];
        }
    }
    return fn;
}
/**
 * Nope, we're not allowed to write messages.
 *
 * @returns {Boolean} false
 * @public
 */ function nope(options) {
    options.enabled = false;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(function diagnopes() {
        return false;
    }, options);
}
/**
 * Yep, we're allowed to write debug messages.
 *
 * @param {Object} options The options for the process.
 * @returns {Function} The function that does the logging.
 * @public
 */ function yep(options) {
    /**
   * The function that receives the actual debug information.
   *
   * @returns {Boolean} indication that we're logging.
   * @public
   */ function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process(args, options));
        return true;
    }
    options.enabled = true;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(diagnostics, options);
}
/**
 * Simple helper function to introduce various of helper methods to our given
 * diagnostics function.
 *
 * @param {Function} diagnostics The diagnostics function.
 * @returns {Function} diagnostics
 * @public
 */ module.exports = function create(diagnostics) {
    diagnostics.introduce = introduce;
    diagnostics.enabled = enabled;
    diagnostics.process = process;
    diagnostics.modify = modify;
    diagnostics.write = write;
    diagnostics.nope = nope;
    diagnostics.yep = yep;
    diagnostics.set = set;
    diagnostics.use = use;
    return diagnostics;
};


/***/ }),

/***/ 6355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// Select the correct build version depending on the environment.
//
if (true) {
    module.exports = __webpack_require__(77873);
} else {}


/***/ }),

/***/ 77873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var create = __webpack_require__(33783);
/**
 * Create a new diagnostics logger.
 *
 * @param {String} namespace The namespace it should enable.
 * @param {Object} options Additional options.
 * @returns {Function} The logger.
 * @public
 */ var diagnostics = create(function prod(namespace, options) {
    options = options || {};
    options.namespace = namespace;
    options.prod = true;
    options.dev = false;
    if (!(options.force || prod.force)) return prod.nope(options);
    return prod.yep(options);
});
//
// Expose the diagnostics logger.
//
module.exports = diagnostics;


/***/ }),

/***/ 34537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $dJwbH$react = __webpack_require__(46261);
function $parcel$export(e, n, v, s) {
    Object.defineProperty(e, n, {
        get: v,
        set: s,
        enumerable: true,
        configurable: true
    });
}
$parcel$export(module.exports, "composeRefs", ()=>$9c2aaba23466b352$export$43e446d32b3d21af);
$parcel$export(module.exports, "useComposedRefs", ()=>$9c2aaba23466b352$export$c7b2cbe3552a0d05);
/**
 * Set a given ref to a given value
 * This utility takes care of different types of refs: callback refs and RefObject(s)
 */ function $9c2aaba23466b352$var$setRef(ref, value) {
    if (typeof ref === "function") ref(value);
    else if (ref !== null && ref !== undefined) ref.current = value;
}
/**
 * A utility to compose multiple refs together
 * Accepts callback refs and RefObject(s)
 */ function $9c2aaba23466b352$export$43e446d32b3d21af(...refs) {
    return (node)=>refs.forEach((ref)=>$9c2aaba23466b352$var$setRef(ref, node));
}
/**
 * A custom hook that composes multiple refs
 * Accepts callback refs and RefObject(s)
 */ function $9c2aaba23466b352$export$c7b2cbe3552a0d05(...refs) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return $dJwbH$react.useCallback($9c2aaba23466b352$export$43e446d32b3d21af(...refs), refs);
} //# sourceMappingURL=index.js.map


/***/ }),

/***/ 22294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Body: ()=>Body
});
module.exports = __toCommonJS(src_exports);
// src/body.tsx
var import_jsx_runtime = __webpack_require__(56786);
var Body = ({ children, style, ...props })=>{
    const styleDefault = {
        wordSpacing: "normal",
        ...style
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("body", {
        ...props,
        "data-id": "__react-email-body",
        style,
        children
    });
};
Body.displayName = "Body";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 23703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Column: ()=>Column
});
module.exports = __toCommonJS(src_exports);
// src/column.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Column = React.forwardRef(({ children, style, ...props }, forwardedRef)=>{
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", {
        ...props,
        ref: forwardedRef,
        "data-id": "__react-email-column",
        style,
        children
    });
});
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 32969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Button: ()=>Button
});
module.exports = __toCommonJS(src_exports);
// src/button.tsx
var React = __toESM(__webpack_require__(46261));
// src/utils/px-to-pt.ts
var pxToPt = (px)=>isNaN(Number(px)) ? null : parseInt(px, 10) * 3 / 4;
// src/button.tsx
var import_jsx_runtime = __webpack_require__(56786);
var Button = React.forwardRef(({ children, style, pX = 0, pY = 0, target = "_blank", ...props }, forwardedRef)=>{
    const y = (pY || 0) * 2;
    const textRaise = pxToPt(y.toString());
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("a", {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-button",
        target,
        style: buttonStyle({
            ...style,
            pX,
            pY
        }),
        children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
                dangerouslySetInnerHTML: {
                    __html: `<!--[if mso]><i style="letter-spacing: ${pX}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`
                }
            }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
                style: buttonTextStyle(pY),
                children
            }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
                dangerouslySetInnerHTML: {
                    __html: `<!--[if mso]><i style="letter-spacing: ${pX}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`
                }
            })
        ]
    });
});
Button.displayName = "Button";
var buttonStyle = (style)=>{
    const { pY, pX, ...rest } = style || {};
    return {
        ...rest,
        lineHeight: "100%",
        textDecoration: "none",
        display: "inline-block",
        maxWidth: "100%",
        padding: `${pY}px ${pX}px`
    };
};
var buttonTextStyle = (pY)=>{
    const paddingY = pY || 0;
    return {
        maxWidth: "100%",
        display: "inline-block",
        lineHeight: "120%",
        msoPaddingAlt: "0px",
        msoTextRaise: pxToPt(paddingY.toString())
    };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 20142:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Container: ()=>Container
});
module.exports = __toCommonJS(src_exports);
// src/container.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Container = React.forwardRef(({ children, style, ...props }, forwardedRef)=>{
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
        align: "center",
        width: "100%",
        ...props,
        ref: forwardedRef,
        "data-id": "__react-email-container",
        role: "presentation",
        cellSpacing: "0",
        cellPadding: "0",
        border: 0,
        style: {
            maxWidth: "37.5em",
            ...style
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", {
            children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", {
                style: {
                    width: "100%"
                },
                children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", {
                    children
                })
            })
        })
    });
});
Container.displayName = "Container";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 11493:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Font: ()=>Font
});
module.exports = __toCommonJS(src_exports);
// src/font.tsx
var import_jsx_runtime = __webpack_require__(56786);
var Font = ({ fontFamily, fallbackFontFamily, webFont, fontStyle = "normal", fontWeight = 400 })=>{
    const src = webFont ? `src: url(${webFont.url}) format('${webFont.format}');` : "";
    const style = `
    @font-face {
      font-family: '${fontFamily}';
      font-style: ${fontStyle};
      font-weight: ${fontWeight};
      mso-font-alt: '${Array.isArray(fallbackFontFamily) ? fallbackFontFamily[0] : fallbackFontFamily}';
      ${src}
    }

    * {
      font-family: '${fontFamily}', ${Array.isArray(fallbackFontFamily) ? fallbackFontFamily.join(", ") : fallbackFontFamily};
    }
  `;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
        dangerouslySetInnerHTML: {
            __html: style
        }
    });
};
Font.displayName = "Font";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 83229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Head: ()=>Head
});
module.exports = __toCommonJS(src_exports);
// src/head.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Head = React.forwardRef(({ children, ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("head", {
        ...props,
        ref: forwardedRef,
        "data-id": "__react-email-head",
        children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("meta", {
                httpEquiv: "Content-Type",
                content: "text/html; charset=UTF-8"
            }),
            children
        ]
    }));
Head.displayName = "Head";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 80554:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Heading: ()=>Heading
});
module.exports = __toCommonJS(src_exports);
// src/heading.tsx
var import_react_slot = __webpack_require__(74333);
var React = __toESM(__webpack_require__(46261));
// src/utils/spaces.ts
var withMargin = (props)=>[
        withSpace(props.m, [
            "margin"
        ]),
        withSpace(props.mx, [
            "marginLeft",
            "marginRight"
        ]),
        withSpace(props.my, [
            "marginTop",
            "marginBottom"
        ]),
        withSpace(props.mt, [
            "marginTop"
        ]),
        withSpace(props.mr, [
            "marginRight"
        ]),
        withSpace(props.mb, [
            "marginBottom"
        ]),
        withSpace(props.ml, [
            "marginLeft"
        ])
    ].filter((s)=>Object.keys(s).length)[0];
var withSpace = (value, properties)=>{
    return properties.reduce((styles, property)=>{
        if (value) {
            return {
                ...styles,
                [property]: `${value}px`
            };
        }
        return styles;
    }, {});
};
// src/heading.tsx
var import_jsx_runtime = __webpack_require__(56786);
var Heading = React.forwardRef(({ as: Tag = "h1", children, style, m, mx, my, mt, mr, mb, ml, ...props }, forwardedRef)=>{
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_slot.Slot, {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-heading",
        style: {
            ...withMargin({
                m,
                mx,
                my,
                mt,
                mr,
                mb,
                ml
            }),
            ...style
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Tag, {
            children
        })
    });
});
Heading.displayName = "Heading";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 74333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $dAvBt$babelruntimehelpersextends = __webpack_require__(99060);
var $dAvBt$react = __webpack_require__(46261);
var $dAvBt$radixuireactcomposerefs = __webpack_require__(34537);
function $parcel$export(e, n, v, s) {
    Object.defineProperty(e, n, {
        get: v,
        set: s,
        enumerable: true,
        configurable: true
    });
}
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
$parcel$export(module.exports, "Slot", ()=>$82dc8d030dec7549$export$8c6ed5c666ac1360);
$parcel$export(module.exports, "Slottable", ()=>$82dc8d030dec7549$export$d9f1ccf0bdb05d45);
$parcel$export(module.exports, "Root", ()=>$82dc8d030dec7549$export$be92b6f5f03c0fe9);
/* -------------------------------------------------------------------------------------------------
 * Slot
 * -----------------------------------------------------------------------------------------------*/ const $82dc8d030dec7549$export$8c6ed5c666ac1360 = /*#__PURE__*/ $dAvBt$react.forwardRef((props, forwardedRef)=>{
    const { children: children, ...slotProps } = props;
    const childrenArray = $dAvBt$react.Children.toArray(children);
    const slottable = childrenArray.find($82dc8d030dec7549$var$isSlottable);
    if (slottable) {
        // the new element to render is the one passed as a child of `Slottable`
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child)=>{
            if (child === slottable) {
                // because the new element will be the one rendered, we are only interested
                // in grabbing its children (`newElement.props.children`)
                if ($dAvBt$react.Children.count(newElement) > 1) return $dAvBt$react.Children.only(null);
                return /*#__PURE__*/ $dAvBt$react.isValidElement(newElement) ? newElement.props.children : null;
            } else return child;
        });
        return /*#__PURE__*/ $dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {
            ref: forwardedRef
        }), /*#__PURE__*/ $dAvBt$react.isValidElement(newElement) ? /*#__PURE__*/ $dAvBt$react.cloneElement(newElement, undefined, newChildren) : null);
    }
    return /*#__PURE__*/ $dAvBt$react.createElement($82dc8d030dec7549$var$SlotClone, $parcel$interopDefault($dAvBt$babelruntimehelpersextends)({}, slotProps, {
        ref: forwardedRef
    }), children);
});
$82dc8d030dec7549$export$8c6ed5c666ac1360.displayName = "Slot";
/* -------------------------------------------------------------------------------------------------
 * SlotClone
 * -----------------------------------------------------------------------------------------------*/ const $82dc8d030dec7549$var$SlotClone = /*#__PURE__*/ $dAvBt$react.forwardRef((props, forwardedRef)=>{
    const { children: children, ...slotProps } = props;
    if (/*#__PURE__*/ $dAvBt$react.isValidElement(children)) return /*#__PURE__*/ $dAvBt$react.cloneElement(children, {
        ...$82dc8d030dec7549$var$mergeProps(slotProps, children.props),
        ref: $dAvBt$radixuireactcomposerefs.composeRefs(forwardedRef, children.ref)
    });
    return $dAvBt$react.Children.count(children) > 1 ? $dAvBt$react.Children.only(null) : null;
});
$82dc8d030dec7549$var$SlotClone.displayName = "SlotClone";
/* -------------------------------------------------------------------------------------------------
 * Slottable
 * -----------------------------------------------------------------------------------------------*/ const $82dc8d030dec7549$export$d9f1ccf0bdb05d45 = ({ children: children })=>{
    return /*#__PURE__*/ $dAvBt$react.createElement($dAvBt$react.Fragment, null, children);
};
/* ---------------------------------------------------------------------------------------------- */ function $82dc8d030dec7549$var$isSlottable(child) {
    return /*#__PURE__*/ $dAvBt$react.isValidElement(child) && child.type === $82dc8d030dec7549$export$d9f1ccf0bdb05d45;
}
function $82dc8d030dec7549$var$mergeProps(slotProps, childProps) {
    // all child props should override
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName); // if it's a handler, modify the override by composing the base handler
        if (isHandler) overrideProps[propName] = (...args)=>{
            childPropValue === null || childPropValue === void 0 || childPropValue(...args);
            slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
        };
        else if (propName === "style") overrideProps[propName] = {
            ...slotPropValue,
            ...childPropValue
        };
        else if (propName === "className") overrideProps[propName] = [
            slotPropValue,
            childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
const $82dc8d030dec7549$export$be92b6f5f03c0fe9 = $82dc8d030dec7549$export$8c6ed5c666ac1360; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 35526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Hr: ()=>Hr
});
module.exports = __toCommonJS(src_exports);
// src/hr.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Hr = React.forwardRef(({ style, ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsx)("hr", {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-hr",
        style: {
            width: "100%",
            border: "none",
            borderTop: "1px solid #eaeaea",
            ...style
        }
    }));
Hr.displayName = "Hr";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 66240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Html: ()=>Html
});
module.exports = __toCommonJS(src_exports);
// src/html.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Html = React.forwardRef(({ children, lang = "en", ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsx)("html", {
        ref: forwardedRef,
        lang,
        ...props,
        children
    }));
Html.displayName = "Html";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 98388:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Img: ()=>Img
});
module.exports = __toCommonJS(src_exports);
// src/img.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Img = React.forwardRef(({ alt, src, width, height, style, ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsx)("img", {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-img",
        alt,
        src,
        width,
        height,
        style: {
            display: "block",
            outline: "none",
            border: "none",
            textDecoration: "none",
            ...style
        }
    }));
Img.displayName = "Img";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 24533:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Link: ()=>Link
});
module.exports = __toCommonJS(src_exports);
// src/link.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Link = React.forwardRef(({ target = "_blank", style, ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-link",
        target,
        style: {
            color: "#067df7",
            textDecoration: "none",
            ...style
        }
    }));
Link.displayName = "Link";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 20908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Preview: ()=>Preview
});
module.exports = __toCommonJS(src_exports);
// src/preview.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var PREVIEW_MAX_LENGTH = 150;
var Preview = React.forwardRef(({ children = "", ...props }, forwardedRef)=>{
    let text = Array.isArray(children) ? children.join("") : children;
    text = text.substr(0, PREVIEW_MAX_LENGTH);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
        ref: forwardedRef,
        id: "__react-email-preview",
        style: {
            display: "none",
            overflow: "hidden",
            lineHeight: "1px",
            opacity: 0,
            maxHeight: 0,
            maxWidth: 0
        },
        ...props,
        children: [
            text,
            renderWhiteSpace(text)
        ]
    });
});
var renderWhiteSpace = (text)=>{
    if (text.length >= PREVIEW_MAX_LENGTH) {
        return null;
    }
    const whiteSpaceCodes = "\xa0‌​‍‎‏\uFEFF";
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
        children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text.length)
    });
};
Preview.displayName = "Preview";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 74449:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    render: ()=>render,
    renderAsync: ()=>renderAsync
});
module.exports = __toCommonJS(src_exports);
// src/render.ts
var ReactDomServer = __toESM(__webpack_require__(3473));
var import_html_to_text = __webpack_require__(41612);
var import_pretty = __toESM(__webpack_require__(8231));
var render = (component, options)=>{
    if (options == null ? void 0 : options.plainText) {
        return renderAsPlainText(component, options);
    }
    const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
    const markup = ReactDomServer.renderToStaticMarkup(component);
    const document = `${doctype}${markup}`;
    if (options && options.pretty) {
        return (0, import_pretty.default)(document);
    }
    return document;
};
var renderAsPlainText = (component, _options)=>{
    return (0, import_html_to_text.convert)(ReactDomServer.renderToStaticMarkup(component), {
        selectors: [
            {
                selector: "img",
                format: "skip"
            },
            {
                selector: "#__react-email-preview",
                format: "skip"
            }
        ]
    });
};
// src/renderAsync.ts
var import_html_to_text2 = __webpack_require__(41612);
var import_pretty2 = __toESM(__webpack_require__(8231));
var import_server = __webpack_require__(3473);
async function renderToString(children) {
    const stream = await (0, import_server.renderToReadableStream)(children);
    const html = await readableStreamToString(stream);
    return html.replace(/^<!DOCTYPE html>/, "").replace(/<!-- -->/g, "");
}
async function readableStreamToString(readableStream) {
    let result = "";
    const decoder = new TextDecoder();
    for await (const chunk of readableStream){
        result += decoder.decode(chunk);
    }
    return result;
}
var renderAsync = async (component, options)=>{
    const markup = typeof import_server.renderToStaticMarkup === "undefined" ? await renderToString(component) : (0, import_server.renderToStaticMarkup)(component);
    if (options == null ? void 0 : options.plainText) {
        return (0, import_html_to_text2.convert)(markup, {
            selectors: [
                {
                    selector: "img",
                    format: "skip"
                },
                {
                    selector: "#__react-email-preview",
                    format: "skip"
                }
            ]
        });
    }
    const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
    const document = `${doctype}${markup}`;
    if (options == null ? void 0 : options.pretty) {
        return (0, import_pretty2.default)(document);
    }
    return document;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 74549:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Row: ()=>Row
});
module.exports = __toCommonJS(src_exports);
// src/row.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Row = React.forwardRef(({ children, style, ...props }, forwardedRef)=>{
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
        align: "center",
        width: "100%",
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-row",
        style,
        role: "presentation",
        cellSpacing: "0",
        cellPadding: "0",
        border: 0,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", {
            style: {
                width: "100%"
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", {
                style: {
                    width: "100%"
                },
                children
            })
        })
    });
});
Row.displayName = "Row";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 57353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Section: ()=>Section
});
module.exports = __toCommonJS(src_exports);
// src/section.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Section = React.forwardRef(({ children, style, ...props }, forwardedRef)=>{
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
        align: "center",
        width: "100%",
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-section",
        style,
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation",
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", {
            children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", {
                children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", {
                    children
                })
            })
        })
    });
});
Section.displayName = "Section";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 97026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Tailwind: ()=>Tailwind
});
module.exports = __toCommonJS(src_exports);
// src/tailwind.tsx
var React = __toESM(__webpack_require__(46261));
var import_server = __webpack_require__(3473);
var import_html_react_parser = __toESM(__webpack_require__(45363));
var import_tw_to_css = __webpack_require__(97959);
var import_jsx_runtime = __webpack_require__(56786);
var Tailwind = ({ children, config })=>{
    const { twi } = (0, import_tw_to_css.tailwindToCSS)({
        config
    });
    const newChildren = React.Children.toArray(children);
    const fullHTML = (0, import_server.renderToStaticMarkup)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children: newChildren
    }));
    const tailwindCss = twi(fullHTML, {
        merge: false,
        ignoreMediaQueries: false
    });
    const css = cleanCss(tailwindCss);
    const cssMap = makeCssMap(css);
    const headStyle = getMediaQueryCss(css);
    const hasResponsiveStyles = /@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm.test(headStyle);
    const hasHTML = /<html[^>]*>/gm.test(fullHTML);
    const hasHead = /<head[^>]*>/gm.test(fullHTML);
    if (hasResponsiveStyles && (!hasHTML || !hasHead)) {
        throw new Error("Tailwind: To use responsive styles you must have a <html> and <head> element in your template.");
    }
    const reactHTML = React.Children.map(newChildren, (child)=>{
        if (!React.isValidElement(child)) return child;
        const html = (0, import_server.renderToStaticMarkup)(child);
        const parsedHTML = (0, import_html_react_parser.default)(html, {
            replace: (domNode)=>{
                var _a;
                if (domNode instanceof import_html_react_parser.Element) {
                    if (hasResponsiveStyles && hasHead && domNode.name === "head") {
                        let newDomNode = null;
                        if (domNode.children) {
                            const props = (0, import_html_react_parser.attributesToProps)(domNode.attribs);
                            newDomNode = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("head", {
                                ...props,
                                children: [
                                    (0, import_html_react_parser.domToReact)(domNode.children),
                                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
                                        children: headStyle
                                    })
                                ]
                            });
                        }
                        return newDomNode;
                    }
                    if ((_a = domNode.attribs) == null ? void 0 : _a.class) {
                        const cleanRegex = /[:#\!\-[\]\/\.%]+/g;
                        const cleanTailwindClasses = domNode.attribs.class.replace(cleanRegex, "_");
                        const currentStyles = domNode.attribs.style ? `${domNode.attribs.style};` : "";
                        const tailwindStyles = cleanTailwindClasses.split(" ").map((className)=>{
                            return cssMap[`.${className}`];
                        }).join(";");
                        domNode.attribs.style = `${currentStyles} ${tailwindStyles}`;
                        domNode.attribs.class = domNode.attribs.class.split(" ").filter((className)=>className.search(/^.{2}:/) !== -1).join(" ").replace(cleanRegex, "_");
                        if (domNode.attribs.class === "") delete domNode.attribs.class;
                    }
                }
            }
        });
        return parsedHTML;
    });
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children: reactHTML
    });
};
Tailwind.displayName = "Tailwind";
function cleanCss(css) {
    let newCss = css.replace(/\\/g, "").replace(/[.\!\#\w\d\\:\-\[\]\/\.%\(\))]+(?=\s*?{[^{]*?\})\s*?{/g, (m)=>{
        return m.replace(/(?<=.)[:#\!\-[\\\]\/\.%]+/g, "_");
    }).replace(/font-family(?<value>[^;\r\n]+)/g, (m, value)=>{
        return `font-family${value.replace(/['"]+/g, "")}`;
    });
    return newCss;
}
function getMediaQueryCss(css) {
    var _a;
    const mediaQueryRegex = /@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm;
    return ((_a = css.replace(mediaQueryRegex, (m)=>{
        return m.replace(/([^{]+\{)([\s\S]+?)(\}\s*\})/gm, (_, start, content, end)=>{
            const newContent = content.replace(/(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^};\r\n]+)/gm, (_2, prop, value)=>{
                return `${prop}: ${value} !important;`;
            });
            return `${start}${newContent}${end}`;
        });
    }).match(/@media\s*([^{]+)\{([^{}]*\{[^{}]*\})*[^{}]*\}/g)) == null ? void 0 : _a.join("")) ?? "";
}
function makeCssMap(css) {
    const cssNoMedia = css.replace(/@media[^{]+\{(?<content>[\s\S]+?)\}\s*\}/gm, "");
    const cssMap = cssNoMedia.split("}").reduce((acc, cur)=>{
        const [key, value] = cur.split("{");
        if (key && value) {
            acc[key] = value;
        }
        return acc;
    }, {});
    return cssMap;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 66601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(39469);
var node_js_1 = __webpack_require__(98447);
__exportStar(__webpack_require__(98447), exports);
// Default options
var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
};
var DomHandler = /** @class */ function() {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */ function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */ this.dom = [];
        /** The root element for the DOM */ this.root = new node_js_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */ this.done = false;
        /** Stack of open tags. */ this.tagStack = [
            this.root
        ];
        /** A data node that is still being written to. */ this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */ this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function(parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [
            this.root
        ];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function() {
        if (this.done) return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function(error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB) this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_js_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function(data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function() {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([
            text
        ]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        } else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}();
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 98447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(39469);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */ var Node = /** @class */ function() {
    function Node() {
        /** Parent of the node */ this.parent = null;
        /** Previous sibling */ this.prev = null;
        /** Next sibling */ this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */ this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */ this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.parent;
        },
        set: function(parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.prev;
        },
        set: function(prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.next;
        },
        set: function(next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */ Node.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
            recursive = false;
        }
        return cloneNode(this, recursive);
    };
    return Node;
}();
exports.Node = Node;
/**
 * A node that contains some data.
 */ var DataNode = /** @class */ function(_super) {
    __extends(DataNode, _super);
    /**
     * @param data The content of the data node
     */ function DataNode(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.data;
        },
        set: function(data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node);
exports.DataNode = DataNode;
/**
 * Text within the document.
 */ var Text = /** @class */ function(_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
    }
    Object.defineProperty(Text.prototype, "nodeType", {
        get: function() {
            return 3;
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(DataNode);
exports.Text = Text;
/**
 * Comments within the document.
 */ var Comment = /** @class */ function(_super) {
    __extends(Comment, _super);
    function Comment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
    }
    Object.defineProperty(Comment.prototype, "nodeType", {
        get: function() {
            return 8;
        },
        enumerable: false,
        configurable: true
    });
    return Comment;
}(DataNode);
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */ var ProcessingInstruction = /** @class */ function(_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
    }
    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    return ProcessingInstruction;
}(DataNode);
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */ var NodeWithChildren = /** @class */ function(_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param children Children of the node. Only certain node types can have children.
     */ function NodeWithChildren(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */ get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */ get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.children;
        },
        set: function(children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node);
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /** @class */ function(_super) {
    __extends(CDATA, _super);
    function CDATA() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
    }
    Object.defineProperty(CDATA.prototype, "nodeType", {
        get: function() {
            return 4;
        },
        enumerable: false,
        configurable: true
    });
    return CDATA;
}(NodeWithChildren);
exports.CDATA = CDATA;
/**
 * The root node of the document.
 */ var Document = /** @class */ function(_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
    }
    Object.defineProperty(Document.prototype, "nodeType", {
        get: function() {
            return 9;
        },
        enumerable: false,
        configurable: true
    });
    return Document;
}(NodeWithChildren);
exports.Document = Document;
/**
 * An element within the DOM.
 */ var Element = /** @class */ function(_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */ function Element(name, attribs, children, type) {
        if (children === void 0) {
            children = [];
        }
        if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
    }
    Object.defineProperty(Element.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.name;
        },
        set: function(name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
                var _a, _b;
                return {
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
                };
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren);
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */ function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */ function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */ function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */ function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */ function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */ function cloneNode(node, recursive) {
    if (recursive === void 0) {
        recursive = false;
    }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    } else if (isComment(node)) {
        result = new Comment(node.data);
    } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
            return child.parent = clone_1;
        });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
            return child.parent = clone_2;
        });
        result = clone_2;
    } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
            return child.parent = clone_3;
        });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    } else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function(child) {
        return cloneNode(child, true);
    });
    for(var i = 1; i < children.length; i++){
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 56574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getFeed = void 0;
var stringify_js_1 = __webpack_require__(20086);
var legacy_js_1 = __webpack_require__(97183);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */ function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */ function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
            var _a;
            var children = item.children;
            var entry = {
                media: getMediaElements(children)
            };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */ function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
            var children = item.children;
            var entry = {
                media: getMediaElements(children)
            };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
            if (pubDate) entry.pubDate = new Date(pubDate);
            return entry;
        })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = [
    "url",
    "type",
    "lang"
];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */ function getMediaElements(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"]
        };
        for(var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++){
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for(var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++){
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs["expression"]) {
            media.expression = attribs["expression"];
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */ function getOneElement(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */ function fetch(tagName, where, recurse) {
    if (recurse === void 0) {
        recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */ function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) {
        recurse = false;
    }
    var val = fetch(tagName, where, recurse);
    if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */ function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
} //# sourceMappingURL=feeds.js.map


/***/ }),

/***/ 77200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(66601);
/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */ function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */ while(--idx >= 0){
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */ if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for(var ancestor = node.parent; ancestor; ancestor = ancestor.parent){
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */ var DocumentPosition;
(function(DocumentPosition) {
    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */ function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while(current){
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while(current){
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while(idx < maxIdx && aParents[idx] === bParents[idx]){
        idx++;
    }
    if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */ function uniqueSort(nodes) {
    nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
    });
    nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
            return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort; //# sourceMappingURL=helpers.js.map


/***/ }),

/***/ 42029:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(20086), exports);
__exportStar(__webpack_require__(47155), exports);
__exportStar(__webpack_require__(87737), exports);
__exportStar(__webpack_require__(85850), exports);
__exportStar(__webpack_require__(97183), exports);
__exportStar(__webpack_require__(77200), exports);
__exportStar(__webpack_require__(56574), exports);
/** @deprecated Use these methods from `domhandler` directly. */ var domhandler_1 = __webpack_require__(66601);
Object.defineProperty(exports, "isTag", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isTag;
    }
}));
Object.defineProperty(exports, "isCDATA", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isCDATA;
    }
}));
Object.defineProperty(exports, "isText", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isText;
    }
}));
Object.defineProperty(exports, "isComment", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isComment;
    }
}));
Object.defineProperty(exports, "isDocument", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isDocument;
    }
}));
Object.defineProperty(exports, "hasChildren", ({
    enumerable: true,
    get: function() {
        return domhandler_1.hasChildren;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 97183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(66601);
var querying_js_1 = __webpack_require__(85850);
/**
 * A map of functions to check nodes against.
 */ var Checks = {
    tag_name: function(name) {
        if (typeof name === "function") {
            return function(elem) {
                return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
        } else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function(elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
    },
    tag_type: function(type) {
        if (typeof type === "function") {
            return function(elem) {
                return type(elem.type);
            };
        }
        return function(elem) {
            return elem.type === type;
        };
    },
    tag_contains: function(data) {
        if (typeof data === "function") {
            return function(elem) {
                return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
        }
        return function(elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
    }
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */ function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function(elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
    }
    return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */ function combineFuncs(a, b) {
    return function(elem) {
        return a(elem) || b(elem);
    };
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */ function compileTest(options) {
    var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */ function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */ function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) {
        limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */ function getElementById(id, nodes, recurse) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (!Array.isArray(nodes)) nodes = [
        nodes
    ];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */ function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */ function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType; //# sourceMappingURL=legacy.js.map


/***/ }),

/***/ 87737:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */ function removeElement(elem) {
    if (elem.prev) elem.prev.next = elem.next;
    if (elem.next) elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
        }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */ function replaceElement(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
        prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
        next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */ function appendChild(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    } else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */ function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    } else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */ function prependChild(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
    } else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */ function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend; //# sourceMappingURL=manipulation.js.map


/***/ }),

/***/ 85850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(66601);
/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */ function filter(test, node, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return find(test, Array.isArray(node) ? node : [
        node
    ], recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */ function find(test, nodes, recurse, limit) {
    var result = [];
    /** Stack of the arrays we are looking at. */ var nodeStack = [
        nodes
    ];
    /** Stack of the indices within the arrays. */ var indexStack = [
        0
    ];
    for(;;){
        // First, check if the current array has any more elements to look at.
        if (indexStack[0] >= nodeStack[0].length) {
            // If we have no more arrays to look at, we are done.
            if (indexStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0) return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            /*
             * Add the children to the stack. We are depth-first, so this is
             * the next array we look at.
             */ indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */ function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */ function findOne(test, nodes, recurse) {
    if (recurse === void 0) {
        recurse = true;
    }
    var elem = null;
    for(var i = 0; i < nodes.length && !elem; i++){
        var node = nodes[i];
        if (!(0, domhandler_1.isTag)(node)) {
            continue;
        } else if (test(node)) {
            elem = node;
        } else if (recurse && node.children.length > 0) {
            elem = findOne(test, node.children, true);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */ function existsOne(test, nodes) {
    return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
    });
}
exports.existsOne = existsOne;
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */ function findAll(test, nodes) {
    var result = [];
    var nodeStack = [
        nodes
    ];
    var indexStack = [
        0
    ];
    for(;;){
        if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem)) continue;
        if (test(elem)) result.push(elem);
        if (elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.findAll = findAll; //# sourceMappingURL=querying.js.map


/***/ }),

/***/ 20086:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(66601);
var dom_serializer_1 = __importDefault(__webpack_require__(82856));
var domelementtype_1 = __webpack_require__(39469);
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */ function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */ function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node) {
        return getOuterHTML(node, options);
    }).join("") : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */ function getText(node) {
    if (Array.isArray(node)) return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node)) return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */ function textContent(node) {
    if (Array.isArray(node)) return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */ function innerText(node) {
    if (Array.isArray(node)) return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.innerText = innerText; //# sourceMappingURL=stringify.js.map


/***/ }),

/***/ 47155:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(66601);
/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */ function getChildren(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */ function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */ function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null) return getChildren(parent);
    var siblings = [
        elem
    ];
    var prev = elem.prev, next = elem.next;
    while(prev != null){
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
    }
    while(next != null){
        siblings.push(next);
        _b = next, next = _b.next;
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */ function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */ function hasAttrib(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */ function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */ function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while(next !== null && !(0, domhandler_1.isTag)(next))_a = next, next = _a.next;
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */ function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while(prev !== null && !(0, domhandler_1.isTag)(prev))_a = prev, prev = _a.prev;
    return prev;
}
exports.prevElementSibling = prevElementSibling; //# sourceMappingURL=traversal.js.map


/***/ }),

/***/ 35554:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * When running on Node.js, use the server parser.
 * When bundling for the browser, use the client parser.
 *
 * @see {@link https://github.com/substack/node-browserify#browser-field}
 */ var HTMLDOMParser = __webpack_require__(43621);
module.exports = HTMLDOMParser;
module.exports["default"] = HTMLDOMParser;


/***/ }),

/***/ 43621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Parser = (__webpack_require__(62665).Parser);
var DomHandler = (__webpack_require__(66601).DomHandler);
var unsetRootParent = (__webpack_require__(14464).unsetRootParent);
/**
 * Parses HTML string to DOM nodes in Node.js.
 *
 * This is the same method as `require('htmlparser2').parseDOM`
 * https://github.com/fb55/htmlparser2/blob/v6.0.0/src/index.ts#L29-L41
 *
 * @param  {string}            html      - HTML markup.
 * @param  {DomHandlerOptions} [options] - Parser options (https://github.com/fb55/domhandler/tree/v4.0.0#readme).
 * @return {Array<Comment|Element|ProcessingInstruction|Text>} - DOM nodes.
 */ function HTMLDOMParser(html, options) {
    if (typeof html !== "string") {
        throw new TypeError("First argument must be a string.");
    }
    if (html === "") {
        return [];
    }
    var handler = new DomHandler(undefined, options);
    new Parser(handler, options).end(html);
    return unsetRootParent(handler.dom);
}
module.exports = HTMLDOMParser;


/***/ }),

/***/ 14464:
/***/ ((module) => {

/**
 * Sets root parent to null.
 *
 * @param  {Array<Comment|Element|ProcessingInstruction|Text>} nodes
 * @return {Array<Comment|Element|ProcessingInstruction|Text>}
 */ function unsetRootParent(nodes) {
    for(var index = 0, len = nodes.length; index < len; index++){
        var node = nodes[index];
        node.parent = null;
    }
    return nodes;
}
module.exports = {
    unsetRootParent: unsetRootParent
};


/***/ }),

/***/ 45363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var domhandler = __webpack_require__(66601);
var htmlToDOM = __webpack_require__(35554);
var attributesToProps = __webpack_require__(29281);
var domToReact = __webpack_require__(70569);
// support backwards compatibility for ES Module
htmlToDOM = /* istanbul ignore next */ typeof htmlToDOM.default === "function" ? htmlToDOM.default : htmlToDOM;
var domParserOptions = {
    lowerCaseAttributeNames: false
};
/**
 * Converts HTML string to React elements.
 *
 * @param {string} html - HTML string.
 * @param {object} [options] - Parser options.
 * @param {object} [options.htmlparser2] - htmlparser2 options.
 * @param {object} [options.library] - Library for React, Preact, etc.
 * @param {Function} [options.replace] - Replace method.
 * @returns {JSX.Element|JSX.Element[]|string} - React element(s), empty array, or string.
 */ function HTMLReactParser(html, options) {
    if (typeof html !== "string") {
        throw new TypeError("First argument must be a string");
    }
    if (html === "") {
        return [];
    }
    options = options || {};
    return domToReact(htmlToDOM(html, options.htmlparser2 || domParserOptions), options);
}
HTMLReactParser.domToReact = domToReact;
HTMLReactParser.htmlToDOM = htmlToDOM;
HTMLReactParser.attributesToProps = attributesToProps;
// domhandler
HTMLReactParser.Comment = domhandler.Comment;
HTMLReactParser.Element = domhandler.Element;
HTMLReactParser.ProcessingInstruction = domhandler.ProcessingInstruction;
HTMLReactParser.Text = domhandler.Text;
// support CommonJS and ES Modules
module.exports = HTMLReactParser;
HTMLReactParser.default = HTMLReactParser;


/***/ }),

/***/ 29281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var reactProperty = __webpack_require__(38880);
var utilities = __webpack_require__(38036);
/**
 * Converts HTML/SVG DOM attributes to React props.
 *
 * @param {object} [attributes={}] - HTML/SVG DOM attributes.
 * @param {string} [nodeName] - DOM node name.
 * @returns - React props.
 */ module.exports = function attributesToProps(attributes, nodeName) {
    attributes = attributes || {};
    var valueOnlyInputs = {
        reset: true,
        submit: true
    };
    var attributeName;
    var attributeNameLowerCased;
    var attributeValue;
    var propName;
    var propertyInfo;
    var props = {};
    var inputIsValueOnly = attributes.type && valueOnlyInputs[attributes.type];
    for(attributeName in attributes){
        attributeValue = attributes[attributeName];
        // ARIA (aria-*) or custom data (data-*) attribute
        if (reactProperty.isCustomAttribute(attributeName)) {
            props[attributeName] = attributeValue;
            continue;
        }
        // convert HTML/SVG attribute to React prop
        attributeNameLowerCased = attributeName.toLowerCase();
        propName = getPropName(attributeNameLowerCased);
        if (propName) {
            propertyInfo = reactProperty.getPropertyInfo(propName);
            // convert attribute to uncontrolled component prop (e.g., `value` to `defaultValue`)
            // https://reactjs.org/docs/uncontrolled-components.html
            if ((propName === "checked" || propName === "value") && nodeName !== "option" && !inputIsValueOnly) {
                propName = getPropName("default" + attributeNameLowerCased);
            }
            props[propName] = attributeValue;
            switch(propertyInfo && propertyInfo.type){
                case reactProperty.BOOLEAN:
                    props[propName] = true;
                    break;
                case reactProperty.OVERLOADED_BOOLEAN:
                    if (attributeValue === "") {
                        props[propName] = true;
                    }
                    break;
            }
            continue;
        }
        // preserve custom attribute if React >=16
        if (utilities.PRESERVE_CUSTOM_ATTRIBUTES) {
            props[attributeName] = attributeValue;
        }
    }
    // transform inline style to object
    utilities.setStyleProp(attributes.style, props);
    return props;
};
/**
 * Gets prop name from lowercased attribute name.
 *
 * @param {string} attributeName - Lowercased attribute name.
 * @returns - Prop name.
 */ function getPropName(attributeName) {
    return reactProperty.possibleStandardNames[attributeName];
}


/***/ }),

/***/ 70569:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var React = __webpack_require__(46261);
var attributesToProps = __webpack_require__(29281);
var utilities = __webpack_require__(38036);
var setStyleProp = utilities.setStyleProp;
var canTextBeChildOfNode = utilities.canTextBeChildOfNode;
/**
 * Converts DOM nodes to JSX element(s).
 *
 * @param {DomElement[]} nodes - DOM nodes.
 * @param {object} [options={}] - Options.
 * @param {Function} [options.replace] - Replacer.
 * @param {object} [options.library] - Library (React, Preact, etc.).
 * @returns - String or JSX element(s).
 */ function domToReact(nodes, options) {
    options = options || {};
    var library = options.library || React;
    var cloneElement = library.cloneElement;
    var createElement = library.createElement;
    var isValidElement = library.isValidElement;
    var result = [];
    var node;
    var isWhitespace;
    var hasReplace = typeof options.replace === "function";
    var replaceElement;
    var props;
    var children;
    var trim = options.trim;
    for(var i = 0, len = nodes.length; i < len; i++){
        node = nodes[i];
        // replace with custom React element (if present)
        if (hasReplace) {
            replaceElement = options.replace(node);
            if (isValidElement(replaceElement)) {
                // set "key" prop for sibling elements
                // https://fb.me/react-warning-keys
                if (len > 1) {
                    replaceElement = cloneElement(replaceElement, {
                        key: replaceElement.key || i
                    });
                }
                result.push(replaceElement);
                continue;
            }
        }
        if (node.type === "text") {
            isWhitespace = !node.data.trim().length;
            if (isWhitespace && node.parent && !canTextBeChildOfNode(node.parent)) {
                continue;
            }
            if (trim && isWhitespace) {
                continue;
            }
            // We have a text node that's not whitespace and it can be nested
            // in its parent so add it to the results
            result.push(node.data);
            continue;
        }
        props = node.attribs;
        if (skipAttributesToProps(node)) {
            setStyleProp(props.style, props);
        } else if (props) {
            props = attributesToProps(props, node.name);
        }
        children = null;
        switch(node.type){
            case "script":
            case "style":
                // prevent text in <script> or <style> from being escaped
                // https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
                if (node.children[0]) {
                    props.dangerouslySetInnerHTML = {
                        __html: node.children[0].data
                    };
                }
                break;
            case "tag":
                // setting textarea value in children is an antipattern in React
                // https://reactjs.org/docs/forms.html#the-textarea-tag
                if (node.name === "textarea" && node.children[0]) {
                    props.defaultValue = node.children[0].data;
                } else if (node.children && node.children.length) {
                    // continue recursion of creating React elements (if applicable)
                    children = domToReact(node.children, options);
                }
                break;
            // skip all other cases (e.g., comment)
            default:
                continue;
        }
        // set "key" prop for sibling elements
        // https://fb.me/react-warning-keys
        if (len > 1) {
            props.key = i;
        }
        result.push(createElement(node.name, props, children));
    }
    return result.length === 1 ? result[0] : result;
}
/**
 * Determines whether DOM element attributes should be transformed to props.
 * Web Components should not have their attributes transformed except for `style`.
 *
 * @param {DomElement} node
 * @returns - Whether node attributes should be converted to props.
 */ function skipAttributesToProps(node) {
    return utilities.PRESERVE_CUSTOM_ATTRIBUTES && node.type === "tag" && utilities.isCustomComponent(node.name, node.attribs);
}
module.exports = domToReact;


/***/ }),

/***/ 38036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var React = __webpack_require__(46261);
var styleToJS = (__webpack_require__(73066)["default"]);
/**
 * Swap key with value in an object.
 *
 * @param {object} obj - The object.
 * @param {Function} [override] - The override method.
 * @returns - The inverted object.
 */ function invertObject(obj, override) {
    if (!obj || typeof obj !== "object") {
        throw new TypeError("First argument must be an object");
    }
    var key;
    var value;
    var isOverridePresent = typeof override === "function";
    var overrides = {};
    var result = {};
    for(key in obj){
        value = obj[key];
        if (isOverridePresent) {
            overrides = override(key, value);
            if (overrides && overrides.length === 2) {
                result[overrides[0]] = overrides[1];
                continue;
            }
        }
        if (typeof value === "string") {
            result[value] = key;
        }
    }
    return result;
}
/**
 * Check if a given tag is a custom component.
 *
 * @see {@link https://github.com/facebook/react/blob/v16.6.3/packages/react-dom/src/shared/isCustomComponent.js}
 *
 * @param {string} tagName - The name of the html tag.
 * @param {object} props - The props being passed to the element.
 * @returns - Whether tag is custom component.
 */ function isCustomComponent(tagName, props) {
    if (tagName.indexOf("-") === -1) {
        return props && typeof props.is === "string";
    }
    switch(tagName){
        // These are reserved SVG and MathML elements.
        // We don't mind this whitelist too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return false;
        default:
            return true;
    }
}
var styleToJSOptions = {
    reactCompat: true
};
/**
 * Sets style prop.
 *
 * @param {null|undefined|string} style
 * @param {object} props
 */ function setStyleProp(style, props) {
    if (style === null || style === undefined) {
        return;
    }
    try {
        props.style = styleToJS(style, styleToJSOptions);
    } catch (err) {
        props.style = {};
    }
}
/**
 * @constant {boolean}
 * @see {@link https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html}
 */ var PRESERVE_CUSTOM_ATTRIBUTES = React.version.split(".")[0] >= 16;
// Taken from
// https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react-dom/src/client/validateDOMNesting.js#L213
var elementsWithNoTextChildren = new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
]);
/**
 * Checks if the given node can contain text nodes
 *
 * @param {DomElement} node - Node.
 * @returns - Whether node can contain text nodes.
 */ function canTextBeChildOfNode(node) {
    return !elementsWithNoTextChildren.has(node.name);
}
module.exports = {
    PRESERVE_CUSTOM_ATTRIBUTES: PRESERVE_CUSTOM_ATTRIBUTES,
    invertObject: invertObject,
    isCustomComponent: isCustomComponent,
    setStyleProp: setStyleProp,
    canTextBeChildOfNode: canTextBeChildOfNode,
    elementsWithNoTextChildren: elementsWithNoTextChildren
};


/***/ }),

/***/ 23187:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Parser = void 0;
var Tokenizer_js_1 = __importStar(__webpack_require__(24179));
var decode_js_1 = __webpack_require__(12657);
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
]);
var pTag = new Set([
    "p"
]);
var tableSectionTags = new Set([
    "thead",
    "tbody"
]);
var ddtTags = new Set([
    "dd",
    "dt"
]);
var rtpTags = new Set([
    "rt",
    "rp"
]);
var openImpliesClose = new Map([
    [
        "tr",
        new Set([
            "tr",
            "th",
            "td"
        ])
    ],
    [
        "th",
        new Set([
            "th"
        ])
    ],
    [
        "td",
        new Set([
            "thead",
            "th",
            "td"
        ])
    ],
    [
        "body",
        new Set([
            "head",
            "link",
            "script"
        ])
    ],
    [
        "li",
        new Set([
            "li"
        ])
    ],
    [
        "p",
        pTag
    ],
    [
        "h1",
        pTag
    ],
    [
        "h2",
        pTag
    ],
    [
        "h3",
        pTag
    ],
    [
        "h4",
        pTag
    ],
    [
        "h5",
        pTag
    ],
    [
        "h6",
        pTag
    ],
    [
        "select",
        formTags
    ],
    [
        "input",
        formTags
    ],
    [
        "output",
        formTags
    ],
    [
        "button",
        formTags
    ],
    [
        "datalist",
        formTags
    ],
    [
        "textarea",
        formTags
    ],
    [
        "option",
        new Set([
            "option"
        ])
    ],
    [
        "optgroup",
        new Set([
            "optgroup",
            "option"
        ])
    ],
    [
        "dd",
        ddtTags
    ],
    [
        "dt",
        ddtTags
    ],
    [
        "address",
        pTag
    ],
    [
        "article",
        pTag
    ],
    [
        "aside",
        pTag
    ],
    [
        "blockquote",
        pTag
    ],
    [
        "details",
        pTag
    ],
    [
        "div",
        pTag
    ],
    [
        "dl",
        pTag
    ],
    [
        "fieldset",
        pTag
    ],
    [
        "figcaption",
        pTag
    ],
    [
        "figure",
        pTag
    ],
    [
        "footer",
        pTag
    ],
    [
        "form",
        pTag
    ],
    [
        "header",
        pTag
    ],
    [
        "hr",
        pTag
    ],
    [
        "main",
        pTag
    ],
    [
        "nav",
        pTag
    ],
    [
        "ol",
        pTag
    ],
    [
        "pre",
        pTag
    ],
    [
        "section",
        pTag
    ],
    [
        "table",
        pTag
    ],
    [
        "ul",
        pTag
    ],
    [
        "rt",
        rtpTags
    ],
    [
        "rp",
        rtpTags
    ],
    [
        "tbody",
        tableSectionTags
    ],
    [
        "tfoot",
        tableSectionTags
    ]
]);
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
var foreignContextElements = new Set([
    "math",
    "svg"
]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ function() {
    function Parser(cbs, options) {
        if (options === void 0) {
            options = {};
        }
        var _a, _b, _c, _d, _e;
        this.options = options;
        /** The start index of the last event. */ this.startIndex = 0;
        /** The end index of the last event. */ this.endIndex = 0;
        /**
         * Store the start index of the current open tag,
         * so we can update the start index for attributes.
         */ this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        /** The index of the last written buffer. Used when resuming after a `pause()`. */ this.writeIndex = 0;
        /** Indicates whether the parser has finished running / `.end` has been called. */ this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    // Tokenizer event handlers
    /** @internal */ Parser.prototype.ontext = function(start, endIndex) {
        var _a, _b;
        var data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
    };
    /** @internal */ Parser.prototype.ontextentity = function(cp) {
        var _a, _b;
        /*
         * Entities can be emitted on the character, or directly after.
         * We use the section start here to get accurate indices.
         */ var idx = this.tokenizer.getSectionStart();
        this.endIndex = idx - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
        this.startIndex = idx;
    };
    Parser.prototype.isVoidElement = function(name) {
        return !this.options.xmlMode && voidElements.has(name);
    };
    /** @internal */ Parser.prototype.onopentagname = function(start, endIndex) {
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.emitOpenTag(name);
    };
    Parser.prototype.emitOpenTag = function(name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
            while(this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])){
                var el = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
            }
        }
        if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag) this.attribs = {};
    };
    Parser.prototype.endOpenTag = function(isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
    };
    /** @internal */ Parser.prototype.onopentagend = function(endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onclosetag = function(start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    var count = this.stack.length - pos;
                    while(count--){
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop(), count !== 0);
                    }
                } else this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
                // Implicit open before close
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
            }
        } else if (!this.options.xmlMode && name === "br") {
            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onselfclosingtag = function(endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        } else {
            // Ignore the fact that the tag is self-closing.
            this.onopentagend(endIndex);
        }
    };
    Parser.prototype.closeCurrentTag = function(isOpenImplied) {
        var _a, _b;
        var name = this.tagname;
        this.endOpenTag(isOpenImplied);
        // Self-closing tags will be on the top of the stack
        if (this.stack[this.stack.length - 1] === name) {
            // If the opening tag isn't implied, the closing tag has to be implied.
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
        }
    };
    /** @internal */ Parser.prototype.onattribname = function(start, endIndex) {
        this.startIndex = start;
        var name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    };
    /** @internal */ Parser.prototype.onattribdata = function(start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
    };
    /** @internal */ Parser.prototype.onattribentity = function(cp) {
        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    /** @internal */ Parser.prototype.onattribend = function(quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? undefined : null);
        if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function(value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    /** @internal */ Parser.prototype.ondeclaration = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onprocessinginstruction = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.oncomment = function(start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.oncdata = function(start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onend = function() {
        var _a, _b;
        if (this.cbs.onclosetag) {
            // Set the end index for all remaining tags
            this.endIndex = this.startIndex;
            for(var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true));
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */ Parser.prototype.reset = function() {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */ Parser.prototype.parseComplete = function(data) {
        this.reset();
        this.end(data);
    };
    Parser.prototype.getSlice = function(start, end) {
        while(start - this.bufferOffset >= this.buffers[0].length){
            this.shiftBuffer();
        }
        var str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while(end - this.bufferOffset > this.buffers[0].length){
            this.shiftBuffer();
            str += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return str;
    };
    Parser.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */ Parser.prototype.write = function(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
        }
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */ Parser.prototype.end = function(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(".end() after done!"));
            return;
        }
        if (chunk) this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */ Parser.prototype.pause = function() {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */ Parser.prototype.resume = function() {
        this.tokenizer.resume();
        while(this.tokenizer.running && this.writeIndex < this.buffers.length){
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended) this.tokenizer.end();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */ Parser.prototype.parseChunk = function(chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */ Parser.prototype.done = function(chunk) {
        this.end(chunk);
    };
    return Parser;
}();
exports.Parser = Parser; //# sourceMappingURL=Parser.js.map


/***/ }),

/***/ 24179:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.QuoteType = void 0;
var decode_js_1 = __webpack_require__(12657);
var CharCodes;
(function(CharCodes) {
    CharCodes[CharCodes["Tab"] = 9] = "Tab";
    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes[CharCodes["Space"] = 32] = "Space";
    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes[CharCodes["Num"] = 35] = "Num";
    CharCodes[CharCodes["Amp"] = 38] = "Amp";
    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes[CharCodes["Dash"] = 45] = "Dash";
    CharCodes[CharCodes["Slash"] = 47] = "Slash";
    CharCodes[CharCodes["Zero"] = 48] = "Zero";
    CharCodes[CharCodes["Nine"] = 57] = "Nine";
    CharCodes[CharCodes["Semi"] = 59] = "Semi";
    CharCodes[CharCodes["Lt"] = 60] = "Lt";
    CharCodes[CharCodes["Eq"] = 61] = "Eq";
    CharCodes[CharCodes["Gt"] = 62] = "Gt";
    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */ var State;
(function(State) {
    State[State["Text"] = 1] = "Text";
    State[State["BeforeTagName"] = 2] = "BeforeTagName";
    State[State["InTagName"] = 3] = "InTagName";
    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State[State["InClosingTagName"] = 6] = "InClosingTagName";
    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    // Attributes
    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State[State["InAttributeName"] = 9] = "InAttributeName";
    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    // Declarations
    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State[State["InDeclaration"] = 16] = "InDeclaration";
    // Processing instructions
    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    // Comments & CDATA
    State[State["BeforeComment"] = 18] = "BeforeComment";
    State[State["CDATASequence"] = 19] = "CDATASequence";
    State[State["InSpecialComment"] = 20] = "InSpecialComment";
    State[State["InCommentLike"] = 21] = "InCommentLike";
    // Special tags
    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State[State["InSpecialTag"] = 24] = "InSpecialTag";
    State[State["BeforeEntity"] = 25] = "BeforeEntity";
    State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State[State["InNamedEntity"] = 27] = "InNamedEntity";
    State[State["InNumericEntity"] = 28] = "InNumericEntity";
    State[State["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isNumber(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
}
function isHexDigit(c) {
    return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
}
var QuoteType;
(function(QuoteType) {
    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
    QuoteType[QuoteType["Single"] = 2] = "Single";
    QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */ var Sequences = {
    Cdata: new Uint8Array([
        0x43,
        0x44,
        0x41,
        0x54,
        0x41,
        0x5b
    ]),
    CdataEnd: new Uint8Array([
        0x5d,
        0x5d,
        0x3e
    ]),
    CommentEnd: new Uint8Array([
        0x2d,
        0x2d,
        0x3e
    ]),
    ScriptEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x73,
        0x63,
        0x72,
        0x69,
        0x70,
        0x74
    ]),
    StyleEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x73,
        0x74,
        0x79,
        0x6c,
        0x65
    ]),
    TitleEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x74,
        0x69,
        0x74,
        0x6c,
        0x65
    ])
};
var Tokenizer = /** @class */ function() {
    function Tokenizer(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        /** The current state the tokenizer is in. */ this.state = State.Text;
        /** The read buffer. */ this.buffer = "";
        /** The beginning of the section that is currently being read. */ this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */ this.index = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */ this.baseState = State.Text;
        /** For special parsing behavior inside of script and style tags. */ this.isSpecial = false;
        /** Indicates whether the tokenizer has been paused. */ this.running = true;
        /** The offset of the current buffer. */ this.offset = 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        /** For named entities, the index of the value. For numeric entities, the code point. */ this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer.prototype.reset = function() {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = undefined;
        this.running = true;
        this.offset = 0;
    };
    Tokenizer.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function() {
        if (this.running) this.finish();
    };
    Tokenizer.prototype.pause = function() {
        this.running = false;
    };
    Tokenizer.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
            this.parse();
        }
    };
    /**
     * The current index within all of the written data.
     */ Tokenizer.prototype.getIndex = function() {
        return this.index;
    };
    /**
     * The start of the current section.
     */ Tokenizer.prototype.getSectionStart = function() {
        return this.sectionStart;
    };
    Tokenizer.prototype.stateText = function(c) {
        if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State.BeforeTagName;
            this.sectionStart = this.index;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateSpecialStartSequence = function(c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? isEndOfTagSection(c) : (c | 0x20) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
            this.isSpecial = false;
        } else if (!isEnd) {
            this.sequenceIndex++;
            return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
    };
    /** Look for an end tag. For <title> tags, also decode entities. */ Tokenizer.prototype.stateInSpecialTag = function(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                var endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                    // Spoof the index so that reported locations match up.
                    var actualIndex = this.index;
                    this.index = endOfText;
                    this.cbs.ontext(this.sectionStart, endOfText);
                    this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2; // Skip over the `</`
                this.stateInClosingTagName(c);
                return; // We are done; skip the rest of the function.
            }
            this.sequenceIndex = 0;
        }
        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
                // We have to parse entities in <title> tags.
                if (this.decodeEntities && c === CharCodes.Amp) {
                    this.state = State.BeforeEntity;
                }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
                // Outside of <title> tags, we can fast-forward.
                this.sequenceIndex = 1;
            }
        } else {
            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
            this.sequenceIndex = Number(c === CharCodes.Lt);
        }
    };
    Tokenizer.prototype.stateCDATASequence = function(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
            }
        } else {
            this.sequenceIndex = 0;
            this.state = State.InDeclaration;
            this.stateInDeclaration(c); // Reconsume the character
        }
    };
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */ Tokenizer.prototype.fastForwardTo = function(c) {
        while(++this.index < this.buffer.length + this.offset){
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
            }
        }
        /*
         * We increment the index at the end of the `parse` loop,
         * so set it to `buffer.length - 1` here.
         *
         * TODO: Refactor `parse` to increment index before calling states.
         */ this.index = this.buffer.length + this.offset - 1;
        return false;
    };
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */ Tokenizer.prototype.stateInCommentLike = function(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, this.index, 2);
                } else {
                    this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
            }
        } else if (this.sequenceIndex === 0) {
            // Fast-forward to the first character of the sequence
            if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
            }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            // Allow long sequences, eg. --->, ]]]>
            this.sequenceIndex = 0;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */ Tokenizer.prototype.isTagStartChar = function(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    };
    Tokenizer.prototype.startSpecial = function(sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
    };
    Tokenizer.prototype.stateBeforeTagName = function(c) {
        if (c === CharCodes.ExclamationMark) {
            this.state = State.BeforeDeclaration;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Questionmark) {
            this.state = State.InProcessingInstruction;
            this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c)) {
            var lower = c | 0x20;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
            } else {
                this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
            }
        } else if (c === CharCodes.Slash) {
            this.state = State.BeforeClosingTagName;
        } else {
            this.state = State.Text;
            this.stateText(c);
        }
    };
    Tokenizer.prototype.stateInTagName = function(c) {
        if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function(c) {
        if (isWhitespace(c)) {
        // Ignore
        } else if (c === CharCodes.Gt) {
            this.state = State.Text;
        } else {
            this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function(c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function(c) {
        // Skip everything until ">"
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function(c) {
        if (c === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
            } else {
                this.state = State.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Slash) {
            this.state = State.InSelfClosingTag;
        } else if (!isWhitespace(c)) {
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function(c) {
        if (c === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false; // Reset special state, in case of self-closing special tags
        } else if (!isWhitespace(c)) {
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateInAttributeName = function(c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterAttributeName;
            this.stateAfterAttributeName(c);
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function(c) {
        if (c === CharCodes.Eq) {
            this.state = State.BeforeAttributeValue;
        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        } else if (!isWhitespace(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function(c) {
        if (c === CharCodes.DoubleQuote) {
            this.state = State.InAttributeValueDq;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.SingleQuote) {
            this.state = State.InAttributeValueSq;
            this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
            this.sectionStart = this.index;
            this.state = State.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c); // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State.BeforeAttributeName;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function(c) {
        if (c === CharCodes.OpeningSquareBracket) {
            this.state = State.CDATASequence;
            this.sequenceIndex = 0;
        } else {
            this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInDeclaration = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function(c) {
        if (c === CharCodes.Dash) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            // Allow short comments (eg. <!-->)
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
        } else {
            this.state = State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInSpecialComment = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeSpecialS = function(c) {
        var lower = c | 0x20;
        if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
        } else {
            this.state = State.InTagName;
            this.stateInTagName(c); // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeEntity = function(c) {
        // Start excess with 1 to include the '&'
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Num) {
            this.state = State.BeforeNumericEntity;
        } else if (c === CharCodes.Amp) {
        // We have two `&` characters in a row. Stay in the current state.
        } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State.InNamedEntity;
            this.stateInNamedEntity(c);
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function(c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
        // If the branch is a value, store it and continue
        if (masked) {
            // The mask is the number of bytes of the value, including the current byte.
            var valueLength = (masked >> 14) - 1;
            // If we have a legacy entity while parsing strictly, just skip the number of bytes
            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                this.trieIndex += valueLength;
            } else {
                // Add 1 as we have already incremented the excess
                var entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                // If this is a surrogate pair, consume the next two bytes
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                    this.emitNamedEntity();
                }
            }
        }
    };
    Tokenizer.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
            return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch(valueLength){
            case 1:
                this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
                break;
            case 2:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
            case 3:
                {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
                }
        }
    };
    Tokenizer.prototype.stateBeforeNumericEntity = function(c) {
        if ((c | 0x20) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State.InHexEntity;
        } else {
            this.state = State.InNumericEntity;
            this.stateInNumericEntity(c);
        }
    };
    Tokenizer.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
            // Emit leading data if any
            if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function(c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
            this.entityExcess++;
        } else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            } else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function(c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
            this.entityExcess++;
        } else if (isHexDigit(c)) {
            this.entityResult = this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
            this.entityExcess++;
        } else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            } else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    };
    /**
     * Remove data that has already been consumed from the buffer.
     */ Tokenizer.prototype.cleanup = function() {
        // If we are inside of text or attributes, emit what we already have.
        if (this.running && this.sectionStart !== this.index) {
            if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
            } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
        }
    };
    Tokenizer.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */ Tokenizer.prototype.parse = function() {
        while(this.shouldContinue()){
            var c = this.buffer.charCodeAt(this.index - this.offset);
            if (this.state === State.Text) {
                this.stateText(c);
            } else if (this.state === State.SpecialStartSequence) {
                this.stateSpecialStartSequence(c);
            } else if (this.state === State.InSpecialTag) {
                this.stateInSpecialTag(c);
            } else if (this.state === State.CDATASequence) {
                this.stateCDATASequence(c);
            } else if (this.state === State.InAttributeValueDq) {
                this.stateInAttributeValueDoubleQuotes(c);
            } else if (this.state === State.InAttributeName) {
                this.stateInAttributeName(c);
            } else if (this.state === State.InCommentLike) {
                this.stateInCommentLike(c);
            } else if (this.state === State.InSpecialComment) {
                this.stateInSpecialComment(c);
            } else if (this.state === State.BeforeAttributeName) {
                this.stateBeforeAttributeName(c);
            } else if (this.state === State.InTagName) {
                this.stateInTagName(c);
            } else if (this.state === State.InClosingTagName) {
                this.stateInClosingTagName(c);
            } else if (this.state === State.BeforeTagName) {
                this.stateBeforeTagName(c);
            } else if (this.state === State.AfterAttributeName) {
                this.stateAfterAttributeName(c);
            } else if (this.state === State.InAttributeValueSq) {
                this.stateInAttributeValueSingleQuotes(c);
            } else if (this.state === State.BeforeAttributeValue) {
                this.stateBeforeAttributeValue(c);
            } else if (this.state === State.BeforeClosingTagName) {
                this.stateBeforeClosingTagName(c);
            } else if (this.state === State.AfterClosingTagName) {
                this.stateAfterClosingTagName(c);
            } else if (this.state === State.BeforeSpecialS) {
                this.stateBeforeSpecialS(c);
            } else if (this.state === State.InAttributeValueNq) {
                this.stateInAttributeValueNoQuotes(c);
            } else if (this.state === State.InSelfClosingTag) {
                this.stateInSelfClosingTag(c);
            } else if (this.state === State.InDeclaration) {
                this.stateInDeclaration(c);
            } else if (this.state === State.BeforeDeclaration) {
                this.stateBeforeDeclaration(c);
            } else if (this.state === State.BeforeComment) {
                this.stateBeforeComment(c);
            } else if (this.state === State.InProcessingInstruction) {
                this.stateInProcessingInstruction(c);
            } else if (this.state === State.InNamedEntity) {
                this.stateInNamedEntity(c);
            } else if (this.state === State.BeforeEntity) {
                this.stateBeforeEntity(c);
            } else if (this.state === State.InHexEntity) {
                this.stateInHexEntity(c);
            } else if (this.state === State.InNumericEntity) {
                this.stateInNumericEntity(c);
            } else {
                // `this._state === State.BeforeNumericEntity`
                this.stateBeforeNumericEntity(c);
            }
            this.index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function() {
        if (this.state === State.InNamedEntity) {
            this.emitNamedEntity();
        }
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this.index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    /** Handle any trailing data. */ Tokenizer.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
        } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
        // All trailing data will have been consumed
        } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
        // All trailing data will have been consumed
        } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
        /*
             * If we are currently in an opening or closing tag, us not calling the
             * respective callback signals that the tag should be ignored.
             */ } else {
            this.cbs.ontext(this.sectionStart, endIndex);
        }
    };
    Tokenizer.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
        } else {
            this.cbs.ontext(start, endIndex);
        }
    };
    Tokenizer.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
            this.cbs.onattribentity(cp);
        } else {
            this.cbs.ontextentity(cp);
        }
    };
    return Tokenizer;
}();
exports["default"] = Tokenizer; //# sourceMappingURL=Tokenizer.js.map


/***/ }),

/***/ 62665:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DefaultHandler = exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
var Parser_js_1 = __webpack_require__(23187);
Object.defineProperty(exports, "Parser", ({
    enumerable: true,
    get: function() {
        return Parser_js_1.Parser;
    }
}));
var domhandler_1 = __webpack_require__(66601);
Object.defineProperty(exports, "DomHandler", ({
    enumerable: true,
    get: function() {
        return domhandler_1.DomHandler;
    }
}));
Object.defineProperty(exports, "DefaultHandler", ({
    enumerable: true,
    get: function() {
        return domhandler_1.DomHandler;
    }
}));
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */ function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */ function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */ function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_js_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_js_1 = __webpack_require__(24179);
Object.defineProperty(exports, "Tokenizer", ({
    enumerable: true,
    get: function() {
        return __importDefault(Tokenizer_js_1).default;
    }
}));
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */ var ElementType = __importStar(__webpack_require__(39469));
exports.ElementType = ElementType;
var domutils_1 = __webpack_require__(42029);
Object.defineProperty(exports, "getFeed", ({
    enumerable: true,
    get: function() {
        return domutils_1.getFeed;
    }
}));
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */ function parseFeed(feed, options) {
    if (options === void 0) {
        options = {
            xmlMode: true
        };
    }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
}
exports.parseFeed = parseFeed;
exports.DomUtils = __importStar(__webpack_require__(42029)); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 73066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
exports.__esModule = true;
var style_to_object_1 = __importDefault(__webpack_require__(80799));
var utilities_1 = __webpack_require__(98985);
function StyleToJS(style, options) {
    var output = {};
    if (!style || typeof style !== "string") {
        return output;
    }
    (0, style_to_object_1["default"])(style, function(property, value) {
        if (property && value) {
            output[(0, utilities_1.camelCase)(property, options)] = value;
        }
    });
    return output;
}
exports["default"] = StyleToJS;


/***/ }),

/***/ 98985:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.camelCase = void 0;
var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;
var HYPHEN_REGEX = /-([a-z])/g;
var NO_HYPHEN_REGEX = /^[^-]+$/;
var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
var skipCamelCase = function(property) {
    return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
};
var capitalize = function(match, character) {
    return character.toUpperCase();
};
var trimHyphen = function(match, prefix) {
    return "".concat(prefix, "-");
};
var camelCase = function(property, options) {
    if (options === void 0) {
        options = {};
    }
    if (skipCamelCase(property)) {
        return property;
    }
    property = property.toLowerCase();
    if (options.reactCompat) {
        property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
    } else {
        property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
    }
    return property.replace(HYPHEN_REGEX, capitalize);
};
exports.camelCase = camelCase;


/***/ }),

/***/ 80799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(76278);
/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */ function StyleToObject(style, iterator) {
    var output = null;
    if (!style || typeof style !== "string") {
        return output;
    }
    var declaration;
    var declarations = parse(style);
    var hasIterator = typeof iterator === "function";
    var property;
    var value;
    for(var i = 0, len = declarations.length; i < len; i++){
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
            iterator(property, value, declaration);
        } else if (value) {
            output || (output = {});
            output[property] = value;
        }
    }
    return output;
}
module.exports = StyleToObject;
module.exports["default"] = StyleToObject; // ESM support


/***/ }),

/***/ 68763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Text: ()=>Text
});
module.exports = __toCommonJS(src_exports);
// src/text.tsx
var React = __toESM(__webpack_require__(46261));
var import_jsx_runtime = __webpack_require__(56786);
var Text = React.forwardRef(({ style, ...props }, forwardedRef)=>/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
        ...props,
        ref: forwardedRef,
        "data-id": "react-email-text",
        style: {
            fontSize: "14px",
            lineHeight: "24px",
            margin: "16px 0",
            ...style
        }
    }));
Text.displayName = "Text";
// Annotate the CommonJS export names for ESM import in node:
0 && (0);


/***/ }),

/***/ 95951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(39469);
var node_js_1 = __webpack_require__(77332);
__exportStar(__webpack_require__(77332), exports);
// Default options
var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
};
var DomHandler = /** @class */ function() {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */ function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */ this.dom = [];
        /** The root element for the DOM */ this.root = new node_js_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */ this.done = false;
        /** Stack of open tags. */ this.tagStack = [
            this.root
        ];
        /** A data node that is still being written to. */ this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */ this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function(parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [
            this.root
        ];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function() {
        if (this.done) return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function(error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB) this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_js_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function(data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function() {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([
            text
        ]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        } else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}();
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 77332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(39469);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */ var Node = /** @class */ function() {
    function Node() {
        /** Parent of the node */ this.parent = null;
        /** Previous sibling */ this.prev = null;
        /** Next sibling */ this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */ this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */ this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.parent;
        },
        set: function(parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.prev;
        },
        set: function(prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.next;
        },
        set: function(next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */ Node.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
            recursive = false;
        }
        return cloneNode(this, recursive);
    };
    return Node;
}();
exports.Node = Node;
/**
 * A node that contains some data.
 */ var DataNode = /** @class */ function(_super) {
    __extends(DataNode, _super);
    /**
     * @param data The content of the data node
     */ function DataNode(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.data;
        },
        set: function(data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node);
exports.DataNode = DataNode;
/**
 * Text within the document.
 */ var Text = /** @class */ function(_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
    }
    Object.defineProperty(Text.prototype, "nodeType", {
        get: function() {
            return 3;
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(DataNode);
exports.Text = Text;
/**
 * Comments within the document.
 */ var Comment = /** @class */ function(_super) {
    __extends(Comment, _super);
    function Comment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
    }
    Object.defineProperty(Comment.prototype, "nodeType", {
        get: function() {
            return 8;
        },
        enumerable: false,
        configurable: true
    });
    return Comment;
}(DataNode);
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */ var ProcessingInstruction = /** @class */ function(_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
    }
    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    return ProcessingInstruction;
}(DataNode);
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */ var NodeWithChildren = /** @class */ function(_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param children Children of the node. Only certain node types can have children.
     */ function NodeWithChildren(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */ get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */ get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.children;
        },
        set: function(children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node);
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /** @class */ function(_super) {
    __extends(CDATA, _super);
    function CDATA() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
    }
    Object.defineProperty(CDATA.prototype, "nodeType", {
        get: function() {
            return 4;
        },
        enumerable: false,
        configurable: true
    });
    return CDATA;
}(NodeWithChildren);
exports.CDATA = CDATA;
/**
 * The root node of the document.
 */ var Document = /** @class */ function(_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
    }
    Object.defineProperty(Document.prototype, "nodeType", {
        get: function() {
            return 9;
        },
        enumerable: false,
        configurable: true
    });
    return Document;
}(NodeWithChildren);
exports.Document = Document;
/**
 * An element within the DOM.
 */ var Element = /** @class */ function(_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */ function Element(name, attribs, children, type) {
        if (children === void 0) {
            children = [];
        }
        if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
    }
    Object.defineProperty(Element.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.name;
        },
        set: function(name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
                var _a, _b;
                return {
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
                };
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren);
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */ function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */ function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */ function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */ function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */ function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */ function cloneNode(node, recursive) {
    if (recursive === void 0) {
        recursive = false;
    }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    } else if (isComment(node)) {
        result = new Comment(node.data);
    } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
            return child.parent = clone_1;
        });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
            return child.parent = clone_2;
        });
        result = clone_2;
    } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
            return child.parent = clone_3;
        });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    } else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function(child) {
        return cloneNode(child, true);
    });
    for(var i = 1; i < children.length; i++){
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 16617:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncify;
var _initialParams = __webpack_require__(55795);
var _initialParams2 = _interopRequireDefault(_initialParams);
var _setImmediate = __webpack_require__(32042);
var _setImmediate2 = _interopRequireDefault(_setImmediate);
var _wrapAsync = __webpack_require__(86080);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */ function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args /*, callback*/ ) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
        };
    }
    return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
        } else {
            callback(null, result);
        }
    });
}
function handlePromise(promise, callback) {
    return promise.then((value)=>{
        invokeCallback(callback, null, value);
    }, (err)=>{
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
}
function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0, _setImmediate2.default)((e)=>{
            throw e;
        }, err);
    }
}
module.exports = exports.default;


/***/ }),

/***/ 30599:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _isArrayLike = __webpack_require__(68842);
var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
var _breakLoop = __webpack_require__(35454);
var _breakLoop2 = _interopRequireDefault(_breakLoop);
var _eachOfLimit = __webpack_require__(91951);
var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
var _once = __webpack_require__(67909);
var _once2 = _interopRequireDefault(_once);
var _onlyOnce = __webpack_require__(65492);
var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
var _wrapAsync = __webpack_require__(86080);
var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
var _awaitify = __webpack_require__(56944);
var _awaitify2 = _interopRequireDefault(_awaitify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0, completed = 0, { length } = coll, canceled = false;
    if (length === 0) {
        callback(null);
    }
    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return;
        if (err) {
            callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
            callback(null);
        }
    }
    for(; index < length; index++){
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}
// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
}
/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dev.json is a file containing a valid json object config for dev environment
 * // dev.json is a file containing a valid json object config for test environment
 * // prod.json is a file containing a valid json object config for prod environment
 * // invalid.json is a file with a malformed json object
 *
 * let configs = {}; //global variable
 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
 *
 * // asynchronous function that reads a json file and parses the contents as json object
 * function parseFile(file, key, callback) {
 *     fs.readFile(file, "utf8", function(err, data) {
 *         if (err) return calback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }
 *
 * // Using callbacks
 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *     } else {
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
 *     if (err) {
 *         console.error(err);
 *         // JSON parse error exception
 *     } else {
 *         console.log(configs);
 *     }
 * });
 *
 * // Using Promises
 * async.forEachOf(validConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 *     // configs is now a map of JSON data, e.g.
 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 * }).catch( err => {
 *     console.error(err);
 * });
 *
 * //Error handing
 * async.forEachOf(invalidConfigFileMap, parseFile)
 * .then( () => {
 *     console.log(configs);
 * }).catch( err => {
 *     console.error(err);
 *     // JSON parse error exception
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
 *         console.log(configs);
 *         // configs is now a map of JSON data, e.g.
 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * //Error handing
 * async () => {
 *     try {
 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
 *         console.log(configs);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // JSON parse error exception
 *     }
 * }
 *
 */ function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}
exports["default"] = (0, _awaitify2.default)(eachOf, 3);
module.exports = exports.default;


/***/ }),

/***/ 91951:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _eachOfLimit2 = __webpack_require__(73945);
var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
var _wrapAsync = __webpack_require__(86080);
var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
var _awaitify = __webpack_require__(56944);
var _awaitify2 = _interopRequireDefault(_awaitify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */ function eachOfLimit(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}
exports["default"] = (0, _awaitify2.default)(eachOfLimit, 4);
module.exports = exports.default;


/***/ }),

/***/ 75757:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _eachOfLimit = __webpack_require__(91951);
var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
var _awaitify = __webpack_require__(56944);
var _awaitify2 = _interopRequireDefault(_awaitify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */ function eachOfSeries(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
}
exports["default"] = (0, _awaitify2.default)(eachOfSeries, 3);
module.exports = exports.default;


/***/ }),

/***/ 12236:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _eachOf = __webpack_require__(30599);
var _eachOf2 = _interopRequireDefault(_eachOf);
var _withoutIndex = __webpack_require__(84714);
var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
var _wrapAsync = __webpack_require__(86080);
var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
var _awaitify = __webpack_require__(56944);
var _awaitify2 = _interopRequireDefault(_awaitify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * // dir1 is a directory that contains file1.txt, file2.txt
 * // dir2 is a directory that contains file3.txt, file4.txt
 * // dir3 is a directory that contains file5.txt
 * // dir4 does not exist
 *
 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
 *
 * // asynchronous function that deletes a file
 * const deleteFile = function(file, callback) {
 *     fs.unlink(file, callback);
 * };
 *
 * // Using callbacks
 * async.each(fileList, deleteFile, function(err) {
 *     if( err ) {
 *         console.log(err);
 *     } else {
 *         console.log('All files have been deleted successfully');
 *     }
 * });
 *
 * // Error Handling
 * async.each(withMissingFileList, deleteFile, function(err){
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using Promises
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 * });
 *
 * // Error Handling
 * async.each(fileList, deleteFile)
 * .then( () => {
 *     console.log('All files have been deleted successfully');
 * }).catch( err => {
 *     console.log(err);
 *     // [ Error: ENOENT: no such file or directory ]
 *     // since dir4/file2.txt does not exist
 *     // dir1/file1.txt could have been deleted
 * });
 *
 * // Using async/await
 * async () => {
 *     try {
 *         await async.each(files, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // Error Handling
 * async () => {
 *     try {
 *         await async.each(withMissingFileList, deleteFile);
 *     }
 *     catch (err) {
 *         console.log(err);
 *         // [ Error: ENOENT: no such file or directory ]
 *         // since dir4/file2.txt does not exist
 *         // dir1/file1.txt could have been deleted
 *     }
 * }
 *
 */ function eachLimit(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}
exports["default"] = (0, _awaitify2.default)(eachLimit, 3);
module.exports = exports.default;


/***/ }),

/***/ 41639:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = asyncEachOfLimit;
var _breakLoop = __webpack_require__(35454);
var _breakLoop2 = _interopRequireDefault(_breakLoop);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return;
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({ value, done: iterDone })=>{
            //console.log('got value', value)
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }
    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);
        if (err === false) {
            done = true;
            canceled = true;
            return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }
    function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
    }
    replenish();
}
module.exports = exports.default;


/***/ }),

/***/ 56944:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = awaitify;
// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify(asyncFn, arity) {
    if (!arity) arity = asyncFn.length;
    if (!arity) throw new Error("arity is undefined");
    function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject)=>{
            args[arity - 1] = (err, ...cbArgs)=>{
                if (err) return reject(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        });
    }
    return awaitable;
}
module.exports = exports.default;


/***/ }),

/***/ 35454:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};
exports["default"] = breakLoop;
module.exports = exports.default;


/***/ }),

/***/ 73945:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _once = __webpack_require__(67909);
var _once2 = _interopRequireDefault(_once);
var _iterator = __webpack_require__(71342);
var _iterator2 = _interopRequireDefault(_iterator);
var _onlyOnce = __webpack_require__(65492);
var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
var _wrapAsync = __webpack_require__(86080);
var _asyncEachOfLimit = __webpack_require__(41639);
var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
var _breakLoop = __webpack_require__(35454);
var _breakLoop2 = _interopRequireDefault(_breakLoop);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports["default"] = (limit)=>{
    return (obj, iteratee, callback)=>{
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
            return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (err === false) {
                done = true;
                canceled = true;
            } else if (value === _breakLoop2.default || done && running <= 0) {
                done = true;
                return callback(null);
            } else if (!looping) {
                replenish();
            }
        }
        function replenish() {
            looping = true;
            while(running < limit && !done){
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
            looping = false;
        }
        replenish();
    };
};
module.exports = exports.default;


/***/ }),

/***/ 56008:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
};
module.exports = exports.default;


/***/ }),

/***/ 55795:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = function(fn) {
    return function(...args /*, callback*/ ) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
};
module.exports = exports.default;


/***/ }),

/***/ 68842:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = isArrayLike;
function isArrayLike(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
module.exports = exports.default;


/***/ }),

/***/ 71342:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = createIterator;
var _isArrayLike = __webpack_require__(68842);
var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
var _getIterator = __webpack_require__(56008);
var _getIterator2 = _interopRequireDefault(_getIterator);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {
            value: coll[i],
            key: i
        } : null;
    };
}
function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return {
            value: item.value,
            key: i
        };
    };
}
function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
            return next();
        }
        return i < len ? {
            value: obj[key],
            key
        } : null;
    };
}
function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports.default;


/***/ }),

/***/ 67909:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = once;
function once(fn) {
    function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
}
module.exports = exports.default;


/***/ }),

/***/ 65492:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = onlyOnce;
function onlyOnce(fn) {
    return function(...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}
module.exports = exports.default;


/***/ }),

/***/ 35897:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _isArrayLike = __webpack_require__(68842);
var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
var _wrapAsync = __webpack_require__(86080);
var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
var _awaitify = __webpack_require__(56944);
var _awaitify2 = _interopRequireDefault(_awaitify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports["default"] = (0, _awaitify2.default)((eachfn, tasks, callback)=>{
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb)=>{
        (0, _wrapAsync2.default)(task)((err, ...result)=>{
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, (err)=>callback(err, results));
}, 3);
module.exports = exports.default;


/***/ }),

/***/ 32042:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fallback = fallback;
exports.wrap = wrap;
/* istanbul ignore file */ var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
    setTimeout(fn, 0);
}
function wrap(defer) {
    return (fn, ...args)=>defer(()=>fn(...args));
}
var _defer;
if (hasQueueMicrotask) {
    _defer = queueMicrotask;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}
exports["default"] = wrap(_defer);


/***/ }),

/***/ 84714:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = _withoutIndex;
function _withoutIndex(iteratee) {
    return (value, index, callback)=>iteratee(value, callback);
}
module.exports = exports.default;


/***/ }),

/***/ 86080:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
var _asyncify = __webpack_require__(16617);
var _asyncify2 = _interopRequireDefault(_asyncify);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isAsync(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
    if (typeof asyncFn !== "function") throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}
exports["default"] = wrapAsync;
exports.isAsync = isAsync;
exports.isAsyncGenerator = isAsyncGenerator;
exports.isAsyncIterable = isAsyncIterable;


/***/ }),

/***/ 39563:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = series;
var _parallel2 = __webpack_require__(35897);
var _parallel3 = _interopRequireDefault(_parallel2);
var _eachOfSeries = __webpack_require__(75757);
var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @return {Promise} a promise, if no callback is passed
 * @example
 *
 * //Using Callbacks
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ], function(err, results) {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * });
 *
 * // an example using objects instead of arrays
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * });
 *
 * //Using Promises
 * async.series([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ]).then(results => {
 *     console.log(results);
 *     // results is equal to ['one','two']
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * // an example using an object instead of an array
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             // do some async task
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             // then do another async task
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }).then(results => {
 *     console.log(results);
 *     // results is equal to: { one: 1, two: 2 }
 * }).catch(err => {
 *     console.log(err);
 * });
 *
 * //Using async/await
 * async () => {
 *     try {
 *         let results = await async.series([
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 'one');
 *                 }, 200);
 *             },
 *             function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 'two');
 *                 }, 100);
 *             }
 *         ]);
 *         console.log(results);
 *         // results is equal to ['one','two']
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 * // an example using an object instead of an array
 * async () => {
 *     try {
 *         let results = await async.parallel({
 *             one: function(callback) {
 *                 setTimeout(function() {
 *                     // do some async task
 *                     callback(null, 1);
 *                 }, 200);
 *             },
 *            two: function(callback) {
 *                 setTimeout(function() {
 *                     // then do another async task
 *                     callback(null, 2);
 *                 }, 100);
 *            }
 *         });
 *         console.log(results);
 *         // results is equal to: { one: 1, two: 2 }
 *     }
 *     catch (err) {
 *         console.log(err);
 *     }
 * }
 *
 */ function series(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
}
module.exports = exports.default;


/***/ }),

/***/ 55956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * condense-newlines <https://github.com/jonschlinkert/condense-newlines>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */ 
var isWhitespace = __webpack_require__(30279);
var extend = __webpack_require__(87845);
var typeOf = __webpack_require__(58648);
module.exports = function(str, options) {
    var opts = extend({}, options);
    var sep = opts.sep || "\n\n";
    var min = opts.min;
    var re;
    if (typeof min === "number" && min !== 2) {
        re = new RegExp("(\\r\\n|\\n|\\u2424) {" + min + ",}");
    }
    if (typeof re === "undefined") {
        re = opts.regex || /(\r\n|\n|\u2424){2,}/g;
    }
    // if a line is 100% whitespace it will be trimmed, so that
    // later we can condense newlines correctly
    if (opts.keepWhitespace !== true) {
        str = str.split("\n").map(function(line) {
            return isWhitespace(line) ? line.trim() : line;
        }).join("\n");
    }
    str = trailingNewline(str, opts);
    return str.replace(re, sep);
};
function trailingNewline(str, options) {
    var val = options.trailingNewline;
    if (val === false) {
        return str;
    }
    switch(typeOf(val)){
        case "string":
            str = str.replace(/\s+$/, options.trailingNewline);
            break;
        case "function":
            str = options.trailingNewline(str);
            break;
        case "undefined":
        case "boolean":
        default:
            {
                str = str.replace(/\s+$/, "\n");
                break;
            }
    }
    return str;
}


/***/ }),

/***/ 27186:
/***/ ((module) => {

"use strict";

var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === "object";
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) {
        return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key) // and also unsafe if they're nonenumerable.
    );
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
    }
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
            return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
    } else {
        return mergeObject(target, source, options);
    }
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;


/***/ }),

/***/ 38680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
].map(function(val) {
    return [
        val.toLowerCase(),
        val
    ];
}));
exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
].map(function(val) {
    return [
        val.toLowerCase(),
        val
    ];
}));


/***/ }),

/***/ 82856:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.render = void 0;
/*
 * Module dependencies
 */ var ElementType = __importStar(__webpack_require__(39469));
var entities_1 = __webpack_require__(59620);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */ var foreignNames_js_1 = __webpack_require__(38680);
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
]);
function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */ function formatAttributes(attributes, opts) {
    var _a;
    if (!attributes) return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
    return Object.keys(attributes).map(function(key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */ key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
    }).join(" ");
}
/**
 * Self-enclosing tags
 */ var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */ function render(node, options) {
    if (options === void 0) {
        options = {};
    }
    var nodes = "length" in node ? node : [
        node
    ];
    var output = "";
    for(var i = 0; i < nodes.length; i++){
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports.render = render;
exports["default"] = render;
function renderNode(node, options) {
    switch(node.type){
        case ElementType.Root:
            return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
]);
var foreignElements = new Set([
    "svg",
    "math"
]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */ elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */ if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), {
                xmlMode: false
            });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), {
            xmlMode: "foreign"
        });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode) tag += " ";
        tag += "/>";
    } else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
    var _a;
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
    return "<!--".concat(elem.data, "-->");
}


/***/ }),

/***/ 39469:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */ var ElementType;
(function(ElementType) {
    /** Type for the root element of a document */ ElementType["Root"] = "root";
    /** Type for Text */ ElementType["Text"] = "text";
    /** Type for <? ... ?> */ ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */ ElementType["Comment"] = "comment";
    /** Type for <script> tags */ ElementType["Script"] = "script";
    /** Type for <style> tags */ ElementType["Style"] = "style";
    /** Type for Any tag */ ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */ ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */ ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */ function isTag(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */ exports.Root = ElementType.Root;
/** Type for Text */ exports.Text = ElementType.Text;
/** Type for <? ... ?> */ exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */ exports.Comment = ElementType.Comment;
/** Type for <script> tags */ exports.Script = ElementType.Script;
/** Type for <style> tags */ exports.Style = ElementType.Style;
/** Type for Any tag */ exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */ exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */ exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ 12657:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
var decode_data_html_js_1 = __importDefault(__webpack_require__(12872));
exports.htmlDecodeTree = decode_data_html_js_1.default;
var decode_data_xml_js_1 = __importDefault(__webpack_require__(54778));
exports.xmlDecodeTree = decode_data_xml_js_1.default;
var decode_codepoint_js_1 = __importStar(__webpack_require__(20117));
exports.decodeCodePoint = decode_codepoint_js_1.default;
var decode_codepoint_js_2 = __webpack_require__(20117);
Object.defineProperty(exports, "replaceCodePoint", ({
    enumerable: true,
    get: function() {
        return decode_codepoint_js_2.replaceCodePoint;
    }
}));
Object.defineProperty(exports, "fromCodePoint", ({
    enumerable: true,
    get: function() {
        return decode_codepoint_js_2.fromCodePoint;
    }
}));
var CharCodes;
(function(CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */ var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */ function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState) {
    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode) {
    /** Entities in text nodes that can end with any character. */ DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Only allow entities terminated with a semicolon. */ DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    /** Entities in attributes have limitations on ending characters. */ DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */ var EntityDecoder = /** @class */ function() {
    function EntityDecoder(/** The tree used to decode entities. */ decodeTree, /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */ emitCodePoint, /** An object that is used to produce errors. */ errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        /** The current state of the decoder. */ this.state = EntityDecoderState.EntityStart;
        /** Characters that were consumed while parsing an entity. */ this.consumed = 1;
        /**
         * The result of the entity.
         *
         * Either the result index of a numeric entity, or the codepoint of a
         * numeric entity.
         */ this.result = 0;
        /** The current index in the decode tree. */ this.treeIndex = 0;
        /** The number of characters that were consumed in excess. */ this.excess = 1;
        /** The mode in which the decoder is operating. */ this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */ EntityDecoder.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
    };
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */ EntityDecoder.prototype.write = function(str, offset) {
        switch(this.state){
            case EntityDecoderState.EntityStart:
                {
                    if (str.charCodeAt(offset) === CharCodes.NUM) {
                        this.state = EntityDecoderState.NumericStart;
                        this.consumed += 1;
                        return this.stateNumericStart(str, offset + 1);
                    }
                    this.state = EntityDecoderState.NamedEntity;
                    return this.stateNamedEntity(str, offset);
                }
            case EntityDecoderState.NumericStart:
                {
                    return this.stateNumericStart(str, offset);
                }
            case EntityDecoderState.NumericDecimal:
                {
                    return this.stateNumericDecimal(str, offset);
                }
            case EntityDecoderState.NumericHex:
                {
                    return this.stateNumericHex(str, offset);
                }
            case EntityDecoderState.NamedEntity:
                {
                    return this.stateNamedEntity(str, offset);
                }
        }
    };
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */ EntityDecoder.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
            return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder.prototype.addToNumericResult = function(str, start, end, base) {
        if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
        }
    };
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */ EntityDecoder.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while(offset < str.length){
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
                offset += 1;
            } else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
    };
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */ EntityDecoder.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while(offset < str.length){
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
                offset += 1;
            } else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
    };
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */ EntityDecoder.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        // Ensure we consumed at least one digit.
        if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
        }
        // Figure out if this is a legit end of the entity
        if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
    };
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */ EntityDecoder.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        // The mask is the number of bytes of the value, including the current byte.
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for(; offset < str.length; offset++, this.excess++){
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
                return this.result === 0 || // If we are parsing an attribute
                this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
                (valueLength === 0 || // And there should be no invalid characters.
                isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            // If the branch is a value, store it and continue
            if (valueLength !== 0) {
                // If the entity is terminated by a semicolon, we are done.
                if (char === CharCodes.SEMI) {
                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                if (this.decodeMode !== DecodingMode.Strict) {
                    this.result = this.treeIndex;
                    this.consumed += this.excess;
                    this.excess = 0;
                }
            }
        }
        return -1;
    };
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */ EntityDecoder.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
    };
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */ EntityDecoder.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
            // For multi-byte values, we need to emit the second byte.
            this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
    };
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */ EntityDecoder.prototype.end = function() {
        var _a;
        switch(this.state){
            case EntityDecoderState.NamedEntity:
                {
                    // Emit a named entity if we have one.
                    return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
                }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal:
                {
                    return this.emitNumericEntity(0, 2);
                }
            case EntityDecoderState.NumericHex:
                {
                    return this.emitNumericEntity(0, 3);
                }
            case EntityDecoderState.NumericStart:
                {
                    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                    return 0;
                }
            case EntityDecoderState.EntityStart:
                {
                    // Return 0 if we have no entity.
                    return 0;
                }
        }
    };
    return EntityDecoder;
}();
exports.EntityDecoder = EntityDecoder;
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */ function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while((offset = str.indexOf("&", offset)) >= 0){
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            var len = decoder.write(str, // Skip the "&"
            offset + 1);
            if (len < 0) {
                lastIndex = offset + decoder.end();
                break;
            }
            lastIndex = offset + len;
            // If `len` is 0, skip the current `&` and continue.
            offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        // Make sure we don't keep a reference to the final string.
        ret = "";
        return result;
    };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */ function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while(lo <= hi){
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
            lo = mid + 1;
        } else if (midVal > char) {
            hi = mid - 1;
        } else {
            return decodeTree[mid + branchCount];
        }
    }
    return -1;
}
exports.determineBranch = determineBranch;
var htmlDecoder = getDecoder(decode_data_html_js_1.default);
var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */ function decodeHTML(str, mode) {
    if (mode === void 0) {
        mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
}
exports.decodeHTML = decodeHTML;
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */ function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
}
exports.decodeHTMLAttribute = decodeHTMLAttribute;
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */ function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
}
exports.decodeHTMLStrict = decodeHTMLStrict;
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */ function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
}
exports.decodeXML = decodeXML; //# sourceMappingURL=decode.js.map


/***/ }),

/***/ 20117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.replaceCodePoint = exports.fromCodePoint = void 0;
var decodeMap = new Map([
    [
        0,
        65533
    ],
    // C1 Unicode control character reference replacements
    [
        128,
        8364
    ],
    [
        130,
        8218
    ],
    [
        131,
        402
    ],
    [
        132,
        8222
    ],
    [
        133,
        8230
    ],
    [
        134,
        8224
    ],
    [
        135,
        8225
    ],
    [
        136,
        710
    ],
    [
        137,
        8240
    ],
    [
        138,
        352
    ],
    [
        139,
        8249
    ],
    [
        140,
        338
    ],
    [
        142,
        381
    ],
    [
        145,
        8216
    ],
    [
        146,
        8217
    ],
    [
        147,
        8220
    ],
    [
        148,
        8221
    ],
    [
        149,
        8226
    ],
    [
        150,
        8211
    ],
    [
        151,
        8212
    ],
    [
        152,
        732
    ],
    [
        153,
        8482
    ],
    [
        154,
        353
    ],
    [
        155,
        8250
    ],
    [
        156,
        339
    ],
    [
        158,
        382
    ],
    [
        159,
        376
    ]
]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */ exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
        codePoint = 0xdc00 | codePoint & 0x3ff;
    }
    output += String.fromCharCode(codePoint);
    return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */ function replaceCodePoint(codePoint) {
    var _a;
    if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
        return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
exports.replaceCodePoint = replaceCodePoint;
/**
 * Replace the code point if relevant, then convert it to a string.
 *
 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
 * @param codePoint The code point to decode.
 * @returns The decoded code point.
 */ function decodeCodePoint(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
}
exports["default"] = decodeCodePoint; //# sourceMappingURL=decode_codepoint.js.map


/***/ }),

/***/ 357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
var encode_html_js_1 = __importDefault(__webpack_require__(67331));
var escape_js_1 = __webpack_require__(2950);
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */ function encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
}
exports.encodeHTML = encodeHTML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */ function encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
}
exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while((match = regExp.exec(str)) !== null){
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
            // We are in a branch. Try to match the next char.
            if (i + 1 < str.length) {
                var nextChar = str.charCodeAt(i + 1);
                var value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
                if (value !== undefined) {
                    ret += value;
                    lastIdx = regExp.lastIndex += 1;
                    continue;
                }
            }
            next = next.v;
        }
        // We might have a tree node without a value; skip and use a numeric entity.
        if (next !== undefined) {
            ret += next;
            lastIdx = i + 1;
        } else {
            var cp = (0, escape_js_1.getCodePoint)(str, i);
            ret += "&#x".concat(cp.toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = regExp.lastIndex += Number(cp !== char);
        }
    }
    return ret + str.substr(lastIdx);
} //# sourceMappingURL=encode.js.map


/***/ }),

/***/ 2950:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
    [
        34,
        "&quot;"
    ],
    [
        38,
        "&amp;"
    ],
    [
        39,
        "&apos;"
    ],
    [
        60,
        "&lt;"
    ],
    [
        62,
        "&gt;"
    ]
]);
// For compatibility with node < 4, we wrap `codePointAt`
exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
} : function(c, index) {
    return (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);
};
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */ function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while((match = exports.xmlReplacer.exec(str)) !== null){
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== undefined) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
        } else {
            ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
        }
    }
    return ret + str.substr(lastIdx);
}
exports.encodeXML = encodeXML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */ exports.escape = encodeXML;
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */ function getEscaper(regex, map) {
    return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while(match = regex.exec(data)){
            if (lastIdx !== match.index) {
                result += data.substring(lastIdx, match.index);
            }
            // We know that this character will be in the map.
            result += map.get(match[0].charCodeAt(0));
            // Every match will be of length 1
            lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
    };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */ exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */ exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [
        34,
        "&quot;"
    ],
    [
        38,
        "&amp;"
    ],
    [
        160,
        "&nbsp;"
    ]
]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */ exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [
        38,
        "&amp;"
    ],
    [
        60,
        "&lt;"
    ],
    [
        62,
        "&gt;"
    ],
    [
        160,
        "&nbsp;"
    ]
])); //# sourceMappingURL=escape.js.map


/***/ }),

/***/ 12872:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = new Uint16Array(// prettier-ignore
'ᵁ<\xd5ıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\x00\x00\x00\x00\x00\x00ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig耻\xc6䃆P耻&䀦cute耻\xc1䃁reve;䄂Āiyx}rc耻\xc2䃂;䐐r;쀀\ud835\udd04rave耻\xc0䃀pha;䎑acr;䄀d;橓Āgp\x9d\xa1on;䄄f;쀀\ud835\udd38plyFunction;恡ing耻\xc5䃅Ācs\xbe\xc3r;쀀\ud835\udc9cign;扔ilde耻\xc3䃃ml耻\xc4䃄Ѐaceforsu\xe5\xfb\xfeėĜĢħĪĀcr\xea\xf2kslash;或Ŷ\xf6\xf8;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀\ud835\udd05pf;쀀\ud835\udd39eve;䋘c\xf2ēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻\xa9䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻\xc7䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷\xf2ſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀\ud835\udc9epĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀\ud835\udd07Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\x00\x00\x00͔͂\x00Ѕf;쀀\ud835\udd3bƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegra\xecȹoɴ͹\x00\x00ͻ\xbb͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔e\xe5ˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\x00\x00ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\x00ц\x00ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\x00ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀\ud835\udc9frok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻\xd0䃐cute耻\xc9䃉ƀaiyӒӗӜron;䄚rc耻\xca䃊;䐭ot;䄖r;쀀\ud835\udd08rave耻\xc8䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\x00\x00ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀\ud835\udd3csilon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻\xcb䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀\ud835\udd09lledɓ֗\x00\x00֣mallSquare;旼erySmallSquare;斪Ͱֺ\x00ֿ\x00\x00ׄf;쀀\ud835\udd3dAll;戀riertrf;愱c\xf2׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀\ud835\udd0a;拙pf;쀀\ud835\udd3eeater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀\ud835\udca2;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\x00ڲf;愍izontalLine;攀Āctۃۅ\xf2کrok;䄦mpńېۘownHum\xf0įqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻\xcd䃍Āiyܓܘrc耻\xce䃎;䐘ot;䄰r;愑rave耻\xcc䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lie\xf3ϝǴ݉\x00ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀\ud835\udd40a;䎙cr;愐ilde;䄨ǫޚ\x00ޞcy;䐆l耻\xcf䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀\ud835\udd0dpf;쀀\ud835\udd41ǣ߇\x00ߌr;쀀\ud835\udca5rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀\ud835\udd0epf;쀀\ud835\udd42cr;쀀\ud835\udca6րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\x00ࣃbleBracket;柦nǔࣈ\x00࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ight\xe1Μs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀\ud835\udd0fĀ;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊight\xe1οight\xe1ϊf;쀀\ud835\udd43erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂ\xf2ࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀\ud835\udd10nusPlus;戓pf;쀀\ud835\udd44c\xf2੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘\xeb૙eryThi\xee૙tedĀGL૸ଆreaterGreate\xf2ٳessLes\xf3ੈLine;䀊r;쀀\ud835\udd11ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀\ud835\udca9ilde耻\xd1䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻\xd3䃓Āiy෎ීrc耻\xd4䃔;䐞blac;䅐r;쀀\ud835\udd12rave耻\xd2䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀\ud835\udd46enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀\ud835\udcaaash耻\xd8䃘iŬื฼de耻\xd5䃕es;樷ml耻\xd6䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀\ud835\udd13i;䎦;䎠usMinus;䂱Āipຢອncareplan\xe5ڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀\ud835\udcab;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀\ud835\udd14pf;愚cr;쀀\ud835\udcac؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻\xae䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r\xbbཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\x00စbleBracket;柧nǔည\x00နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀\ud835\udd16ortȀDLRUᄪᄴᄾᅉownArrow\xbbОeftArrow\xbb࢚ightArrow\xbb࿝pArrow;憑gma;䎣allCircle;战pf;쀀\ud835\udd4aɲᅭ\x00\x00ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀\ud835\udcaear;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Th\xe1ྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et\xbbሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻\xde䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀\ud835\udd17Āeiቻ኉ǲኀ\x00ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀\ud835\udd4bipleDot;惛Āctዖዛr;쀀\ud835\udcafrok;䅦ૡዷጎጚጦ\x00ጬጱ\x00\x00\x00\x00\x00ጸጽ፷ᎅ\x00᏿ᐄᐊᐐĀcrዻጁute耻\xda䃚rĀ;oጇገ憟cir;楉rǣጓ\x00጖y;䐎ve;䅬Āiyጞጣrc耻\xdb䃛;䐣blac;䅰r;쀀\ud835\udd18rave耻\xd9䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀\ud835\udd4cЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥own\xe1ϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀\ud835\udcb0ilde;䅨ml耻\xdc䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀\ud835\udd19pf;쀀\ud835\udd4dcr;쀀\ud835\udcb1dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀\ud835\udd1apf;쀀\ud835\udd4ecr;쀀\ud835\udcb2Ȁfiosᓋᓐᓒᓘr;쀀\ud835\udd1b;䎞pf;쀀\ud835\udd4fcr;쀀\ud835\udcb3ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻\xdd䃝Āiyᔉᔍrc;䅶;䐫r;쀀\ud835\udd1cpf;쀀\ud835\udd50cr;쀀\ud835\udcb4ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\x00ᕛoWidt\xe8૙a;䎖r;愨pf;愤cr;쀀\ud835\udcb5௡ᖃᖊᖐ\x00ᖰᖶᖿ\x00\x00\x00\x00ᗆᗛᗫᙟ᙭\x00ᚕ᚛ᚲᚹ\x00ᚾcute耻\xe1䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻\xe2䃢te肻\xb4̆;䐰lig耻\xe6䃦Ā;r\xb2ᖺ;쀀\ud835\udd1erave耻\xe0䃠ĀepᗊᗖĀfpᗏᗔsym;愵\xe8ᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\x00\x00ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e\xbbᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢\xbb\xb9arr;捼Āgpᙣᙧon;䄅f;쀀\ud835\udd52΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒ\xf1ᚃing耻\xe5䃥ƀctyᚡᚦᚨr;쀀\ud835\udcb6;䀪mpĀ;e዁ᚯ\xf1ʈilde耻\xe3䃣ml耻\xe4䃤Āciᛂᛈonin\xf4ɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e\xbbᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰s\xe9ᜌno\xf5ēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀\ud835\udd1fg΀costuvwឍឝឳេ៕៛៞ƀaiuបពរ\xf0ݠrc;旯p\xbb፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\x00\x00ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄e\xe5ᑄ\xe5ᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\x00ᠳƲᠯ\x00ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀\ud835\udd53Ā;tᏋᡣom\xbbᏌtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻\xa6䂦Ȁceioᥑᥖᥚᥠr;쀀\ud835\udcb7mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t\xbb᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\x00᧨ᨑᨕᨲ\x00ᨷᩐ\x00\x00᪴\x00\x00᫁\x00\x00ᬡᬮ᭍᭒\x00᯽\x00ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁\xeeړȀaeiu᧰᧻ᨁᨅǰ᧵\x00᧸s;橍on;䄍dil耻\xe7䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻\xb8ƭptyv;榲t脀\xa2;eᨭᨮ䂢r\xe4Ʋr;쀀\ud835\udd20ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark\xbbᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\x00\x00᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟\xbbཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it\xbb᪼ˬ᫇᫔᫺\x00ᬊonĀ;eᫍᫎ䀺Ā;q\xc7\xc6ɭ᫙\x00\x00᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁\xeeᅠeĀmx᫱᫶ent\xbb᫩e\xf3ɍǧ᫾\x00ᬇĀ;dኻᬂot;橭n\xf4Ɇƀfryᬐᬔᬗ;쀀\ud835\udd54o\xe4ɔ脀\xa9;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀\ud835\udcb8Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\x00\x00᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\x00\x00ᯒre\xe3᭳u\xe3᭵ee;拎edge;拏en耻\xa4䂤earrowĀlrᯮ᯳eft\xbbᮀight\xbbᮽe\xe4ᯝĀciᰁᰇonin\xf4Ƿnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍r\xf2΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸\xf2ᄳhĀ;vᱚᱛ怐\xbbऊūᱡᱧarow;椏a\xe3̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻\xb0䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀\ud835\udd21arĀlrᲳᲵ\xbbࣜ\xbbသʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀\xf7;o᳧ᳰntimes;拇n\xf8᳷cy;䑒cɯᴆ\x00\x00ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀\ud835\udd55ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedg\xe5\xfanƀadhᄮᵝᵧownarrow\xf3ᲃarpoonĀlrᵲᵶef\xf4Ჴigh\xf4ᲶŢᵿᶅkaro\xf7གɯᶊ\x00\x00ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀\ud835\udcb9;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃r\xf2Щa\xf2ྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴo\xf4ᲉĀcsḎḔute耻\xe9䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻\xea䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀\ud835\udd22ƀ;rsṐṑṗ檚ave耻\xe8䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et\xbbẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀\ud835\udd56ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on\xbbớ;䏵ȀcsuvỪỳἋἣĀioữḱrc\xbbḮɩỹ\x00\x00ỻ\xedՈantĀglἂἆtr\xbbṝess\xbbṺƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯o\xf4͒ĀahὉὋ;䎷耻\xf0䃰Āmrὓὗl耻\xeb䃫o;悬ƀcipὡὤὧl;䀡s\xf4ծĀeoὬὴctatio\xeeՙnential\xe5չৡᾒ\x00ᾞ\x00ᾡᾧ\x00\x00ῆῌ\x00ΐ\x00ῦῪ \x00 ⁚llingdotse\xf1Ṅy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\x00\x00᾽g;耀ﬀig;耀ﬄ;쀀\ud835\udd23lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\x00ῳf;쀀\ud835\udd57ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\x00⁐β•‥‧‪‬\x00‮耻\xbd䂽;慓耻\xbc䂼;慕;慙;慛Ƴ‴\x00‶;慔;慖ʴ‾⁁\x00\x00⁃耻\xbe䂾;慗;慜5;慘ƶ⁌\x00⁎;慚;慝8;慞l;恄wn;挢cr;쀀\ud835\udcbbࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lan\xf4٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀\ud835\udd24Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox\xbbℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀\ud835\udd58Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\x00↎pro\xf8₞r;楸qĀlqؿ↖les\xf3₈i\xed٫Āen↣↭rtneqq;쀀≩︀\xc5↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽r\xf2ΠȀilmr⇐⇔⇗⇛rs\xf0ᒄf\xbb․il\xf4کĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it\xbb∊lip;怦con;抹r;쀀\ud835\udd25sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀\ud835\udd59bar;怕ƀclt≯≴≸r;쀀\ud835\udcbdas\xe8⇴rok;䄧Ābp⊂⊇ull;恃hen\xbbᱛૡ⊣\x00⊪\x00⊸⋅⋎\x00⋕⋳\x00\x00⋸⌢⍧⍢⍿\x00⎆⎪⎴cute耻\xed䃭ƀ;iyݱ⊰⊵rc耻\xee䃮;䐸Ācx⊼⊿y;䐵cl耻\xa1䂡ĀfrΟ⋉;쀀\ud835\udd26rave耻\xec䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓in\xe5ގar\xf4ܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝do\xf4⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙er\xf3ᕣ\xe3⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀\ud835\udd5aa;䎹uest耻\xbf䂿Āci⎊⎏r;쀀\ud835\udcbenʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\x00⎼cy;䑖l耻\xef䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀\ud835\udd27ath;䈷pf;쀀\ud835\udd5bǣ⏬\x00⏱r;쀀\ud835\udcbfrcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀\ud835\udd28reen;䄸cy;䑅cy;䑜pf;쀀\ud835\udd5ccr;쀀\ud835\udcc0஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼r\xf2৆\xf2Εail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\x00⒪\x00⒱\x00\x00\x00\x00\x00⒵Ⓔ\x00ⓆⓈⓍ\x00⓹ute;䄺mptyv;榴ra\xeeࡌbda;䎻gƀ;dlࢎⓁⓃ;榑\xe5ࢎ;檅uo耻\xab䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝\xeb≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼\xecࢰ\xe2┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□a\xe9⓶arpoonĀdu▯▴own\xbbњp\xbb०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoon\xf3྘quigarro\xf7⇰hreetimes;拋ƀ;qs▋ও◺lan\xf4বʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋ppro\xf8Ⓠot;拖qĀgq♃♅\xf4উgt\xf2⒌\xf4ছi\xedলƀilr♕࣡♚sht;楼;쀀\ud835\udd29Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖r\xf2◁orne\xf2ᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che\xbb⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox\xbb⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽r\xebࣁgƀlmr⛿✍✔eftĀar০✇ight\xe1৲apsto;柼ight\xe1৽parrowĀlr✥✩ef\xf4⓭ight;憬ƀafl✶✹✽r;榅;쀀\ud835\udd5dus;樭imes;樴š❋❏st;戗\xe1ፎƀ;ef❗❘᠀旊nge\xbb❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇r\xf2ࢨorne\xf2ᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀\ud835\udcc1mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹re\xe5◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀\xc5⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻\xaf䂯Āet⡗⡙;時Ā;e⡞⡟朠se\xbb⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻ow\xeeҌef\xf4ए\xf0Ꮡker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle\xbbᘦr;쀀\ud835\udd2ao;愧ƀcdn⢯⢴⣉ro耻\xb5䂵Ȁ;acdᑤ⢽⣀⣄s\xf4ᚧir;櫰ot肻\xb7Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛\xf2−\xf0ઁĀdp⣩⣮els;抧f;쀀\ud835\udd5eĀct⣸⣽r;쀀\ud835\udcc2pos\xbbᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la\xbb˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉ro\xf8඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\x00⧣p肻\xa0ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\x00⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸ui\xf6ୣĀei⩊⩎ar;椨\xed஘istĀ;s஠டr;쀀\ud835\udd2bȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lan\xf4௢i\xed௪Ā;rஶ⪁\xbbஷƀAap⪊⪍⪑r\xf2⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹r\xf2⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro\xf7⫁ightarro\xf7⪐ƀ;qs఻⪺⫪lan\xf4ౕĀ;sౕ⫴\xbbశi\xedౝĀ;rవ⫾iĀ;eచథi\xe4ඐĀpt⬌⬑f;쀀\ud835\udd5f膀\xac;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lle\xec୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳u\xe5ಥĀ;cಘ⭸Ā;eಒ⭽\xf1ಘȀAait⮈⮋⮝⮧r\xf2⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow\xbb⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉u\xe5൅;쀀\ud835\udcc3ortɭ⬅\x00\x00⯖ar\xe1⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭\xe5೸\xe5ഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗ\xf1സȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇ\xecௗlde耻\xf1䃱\xe7ృiangleĀlrⱒⱜeftĀ;eచⱚ\xf1దightĀ;eೋⱥ\xf1೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00ⴭ\x00ⴸⵈⵠⵥ⵲ⶄᬇ\x00\x00ⶍⶫ\x00ⷈⷎ\x00ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻\xf3䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻\xf4䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀\ud835\udd2cͯ⵹\x00\x00⵼\x00ⶂn;䋛ave耻\xf2䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨr\xf2᪀Āir⶝ⶠr;榾oss;榻n\xe5๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀\ud835\udd60ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨r\xf2᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f\xbbⷿ耻\xaa䂪耻\xba䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧\xf2⸁ash耻\xf8䃸l;折iŬⸯ⸴de耻\xf5䃵esĀ;aǛ⸺s;樶ml耻\xf6䃶bar;挽ૡ⹞\x00⹽\x00⺀⺝\x00⺢⺹\x00\x00⻋ຜ\x00⼓\x00\x00⼫⾼\x00⿈rȀ;astЃ⹧⹲຅脀\xb6;l⹭⹮䂶le\xecЃɩ⹸\x00\x00⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀\ud835\udd2dƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕ma\xf4੶ne;明ƀ;tv⺿⻀⻈䏀chfork\xbb´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎\xf6⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻\xb1ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀\ud835\udd61nd耻\xa3䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷u\xe5໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾ppro\xf8⽃urlye\xf1໙\xf1໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨i\xedໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺\xf0⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴\xef໻rel;抰Āci⿀⿅r;쀀\ud835\udcc5;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀\ud835\udd2epf;쀀\ud835\udd62rime;恗cr;쀀\ud835\udcc6ƀaeo⿸〉〓tĀei⿾々rnion\xf3ڰnt;樖stĀ;e【】䀿\xf1Ἑ\xf4༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがr\xf2Ⴓ\xf2ϝail;検ar\xf2ᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕i\xe3ᅮmptyv;榳gȀ;del࿑らるろ;榒;榥\xe5࿑uo耻\xbb䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞\xeb≝\xf0✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶al\xf3༞ƀabrョリヮr\xf2៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗\xec࿲\xe2ヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜn\xe5Ⴛar\xf4ྩt;断ƀilrㅩဣㅮsht;楽;쀀\ud835\udd2fĀaoㅷㆆrĀduㅽㅿ\xbbѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭa\xe9トarpoonĀduㆻㆿow\xeeㅾp\xbb႒eftĀah㇊㇐rrow\xf3࿪arpoon\xf3Ցightarrows;應quigarro\xf7ニhreetimes;拌g;䋚ingdotse\xf1ἲƀahm㈍㈐㈓r\xf2࿪a\xf2Ց;怏oustĀ;a㈞㈟掱che\xbb㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾r\xebဃƀafl㉇㉊㉎r;榆;쀀\ud835\udd63us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒ar\xf2㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀\ud835\udcc7Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠re\xe5ㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\x00㍺㎤\x00\x00㏬㏰\x00㐨㑈㑚㒭㒱㓊㓱\x00㘖\x00\x00㘳cute;䅛qu\xef➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\x00㋼;檸on;䅡u\xe5ᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓i\xedሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒\xeb∨Ā;oਸ਼਴t耻\xa7䂧i;䀻war;椩mĀin㍩\xf0nu\xf3\xf1t;朶rĀ;o㍶⁕쀀\ud835\udd30Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\x00\x00㎜i\xe4ᑤara\xec⹯耻\xad䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲ar\xf2ᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetm\xe9㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀\ud835\udd64aĀdr㑍ЂesĀ;u㑔㑕晠it\xbb㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍\xf1ᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝\xf1ᆮƀ;afᅻ㒦ְrť㒫ֱ\xbbᅼar\xf2ᅈȀcemt㒹㒾㓂㓅r;쀀\ud835\udcc8tm\xee\xf1i\xec㐕ar\xe6ᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psilo\xeeỠh\xe9⺯s\xbb⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦ppro\xf8㋺urlye\xf1ᇾ\xf1ᇳƀaes㖂㖈㌛ppro\xf8㌚q\xf1㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻\xb9䂹耻\xb2䂲耻\xb3䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨\xeb∮Ā;oਫ਩war;椪lig耻\xdf䃟௡㙑㙝㙠ዎ㙳㙹\x00㙾㛂\x00\x00\x00\x00\x00㛛㜃\x00㜉㝬\x00\x00\x00㞇ɲ㙖\x00\x00㙛get;挖;䏄r\xeb๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀\ud835\udd31Ȁeiko㚆㚝㚵㚼ǲ㚋\x00㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮ppro\xf8዁im\xbbኬs\xf0ኞĀas㚺㚮\xf0዁rn耻\xfe䃾Ǭ̟㛆⋧es膀\xd7;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀\xe1⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀\ud835\udd65rk;櫚\xe1㍢rime;怴ƀaip㜏㜒㝤d\xe5ቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own\xbbᶻeftĀ;e⠀㜾\xf1म;扜ightĀ;e㊪㝋\xf1ၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀\ud835\udcc9;䑆cy;䑛rok;䅧Āio㞋㞎x\xf4᝷headĀlr㞗㞠eftarro\xf7ࡏightarrow\xbbཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶r\xf2ϭar;楣Ācr㟜㟢ute耻\xfa䃺\xf2ᅐrǣ㟪\x00㟭y;䑞ve;䅭Āiy㟵㟺rc耻\xfb䃻;䑃ƀabh㠃㠆㠋r\xf2Ꭽlac;䅱a\xf2ᏃĀir㠓㠘sht;楾;쀀\ud835\udd32rave耻\xf9䃹š㠧㠱rĀlr㠬㠮\xbbॗ\xbbႃlk;斀Āct㠹㡍ɯ㠿\x00\x00㡊rnĀ;e㡅㡆挜r\xbb㡆op;挏ri;旸Āal㡖㡚cr;䅫肻\xa8͉Āgp㡢㡦on;䅳f;쀀\ud835\udd66̀adhlsuᅋ㡸㡽፲㢑㢠own\xe1ᎳarpoonĀlr㢈㢌ef\xf4㠭igh\xf4㠯iƀ;hl㢙㢚㢜䏅\xbbᏺon\xbb㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\x00\x00㣁rnĀ;e㢼㢽挝r\xbb㢽op;挎ng;䅯ri;旹cr;쀀\ud835\udccaƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨\xbb᠓Āam㣯㣲r\xf2㢨l耻\xfc䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠r\xf2ϷarĀ;v㤦㤧櫨;櫩as\xe8ϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖app\xe1␕othin\xe7ẖƀhir㓫⻈㥙op\xf4⾵Ā;hᎷ㥢\xefㆍĀiu㥩㥭gm\xe1㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟et\xe1㚜iangleĀlr㦪㦯eft\xbbथight\xbbၑy;䐲ash\xbbံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨa\xf2ᑩr;쀀\ud835\udd33tr\xe9㦮suĀbp㧯㧱\xbbജ\xbb൙pf;쀀\ud835\udd67ro\xf0໻tr\xe9㦴Ācu㨆㨋r;쀀\ud835\udccbĀbp㨐㨘nĀEe㦀㨖\xbb㥾nĀEe㦒㨞\xbb㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀\ud835\udd34pf;쀀\ud835\udd68Ā;eᑹ㩦at\xe8ᑹcr;쀀\ud835\udcccૣណ㪇\x00㪋\x00㪐㪛\x00\x00㪝㪨㪫㪯\x00\x00㫃㫎\x00㫘ៜ៟tr\xe9៑r;쀀\ud835\udd35ĀAa㪔㪗r\xf2σr\xf2৶;䎾ĀAa㪡㪤r\xf2θr\xf2৫a\xf0✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀\ud835\udd69im\xe5ឲĀAa㫇㫊r\xf2ώr\xf2ਁĀcq㫒ីr;쀀\ud835\udccdĀpt៖㫜r\xe9។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻\xfd䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻\xa5䂥r;쀀\ud835\udd36cy;䑗pf;쀀\ud835\udd6acr;쀀\ud835\udcceĀcm㬦㬩y;䑎l耻\xff䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡tr\xe6ᕟa;䎶r;쀀\ud835\udd37cy;䐶grarr;懝pf;쀀\ud835\udd6bcr;쀀\ud835\udccfĀjn㮅㮇;怍j;怌'.split("").map(function(c) {
    return c.charCodeAt(0);
})); //# sourceMappingURL=decode-data-html.js.map


/***/ }),

/***/ 54778:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = new Uint16Array(// prettier-ignore
"Ȁaglq	\x15\x18\x1bɭ\x0f\x00\x00\x12p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map(function(c) {
    return c.charCodeAt(0);
})); //# sourceMappingURL=decode-data-xml.js.map


/***/ }),

/***/ 67331:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-encode-map.ts
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function restoreDiff(arr) {
    for(var i = 1; i < arr.length; i++){
        arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
}
// prettier-ignore
exports["default"] = new Map(/* #__PURE__ */ restoreDiff([
    [
        9,
        "&Tab;"
    ],
    [
        0,
        "&NewLine;"
    ],
    [
        22,
        "&excl;"
    ],
    [
        0,
        "&quot;"
    ],
    [
        0,
        "&num;"
    ],
    [
        0,
        "&dollar;"
    ],
    [
        0,
        "&percnt;"
    ],
    [
        0,
        "&amp;"
    ],
    [
        0,
        "&apos;"
    ],
    [
        0,
        "&lpar;"
    ],
    [
        0,
        "&rpar;"
    ],
    [
        0,
        "&ast;"
    ],
    [
        0,
        "&plus;"
    ],
    [
        0,
        "&comma;"
    ],
    [
        1,
        "&period;"
    ],
    [
        0,
        "&sol;"
    ],
    [
        10,
        "&colon;"
    ],
    [
        0,
        "&semi;"
    ],
    [
        0,
        {
            v: "&lt;",
            n: 8402,
            o: "&nvlt;"
        }
    ],
    [
        0,
        {
            v: "&equals;",
            n: 8421,
            o: "&bne;"
        }
    ],
    [
        0,
        {
            v: "&gt;",
            n: 8402,
            o: "&nvgt;"
        }
    ],
    [
        0,
        "&quest;"
    ],
    [
        0,
        "&commat;"
    ],
    [
        26,
        "&lbrack;"
    ],
    [
        0,
        "&bsol;"
    ],
    [
        0,
        "&rbrack;"
    ],
    [
        0,
        "&Hat;"
    ],
    [
        0,
        "&lowbar;"
    ],
    [
        0,
        "&DiacriticalGrave;"
    ],
    [
        5,
        {
            n: 106,
            o: "&fjlig;"
        }
    ],
    [
        20,
        "&lbrace;"
    ],
    [
        0,
        "&verbar;"
    ],
    [
        0,
        "&rbrace;"
    ],
    [
        34,
        "&nbsp;"
    ],
    [
        0,
        "&iexcl;"
    ],
    [
        0,
        "&cent;"
    ],
    [
        0,
        "&pound;"
    ],
    [
        0,
        "&curren;"
    ],
    [
        0,
        "&yen;"
    ],
    [
        0,
        "&brvbar;"
    ],
    [
        0,
        "&sect;"
    ],
    [
        0,
        "&die;"
    ],
    [
        0,
        "&copy;"
    ],
    [
        0,
        "&ordf;"
    ],
    [
        0,
        "&laquo;"
    ],
    [
        0,
        "&not;"
    ],
    [
        0,
        "&shy;"
    ],
    [
        0,
        "&circledR;"
    ],
    [
        0,
        "&macr;"
    ],
    [
        0,
        "&deg;"
    ],
    [
        0,
        "&PlusMinus;"
    ],
    [
        0,
        "&sup2;"
    ],
    [
        0,
        "&sup3;"
    ],
    [
        0,
        "&acute;"
    ],
    [
        0,
        "&micro;"
    ],
    [
        0,
        "&para;"
    ],
    [
        0,
        "&centerdot;"
    ],
    [
        0,
        "&cedil;"
    ],
    [
        0,
        "&sup1;"
    ],
    [
        0,
        "&ordm;"
    ],
    [
        0,
        "&raquo;"
    ],
    [
        0,
        "&frac14;"
    ],
    [
        0,
        "&frac12;"
    ],
    [
        0,
        "&frac34;"
    ],
    [
        0,
        "&iquest;"
    ],
    [
        0,
        "&Agrave;"
    ],
    [
        0,
        "&Aacute;"
    ],
    [
        0,
        "&Acirc;"
    ],
    [
        0,
        "&Atilde;"
    ],
    [
        0,
        "&Auml;"
    ],
    [
        0,
        "&angst;"
    ],
    [
        0,
        "&AElig;"
    ],
    [
        0,
        "&Ccedil;"
    ],
    [
        0,
        "&Egrave;"
    ],
    [
        0,
        "&Eacute;"
    ],
    [
        0,
        "&Ecirc;"
    ],
    [
        0,
        "&Euml;"
    ],
    [
        0,
        "&Igrave;"
    ],
    [
        0,
        "&Iacute;"
    ],
    [
        0,
        "&Icirc;"
    ],
    [
        0,
        "&Iuml;"
    ],
    [
        0,
        "&ETH;"
    ],
    [
        0,
        "&Ntilde;"
    ],
    [
        0,
        "&Ograve;"
    ],
    [
        0,
        "&Oacute;"
    ],
    [
        0,
        "&Ocirc;"
    ],
    [
        0,
        "&Otilde;"
    ],
    [
        0,
        "&Ouml;"
    ],
    [
        0,
        "&times;"
    ],
    [
        0,
        "&Oslash;"
    ],
    [
        0,
        "&Ugrave;"
    ],
    [
        0,
        "&Uacute;"
    ],
    [
        0,
        "&Ucirc;"
    ],
    [
        0,
        "&Uuml;"
    ],
    [
        0,
        "&Yacute;"
    ],
    [
        0,
        "&THORN;"
    ],
    [
        0,
        "&szlig;"
    ],
    [
        0,
        "&agrave;"
    ],
    [
        0,
        "&aacute;"
    ],
    [
        0,
        "&acirc;"
    ],
    [
        0,
        "&atilde;"
    ],
    [
        0,
        "&auml;"
    ],
    [
        0,
        "&aring;"
    ],
    [
        0,
        "&aelig;"
    ],
    [
        0,
        "&ccedil;"
    ],
    [
        0,
        "&egrave;"
    ],
    [
        0,
        "&eacute;"
    ],
    [
        0,
        "&ecirc;"
    ],
    [
        0,
        "&euml;"
    ],
    [
        0,
        "&igrave;"
    ],
    [
        0,
        "&iacute;"
    ],
    [
        0,
        "&icirc;"
    ],
    [
        0,
        "&iuml;"
    ],
    [
        0,
        "&eth;"
    ],
    [
        0,
        "&ntilde;"
    ],
    [
        0,
        "&ograve;"
    ],
    [
        0,
        "&oacute;"
    ],
    [
        0,
        "&ocirc;"
    ],
    [
        0,
        "&otilde;"
    ],
    [
        0,
        "&ouml;"
    ],
    [
        0,
        "&div;"
    ],
    [
        0,
        "&oslash;"
    ],
    [
        0,
        "&ugrave;"
    ],
    [
        0,
        "&uacute;"
    ],
    [
        0,
        "&ucirc;"
    ],
    [
        0,
        "&uuml;"
    ],
    [
        0,
        "&yacute;"
    ],
    [
        0,
        "&thorn;"
    ],
    [
        0,
        "&yuml;"
    ],
    [
        0,
        "&Amacr;"
    ],
    [
        0,
        "&amacr;"
    ],
    [
        0,
        "&Abreve;"
    ],
    [
        0,
        "&abreve;"
    ],
    [
        0,
        "&Aogon;"
    ],
    [
        0,
        "&aogon;"
    ],
    [
        0,
        "&Cacute;"
    ],
    [
        0,
        "&cacute;"
    ],
    [
        0,
        "&Ccirc;"
    ],
    [
        0,
        "&ccirc;"
    ],
    [
        0,
        "&Cdot;"
    ],
    [
        0,
        "&cdot;"
    ],
    [
        0,
        "&Ccaron;"
    ],
    [
        0,
        "&ccaron;"
    ],
    [
        0,
        "&Dcaron;"
    ],
    [
        0,
        "&dcaron;"
    ],
    [
        0,
        "&Dstrok;"
    ],
    [
        0,
        "&dstrok;"
    ],
    [
        0,
        "&Emacr;"
    ],
    [
        0,
        "&emacr;"
    ],
    [
        2,
        "&Edot;"
    ],
    [
        0,
        "&edot;"
    ],
    [
        0,
        "&Eogon;"
    ],
    [
        0,
        "&eogon;"
    ],
    [
        0,
        "&Ecaron;"
    ],
    [
        0,
        "&ecaron;"
    ],
    [
        0,
        "&Gcirc;"
    ],
    [
        0,
        "&gcirc;"
    ],
    [
        0,
        "&Gbreve;"
    ],
    [
        0,
        "&gbreve;"
    ],
    [
        0,
        "&Gdot;"
    ],
    [
        0,
        "&gdot;"
    ],
    [
        0,
        "&Gcedil;"
    ],
    [
        1,
        "&Hcirc;"
    ],
    [
        0,
        "&hcirc;"
    ],
    [
        0,
        "&Hstrok;"
    ],
    [
        0,
        "&hstrok;"
    ],
    [
        0,
        "&Itilde;"
    ],
    [
        0,
        "&itilde;"
    ],
    [
        0,
        "&Imacr;"
    ],
    [
        0,
        "&imacr;"
    ],
    [
        2,
        "&Iogon;"
    ],
    [
        0,
        "&iogon;"
    ],
    [
        0,
        "&Idot;"
    ],
    [
        0,
        "&imath;"
    ],
    [
        0,
        "&IJlig;"
    ],
    [
        0,
        "&ijlig;"
    ],
    [
        0,
        "&Jcirc;"
    ],
    [
        0,
        "&jcirc;"
    ],
    [
        0,
        "&Kcedil;"
    ],
    [
        0,
        "&kcedil;"
    ],
    [
        0,
        "&kgreen;"
    ],
    [
        0,
        "&Lacute;"
    ],
    [
        0,
        "&lacute;"
    ],
    [
        0,
        "&Lcedil;"
    ],
    [
        0,
        "&lcedil;"
    ],
    [
        0,
        "&Lcaron;"
    ],
    [
        0,
        "&lcaron;"
    ],
    [
        0,
        "&Lmidot;"
    ],
    [
        0,
        "&lmidot;"
    ],
    [
        0,
        "&Lstrok;"
    ],
    [
        0,
        "&lstrok;"
    ],
    [
        0,
        "&Nacute;"
    ],
    [
        0,
        "&nacute;"
    ],
    [
        0,
        "&Ncedil;"
    ],
    [
        0,
        "&ncedil;"
    ],
    [
        0,
        "&Ncaron;"
    ],
    [
        0,
        "&ncaron;"
    ],
    [
        0,
        "&napos;"
    ],
    [
        0,
        "&ENG;"
    ],
    [
        0,
        "&eng;"
    ],
    [
        0,
        "&Omacr;"
    ],
    [
        0,
        "&omacr;"
    ],
    [
        2,
        "&Odblac;"
    ],
    [
        0,
        "&odblac;"
    ],
    [
        0,
        "&OElig;"
    ],
    [
        0,
        "&oelig;"
    ],
    [
        0,
        "&Racute;"
    ],
    [
        0,
        "&racute;"
    ],
    [
        0,
        "&Rcedil;"
    ],
    [
        0,
        "&rcedil;"
    ],
    [
        0,
        "&Rcaron;"
    ],
    [
        0,
        "&rcaron;"
    ],
    [
        0,
        "&Sacute;"
    ],
    [
        0,
        "&sacute;"
    ],
    [
        0,
        "&Scirc;"
    ],
    [
        0,
        "&scirc;"
    ],
    [
        0,
        "&Scedil;"
    ],
    [
        0,
        "&scedil;"
    ],
    [
        0,
        "&Scaron;"
    ],
    [
        0,
        "&scaron;"
    ],
    [
        0,
        "&Tcedil;"
    ],
    [
        0,
        "&tcedil;"
    ],
    [
        0,
        "&Tcaron;"
    ],
    [
        0,
        "&tcaron;"
    ],
    [
        0,
        "&Tstrok;"
    ],
    [
        0,
        "&tstrok;"
    ],
    [
        0,
        "&Utilde;"
    ],
    [
        0,
        "&utilde;"
    ],
    [
        0,
        "&Umacr;"
    ],
    [
        0,
        "&umacr;"
    ],
    [
        0,
        "&Ubreve;"
    ],
    [
        0,
        "&ubreve;"
    ],
    [
        0,
        "&Uring;"
    ],
    [
        0,
        "&uring;"
    ],
    [
        0,
        "&Udblac;"
    ],
    [
        0,
        "&udblac;"
    ],
    [
        0,
        "&Uogon;"
    ],
    [
        0,
        "&uogon;"
    ],
    [
        0,
        "&Wcirc;"
    ],
    [
        0,
        "&wcirc;"
    ],
    [
        0,
        "&Ycirc;"
    ],
    [
        0,
        "&ycirc;"
    ],
    [
        0,
        "&Yuml;"
    ],
    [
        0,
        "&Zacute;"
    ],
    [
        0,
        "&zacute;"
    ],
    [
        0,
        "&Zdot;"
    ],
    [
        0,
        "&zdot;"
    ],
    [
        0,
        "&Zcaron;"
    ],
    [
        0,
        "&zcaron;"
    ],
    [
        19,
        "&fnof;"
    ],
    [
        34,
        "&imped;"
    ],
    [
        63,
        "&gacute;"
    ],
    [
        65,
        "&jmath;"
    ],
    [
        142,
        "&circ;"
    ],
    [
        0,
        "&caron;"
    ],
    [
        16,
        "&breve;"
    ],
    [
        0,
        "&DiacriticalDot;"
    ],
    [
        0,
        "&ring;"
    ],
    [
        0,
        "&ogon;"
    ],
    [
        0,
        "&DiacriticalTilde;"
    ],
    [
        0,
        "&dblac;"
    ],
    [
        51,
        "&DownBreve;"
    ],
    [
        127,
        "&Alpha;"
    ],
    [
        0,
        "&Beta;"
    ],
    [
        0,
        "&Gamma;"
    ],
    [
        0,
        "&Delta;"
    ],
    [
        0,
        "&Epsilon;"
    ],
    [
        0,
        "&Zeta;"
    ],
    [
        0,
        "&Eta;"
    ],
    [
        0,
        "&Theta;"
    ],
    [
        0,
        "&Iota;"
    ],
    [
        0,
        "&Kappa;"
    ],
    [
        0,
        "&Lambda;"
    ],
    [
        0,
        "&Mu;"
    ],
    [
        0,
        "&Nu;"
    ],
    [
        0,
        "&Xi;"
    ],
    [
        0,
        "&Omicron;"
    ],
    [
        0,
        "&Pi;"
    ],
    [
        0,
        "&Rho;"
    ],
    [
        1,
        "&Sigma;"
    ],
    [
        0,
        "&Tau;"
    ],
    [
        0,
        "&Upsilon;"
    ],
    [
        0,
        "&Phi;"
    ],
    [
        0,
        "&Chi;"
    ],
    [
        0,
        "&Psi;"
    ],
    [
        0,
        "&ohm;"
    ],
    [
        7,
        "&alpha;"
    ],
    [
        0,
        "&beta;"
    ],
    [
        0,
        "&gamma;"
    ],
    [
        0,
        "&delta;"
    ],
    [
        0,
        "&epsi;"
    ],
    [
        0,
        "&zeta;"
    ],
    [
        0,
        "&eta;"
    ],
    [
        0,
        "&theta;"
    ],
    [
        0,
        "&iota;"
    ],
    [
        0,
        "&kappa;"
    ],
    [
        0,
        "&lambda;"
    ],
    [
        0,
        "&mu;"
    ],
    [
        0,
        "&nu;"
    ],
    [
        0,
        "&xi;"
    ],
    [
        0,
        "&omicron;"
    ],
    [
        0,
        "&pi;"
    ],
    [
        0,
        "&rho;"
    ],
    [
        0,
        "&sigmaf;"
    ],
    [
        0,
        "&sigma;"
    ],
    [
        0,
        "&tau;"
    ],
    [
        0,
        "&upsi;"
    ],
    [
        0,
        "&phi;"
    ],
    [
        0,
        "&chi;"
    ],
    [
        0,
        "&psi;"
    ],
    [
        0,
        "&omega;"
    ],
    [
        7,
        "&thetasym;"
    ],
    [
        0,
        "&Upsi;"
    ],
    [
        2,
        "&phiv;"
    ],
    [
        0,
        "&piv;"
    ],
    [
        5,
        "&Gammad;"
    ],
    [
        0,
        "&digamma;"
    ],
    [
        18,
        "&kappav;"
    ],
    [
        0,
        "&rhov;"
    ],
    [
        3,
        "&epsiv;"
    ],
    [
        0,
        "&backepsilon;"
    ],
    [
        10,
        "&IOcy;"
    ],
    [
        0,
        "&DJcy;"
    ],
    [
        0,
        "&GJcy;"
    ],
    [
        0,
        "&Jukcy;"
    ],
    [
        0,
        "&DScy;"
    ],
    [
        0,
        "&Iukcy;"
    ],
    [
        0,
        "&YIcy;"
    ],
    [
        0,
        "&Jsercy;"
    ],
    [
        0,
        "&LJcy;"
    ],
    [
        0,
        "&NJcy;"
    ],
    [
        0,
        "&TSHcy;"
    ],
    [
        0,
        "&KJcy;"
    ],
    [
        1,
        "&Ubrcy;"
    ],
    [
        0,
        "&DZcy;"
    ],
    [
        0,
        "&Acy;"
    ],
    [
        0,
        "&Bcy;"
    ],
    [
        0,
        "&Vcy;"
    ],
    [
        0,
        "&Gcy;"
    ],
    [
        0,
        "&Dcy;"
    ],
    [
        0,
        "&IEcy;"
    ],
    [
        0,
        "&ZHcy;"
    ],
    [
        0,
        "&Zcy;"
    ],
    [
        0,
        "&Icy;"
    ],
    [
        0,
        "&Jcy;"
    ],
    [
        0,
        "&Kcy;"
    ],
    [
        0,
        "&Lcy;"
    ],
    [
        0,
        "&Mcy;"
    ],
    [
        0,
        "&Ncy;"
    ],
    [
        0,
        "&Ocy;"
    ],
    [
        0,
        "&Pcy;"
    ],
    [
        0,
        "&Rcy;"
    ],
    [
        0,
        "&Scy;"
    ],
    [
        0,
        "&Tcy;"
    ],
    [
        0,
        "&Ucy;"
    ],
    [
        0,
        "&Fcy;"
    ],
    [
        0,
        "&KHcy;"
    ],
    [
        0,
        "&TScy;"
    ],
    [
        0,
        "&CHcy;"
    ],
    [
        0,
        "&SHcy;"
    ],
    [
        0,
        "&SHCHcy;"
    ],
    [
        0,
        "&HARDcy;"
    ],
    [
        0,
        "&Ycy;"
    ],
    [
        0,
        "&SOFTcy;"
    ],
    [
        0,
        "&Ecy;"
    ],
    [
        0,
        "&YUcy;"
    ],
    [
        0,
        "&YAcy;"
    ],
    [
        0,
        "&acy;"
    ],
    [
        0,
        "&bcy;"
    ],
    [
        0,
        "&vcy;"
    ],
    [
        0,
        "&gcy;"
    ],
    [
        0,
        "&dcy;"
    ],
    [
        0,
        "&iecy;"
    ],
    [
        0,
        "&zhcy;"
    ],
    [
        0,
        "&zcy;"
    ],
    [
        0,
        "&icy;"
    ],
    [
        0,
        "&jcy;"
    ],
    [
        0,
        "&kcy;"
    ],
    [
        0,
        "&lcy;"
    ],
    [
        0,
        "&mcy;"
    ],
    [
        0,
        "&ncy;"
    ],
    [
        0,
        "&ocy;"
    ],
    [
        0,
        "&pcy;"
    ],
    [
        0,
        "&rcy;"
    ],
    [
        0,
        "&scy;"
    ],
    [
        0,
        "&tcy;"
    ],
    [
        0,
        "&ucy;"
    ],
    [
        0,
        "&fcy;"
    ],
    [
        0,
        "&khcy;"
    ],
    [
        0,
        "&tscy;"
    ],
    [
        0,
        "&chcy;"
    ],
    [
        0,
        "&shcy;"
    ],
    [
        0,
        "&shchcy;"
    ],
    [
        0,
        "&hardcy;"
    ],
    [
        0,
        "&ycy;"
    ],
    [
        0,
        "&softcy;"
    ],
    [
        0,
        "&ecy;"
    ],
    [
        0,
        "&yucy;"
    ],
    [
        0,
        "&yacy;"
    ],
    [
        1,
        "&iocy;"
    ],
    [
        0,
        "&djcy;"
    ],
    [
        0,
        "&gjcy;"
    ],
    [
        0,
        "&jukcy;"
    ],
    [
        0,
        "&dscy;"
    ],
    [
        0,
        "&iukcy;"
    ],
    [
        0,
        "&yicy;"
    ],
    [
        0,
        "&jsercy;"
    ],
    [
        0,
        "&ljcy;"
    ],
    [
        0,
        "&njcy;"
    ],
    [
        0,
        "&tshcy;"
    ],
    [
        0,
        "&kjcy;"
    ],
    [
        1,
        "&ubrcy;"
    ],
    [
        0,
        "&dzcy;"
    ],
    [
        7074,
        "&ensp;"
    ],
    [
        0,
        "&emsp;"
    ],
    [
        0,
        "&emsp13;"
    ],
    [
        0,
        "&emsp14;"
    ],
    [
        1,
        "&numsp;"
    ],
    [
        0,
        "&puncsp;"
    ],
    [
        0,
        "&ThinSpace;"
    ],
    [
        0,
        "&hairsp;"
    ],
    [
        0,
        "&NegativeMediumSpace;"
    ],
    [
        0,
        "&zwnj;"
    ],
    [
        0,
        "&zwj;"
    ],
    [
        0,
        "&lrm;"
    ],
    [
        0,
        "&rlm;"
    ],
    [
        0,
        "&dash;"
    ],
    [
        2,
        "&ndash;"
    ],
    [
        0,
        "&mdash;"
    ],
    [
        0,
        "&horbar;"
    ],
    [
        0,
        "&Verbar;"
    ],
    [
        1,
        "&lsquo;"
    ],
    [
        0,
        "&CloseCurlyQuote;"
    ],
    [
        0,
        "&lsquor;"
    ],
    [
        1,
        "&ldquo;"
    ],
    [
        0,
        "&CloseCurlyDoubleQuote;"
    ],
    [
        0,
        "&bdquo;"
    ],
    [
        1,
        "&dagger;"
    ],
    [
        0,
        "&Dagger;"
    ],
    [
        0,
        "&bull;"
    ],
    [
        2,
        "&nldr;"
    ],
    [
        0,
        "&hellip;"
    ],
    [
        9,
        "&permil;"
    ],
    [
        0,
        "&pertenk;"
    ],
    [
        0,
        "&prime;"
    ],
    [
        0,
        "&Prime;"
    ],
    [
        0,
        "&tprime;"
    ],
    [
        0,
        "&backprime;"
    ],
    [
        3,
        "&lsaquo;"
    ],
    [
        0,
        "&rsaquo;"
    ],
    [
        3,
        "&oline;"
    ],
    [
        2,
        "&caret;"
    ],
    [
        1,
        "&hybull;"
    ],
    [
        0,
        "&frasl;"
    ],
    [
        10,
        "&bsemi;"
    ],
    [
        7,
        "&qprime;"
    ],
    [
        7,
        {
            v: "&MediumSpace;",
            n: 8202,
            o: "&ThickSpace;"
        }
    ],
    [
        0,
        "&NoBreak;"
    ],
    [
        0,
        "&af;"
    ],
    [
        0,
        "&InvisibleTimes;"
    ],
    [
        0,
        "&ic;"
    ],
    [
        72,
        "&euro;"
    ],
    [
        46,
        "&tdot;"
    ],
    [
        0,
        "&DotDot;"
    ],
    [
        37,
        "&complexes;"
    ],
    [
        2,
        "&incare;"
    ],
    [
        4,
        "&gscr;"
    ],
    [
        0,
        "&hamilt;"
    ],
    [
        0,
        "&Hfr;"
    ],
    [
        0,
        "&Hopf;"
    ],
    [
        0,
        "&planckh;"
    ],
    [
        0,
        "&hbar;"
    ],
    [
        0,
        "&imagline;"
    ],
    [
        0,
        "&Ifr;"
    ],
    [
        0,
        "&lagran;"
    ],
    [
        0,
        "&ell;"
    ],
    [
        1,
        "&naturals;"
    ],
    [
        0,
        "&numero;"
    ],
    [
        0,
        "&copysr;"
    ],
    [
        0,
        "&weierp;"
    ],
    [
        0,
        "&Popf;"
    ],
    [
        0,
        "&Qopf;"
    ],
    [
        0,
        "&realine;"
    ],
    [
        0,
        "&real;"
    ],
    [
        0,
        "&reals;"
    ],
    [
        0,
        "&rx;"
    ],
    [
        3,
        "&trade;"
    ],
    [
        1,
        "&integers;"
    ],
    [
        2,
        "&mho;"
    ],
    [
        0,
        "&zeetrf;"
    ],
    [
        0,
        "&iiota;"
    ],
    [
        2,
        "&bernou;"
    ],
    [
        0,
        "&Cayleys;"
    ],
    [
        1,
        "&escr;"
    ],
    [
        0,
        "&Escr;"
    ],
    [
        0,
        "&Fouriertrf;"
    ],
    [
        1,
        "&Mellintrf;"
    ],
    [
        0,
        "&order;"
    ],
    [
        0,
        "&alefsym;"
    ],
    [
        0,
        "&beth;"
    ],
    [
        0,
        "&gimel;"
    ],
    [
        0,
        "&daleth;"
    ],
    [
        12,
        "&CapitalDifferentialD;"
    ],
    [
        0,
        "&dd;"
    ],
    [
        0,
        "&ee;"
    ],
    [
        0,
        "&ii;"
    ],
    [
        10,
        "&frac13;"
    ],
    [
        0,
        "&frac23;"
    ],
    [
        0,
        "&frac15;"
    ],
    [
        0,
        "&frac25;"
    ],
    [
        0,
        "&frac35;"
    ],
    [
        0,
        "&frac45;"
    ],
    [
        0,
        "&frac16;"
    ],
    [
        0,
        "&frac56;"
    ],
    [
        0,
        "&frac18;"
    ],
    [
        0,
        "&frac38;"
    ],
    [
        0,
        "&frac58;"
    ],
    [
        0,
        "&frac78;"
    ],
    [
        49,
        "&larr;"
    ],
    [
        0,
        "&ShortUpArrow;"
    ],
    [
        0,
        "&rarr;"
    ],
    [
        0,
        "&darr;"
    ],
    [
        0,
        "&harr;"
    ],
    [
        0,
        "&updownarrow;"
    ],
    [
        0,
        "&nwarr;"
    ],
    [
        0,
        "&nearr;"
    ],
    [
        0,
        "&LowerRightArrow;"
    ],
    [
        0,
        "&LowerLeftArrow;"
    ],
    [
        0,
        "&nlarr;"
    ],
    [
        0,
        "&nrarr;"
    ],
    [
        1,
        {
            v: "&rarrw;",
            n: 824,
            o: "&nrarrw;"
        }
    ],
    [
        0,
        "&Larr;"
    ],
    [
        0,
        "&Uarr;"
    ],
    [
        0,
        "&Rarr;"
    ],
    [
        0,
        "&Darr;"
    ],
    [
        0,
        "&larrtl;"
    ],
    [
        0,
        "&rarrtl;"
    ],
    [
        0,
        "&LeftTeeArrow;"
    ],
    [
        0,
        "&mapstoup;"
    ],
    [
        0,
        "&map;"
    ],
    [
        0,
        "&DownTeeArrow;"
    ],
    [
        1,
        "&hookleftarrow;"
    ],
    [
        0,
        "&hookrightarrow;"
    ],
    [
        0,
        "&larrlp;"
    ],
    [
        0,
        "&looparrowright;"
    ],
    [
        0,
        "&harrw;"
    ],
    [
        0,
        "&nharr;"
    ],
    [
        1,
        "&lsh;"
    ],
    [
        0,
        "&rsh;"
    ],
    [
        0,
        "&ldsh;"
    ],
    [
        0,
        "&rdsh;"
    ],
    [
        1,
        "&crarr;"
    ],
    [
        0,
        "&cularr;"
    ],
    [
        0,
        "&curarr;"
    ],
    [
        2,
        "&circlearrowleft;"
    ],
    [
        0,
        "&circlearrowright;"
    ],
    [
        0,
        "&leftharpoonup;"
    ],
    [
        0,
        "&DownLeftVector;"
    ],
    [
        0,
        "&RightUpVector;"
    ],
    [
        0,
        "&LeftUpVector;"
    ],
    [
        0,
        "&rharu;"
    ],
    [
        0,
        "&DownRightVector;"
    ],
    [
        0,
        "&dharr;"
    ],
    [
        0,
        "&dharl;"
    ],
    [
        0,
        "&RightArrowLeftArrow;"
    ],
    [
        0,
        "&udarr;"
    ],
    [
        0,
        "&LeftArrowRightArrow;"
    ],
    [
        0,
        "&leftleftarrows;"
    ],
    [
        0,
        "&upuparrows;"
    ],
    [
        0,
        "&rightrightarrows;"
    ],
    [
        0,
        "&ddarr;"
    ],
    [
        0,
        "&leftrightharpoons;"
    ],
    [
        0,
        "&Equilibrium;"
    ],
    [
        0,
        "&nlArr;"
    ],
    [
        0,
        "&nhArr;"
    ],
    [
        0,
        "&nrArr;"
    ],
    [
        0,
        "&DoubleLeftArrow;"
    ],
    [
        0,
        "&DoubleUpArrow;"
    ],
    [
        0,
        "&DoubleRightArrow;"
    ],
    [
        0,
        "&dArr;"
    ],
    [
        0,
        "&DoubleLeftRightArrow;"
    ],
    [
        0,
        "&DoubleUpDownArrow;"
    ],
    [
        0,
        "&nwArr;"
    ],
    [
        0,
        "&neArr;"
    ],
    [
        0,
        "&seArr;"
    ],
    [
        0,
        "&swArr;"
    ],
    [
        0,
        "&lAarr;"
    ],
    [
        0,
        "&rAarr;"
    ],
    [
        1,
        "&zigrarr;"
    ],
    [
        6,
        "&larrb;"
    ],
    [
        0,
        "&rarrb;"
    ],
    [
        15,
        "&DownArrowUpArrow;"
    ],
    [
        7,
        "&loarr;"
    ],
    [
        0,
        "&roarr;"
    ],
    [
        0,
        "&hoarr;"
    ],
    [
        0,
        "&forall;"
    ],
    [
        0,
        "&comp;"
    ],
    [
        0,
        {
            v: "&part;",
            n: 824,
            o: "&npart;"
        }
    ],
    [
        0,
        "&exist;"
    ],
    [
        0,
        "&nexist;"
    ],
    [
        0,
        "&empty;"
    ],
    [
        1,
        "&Del;"
    ],
    [
        0,
        "&Element;"
    ],
    [
        0,
        "&NotElement;"
    ],
    [
        1,
        "&ni;"
    ],
    [
        0,
        "&notni;"
    ],
    [
        2,
        "&prod;"
    ],
    [
        0,
        "&coprod;"
    ],
    [
        0,
        "&sum;"
    ],
    [
        0,
        "&minus;"
    ],
    [
        0,
        "&MinusPlus;"
    ],
    [
        0,
        "&dotplus;"
    ],
    [
        1,
        "&Backslash;"
    ],
    [
        0,
        "&lowast;"
    ],
    [
        0,
        "&compfn;"
    ],
    [
        1,
        "&radic;"
    ],
    [
        2,
        "&prop;"
    ],
    [
        0,
        "&infin;"
    ],
    [
        0,
        "&angrt;"
    ],
    [
        0,
        {
            v: "&ang;",
            n: 8402,
            o: "&nang;"
        }
    ],
    [
        0,
        "&angmsd;"
    ],
    [
        0,
        "&angsph;"
    ],
    [
        0,
        "&mid;"
    ],
    [
        0,
        "&nmid;"
    ],
    [
        0,
        "&DoubleVerticalBar;"
    ],
    [
        0,
        "&NotDoubleVerticalBar;"
    ],
    [
        0,
        "&and;"
    ],
    [
        0,
        "&or;"
    ],
    [
        0,
        {
            v: "&cap;",
            n: 65024,
            o: "&caps;"
        }
    ],
    [
        0,
        {
            v: "&cup;",
            n: 65024,
            o: "&cups;"
        }
    ],
    [
        0,
        "&int;"
    ],
    [
        0,
        "&Int;"
    ],
    [
        0,
        "&iiint;"
    ],
    [
        0,
        "&conint;"
    ],
    [
        0,
        "&Conint;"
    ],
    [
        0,
        "&Cconint;"
    ],
    [
        0,
        "&cwint;"
    ],
    [
        0,
        "&ClockwiseContourIntegral;"
    ],
    [
        0,
        "&awconint;"
    ],
    [
        0,
        "&there4;"
    ],
    [
        0,
        "&becaus;"
    ],
    [
        0,
        "&ratio;"
    ],
    [
        0,
        "&Colon;"
    ],
    [
        0,
        "&dotminus;"
    ],
    [
        1,
        "&mDDot;"
    ],
    [
        0,
        "&homtht;"
    ],
    [
        0,
        {
            v: "&sim;",
            n: 8402,
            o: "&nvsim;"
        }
    ],
    [
        0,
        {
            v: "&backsim;",
            n: 817,
            o: "&race;"
        }
    ],
    [
        0,
        {
            v: "&ac;",
            n: 819,
            o: "&acE;"
        }
    ],
    [
        0,
        "&acd;"
    ],
    [
        0,
        "&VerticalTilde;"
    ],
    [
        0,
        "&NotTilde;"
    ],
    [
        0,
        {
            v: "&eqsim;",
            n: 824,
            o: "&nesim;"
        }
    ],
    [
        0,
        "&sime;"
    ],
    [
        0,
        "&NotTildeEqual;"
    ],
    [
        0,
        "&cong;"
    ],
    [
        0,
        "&simne;"
    ],
    [
        0,
        "&ncong;"
    ],
    [
        0,
        "&ap;"
    ],
    [
        0,
        "&nap;"
    ],
    [
        0,
        "&ape;"
    ],
    [
        0,
        {
            v: "&apid;",
            n: 824,
            o: "&napid;"
        }
    ],
    [
        0,
        "&backcong;"
    ],
    [
        0,
        {
            v: "&asympeq;",
            n: 8402,
            o: "&nvap;"
        }
    ],
    [
        0,
        {
            v: "&bump;",
            n: 824,
            o: "&nbump;"
        }
    ],
    [
        0,
        {
            v: "&bumpe;",
            n: 824,
            o: "&nbumpe;"
        }
    ],
    [
        0,
        {
            v: "&doteq;",
            n: 824,
            o: "&nedot;"
        }
    ],
    [
        0,
        "&doteqdot;"
    ],
    [
        0,
        "&efDot;"
    ],
    [
        0,
        "&erDot;"
    ],
    [
        0,
        "&Assign;"
    ],
    [
        0,
        "&ecolon;"
    ],
    [
        0,
        "&ecir;"
    ],
    [
        0,
        "&circeq;"
    ],
    [
        1,
        "&wedgeq;"
    ],
    [
        0,
        "&veeeq;"
    ],
    [
        1,
        "&triangleq;"
    ],
    [
        2,
        "&equest;"
    ],
    [
        0,
        "&ne;"
    ],
    [
        0,
        {
            v: "&Congruent;",
            n: 8421,
            o: "&bnequiv;"
        }
    ],
    [
        0,
        "&nequiv;"
    ],
    [
        1,
        {
            v: "&le;",
            n: 8402,
            o: "&nvle;"
        }
    ],
    [
        0,
        {
            v: "&ge;",
            n: 8402,
            o: "&nvge;"
        }
    ],
    [
        0,
        {
            v: "&lE;",
            n: 824,
            o: "&nlE;"
        }
    ],
    [
        0,
        {
            v: "&gE;",
            n: 824,
            o: "&ngE;"
        }
    ],
    [
        0,
        {
            v: "&lnE;",
            n: 65024,
            o: "&lvertneqq;"
        }
    ],
    [
        0,
        {
            v: "&gnE;",
            n: 65024,
            o: "&gvertneqq;"
        }
    ],
    [
        0,
        {
            v: "&ll;",
            n: new Map(/* #__PURE__ */ restoreDiff([
                [
                    824,
                    "&nLtv;"
                ],
                [
                    7577,
                    "&nLt;"
                ]
            ]))
        }
    ],
    [
        0,
        {
            v: "&gg;",
            n: new Map(/* #__PURE__ */ restoreDiff([
                [
                    824,
                    "&nGtv;"
                ],
                [
                    7577,
                    "&nGt;"
                ]
            ]))
        }
    ],
    [
        0,
        "&between;"
    ],
    [
        0,
        "&NotCupCap;"
    ],
    [
        0,
        "&nless;"
    ],
    [
        0,
        "&ngt;"
    ],
    [
        0,
        "&nle;"
    ],
    [
        0,
        "&nge;"
    ],
    [
        0,
        "&lesssim;"
    ],
    [
        0,
        "&GreaterTilde;"
    ],
    [
        0,
        "&nlsim;"
    ],
    [
        0,
        "&ngsim;"
    ],
    [
        0,
        "&LessGreater;"
    ],
    [
        0,
        "&gl;"
    ],
    [
        0,
        "&NotLessGreater;"
    ],
    [
        0,
        "&NotGreaterLess;"
    ],
    [
        0,
        "&pr;"
    ],
    [
        0,
        "&sc;"
    ],
    [
        0,
        "&prcue;"
    ],
    [
        0,
        "&sccue;"
    ],
    [
        0,
        "&PrecedesTilde;"
    ],
    [
        0,
        {
            v: "&scsim;",
            n: 824,
            o: "&NotSucceedsTilde;"
        }
    ],
    [
        0,
        "&NotPrecedes;"
    ],
    [
        0,
        "&NotSucceeds;"
    ],
    [
        0,
        {
            v: "&sub;",
            n: 8402,
            o: "&NotSubset;"
        }
    ],
    [
        0,
        {
            v: "&sup;",
            n: 8402,
            o: "&NotSuperset;"
        }
    ],
    [
        0,
        "&nsub;"
    ],
    [
        0,
        "&nsup;"
    ],
    [
        0,
        "&sube;"
    ],
    [
        0,
        "&supe;"
    ],
    [
        0,
        "&NotSubsetEqual;"
    ],
    [
        0,
        "&NotSupersetEqual;"
    ],
    [
        0,
        {
            v: "&subne;",
            n: 65024,
            o: "&varsubsetneq;"
        }
    ],
    [
        0,
        {
            v: "&supne;",
            n: 65024,
            o: "&varsupsetneq;"
        }
    ],
    [
        1,
        "&cupdot;"
    ],
    [
        0,
        "&UnionPlus;"
    ],
    [
        0,
        {
            v: "&sqsub;",
            n: 824,
            o: "&NotSquareSubset;"
        }
    ],
    [
        0,
        {
            v: "&sqsup;",
            n: 824,
            o: "&NotSquareSuperset;"
        }
    ],
    [
        0,
        "&sqsube;"
    ],
    [
        0,
        "&sqsupe;"
    ],
    [
        0,
        {
            v: "&sqcap;",
            n: 65024,
            o: "&sqcaps;"
        }
    ],
    [
        0,
        {
            v: "&sqcup;",
            n: 65024,
            o: "&sqcups;"
        }
    ],
    [
        0,
        "&CirclePlus;"
    ],
    [
        0,
        "&CircleMinus;"
    ],
    [
        0,
        "&CircleTimes;"
    ],
    [
        0,
        "&osol;"
    ],
    [
        0,
        "&CircleDot;"
    ],
    [
        0,
        "&circledcirc;"
    ],
    [
        0,
        "&circledast;"
    ],
    [
        1,
        "&circleddash;"
    ],
    [
        0,
        "&boxplus;"
    ],
    [
        0,
        "&boxminus;"
    ],
    [
        0,
        "&boxtimes;"
    ],
    [
        0,
        "&dotsquare;"
    ],
    [
        0,
        "&RightTee;"
    ],
    [
        0,
        "&dashv;"
    ],
    [
        0,
        "&DownTee;"
    ],
    [
        0,
        "&bot;"
    ],
    [
        1,
        "&models;"
    ],
    [
        0,
        "&DoubleRightTee;"
    ],
    [
        0,
        "&Vdash;"
    ],
    [
        0,
        "&Vvdash;"
    ],
    [
        0,
        "&VDash;"
    ],
    [
        0,
        "&nvdash;"
    ],
    [
        0,
        "&nvDash;"
    ],
    [
        0,
        "&nVdash;"
    ],
    [
        0,
        "&nVDash;"
    ],
    [
        0,
        "&prurel;"
    ],
    [
        1,
        "&LeftTriangle;"
    ],
    [
        0,
        "&RightTriangle;"
    ],
    [
        0,
        {
            v: "&LeftTriangleEqual;",
            n: 8402,
            o: "&nvltrie;"
        }
    ],
    [
        0,
        {
            v: "&RightTriangleEqual;",
            n: 8402,
            o: "&nvrtrie;"
        }
    ],
    [
        0,
        "&origof;"
    ],
    [
        0,
        "&imof;"
    ],
    [
        0,
        "&multimap;"
    ],
    [
        0,
        "&hercon;"
    ],
    [
        0,
        "&intcal;"
    ],
    [
        0,
        "&veebar;"
    ],
    [
        1,
        "&barvee;"
    ],
    [
        0,
        "&angrtvb;"
    ],
    [
        0,
        "&lrtri;"
    ],
    [
        0,
        "&bigwedge;"
    ],
    [
        0,
        "&bigvee;"
    ],
    [
        0,
        "&bigcap;"
    ],
    [
        0,
        "&bigcup;"
    ],
    [
        0,
        "&diam;"
    ],
    [
        0,
        "&sdot;"
    ],
    [
        0,
        "&sstarf;"
    ],
    [
        0,
        "&divideontimes;"
    ],
    [
        0,
        "&bowtie;"
    ],
    [
        0,
        "&ltimes;"
    ],
    [
        0,
        "&rtimes;"
    ],
    [
        0,
        "&leftthreetimes;"
    ],
    [
        0,
        "&rightthreetimes;"
    ],
    [
        0,
        "&backsimeq;"
    ],
    [
        0,
        "&curlyvee;"
    ],
    [
        0,
        "&curlywedge;"
    ],
    [
        0,
        "&Sub;"
    ],
    [
        0,
        "&Sup;"
    ],
    [
        0,
        "&Cap;"
    ],
    [
        0,
        "&Cup;"
    ],
    [
        0,
        "&fork;"
    ],
    [
        0,
        "&epar;"
    ],
    [
        0,
        "&lessdot;"
    ],
    [
        0,
        "&gtdot;"
    ],
    [
        0,
        {
            v: "&Ll;",
            n: 824,
            o: "&nLl;"
        }
    ],
    [
        0,
        {
            v: "&Gg;",
            n: 824,
            o: "&nGg;"
        }
    ],
    [
        0,
        {
            v: "&leg;",
            n: 65024,
            o: "&lesg;"
        }
    ],
    [
        0,
        {
            v: "&gel;",
            n: 65024,
            o: "&gesl;"
        }
    ],
    [
        2,
        "&cuepr;"
    ],
    [
        0,
        "&cuesc;"
    ],
    [
        0,
        "&NotPrecedesSlantEqual;"
    ],
    [
        0,
        "&NotSucceedsSlantEqual;"
    ],
    [
        0,
        "&NotSquareSubsetEqual;"
    ],
    [
        0,
        "&NotSquareSupersetEqual;"
    ],
    [
        2,
        "&lnsim;"
    ],
    [
        0,
        "&gnsim;"
    ],
    [
        0,
        "&precnsim;"
    ],
    [
        0,
        "&scnsim;"
    ],
    [
        0,
        "&nltri;"
    ],
    [
        0,
        "&NotRightTriangle;"
    ],
    [
        0,
        "&nltrie;"
    ],
    [
        0,
        "&NotRightTriangleEqual;"
    ],
    [
        0,
        "&vellip;"
    ],
    [
        0,
        "&ctdot;"
    ],
    [
        0,
        "&utdot;"
    ],
    [
        0,
        "&dtdot;"
    ],
    [
        0,
        "&disin;"
    ],
    [
        0,
        "&isinsv;"
    ],
    [
        0,
        "&isins;"
    ],
    [
        0,
        {
            v: "&isindot;",
            n: 824,
            o: "&notindot;"
        }
    ],
    [
        0,
        "&notinvc;"
    ],
    [
        0,
        "&notinvb;"
    ],
    [
        1,
        {
            v: "&isinE;",
            n: 824,
            o: "&notinE;"
        }
    ],
    [
        0,
        "&nisd;"
    ],
    [
        0,
        "&xnis;"
    ],
    [
        0,
        "&nis;"
    ],
    [
        0,
        "&notnivc;"
    ],
    [
        0,
        "&notnivb;"
    ],
    [
        6,
        "&barwed;"
    ],
    [
        0,
        "&Barwed;"
    ],
    [
        1,
        "&lceil;"
    ],
    [
        0,
        "&rceil;"
    ],
    [
        0,
        "&LeftFloor;"
    ],
    [
        0,
        "&rfloor;"
    ],
    [
        0,
        "&drcrop;"
    ],
    [
        0,
        "&dlcrop;"
    ],
    [
        0,
        "&urcrop;"
    ],
    [
        0,
        "&ulcrop;"
    ],
    [
        0,
        "&bnot;"
    ],
    [
        1,
        "&profline;"
    ],
    [
        0,
        "&profsurf;"
    ],
    [
        1,
        "&telrec;"
    ],
    [
        0,
        "&target;"
    ],
    [
        5,
        "&ulcorn;"
    ],
    [
        0,
        "&urcorn;"
    ],
    [
        0,
        "&dlcorn;"
    ],
    [
        0,
        "&drcorn;"
    ],
    [
        2,
        "&frown;"
    ],
    [
        0,
        "&smile;"
    ],
    [
        9,
        "&cylcty;"
    ],
    [
        0,
        "&profalar;"
    ],
    [
        7,
        "&topbot;"
    ],
    [
        6,
        "&ovbar;"
    ],
    [
        1,
        "&solbar;"
    ],
    [
        60,
        "&angzarr;"
    ],
    [
        51,
        "&lmoustache;"
    ],
    [
        0,
        "&rmoustache;"
    ],
    [
        2,
        "&OverBracket;"
    ],
    [
        0,
        "&bbrk;"
    ],
    [
        0,
        "&bbrktbrk;"
    ],
    [
        37,
        "&OverParenthesis;"
    ],
    [
        0,
        "&UnderParenthesis;"
    ],
    [
        0,
        "&OverBrace;"
    ],
    [
        0,
        "&UnderBrace;"
    ],
    [
        2,
        "&trpezium;"
    ],
    [
        4,
        "&elinters;"
    ],
    [
        59,
        "&blank;"
    ],
    [
        164,
        "&circledS;"
    ],
    [
        55,
        "&boxh;"
    ],
    [
        1,
        "&boxv;"
    ],
    [
        9,
        "&boxdr;"
    ],
    [
        3,
        "&boxdl;"
    ],
    [
        3,
        "&boxur;"
    ],
    [
        3,
        "&boxul;"
    ],
    [
        3,
        "&boxvr;"
    ],
    [
        7,
        "&boxvl;"
    ],
    [
        7,
        "&boxhd;"
    ],
    [
        7,
        "&boxhu;"
    ],
    [
        7,
        "&boxvh;"
    ],
    [
        19,
        "&boxH;"
    ],
    [
        0,
        "&boxV;"
    ],
    [
        0,
        "&boxdR;"
    ],
    [
        0,
        "&boxDr;"
    ],
    [
        0,
        "&boxDR;"
    ],
    [
        0,
        "&boxdL;"
    ],
    [
        0,
        "&boxDl;"
    ],
    [
        0,
        "&boxDL;"
    ],
    [
        0,
        "&boxuR;"
    ],
    [
        0,
        "&boxUr;"
    ],
    [
        0,
        "&boxUR;"
    ],
    [
        0,
        "&boxuL;"
    ],
    [
        0,
        "&boxUl;"
    ],
    [
        0,
        "&boxUL;"
    ],
    [
        0,
        "&boxvR;"
    ],
    [
        0,
        "&boxVr;"
    ],
    [
        0,
        "&boxVR;"
    ],
    [
        0,
        "&boxvL;"
    ],
    [
        0,
        "&boxVl;"
    ],
    [
        0,
        "&boxVL;"
    ],
    [
        0,
        "&boxHd;"
    ],
    [
        0,
        "&boxhD;"
    ],
    [
        0,
        "&boxHD;"
    ],
    [
        0,
        "&boxHu;"
    ],
    [
        0,
        "&boxhU;"
    ],
    [
        0,
        "&boxHU;"
    ],
    [
        0,
        "&boxvH;"
    ],
    [
        0,
        "&boxVh;"
    ],
    [
        0,
        "&boxVH;"
    ],
    [
        19,
        "&uhblk;"
    ],
    [
        3,
        "&lhblk;"
    ],
    [
        3,
        "&block;"
    ],
    [
        8,
        "&blk14;"
    ],
    [
        0,
        "&blk12;"
    ],
    [
        0,
        "&blk34;"
    ],
    [
        13,
        "&square;"
    ],
    [
        8,
        "&blacksquare;"
    ],
    [
        0,
        "&EmptyVerySmallSquare;"
    ],
    [
        1,
        "&rect;"
    ],
    [
        0,
        "&marker;"
    ],
    [
        2,
        "&fltns;"
    ],
    [
        1,
        "&bigtriangleup;"
    ],
    [
        0,
        "&blacktriangle;"
    ],
    [
        0,
        "&triangle;"
    ],
    [
        2,
        "&blacktriangleright;"
    ],
    [
        0,
        "&rtri;"
    ],
    [
        3,
        "&bigtriangledown;"
    ],
    [
        0,
        "&blacktriangledown;"
    ],
    [
        0,
        "&dtri;"
    ],
    [
        2,
        "&blacktriangleleft;"
    ],
    [
        0,
        "&ltri;"
    ],
    [
        6,
        "&loz;"
    ],
    [
        0,
        "&cir;"
    ],
    [
        32,
        "&tridot;"
    ],
    [
        2,
        "&bigcirc;"
    ],
    [
        8,
        "&ultri;"
    ],
    [
        0,
        "&urtri;"
    ],
    [
        0,
        "&lltri;"
    ],
    [
        0,
        "&EmptySmallSquare;"
    ],
    [
        0,
        "&FilledSmallSquare;"
    ],
    [
        8,
        "&bigstar;"
    ],
    [
        0,
        "&star;"
    ],
    [
        7,
        "&phone;"
    ],
    [
        49,
        "&female;"
    ],
    [
        1,
        "&male;"
    ],
    [
        29,
        "&spades;"
    ],
    [
        2,
        "&clubs;"
    ],
    [
        1,
        "&hearts;"
    ],
    [
        0,
        "&diamondsuit;"
    ],
    [
        3,
        "&sung;"
    ],
    [
        2,
        "&flat;"
    ],
    [
        0,
        "&natural;"
    ],
    [
        0,
        "&sharp;"
    ],
    [
        163,
        "&check;"
    ],
    [
        3,
        "&cross;"
    ],
    [
        8,
        "&malt;"
    ],
    [
        21,
        "&sext;"
    ],
    [
        33,
        "&VerticalSeparator;"
    ],
    [
        25,
        "&lbbrk;"
    ],
    [
        0,
        "&rbbrk;"
    ],
    [
        84,
        "&bsolhsub;"
    ],
    [
        0,
        "&suphsol;"
    ],
    [
        28,
        "&LeftDoubleBracket;"
    ],
    [
        0,
        "&RightDoubleBracket;"
    ],
    [
        0,
        "&lang;"
    ],
    [
        0,
        "&rang;"
    ],
    [
        0,
        "&Lang;"
    ],
    [
        0,
        "&Rang;"
    ],
    [
        0,
        "&loang;"
    ],
    [
        0,
        "&roang;"
    ],
    [
        7,
        "&longleftarrow;"
    ],
    [
        0,
        "&longrightarrow;"
    ],
    [
        0,
        "&longleftrightarrow;"
    ],
    [
        0,
        "&DoubleLongLeftArrow;"
    ],
    [
        0,
        "&DoubleLongRightArrow;"
    ],
    [
        0,
        "&DoubleLongLeftRightArrow;"
    ],
    [
        1,
        "&longmapsto;"
    ],
    [
        2,
        "&dzigrarr;"
    ],
    [
        258,
        "&nvlArr;"
    ],
    [
        0,
        "&nvrArr;"
    ],
    [
        0,
        "&nvHarr;"
    ],
    [
        0,
        "&Map;"
    ],
    [
        6,
        "&lbarr;"
    ],
    [
        0,
        "&bkarow;"
    ],
    [
        0,
        "&lBarr;"
    ],
    [
        0,
        "&dbkarow;"
    ],
    [
        0,
        "&drbkarow;"
    ],
    [
        0,
        "&DDotrahd;"
    ],
    [
        0,
        "&UpArrowBar;"
    ],
    [
        0,
        "&DownArrowBar;"
    ],
    [
        2,
        "&Rarrtl;"
    ],
    [
        2,
        "&latail;"
    ],
    [
        0,
        "&ratail;"
    ],
    [
        0,
        "&lAtail;"
    ],
    [
        0,
        "&rAtail;"
    ],
    [
        0,
        "&larrfs;"
    ],
    [
        0,
        "&rarrfs;"
    ],
    [
        0,
        "&larrbfs;"
    ],
    [
        0,
        "&rarrbfs;"
    ],
    [
        2,
        "&nwarhk;"
    ],
    [
        0,
        "&nearhk;"
    ],
    [
        0,
        "&hksearow;"
    ],
    [
        0,
        "&hkswarow;"
    ],
    [
        0,
        "&nwnear;"
    ],
    [
        0,
        "&nesear;"
    ],
    [
        0,
        "&seswar;"
    ],
    [
        0,
        "&swnwar;"
    ],
    [
        8,
        {
            v: "&rarrc;",
            n: 824,
            o: "&nrarrc;"
        }
    ],
    [
        1,
        "&cudarrr;"
    ],
    [
        0,
        "&ldca;"
    ],
    [
        0,
        "&rdca;"
    ],
    [
        0,
        "&cudarrl;"
    ],
    [
        0,
        "&larrpl;"
    ],
    [
        2,
        "&curarrm;"
    ],
    [
        0,
        "&cularrp;"
    ],
    [
        7,
        "&rarrpl;"
    ],
    [
        2,
        "&harrcir;"
    ],
    [
        0,
        "&Uarrocir;"
    ],
    [
        0,
        "&lurdshar;"
    ],
    [
        0,
        "&ldrushar;"
    ],
    [
        2,
        "&LeftRightVector;"
    ],
    [
        0,
        "&RightUpDownVector;"
    ],
    [
        0,
        "&DownLeftRightVector;"
    ],
    [
        0,
        "&LeftUpDownVector;"
    ],
    [
        0,
        "&LeftVectorBar;"
    ],
    [
        0,
        "&RightVectorBar;"
    ],
    [
        0,
        "&RightUpVectorBar;"
    ],
    [
        0,
        "&RightDownVectorBar;"
    ],
    [
        0,
        "&DownLeftVectorBar;"
    ],
    [
        0,
        "&DownRightVectorBar;"
    ],
    [
        0,
        "&LeftUpVectorBar;"
    ],
    [
        0,
        "&LeftDownVectorBar;"
    ],
    [
        0,
        "&LeftTeeVector;"
    ],
    [
        0,
        "&RightTeeVector;"
    ],
    [
        0,
        "&RightUpTeeVector;"
    ],
    [
        0,
        "&RightDownTeeVector;"
    ],
    [
        0,
        "&DownLeftTeeVector;"
    ],
    [
        0,
        "&DownRightTeeVector;"
    ],
    [
        0,
        "&LeftUpTeeVector;"
    ],
    [
        0,
        "&LeftDownTeeVector;"
    ],
    [
        0,
        "&lHar;"
    ],
    [
        0,
        "&uHar;"
    ],
    [
        0,
        "&rHar;"
    ],
    [
        0,
        "&dHar;"
    ],
    [
        0,
        "&luruhar;"
    ],
    [
        0,
        "&ldrdhar;"
    ],
    [
        0,
        "&ruluhar;"
    ],
    [
        0,
        "&rdldhar;"
    ],
    [
        0,
        "&lharul;"
    ],
    [
        0,
        "&llhard;"
    ],
    [
        0,
        "&rharul;"
    ],
    [
        0,
        "&lrhard;"
    ],
    [
        0,
        "&udhar;"
    ],
    [
        0,
        "&duhar;"
    ],
    [
        0,
        "&RoundImplies;"
    ],
    [
        0,
        "&erarr;"
    ],
    [
        0,
        "&simrarr;"
    ],
    [
        0,
        "&larrsim;"
    ],
    [
        0,
        "&rarrsim;"
    ],
    [
        0,
        "&rarrap;"
    ],
    [
        0,
        "&ltlarr;"
    ],
    [
        1,
        "&gtrarr;"
    ],
    [
        0,
        "&subrarr;"
    ],
    [
        1,
        "&suplarr;"
    ],
    [
        0,
        "&lfisht;"
    ],
    [
        0,
        "&rfisht;"
    ],
    [
        0,
        "&ufisht;"
    ],
    [
        0,
        "&dfisht;"
    ],
    [
        5,
        "&lopar;"
    ],
    [
        0,
        "&ropar;"
    ],
    [
        4,
        "&lbrke;"
    ],
    [
        0,
        "&rbrke;"
    ],
    [
        0,
        "&lbrkslu;"
    ],
    [
        0,
        "&rbrksld;"
    ],
    [
        0,
        "&lbrksld;"
    ],
    [
        0,
        "&rbrkslu;"
    ],
    [
        0,
        "&langd;"
    ],
    [
        0,
        "&rangd;"
    ],
    [
        0,
        "&lparlt;"
    ],
    [
        0,
        "&rpargt;"
    ],
    [
        0,
        "&gtlPar;"
    ],
    [
        0,
        "&ltrPar;"
    ],
    [
        3,
        "&vzigzag;"
    ],
    [
        1,
        "&vangrt;"
    ],
    [
        0,
        "&angrtvbd;"
    ],
    [
        6,
        "&ange;"
    ],
    [
        0,
        "&range;"
    ],
    [
        0,
        "&dwangle;"
    ],
    [
        0,
        "&uwangle;"
    ],
    [
        0,
        "&angmsdaa;"
    ],
    [
        0,
        "&angmsdab;"
    ],
    [
        0,
        "&angmsdac;"
    ],
    [
        0,
        "&angmsdad;"
    ],
    [
        0,
        "&angmsdae;"
    ],
    [
        0,
        "&angmsdaf;"
    ],
    [
        0,
        "&angmsdag;"
    ],
    [
        0,
        "&angmsdah;"
    ],
    [
        0,
        "&bemptyv;"
    ],
    [
        0,
        "&demptyv;"
    ],
    [
        0,
        "&cemptyv;"
    ],
    [
        0,
        "&raemptyv;"
    ],
    [
        0,
        "&laemptyv;"
    ],
    [
        0,
        "&ohbar;"
    ],
    [
        0,
        "&omid;"
    ],
    [
        0,
        "&opar;"
    ],
    [
        1,
        "&operp;"
    ],
    [
        1,
        "&olcross;"
    ],
    [
        0,
        "&odsold;"
    ],
    [
        1,
        "&olcir;"
    ],
    [
        0,
        "&ofcir;"
    ],
    [
        0,
        "&olt;"
    ],
    [
        0,
        "&ogt;"
    ],
    [
        0,
        "&cirscir;"
    ],
    [
        0,
        "&cirE;"
    ],
    [
        0,
        "&solb;"
    ],
    [
        0,
        "&bsolb;"
    ],
    [
        3,
        "&boxbox;"
    ],
    [
        3,
        "&trisb;"
    ],
    [
        0,
        "&rtriltri;"
    ],
    [
        0,
        {
            v: "&LeftTriangleBar;",
            n: 824,
            o: "&NotLeftTriangleBar;"
        }
    ],
    [
        0,
        {
            v: "&RightTriangleBar;",
            n: 824,
            o: "&NotRightTriangleBar;"
        }
    ],
    [
        11,
        "&iinfin;"
    ],
    [
        0,
        "&infintie;"
    ],
    [
        0,
        "&nvinfin;"
    ],
    [
        4,
        "&eparsl;"
    ],
    [
        0,
        "&smeparsl;"
    ],
    [
        0,
        "&eqvparsl;"
    ],
    [
        5,
        "&blacklozenge;"
    ],
    [
        8,
        "&RuleDelayed;"
    ],
    [
        1,
        "&dsol;"
    ],
    [
        9,
        "&bigodot;"
    ],
    [
        0,
        "&bigoplus;"
    ],
    [
        0,
        "&bigotimes;"
    ],
    [
        1,
        "&biguplus;"
    ],
    [
        1,
        "&bigsqcup;"
    ],
    [
        5,
        "&iiiint;"
    ],
    [
        0,
        "&fpartint;"
    ],
    [
        2,
        "&cirfnint;"
    ],
    [
        0,
        "&awint;"
    ],
    [
        0,
        "&rppolint;"
    ],
    [
        0,
        "&scpolint;"
    ],
    [
        0,
        "&npolint;"
    ],
    [
        0,
        "&pointint;"
    ],
    [
        0,
        "&quatint;"
    ],
    [
        0,
        "&intlarhk;"
    ],
    [
        10,
        "&pluscir;"
    ],
    [
        0,
        "&plusacir;"
    ],
    [
        0,
        "&simplus;"
    ],
    [
        0,
        "&plusdu;"
    ],
    [
        0,
        "&plussim;"
    ],
    [
        0,
        "&plustwo;"
    ],
    [
        1,
        "&mcomma;"
    ],
    [
        0,
        "&minusdu;"
    ],
    [
        2,
        "&loplus;"
    ],
    [
        0,
        "&roplus;"
    ],
    [
        0,
        "&Cross;"
    ],
    [
        0,
        "&timesd;"
    ],
    [
        0,
        "&timesbar;"
    ],
    [
        1,
        "&smashp;"
    ],
    [
        0,
        "&lotimes;"
    ],
    [
        0,
        "&rotimes;"
    ],
    [
        0,
        "&otimesas;"
    ],
    [
        0,
        "&Otimes;"
    ],
    [
        0,
        "&odiv;"
    ],
    [
        0,
        "&triplus;"
    ],
    [
        0,
        "&triminus;"
    ],
    [
        0,
        "&tritime;"
    ],
    [
        0,
        "&intprod;"
    ],
    [
        2,
        "&amalg;"
    ],
    [
        0,
        "&capdot;"
    ],
    [
        1,
        "&ncup;"
    ],
    [
        0,
        "&ncap;"
    ],
    [
        0,
        "&capand;"
    ],
    [
        0,
        "&cupor;"
    ],
    [
        0,
        "&cupcap;"
    ],
    [
        0,
        "&capcup;"
    ],
    [
        0,
        "&cupbrcap;"
    ],
    [
        0,
        "&capbrcup;"
    ],
    [
        0,
        "&cupcup;"
    ],
    [
        0,
        "&capcap;"
    ],
    [
        0,
        "&ccups;"
    ],
    [
        0,
        "&ccaps;"
    ],
    [
        2,
        "&ccupssm;"
    ],
    [
        2,
        "&And;"
    ],
    [
        0,
        "&Or;"
    ],
    [
        0,
        "&andand;"
    ],
    [
        0,
        "&oror;"
    ],
    [
        0,
        "&orslope;"
    ],
    [
        0,
        "&andslope;"
    ],
    [
        1,
        "&andv;"
    ],
    [
        0,
        "&orv;"
    ],
    [
        0,
        "&andd;"
    ],
    [
        0,
        "&ord;"
    ],
    [
        1,
        "&wedbar;"
    ],
    [
        6,
        "&sdote;"
    ],
    [
        3,
        "&simdot;"
    ],
    [
        2,
        {
            v: "&congdot;",
            n: 824,
            o: "&ncongdot;"
        }
    ],
    [
        0,
        "&easter;"
    ],
    [
        0,
        "&apacir;"
    ],
    [
        0,
        {
            v: "&apE;",
            n: 824,
            o: "&napE;"
        }
    ],
    [
        0,
        "&eplus;"
    ],
    [
        0,
        "&pluse;"
    ],
    [
        0,
        "&Esim;"
    ],
    [
        0,
        "&Colone;"
    ],
    [
        0,
        "&Equal;"
    ],
    [
        1,
        "&ddotseq;"
    ],
    [
        0,
        "&equivDD;"
    ],
    [
        0,
        "&ltcir;"
    ],
    [
        0,
        "&gtcir;"
    ],
    [
        0,
        "&ltquest;"
    ],
    [
        0,
        "&gtquest;"
    ],
    [
        0,
        {
            v: "&leqslant;",
            n: 824,
            o: "&nleqslant;"
        }
    ],
    [
        0,
        {
            v: "&geqslant;",
            n: 824,
            o: "&ngeqslant;"
        }
    ],
    [
        0,
        "&lesdot;"
    ],
    [
        0,
        "&gesdot;"
    ],
    [
        0,
        "&lesdoto;"
    ],
    [
        0,
        "&gesdoto;"
    ],
    [
        0,
        "&lesdotor;"
    ],
    [
        0,
        "&gesdotol;"
    ],
    [
        0,
        "&lap;"
    ],
    [
        0,
        "&gap;"
    ],
    [
        0,
        "&lne;"
    ],
    [
        0,
        "&gne;"
    ],
    [
        0,
        "&lnap;"
    ],
    [
        0,
        "&gnap;"
    ],
    [
        0,
        "&lEg;"
    ],
    [
        0,
        "&gEl;"
    ],
    [
        0,
        "&lsime;"
    ],
    [
        0,
        "&gsime;"
    ],
    [
        0,
        "&lsimg;"
    ],
    [
        0,
        "&gsiml;"
    ],
    [
        0,
        "&lgE;"
    ],
    [
        0,
        "&glE;"
    ],
    [
        0,
        "&lesges;"
    ],
    [
        0,
        "&gesles;"
    ],
    [
        0,
        "&els;"
    ],
    [
        0,
        "&egs;"
    ],
    [
        0,
        "&elsdot;"
    ],
    [
        0,
        "&egsdot;"
    ],
    [
        0,
        "&el;"
    ],
    [
        0,
        "&eg;"
    ],
    [
        2,
        "&siml;"
    ],
    [
        0,
        "&simg;"
    ],
    [
        0,
        "&simlE;"
    ],
    [
        0,
        "&simgE;"
    ],
    [
        0,
        {
            v: "&LessLess;",
            n: 824,
            o: "&NotNestedLessLess;"
        }
    ],
    [
        0,
        {
            v: "&GreaterGreater;",
            n: 824,
            o: "&NotNestedGreaterGreater;"
        }
    ],
    [
        1,
        "&glj;"
    ],
    [
        0,
        "&gla;"
    ],
    [
        0,
        "&ltcc;"
    ],
    [
        0,
        "&gtcc;"
    ],
    [
        0,
        "&lescc;"
    ],
    [
        0,
        "&gescc;"
    ],
    [
        0,
        "&smt;"
    ],
    [
        0,
        "&lat;"
    ],
    [
        0,
        {
            v: "&smte;",
            n: 65024,
            o: "&smtes;"
        }
    ],
    [
        0,
        {
            v: "&late;",
            n: 65024,
            o: "&lates;"
        }
    ],
    [
        0,
        "&bumpE;"
    ],
    [
        0,
        {
            v: "&PrecedesEqual;",
            n: 824,
            o: "&NotPrecedesEqual;"
        }
    ],
    [
        0,
        {
            v: "&sce;",
            n: 824,
            o: "&NotSucceedsEqual;"
        }
    ],
    [
        2,
        "&prE;"
    ],
    [
        0,
        "&scE;"
    ],
    [
        0,
        "&precneqq;"
    ],
    [
        0,
        "&scnE;"
    ],
    [
        0,
        "&prap;"
    ],
    [
        0,
        "&scap;"
    ],
    [
        0,
        "&precnapprox;"
    ],
    [
        0,
        "&scnap;"
    ],
    [
        0,
        "&Pr;"
    ],
    [
        0,
        "&Sc;"
    ],
    [
        0,
        "&subdot;"
    ],
    [
        0,
        "&supdot;"
    ],
    [
        0,
        "&subplus;"
    ],
    [
        0,
        "&supplus;"
    ],
    [
        0,
        "&submult;"
    ],
    [
        0,
        "&supmult;"
    ],
    [
        0,
        "&subedot;"
    ],
    [
        0,
        "&supedot;"
    ],
    [
        0,
        {
            v: "&subE;",
            n: 824,
            o: "&nsubE;"
        }
    ],
    [
        0,
        {
            v: "&supE;",
            n: 824,
            o: "&nsupE;"
        }
    ],
    [
        0,
        "&subsim;"
    ],
    [
        0,
        "&supsim;"
    ],
    [
        2,
        {
            v: "&subnE;",
            n: 65024,
            o: "&varsubsetneqq;"
        }
    ],
    [
        0,
        {
            v: "&supnE;",
            n: 65024,
            o: "&varsupsetneqq;"
        }
    ],
    [
        2,
        "&csub;"
    ],
    [
        0,
        "&csup;"
    ],
    [
        0,
        "&csube;"
    ],
    [
        0,
        "&csupe;"
    ],
    [
        0,
        "&subsup;"
    ],
    [
        0,
        "&supsub;"
    ],
    [
        0,
        "&subsub;"
    ],
    [
        0,
        "&supsup;"
    ],
    [
        0,
        "&suphsub;"
    ],
    [
        0,
        "&supdsub;"
    ],
    [
        0,
        "&forkv;"
    ],
    [
        0,
        "&topfork;"
    ],
    [
        0,
        "&mlcp;"
    ],
    [
        8,
        "&Dashv;"
    ],
    [
        1,
        "&Vdashl;"
    ],
    [
        0,
        "&Barv;"
    ],
    [
        0,
        "&vBar;"
    ],
    [
        0,
        "&vBarv;"
    ],
    [
        1,
        "&Vbar;"
    ],
    [
        0,
        "&Not;"
    ],
    [
        0,
        "&bNot;"
    ],
    [
        0,
        "&rnmid;"
    ],
    [
        0,
        "&cirmid;"
    ],
    [
        0,
        "&midcir;"
    ],
    [
        0,
        "&topcir;"
    ],
    [
        0,
        "&nhpar;"
    ],
    [
        0,
        "&parsim;"
    ],
    [
        9,
        {
            v: "&parsl;",
            n: 8421,
            o: "&nparsl;"
        }
    ],
    [
        44343,
        {
            n: new Map(/* #__PURE__ */ restoreDiff([
                [
                    56476,
                    "&Ascr;"
                ],
                [
                    1,
                    "&Cscr;"
                ],
                [
                    0,
                    "&Dscr;"
                ],
                [
                    2,
                    "&Gscr;"
                ],
                [
                    2,
                    "&Jscr;"
                ],
                [
                    0,
                    "&Kscr;"
                ],
                [
                    2,
                    "&Nscr;"
                ],
                [
                    0,
                    "&Oscr;"
                ],
                [
                    0,
                    "&Pscr;"
                ],
                [
                    0,
                    "&Qscr;"
                ],
                [
                    1,
                    "&Sscr;"
                ],
                [
                    0,
                    "&Tscr;"
                ],
                [
                    0,
                    "&Uscr;"
                ],
                [
                    0,
                    "&Vscr;"
                ],
                [
                    0,
                    "&Wscr;"
                ],
                [
                    0,
                    "&Xscr;"
                ],
                [
                    0,
                    "&Yscr;"
                ],
                [
                    0,
                    "&Zscr;"
                ],
                [
                    0,
                    "&ascr;"
                ],
                [
                    0,
                    "&bscr;"
                ],
                [
                    0,
                    "&cscr;"
                ],
                [
                    0,
                    "&dscr;"
                ],
                [
                    1,
                    "&fscr;"
                ],
                [
                    1,
                    "&hscr;"
                ],
                [
                    0,
                    "&iscr;"
                ],
                [
                    0,
                    "&jscr;"
                ],
                [
                    0,
                    "&kscr;"
                ],
                [
                    0,
                    "&lscr;"
                ],
                [
                    0,
                    "&mscr;"
                ],
                [
                    0,
                    "&nscr;"
                ],
                [
                    1,
                    "&pscr;"
                ],
                [
                    0,
                    "&qscr;"
                ],
                [
                    0,
                    "&rscr;"
                ],
                [
                    0,
                    "&sscr;"
                ],
                [
                    0,
                    "&tscr;"
                ],
                [
                    0,
                    "&uscr;"
                ],
                [
                    0,
                    "&vscr;"
                ],
                [
                    0,
                    "&wscr;"
                ],
                [
                    0,
                    "&xscr;"
                ],
                [
                    0,
                    "&yscr;"
                ],
                [
                    0,
                    "&zscr;"
                ],
                [
                    52,
                    "&Afr;"
                ],
                [
                    0,
                    "&Bfr;"
                ],
                [
                    1,
                    "&Dfr;"
                ],
                [
                    0,
                    "&Efr;"
                ],
                [
                    0,
                    "&Ffr;"
                ],
                [
                    0,
                    "&Gfr;"
                ],
                [
                    2,
                    "&Jfr;"
                ],
                [
                    0,
                    "&Kfr;"
                ],
                [
                    0,
                    "&Lfr;"
                ],
                [
                    0,
                    "&Mfr;"
                ],
                [
                    0,
                    "&Nfr;"
                ],
                [
                    0,
                    "&Ofr;"
                ],
                [
                    0,
                    "&Pfr;"
                ],
                [
                    0,
                    "&Qfr;"
                ],
                [
                    1,
                    "&Sfr;"
                ],
                [
                    0,
                    "&Tfr;"
                ],
                [
                    0,
                    "&Ufr;"
                ],
                [
                    0,
                    "&Vfr;"
                ],
                [
                    0,
                    "&Wfr;"
                ],
                [
                    0,
                    "&Xfr;"
                ],
                [
                    0,
                    "&Yfr;"
                ],
                [
                    1,
                    "&afr;"
                ],
                [
                    0,
                    "&bfr;"
                ],
                [
                    0,
                    "&cfr;"
                ],
                [
                    0,
                    "&dfr;"
                ],
                [
                    0,
                    "&efr;"
                ],
                [
                    0,
                    "&ffr;"
                ],
                [
                    0,
                    "&gfr;"
                ],
                [
                    0,
                    "&hfr;"
                ],
                [
                    0,
                    "&ifr;"
                ],
                [
                    0,
                    "&jfr;"
                ],
                [
                    0,
                    "&kfr;"
                ],
                [
                    0,
                    "&lfr;"
                ],
                [
                    0,
                    "&mfr;"
                ],
                [
                    0,
                    "&nfr;"
                ],
                [
                    0,
                    "&ofr;"
                ],
                [
                    0,
                    "&pfr;"
                ],
                [
                    0,
                    "&qfr;"
                ],
                [
                    0,
                    "&rfr;"
                ],
                [
                    0,
                    "&sfr;"
                ],
                [
                    0,
                    "&tfr;"
                ],
                [
                    0,
                    "&ufr;"
                ],
                [
                    0,
                    "&vfr;"
                ],
                [
                    0,
                    "&wfr;"
                ],
                [
                    0,
                    "&xfr;"
                ],
                [
                    0,
                    "&yfr;"
                ],
                [
                    0,
                    "&zfr;"
                ],
                [
                    0,
                    "&Aopf;"
                ],
                [
                    0,
                    "&Bopf;"
                ],
                [
                    1,
                    "&Dopf;"
                ],
                [
                    0,
                    "&Eopf;"
                ],
                [
                    0,
                    "&Fopf;"
                ],
                [
                    0,
                    "&Gopf;"
                ],
                [
                    1,
                    "&Iopf;"
                ],
                [
                    0,
                    "&Jopf;"
                ],
                [
                    0,
                    "&Kopf;"
                ],
                [
                    0,
                    "&Lopf;"
                ],
                [
                    0,
                    "&Mopf;"
                ],
                [
                    1,
                    "&Oopf;"
                ],
                [
                    3,
                    "&Sopf;"
                ],
                [
                    0,
                    "&Topf;"
                ],
                [
                    0,
                    "&Uopf;"
                ],
                [
                    0,
                    "&Vopf;"
                ],
                [
                    0,
                    "&Wopf;"
                ],
                [
                    0,
                    "&Xopf;"
                ],
                [
                    0,
                    "&Yopf;"
                ],
                [
                    1,
                    "&aopf;"
                ],
                [
                    0,
                    "&bopf;"
                ],
                [
                    0,
                    "&copf;"
                ],
                [
                    0,
                    "&dopf;"
                ],
                [
                    0,
                    "&eopf;"
                ],
                [
                    0,
                    "&fopf;"
                ],
                [
                    0,
                    "&gopf;"
                ],
                [
                    0,
                    "&hopf;"
                ],
                [
                    0,
                    "&iopf;"
                ],
                [
                    0,
                    "&jopf;"
                ],
                [
                    0,
                    "&kopf;"
                ],
                [
                    0,
                    "&lopf;"
                ],
                [
                    0,
                    "&mopf;"
                ],
                [
                    0,
                    "&nopf;"
                ],
                [
                    0,
                    "&oopf;"
                ],
                [
                    0,
                    "&popf;"
                ],
                [
                    0,
                    "&qopf;"
                ],
                [
                    0,
                    "&ropf;"
                ],
                [
                    0,
                    "&sopf;"
                ],
                [
                    0,
                    "&topf;"
                ],
                [
                    0,
                    "&uopf;"
                ],
                [
                    0,
                    "&vopf;"
                ],
                [
                    0,
                    "&wopf;"
                ],
                [
                    0,
                    "&xopf;"
                ],
                [
                    0,
                    "&yopf;"
                ],
                [
                    0,
                    "&zopf;"
                ]
            ]))
        }
    ],
    [
        8906,
        "&fflig;"
    ],
    [
        0,
        "&filig;"
    ],
    [
        0,
        "&fllig;"
    ],
    [
        0,
        "&ffilig;"
    ],
    [
        0,
        "&ffllig;"
    ]
])); //# sourceMappingURL=encode-html.js.map


/***/ }),

/***/ 59620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
var decode_js_1 = __webpack_require__(12657);
var encode_js_1 = __webpack_require__(357);
var escape_js_1 = __webpack_require__(2950);
/** The level of entities to support. */ var EntityLevel;
(function(EntityLevel) {
    /** Support only XML entities. */ EntityLevel[EntityLevel["XML"] = 0] = "XML";
    /** Support HTML entities, which are a superset of XML entities. */ EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
})(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
var EncodingMode;
(function(EncodingMode) {
    /**
     * The output is UTF-8 encoded. Only characters that need escaping within
     * XML will be escaped.
     */ EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
    /**
     * The output consists only of ASCII characters. Characters that need
     * escaping within HTML, and characters that aren't ASCII characters will
     * be escaped.
     */ EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
    /**
     * Encode all characters that have an equivalent entity, as well as all
     * characters that are not ASCII characters.
     */ EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
    /**
     * Encode all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */ EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
    /**
     * Encode all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */ EncodingMode[EncodingMode["Text"] = 4] = "Text";
})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */ function decode(data, options) {
    if (options === void 0) {
        options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : undefined;
        return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */ function decodeStrict(data, options) {
    var _a;
    if (options === void 0) {
        options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? {
        level: options
    } : options;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
    return decode(data, opts);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */ function encode(data, options) {
    if (options === void 0) {
        options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? {
        level: options
    } : options;
    // Mode `UTF8` just escapes XML entities
    if (opts.mode === EncodingMode.UTF8) return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute) return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text) return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
    }
    // ASCII and Extensive are equivalent
    return (0, escape_js_1.encodeXML)(data);
}
exports.encode = encode;
var escape_js_2 = __webpack_require__(2950);
Object.defineProperty(exports, "encodeXML", ({
    enumerable: true,
    get: function() {
        return escape_js_2.encodeXML;
    }
}));
Object.defineProperty(exports, "escape", ({
    enumerable: true,
    get: function() {
        return escape_js_2.escape;
    }
}));
Object.defineProperty(exports, "escapeUTF8", ({
    enumerable: true,
    get: function() {
        return escape_js_2.escapeUTF8;
    }
}));
Object.defineProperty(exports, "escapeAttribute", ({
    enumerable: true,
    get: function() {
        return escape_js_2.escapeAttribute;
    }
}));
Object.defineProperty(exports, "escapeText", ({
    enumerable: true,
    get: function() {
        return escape_js_2.escapeText;
    }
}));
var encode_js_2 = __webpack_require__(357);
Object.defineProperty(exports, "encodeHTML", ({
    enumerable: true,
    get: function() {
        return encode_js_2.encodeHTML;
    }
}));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({
    enumerable: true,
    get: function() {
        return encode_js_2.encodeNonAsciiHTML;
    }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({
    enumerable: true,
    get: function() {
        return encode_js_2.encodeHTML;
    }
}));
Object.defineProperty(exports, "encodeHTML5", ({
    enumerable: true,
    get: function() {
        return encode_js_2.encodeHTML;
    }
}));
var decode_js_2 = __webpack_require__(12657);
Object.defineProperty(exports, "EntityDecoder", ({
    enumerable: true,
    get: function() {
        return decode_js_2.EntityDecoder;
    }
}));
Object.defineProperty(exports, "DecodingMode", ({
    enumerable: true,
    get: function() {
        return decode_js_2.DecodingMode;
    }
}));
Object.defineProperty(exports, "decodeXML", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeXML;
    }
}));
Object.defineProperty(exports, "decodeHTML", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTML;
    }
}));
Object.defineProperty(exports, "decodeHTMLStrict", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTMLStrict;
    }
}));
Object.defineProperty(exports, "decodeHTMLAttribute", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTMLAttribute;
    }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTML;
    }
}));
Object.defineProperty(exports, "decodeHTML5", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTML;
    }
}));
Object.defineProperty(exports, "decodeHTML4Strict", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTMLStrict;
    }
}));
Object.defineProperty(exports, "decodeHTML5Strict", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeHTMLStrict;
    }
}));
Object.defineProperty(exports, "decodeXMLStrict", ({
    enumerable: true,
    get: function() {
        return decode_js_2.decodeXML;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 87845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(44386);
module.exports = function extend(o /*, objects*/ ) {
    if (!isObject(o)) {
        o = {};
    }
    var len = arguments.length;
    for(var i = 1; i < len; i++){
        var obj = arguments[i];
        if (isObject(obj)) {
            assign(o, obj);
        }
    }
    return o;
};
function assign(a, b) {
    for(var key in b){
        if (hasOwn(b, key)) {
            a[key] = b[key];
        }
    }
}
/**
 * Returns true if the given `key` is an own property of `obj`.
 */ function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}


/***/ }),

/***/ 23607:
/***/ (function(__unused_webpack_module, exports) {

(function(global, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    var twoDigitsOptional = "\\d\\d?";
    var twoDigits = "\\d\\d";
    var threeDigits = "\\d{3}";
    var fourDigits = "\\d{4}";
    var word = "[^\\s]+";
    var literal = /\[([^]*?)\]/gm;
    function shorten(arr, sLen) {
        var newArr = [];
        for(var i = 0, len = arr.length; i < len; i++){
            newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
    }
    var monthUpdate = function(arrName) {
        return function(v, i18n) {
            var lowerCaseArr = i18n[arrName].map(function(v) {
                return v.toLowerCase();
            });
            var index = lowerCaseArr.indexOf(v.toLowerCase());
            if (index > -1) {
                return index;
            }
            return null;
        };
    };
    function assign(origObj) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        for(var _a = 0, args_1 = args; _a < args_1.length; _a++){
            var obj = args_1[_a];
            for(var key in obj){
                // @ts-ignore ex
                origObj[key] = obj[key];
            }
        }
        return origObj;
    }
    var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ];
    var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ];
    var monthNamesShort = shorten(monthNames, 3);
    var dayNamesShort = shorten(dayNames, 3);
    var defaultI18n = {
        dayNamesShort: dayNamesShort,
        dayNames: dayNames,
        monthNamesShort: monthNamesShort,
        monthNames: monthNames,
        amPm: [
            "am",
            "pm"
        ],
        DoFn: function(dayOfMonth) {
            return dayOfMonth + [
                "th",
                "st",
                "nd",
                "rd"
            ][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
    };
    var globalI18n = assign({}, defaultI18n);
    var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
    };
    var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    var pad = function(val, len) {
        if (len === void 0) {
            len = 2;
        }
        val = String(val);
        while(val.length < len){
            val = "0" + val;
        }
        return val;
    };
    var formatFlags = {
        D: function(dateObj) {
            return String(dateObj.getDate());
        },
        DD: function(dateObj) {
            return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
            return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
            return String(dateObj.getDay());
        },
        dd: function(dateObj) {
            return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
            return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
            return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
            return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
            return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
            return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
            return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
            return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
            return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
            return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
            return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
            return String(dateObj.getHours());
        },
        HH: function(dateObj) {
            return pad(dateObj.getHours());
        },
        m: function(dateObj) {
            return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
            return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
            return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
            return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
            return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
            return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
            return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
            return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
            return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
            var offset = dateObj.getTimezoneOffset();
            return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
            var offset = dateObj.getTimezoneOffset();
            return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
    };
    var monthParse = function(v) {
        return +v - 1;
    };
    var emptyDigits = [
        null,
        twoDigitsOptional
    ];
    var emptyWord = [
        null,
        word
    ];
    var amPm = [
        "isPm",
        word,
        function(v, i18n) {
            var val = v.toLowerCase();
            if (val === i18n.amPm[0]) {
                return 0;
            } else if (val === i18n.amPm[1]) {
                return 1;
            }
            return null;
        }
    ];
    var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
            var parts = (v + "").match(/([+-]|\d\d)/gi);
            if (parts) {
                var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
                return parts[0] === "+" ? minutes : -minutes;
            }
            return 0;
        }
    ];
    var parseFlags = {
        D: [
            "day",
            twoDigitsOptional
        ],
        DD: [
            "day",
            twoDigits
        ],
        Do: [
            "day",
            twoDigitsOptional + word,
            function(v) {
                return parseInt(v, 10);
            }
        ],
        M: [
            "month",
            twoDigitsOptional,
            monthParse
        ],
        MM: [
            "month",
            twoDigits,
            monthParse
        ],
        YY: [
            "year",
            twoDigits,
            function(v) {
                var now = new Date();
                var cent = +("" + now.getFullYear()).substr(0, 2);
                return +("" + (+v > 68 ? cent - 1 : cent) + v);
            }
        ],
        h: [
            "hour",
            twoDigitsOptional,
            undefined,
            "isPm"
        ],
        hh: [
            "hour",
            twoDigits,
            undefined,
            "isPm"
        ],
        H: [
            "hour",
            twoDigitsOptional
        ],
        HH: [
            "hour",
            twoDigits
        ],
        m: [
            "minute",
            twoDigitsOptional
        ],
        mm: [
            "minute",
            twoDigits
        ],
        s: [
            "second",
            twoDigitsOptional
        ],
        ss: [
            "second",
            twoDigits
        ],
        YYYY: [
            "year",
            fourDigits
        ],
        S: [
            "millisecond",
            "\\d",
            function(v) {
                return +v * 100;
            }
        ],
        SS: [
            "millisecond",
            twoDigits,
            function(v) {
                return +v * 10;
            }
        ],
        SSS: [
            "millisecond",
            threeDigits
        ],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: [
            "month",
            word,
            monthUpdate("monthNamesShort")
        ],
        MMMM: [
            "month",
            word,
            monthUpdate("monthNames")
        ],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
    };
    // Some common format strings
    var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
    };
    var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
    };
    /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   * @returns {string} Formatted date string
   */ var format = function(dateObj, mask, i18n) {
        if (mask === void 0) {
            mask = globalMasks["default"];
        }
        if (i18n === void 0) {
            i18n = {};
        }
        if (typeof dateObj === "number") {
            dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
            throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        // Make literals inactive by replacing them with @@@
        mask = mask.replace(literal, function($0, $1) {
            literals.push($1);
            return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        // Apply formatting rules
        mask = mask.replace(token, function($0) {
            return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        // Inline literal values back into the formatted value
        return mask.replace(/@@@/g, function() {
            return literals.shift();
        });
    };
    /**
   * Parse a date string into a Javascript Date object /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
   * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
   */ function parse(dateStr, format, i18n) {
        if (i18n === void 0) {
            i18n = {};
        }
        if (typeof format !== "string") {
            throw new Error("Invalid format in fecha parse");
        }
        // Check to see if the format is actually a mask
        format = globalMasks[format] || format;
        // Avoid regular expression denial of service, fail early for really long strings
        // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
        if (dateStr.length > 1000) {
            return null;
        }
        // Default to the beginning of the year.
        var today = new Date();
        var dateInfo = {
            year: today.getFullYear(),
            month: 0,
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0,
            isPm: null,
            timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        // Replace all the literals with @@@. Hopefully a string that won't exist in the format
        var newFormat = format.replace(literal, function($0, $1) {
            literals.push(regexEscape($1));
            return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        // Change every token that we find into the correct regex
        newFormat = regexEscape(newFormat).replace(token, function($0) {
            var info = parseFlags[$0];
            var field = info[0], regex = info[1], requiredField = info[3];
            // Check if the person has specified the same field twice. This will lead to confusing results.
            if (specifiedFields[field]) {
                throw new Error("Invalid format. " + field + " specified twice in format");
            }
            specifiedFields[field] = true;
            // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified
            if (requiredField) {
                requiredFields[requiredField] = true;
            }
            parseInfo.push(info);
            return "(" + regex + ")";
        });
        // Check all the required fields are present
        Object.keys(requiredFields).forEach(function(field) {
            if (!specifiedFields[field]) {
                throw new Error("Invalid format. " + field + " is required in specified format");
            }
        });
        // Add back all the literals after
        newFormat = newFormat.replace(/@@@/g, function() {
            return literals.shift();
        });
        // Check if the date string matches the format. If it doesn't return null
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
            return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        // For each match, call the parser function for that date part
        for(var i = 1; i < matches.length; i++){
            var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
            var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
            // If the parser can't make sense of the value, return null
            if (value == null) {
                return null;
            }
            dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
            dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
            dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
            dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
            var validateFields = [
                [
                    "month",
                    "getMonth"
                ],
                [
                    "day",
                    "getDate"
                ],
                [
                    "hour",
                    "getHours"
                ],
                [
                    "minute",
                    "getMinutes"
                ],
                [
                    "second",
                    "getSeconds"
                ]
            ];
            for(var i = 0, len = validateFields.length; i < len; i++){
                // Check to make sure the date field is within the allowed range. Javascript dates allows values
                // outside the allowed range. If the values don't match the value was invalid
                if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
                    return null;
                }
            }
        } else {
            dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
            // We can't validate dates in another timezone unfortunately. Do a basic check instead
            if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
                return null;
            }
        }
        // Don't allow invalid dates
        return dateTZ;
    }
    var fecha = {
        format: format,
        parse: parse,
        defaultI18n: defaultI18n,
        setGlobalDateI18n: setGlobalDateI18n,
        setGlobalDateMasks: setGlobalDateMasks
    };
    exports1.assign = assign;
    exports1.default = fecha;
    exports1.format = format;
    exports1.parse = parse;
    exports1.defaultI18n = defaultI18n;
    exports1.setGlobalDateI18n = setGlobalDateI18n;
    exports1.setGlobalDateMasks = setGlobalDateMasks;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
}); //# sourceMappingURL=fecha.umd.js.map


/***/ }),

/***/ 82444:
/***/ ((module) => {

"use strict";

var toString = Object.prototype.toString;
/**
 * Extract names from functions.
 *
 * @param {Function} fn The function who's name we need to extract.
 * @returns {String} The name of the function.
 * @public
 */ module.exports = function name(fn) {
    if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
    } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
    }
    //
    // Check to see if the constructor has a name.
    //
    if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name) return fn.constructor.name;
    //
    // toString the given function and attempt to parse it out of it, or determine
    // the class.
    //
    var named = fn.toString(), type = toString.call(fn).slice(8, -1);
    if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
    } else {
        named = type;
    }
    return named || "anonymous";
};


/***/ }),

/***/ 22619:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(39469);
var node_js_1 = __webpack_require__(7111);
__exportStar(__webpack_require__(7111), exports);
// Default options
var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
};
var DomHandler = /** @class */ function() {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */ function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */ this.dom = [];
        /** The root element for the DOM */ this.root = new node_js_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */ this.done = false;
        /** Stack of open tags. */ this.tagStack = [
            this.root
        ];
        /** A data node that is still being written to. */ this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */ this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function(parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [
            this.root
        ];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function() {
        if (this.done) return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function(error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB) this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_js_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function(data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function() {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([
            text
        ]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function() {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        } else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}();
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 7111:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(39469);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */ var Node = /** @class */ function() {
    function Node() {
        /** Parent of the node */ this.parent = null;
        /** Previous sibling */ this.prev = null;
        /** Next sibling */ this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */ this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */ this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.parent;
        },
        set: function(parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.prev;
        },
        set: function(prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.next;
        },
        set: function(next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */ Node.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
            recursive = false;
        }
        return cloneNode(this, recursive);
    };
    return Node;
}();
exports.Node = Node;
/**
 * A node that contains some data.
 */ var DataNode = /** @class */ function(_super) {
    __extends(DataNode, _super);
    /**
     * @param data The content of the data node
     */ function DataNode(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.data;
        },
        set: function(data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node);
exports.DataNode = DataNode;
/**
 * Text within the document.
 */ var Text = /** @class */ function(_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
    }
    Object.defineProperty(Text.prototype, "nodeType", {
        get: function() {
            return 3;
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(DataNode);
exports.Text = Text;
/**
 * Comments within the document.
 */ var Comment = /** @class */ function(_super) {
    __extends(Comment, _super);
    function Comment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
    }
    Object.defineProperty(Comment.prototype, "nodeType", {
        get: function() {
            return 8;
        },
        enumerable: false,
        configurable: true
    });
    return Comment;
}(DataNode);
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */ var ProcessingInstruction = /** @class */ function(_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
    }
    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    return ProcessingInstruction;
}(DataNode);
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */ var NodeWithChildren = /** @class */ function(_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param children Children of the node. Only certain node types can have children.
     */ function NodeWithChildren(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */ get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */ get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.children;
        },
        set: function(children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node);
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /** @class */ function(_super) {
    __extends(CDATA, _super);
    function CDATA() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
    }
    Object.defineProperty(CDATA.prototype, "nodeType", {
        get: function() {
            return 4;
        },
        enumerable: false,
        configurable: true
    });
    return CDATA;
}(NodeWithChildren);
exports.CDATA = CDATA;
/**
 * The root node of the document.
 */ var Document = /** @class */ function(_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
    }
    Object.defineProperty(Document.prototype, "nodeType", {
        get: function() {
            return 9;
        },
        enumerable: false,
        configurable: true
    });
    return Document;
}(NodeWithChildren);
exports.Document = Document;
/**
 * An element within the DOM.
 */ var Element = /** @class */ function(_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */ function Element(name, attribs, children, type) {
        if (children === void 0) {
            children = [];
        }
        if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
    }
    Object.defineProperty(Element.prototype, "nodeType", {
        get: function() {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */ get: function() {
            return this.name;
        },
        set: function(name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
                var _a, _b;
                return {
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
                };
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren);
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */ function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */ function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */ function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */ function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */ function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */ function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */ function cloneNode(node, recursive) {
    if (recursive === void 0) {
        recursive = false;
    }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    } else if (isComment(node)) {
        result = new Comment(node.data);
    } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
            return child.parent = clone_1;
        });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
            return child.parent = clone_2;
        });
        result = clone_2;
    } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
            return child.parent = clone_3;
        });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    } else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function(child) {
        return cloneNode(child, true);
    });
    for(var i = 1; i < children.length; i++){
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 87945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getFeed = void 0;
var stringify_js_1 = __webpack_require__(8573);
var legacy_js_1 = __webpack_require__(42447);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */ function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */ function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
            var _a;
            var children = item.children;
            var entry = {
                media: getMediaElements(children)
            };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */ function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
            var children = item.children;
            var entry = {
                media: getMediaElements(children)
            };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
            if (pubDate) entry.pubDate = new Date(pubDate);
            return entry;
        })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = [
    "url",
    "type",
    "lang"
];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */ function getMediaElements(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"]
        };
        for(var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++){
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for(var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++){
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs["expression"]) {
            media.expression = attribs["expression"];
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */ function getOneElement(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */ function fetch(tagName, where, recurse) {
    if (recurse === void 0) {
        recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */ function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) {
        recurse = false;
    }
    var val = fetch(tagName, where, recurse);
    if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */ function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
} //# sourceMappingURL=feeds.js.map


/***/ }),

/***/ 79235:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(22619);
/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */ function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */ while(--idx >= 0){
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */ if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for(var ancestor = node.parent; ancestor; ancestor = ancestor.parent){
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */ var DocumentPosition;
(function(DocumentPosition) {
    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */ function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while(current){
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while(current){
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while(idx < maxIdx && aParents[idx] === bParents[idx]){
        idx++;
    }
    if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */ function uniqueSort(nodes) {
    nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
    });
    nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
            return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort; //# sourceMappingURL=helpers.js.map


/***/ }),

/***/ 96670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(8573), exports);
__exportStar(__webpack_require__(33376), exports);
__exportStar(__webpack_require__(33476), exports);
__exportStar(__webpack_require__(92709), exports);
__exportStar(__webpack_require__(42447), exports);
__exportStar(__webpack_require__(79235), exports);
__exportStar(__webpack_require__(87945), exports);
/** @deprecated Use these methods from `domhandler` directly. */ var domhandler_1 = __webpack_require__(22619);
Object.defineProperty(exports, "isTag", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isTag;
    }
}));
Object.defineProperty(exports, "isCDATA", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isCDATA;
    }
}));
Object.defineProperty(exports, "isText", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isText;
    }
}));
Object.defineProperty(exports, "isComment", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isComment;
    }
}));
Object.defineProperty(exports, "isDocument", ({
    enumerable: true,
    get: function() {
        return domhandler_1.isDocument;
    }
}));
Object.defineProperty(exports, "hasChildren", ({
    enumerable: true,
    get: function() {
        return domhandler_1.hasChildren;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 42447:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(22619);
var querying_js_1 = __webpack_require__(92709);
/**
 * A map of functions to check nodes against.
 */ var Checks = {
    tag_name: function(name) {
        if (typeof name === "function") {
            return function(elem) {
                return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
        } else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function(elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
    },
    tag_type: function(type) {
        if (typeof type === "function") {
            return function(elem) {
                return type(elem.type);
            };
        }
        return function(elem) {
            return elem.type === type;
        };
    },
    tag_contains: function(data) {
        if (typeof data === "function") {
            return function(elem) {
                return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
        }
        return function(elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
    }
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */ function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function(elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
    }
    return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */ function combineFuncs(a, b) {
    return function(elem) {
        return a(elem) || b(elem);
    };
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */ function compileTest(options) {
    var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */ function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */ function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) {
        limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */ function getElementById(id, nodes, recurse) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (!Array.isArray(nodes)) nodes = [
        nodes
    ];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */ function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */ function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType; //# sourceMappingURL=legacy.js.map


/***/ }),

/***/ 33476:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */ function removeElement(elem) {
    if (elem.prev) elem.prev.next = elem.next;
    if (elem.next) elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
        }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */ function replaceElement(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
        prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
        next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param parent The element to append to.
 * @param child The element to be added as a child.
 */ function appendChild(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    } else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */ function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    } else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param parent The element to prepend before.
 * @param child The element to be added as a child.
 */ function prependChild(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
    } else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */ function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend; //# sourceMappingURL=manipulation.js.map


/***/ }),

/***/ 92709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(22619);
/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */ function filter(test, node, recurse, limit) {
    if (recurse === void 0) {
        recurse = true;
    }
    if (limit === void 0) {
        limit = Infinity;
    }
    return find(test, Array.isArray(node) ? node : [
        node
    ], recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */ function find(test, nodes, recurse, limit) {
    var result = [];
    /** Stack of the arrays we are looking at. */ var nodeStack = [
        nodes
    ];
    /** Stack of the indices within the arrays. */ var indexStack = [
        0
    ];
    for(;;){
        // First, check if the current array has any more elements to look at.
        if (indexStack[0] >= nodeStack[0].length) {
            // If we have no more arrays to look at, we are done.
            if (indexStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0) return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            /*
             * Add the children to the stack. We are depth-first, so this is
             * the next array we look at.
             */ indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */ function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */ function findOne(test, nodes, recurse) {
    if (recurse === void 0) {
        recurse = true;
    }
    var elem = null;
    for(var i = 0; i < nodes.length && !elem; i++){
        var node = nodes[i];
        if (!(0, domhandler_1.isTag)(node)) {
            continue;
        } else if (test(node)) {
            elem = node;
        } else if (recurse && node.children.length > 0) {
            elem = findOne(test, node.children, true);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */ function existsOne(test, nodes) {
    return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
    });
}
exports.existsOne = existsOne;
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */ function findAll(test, nodes) {
    var result = [];
    var nodeStack = [
        nodes
    ];
    var indexStack = [
        0
    ];
    for(;;){
        if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem)) continue;
        if (test(elem)) result.push(elem);
        if (elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
exports.findAll = findAll; //# sourceMappingURL=querying.js.map


/***/ }),

/***/ 8573:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(22619);
var dom_serializer_1 = __importDefault(__webpack_require__(82856));
var domelementtype_1 = __webpack_require__(39469);
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */ function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */ function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node) {
        return getOuterHTML(node, options);
    }).join("") : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */ function getText(node) {
    if (Array.isArray(node)) return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node)) return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */ function textContent(node) {
    if (Array.isArray(node)) return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */ function innerText(node) {
    if (Array.isArray(node)) return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node)) return node.data;
    return "";
}
exports.innerText = innerText; //# sourceMappingURL=stringify.js.map


/***/ }),

/***/ 33376:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(22619);
/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */ function getChildren(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */ function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */ function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null) return getChildren(parent);
    var siblings = [
        elem
    ];
    var prev = elem.prev, next = elem.next;
    while(prev != null){
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
    }
    while(next != null){
        siblings.push(next);
        _b = next, next = _b.next;
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */ function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */ function hasAttrib(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */ function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */ function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while(next !== null && !(0, domhandler_1.isTag)(next))_a = next, next = _a.next;
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */ function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while(prev !== null && !(0, domhandler_1.isTag)(prev))_a = prev, prev = _a.prev;
    return prev;
}
exports.prevElementSibling = prevElementSibling; //# sourceMappingURL=traversal.js.map


/***/ }),

/***/ 28727:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Parser = void 0;
var Tokenizer_js_1 = __importStar(__webpack_require__(19910));
var decode_js_1 = __webpack_require__(12657);
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
]);
var pTag = new Set([
    "p"
]);
var tableSectionTags = new Set([
    "thead",
    "tbody"
]);
var ddtTags = new Set([
    "dd",
    "dt"
]);
var rtpTags = new Set([
    "rt",
    "rp"
]);
var openImpliesClose = new Map([
    [
        "tr",
        new Set([
            "tr",
            "th",
            "td"
        ])
    ],
    [
        "th",
        new Set([
            "th"
        ])
    ],
    [
        "td",
        new Set([
            "thead",
            "th",
            "td"
        ])
    ],
    [
        "body",
        new Set([
            "head",
            "link",
            "script"
        ])
    ],
    [
        "li",
        new Set([
            "li"
        ])
    ],
    [
        "p",
        pTag
    ],
    [
        "h1",
        pTag
    ],
    [
        "h2",
        pTag
    ],
    [
        "h3",
        pTag
    ],
    [
        "h4",
        pTag
    ],
    [
        "h5",
        pTag
    ],
    [
        "h6",
        pTag
    ],
    [
        "select",
        formTags
    ],
    [
        "input",
        formTags
    ],
    [
        "output",
        formTags
    ],
    [
        "button",
        formTags
    ],
    [
        "datalist",
        formTags
    ],
    [
        "textarea",
        formTags
    ],
    [
        "option",
        new Set([
            "option"
        ])
    ],
    [
        "optgroup",
        new Set([
            "optgroup",
            "option"
        ])
    ],
    [
        "dd",
        ddtTags
    ],
    [
        "dt",
        ddtTags
    ],
    [
        "address",
        pTag
    ],
    [
        "article",
        pTag
    ],
    [
        "aside",
        pTag
    ],
    [
        "blockquote",
        pTag
    ],
    [
        "details",
        pTag
    ],
    [
        "div",
        pTag
    ],
    [
        "dl",
        pTag
    ],
    [
        "fieldset",
        pTag
    ],
    [
        "figcaption",
        pTag
    ],
    [
        "figure",
        pTag
    ],
    [
        "footer",
        pTag
    ],
    [
        "form",
        pTag
    ],
    [
        "header",
        pTag
    ],
    [
        "hr",
        pTag
    ],
    [
        "main",
        pTag
    ],
    [
        "nav",
        pTag
    ],
    [
        "ol",
        pTag
    ],
    [
        "pre",
        pTag
    ],
    [
        "section",
        pTag
    ],
    [
        "table",
        pTag
    ],
    [
        "ul",
        pTag
    ],
    [
        "rt",
        rtpTags
    ],
    [
        "rp",
        rtpTags
    ],
    [
        "tbody",
        tableSectionTags
    ],
    [
        "tfoot",
        tableSectionTags
    ]
]);
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
var foreignContextElements = new Set([
    "math",
    "svg"
]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ function() {
    function Parser(cbs, options) {
        if (options === void 0) {
            options = {};
        }
        var _a, _b, _c, _d, _e;
        this.options = options;
        /** The start index of the last event. */ this.startIndex = 0;
        /** The end index of the last event. */ this.endIndex = 0;
        /**
         * Store the start index of the current open tag,
         * so we can update the start index for attributes.
         */ this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        /** The index of the last written buffer. Used when resuming after a `pause()`. */ this.writeIndex = 0;
        /** Indicates whether the parser has finished running / `.end` has been called. */ this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    // Tokenizer event handlers
    /** @internal */ Parser.prototype.ontext = function(start, endIndex) {
        var _a, _b;
        var data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
    };
    /** @internal */ Parser.prototype.ontextentity = function(cp) {
        var _a, _b;
        /*
         * Entities can be emitted on the character, or directly after.
         * We use the section start here to get accurate indices.
         */ var index = this.tokenizer.getSectionStart();
        this.endIndex = index - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
        this.startIndex = index;
    };
    Parser.prototype.isVoidElement = function(name) {
        return !this.options.xmlMode && voidElements.has(name);
    };
    /** @internal */ Parser.prototype.onopentagname = function(start, endIndex) {
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.emitOpenTag(name);
    };
    Parser.prototype.emitOpenTag = function(name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
            while(this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])){
                var element = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
            }
        }
        if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag) this.attribs = {};
    };
    Parser.prototype.endOpenTag = function(isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
    };
    /** @internal */ Parser.prototype.onopentagend = function(endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onclosetag = function(start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    var count = this.stack.length - pos;
                    while(count--){
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop(), count !== 0);
                    }
                } else this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
                // Implicit open before close
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
            }
        } else if (!this.options.xmlMode && name === "br") {
            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onselfclosingtag = function(endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        } else {
            // Ignore the fact that the tag is self-closing.
            this.onopentagend(endIndex);
        }
    };
    Parser.prototype.closeCurrentTag = function(isOpenImplied) {
        var _a, _b;
        var name = this.tagname;
        this.endOpenTag(isOpenImplied);
        // Self-closing tags will be on the top of the stack
        if (this.stack[this.stack.length - 1] === name) {
            // If the opening tag isn't implied, the closing tag has to be implied.
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
        }
    };
    /** @internal */ Parser.prototype.onattribname = function(start, endIndex) {
        this.startIndex = start;
        var name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    };
    /** @internal */ Parser.prototype.onattribdata = function(start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
    };
    /** @internal */ Parser.prototype.onattribentity = function(cp) {
        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    /** @internal */ Parser.prototype.onattribend = function(quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? undefined : null);
        if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function(value) {
        var index = value.search(reNameEnd);
        var name = index < 0 ? value : value.substr(0, index);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    /** @internal */ Parser.prototype.ondeclaration = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onprocessinginstruction = function(start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.oncomment = function(start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.oncdata = function(start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */ Parser.prototype.onend = function() {
        var _a, _b;
        if (this.cbs.onclosetag) {
            // Set the end index for all remaining tags
            this.endIndex = this.startIndex;
            for(var index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true));
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */ Parser.prototype.reset = function() {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */ Parser.prototype.parseComplete = function(data) {
        this.reset();
        this.end(data);
    };
    Parser.prototype.getSlice = function(start, end) {
        while(start - this.bufferOffset >= this.buffers[0].length){
            this.shiftBuffer();
        }
        var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while(end - this.bufferOffset > this.buffers[0].length){
            this.shiftBuffer();
            slice += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return slice;
    };
    Parser.prototype.shiftBuffer = function() {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */ Parser.prototype.write = function(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
        }
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */ Parser.prototype.end = function(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
        }
        if (chunk) this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */ Parser.prototype.pause = function() {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */ Parser.prototype.resume = function() {
        this.tokenizer.resume();
        while(this.tokenizer.running && this.writeIndex < this.buffers.length){
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended) this.tokenizer.end();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */ Parser.prototype.parseChunk = function(chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */ Parser.prototype.done = function(chunk) {
        this.end(chunk);
    };
    return Parser;
}();
exports.Parser = Parser; //# sourceMappingURL=Parser.js.map


/***/ }),

/***/ 19910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.QuoteType = void 0;
var decode_js_1 = __webpack_require__(12657);
var CharCodes;
(function(CharCodes) {
    CharCodes[CharCodes["Tab"] = 9] = "Tab";
    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes[CharCodes["Space"] = 32] = "Space";
    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes[CharCodes["Number"] = 35] = "Number";
    CharCodes[CharCodes["Amp"] = 38] = "Amp";
    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes[CharCodes["Dash"] = 45] = "Dash";
    CharCodes[CharCodes["Slash"] = 47] = "Slash";
    CharCodes[CharCodes["Zero"] = 48] = "Zero";
    CharCodes[CharCodes["Nine"] = 57] = "Nine";
    CharCodes[CharCodes["Semi"] = 59] = "Semi";
    CharCodes[CharCodes["Lt"] = 60] = "Lt";
    CharCodes[CharCodes["Eq"] = 61] = "Eq";
    CharCodes[CharCodes["Gt"] = 62] = "Gt";
    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */ var State;
(function(State) {
    State[State["Text"] = 1] = "Text";
    State[State["BeforeTagName"] = 2] = "BeforeTagName";
    State[State["InTagName"] = 3] = "InTagName";
    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State[State["InClosingTagName"] = 6] = "InClosingTagName";
    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    // Attributes
    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State[State["InAttributeName"] = 9] = "InAttributeName";
    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    // Declarations
    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State[State["InDeclaration"] = 16] = "InDeclaration";
    // Processing instructions
    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    // Comments & CDATA
    State[State["BeforeComment"] = 18] = "BeforeComment";
    State[State["CDATASequence"] = 19] = "CDATASequence";
    State[State["InSpecialComment"] = 20] = "InSpecialComment";
    State[State["InCommentLike"] = 21] = "InCommentLike";
    // Special tags
    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State[State["InSpecialTag"] = 24] = "InSpecialTag";
    State[State["BeforeEntity"] = 25] = "BeforeEntity";
    State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State[State["InNamedEntity"] = 27] = "InNamedEntity";
    State[State["InNumericEntity"] = 28] = "InNumericEntity";
    State[State["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isNumber(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
}
function isHexDigit(c) {
    return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
}
var QuoteType;
(function(QuoteType) {
    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
    QuoteType[QuoteType["Single"] = 2] = "Single";
    QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */ var Sequences = {
    Cdata: new Uint8Array([
        0x43,
        0x44,
        0x41,
        0x54,
        0x41,
        0x5b
    ]),
    CdataEnd: new Uint8Array([
        0x5d,
        0x5d,
        0x3e
    ]),
    CommentEnd: new Uint8Array([
        0x2d,
        0x2d,
        0x3e
    ]),
    ScriptEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x73,
        0x63,
        0x72,
        0x69,
        0x70,
        0x74
    ]),
    StyleEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x73,
        0x74,
        0x79,
        0x6c,
        0x65
    ]),
    TitleEnd: new Uint8Array([
        0x3c,
        0x2f,
        0x74,
        0x69,
        0x74,
        0x6c,
        0x65
    ])
};
var Tokenizer = /** @class */ function() {
    function Tokenizer(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        /** The current state the tokenizer is in. */ this.state = State.Text;
        /** The read buffer. */ this.buffer = "";
        /** The beginning of the section that is currently being read. */ this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */ this.index = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */ this.baseState = State.Text;
        /** For special parsing behavior inside of script and style tags. */ this.isSpecial = false;
        /** Indicates whether the tokenizer has been paused. */ this.running = true;
        /** The offset of the current buffer. */ this.offset = 0;
        this.currentSequence = undefined;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        /** For named entities, the index of the value. For numeric entities, the code point. */ this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer.prototype.reset = function() {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = undefined;
        this.running = true;
        this.offset = 0;
    };
    Tokenizer.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function() {
        if (this.running) this.finish();
    };
    Tokenizer.prototype.pause = function() {
        this.running = false;
    };
    Tokenizer.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
            this.parse();
        }
    };
    /**
     * The current index within all of the written data.
     */ Tokenizer.prototype.getIndex = function() {
        return this.index;
    };
    /**
     * The start of the current section.
     */ Tokenizer.prototype.getSectionStart = function() {
        return this.sectionStart;
    };
    Tokenizer.prototype.stateText = function(c) {
        if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State.BeforeTagName;
            this.sectionStart = this.index;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateSpecialStartSequence = function(c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? isEndOfTagSection(c) : (c | 0x20) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
            this.isSpecial = false;
        } else if (!isEnd) {
            this.sequenceIndex++;
            return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
    };
    /** Look for an end tag. For <title> tags, also decode entities. */ Tokenizer.prototype.stateInSpecialTag = function(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                var endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                    // Spoof the index so that reported locations match up.
                    var actualIndex = this.index;
                    this.index = endOfText;
                    this.cbs.ontext(this.sectionStart, endOfText);
                    this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2; // Skip over the `</`
                this.stateInClosingTagName(c);
                return; // We are done; skip the rest of the function.
            }
            this.sequenceIndex = 0;
        }
        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
                // We have to parse entities in <title> tags.
                if (this.decodeEntities && c === CharCodes.Amp) {
                    this.state = State.BeforeEntity;
                }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
                // Outside of <title> tags, we can fast-forward.
                this.sequenceIndex = 1;
            }
        } else {
            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
            this.sequenceIndex = Number(c === CharCodes.Lt);
        }
    };
    Tokenizer.prototype.stateCDATASequence = function(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
            }
        } else {
            this.sequenceIndex = 0;
            this.state = State.InDeclaration;
            this.stateInDeclaration(c); // Reconsume the character
        }
    };
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */ Tokenizer.prototype.fastForwardTo = function(c) {
        while(++this.index < this.buffer.length + this.offset){
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
            }
        }
        /*
         * We increment the index at the end of the `parse` loop,
         * so set it to `buffer.length - 1` here.
         *
         * TODO: Refactor `parse` to increment index before calling states.
         */ this.index = this.buffer.length + this.offset - 1;
        return false;
    };
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */ Tokenizer.prototype.stateInCommentLike = function(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, this.index, 2);
                } else {
                    this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
            }
        } else if (this.sequenceIndex === 0) {
            // Fast-forward to the first character of the sequence
            if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
            }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            // Allow long sequences, eg. --->, ]]]>
            this.sequenceIndex = 0;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */ Tokenizer.prototype.isTagStartChar = function(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    };
    Tokenizer.prototype.startSpecial = function(sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
    };
    Tokenizer.prototype.stateBeforeTagName = function(c) {
        if (c === CharCodes.ExclamationMark) {
            this.state = State.BeforeDeclaration;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Questionmark) {
            this.state = State.InProcessingInstruction;
            this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c)) {
            var lower = c | 0x20;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
            } else {
                this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
            }
        } else if (c === CharCodes.Slash) {
            this.state = State.BeforeClosingTagName;
        } else {
            this.state = State.Text;
            this.stateText(c);
        }
    };
    Tokenizer.prototype.stateInTagName = function(c) {
        if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function(c) {
        if (isWhitespace(c)) {
        // Ignore
        } else if (c === CharCodes.Gt) {
            this.state = State.Text;
        } else {
            this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function(c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function(c) {
        // Skip everything until ">"
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function(c) {
        if (c === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
            } else {
                this.state = State.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Slash) {
            this.state = State.InSelfClosingTag;
        } else if (!isWhitespace(c)) {
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function(c) {
        if (c === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false; // Reset special state, in case of self-closing special tags
        } else if (!isWhitespace(c)) {
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateInAttributeName = function(c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterAttributeName;
            this.stateAfterAttributeName(c);
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function(c) {
        if (c === CharCodes.Eq) {
            this.state = State.BeforeAttributeValue;
        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        } else if (!isWhitespace(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function(c) {
        if (c === CharCodes.DoubleQuote) {
            this.state = State.InAttributeValueDq;
            this.sectionStart = this.index + 1;
        } else if (c === CharCodes.SingleQuote) {
            this.state = State.InAttributeValueSq;
            this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
            this.sectionStart = this.index;
            this.state = State.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c); // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State.BeforeAttributeName;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        } else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function(c) {
        if (c === CharCodes.OpeningSquareBracket) {
            this.state = State.CDATASequence;
            this.sequenceIndex = 0;
        } else {
            this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInDeclaration = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function(c) {
        if (c === CharCodes.Dash) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            // Allow short comments (eg. <!-->)
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
        } else {
            this.state = State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInSpecialComment = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeSpecialS = function(c) {
        var lower = c | 0x20;
        if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
        } else {
            this.state = State.InTagName;
            this.stateInTagName(c); // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeEntity = function(c) {
        // Start excess with 1 to include the '&'
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Number) {
            this.state = State.BeforeNumericEntity;
        } else if (c === CharCodes.Amp) {
        // We have two `&` characters in a row. Stay in the current state.
        } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State.InNamedEntity;
            this.stateInNamedEntity(c);
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function(c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
        // If the branch is a value, store it and continue
        if (masked) {
            // The mask is the number of bytes of the value, including the current byte.
            var valueLength = (masked >> 14) - 1;
            // If we have a legacy entity while parsing strictly, just skip the number of bytes
            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                this.trieIndex += valueLength;
            } else {
                // Add 1 as we have already incremented the excess
                var entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                // If this is a surrogate pair, consume the next two bytes
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                    this.emitNamedEntity();
                }
            }
        }
    };
    Tokenizer.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
            return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch(valueLength){
            case 1:
                {
                    this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
                    break;
                }
            case 2:
                {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    break;
                }
            case 3:
                {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
                }
        }
    };
    Tokenizer.prototype.stateBeforeNumericEntity = function(c) {
        if ((c | 0x20) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State.InHexEntity;
        } else {
            this.state = State.InNumericEntity;
            this.stateInNumericEntity(c);
        }
    };
    Tokenizer.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
            // Emit leading data if any
            if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function(c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
            this.entityExcess++;
        } else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            } else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function(c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        } else if (isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
            this.entityExcess++;
        } else if (isHexDigit(c)) {
            this.entityResult = this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
            this.entityExcess++;
        } else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            } else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    };
    /**
     * Remove data that has already been consumed from the buffer.
     */ Tokenizer.prototype.cleanup = function() {
        // If we are inside of text or attributes, emit what we already have.
        if (this.running && this.sectionStart !== this.index) {
            if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
            } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
        }
    };
    Tokenizer.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */ Tokenizer.prototype.parse = function() {
        while(this.shouldContinue()){
            var c = this.buffer.charCodeAt(this.index - this.offset);
            switch(this.state){
                case State.Text:
                    {
                        this.stateText(c);
                        break;
                    }
                case State.SpecialStartSequence:
                    {
                        this.stateSpecialStartSequence(c);
                        break;
                    }
                case State.InSpecialTag:
                    {
                        this.stateInSpecialTag(c);
                        break;
                    }
                case State.CDATASequence:
                    {
                        this.stateCDATASequence(c);
                        break;
                    }
                case State.InAttributeValueDq:
                    {
                        this.stateInAttributeValueDoubleQuotes(c);
                        break;
                    }
                case State.InAttributeName:
                    {
                        this.stateInAttributeName(c);
                        break;
                    }
                case State.InCommentLike:
                    {
                        this.stateInCommentLike(c);
                        break;
                    }
                case State.InSpecialComment:
                    {
                        this.stateInSpecialComment(c);
                        break;
                    }
                case State.BeforeAttributeName:
                    {
                        this.stateBeforeAttributeName(c);
                        break;
                    }
                case State.InTagName:
                    {
                        this.stateInTagName(c);
                        break;
                    }
                case State.InClosingTagName:
                    {
                        this.stateInClosingTagName(c);
                        break;
                    }
                case State.BeforeTagName:
                    {
                        this.stateBeforeTagName(c);
                        break;
                    }
                case State.AfterAttributeName:
                    {
                        this.stateAfterAttributeName(c);
                        break;
                    }
                case State.InAttributeValueSq:
                    {
                        this.stateInAttributeValueSingleQuotes(c);
                        break;
                    }
                case State.BeforeAttributeValue:
                    {
                        this.stateBeforeAttributeValue(c);
                        break;
                    }
                case State.BeforeClosingTagName:
                    {
                        this.stateBeforeClosingTagName(c);
                        break;
                    }
                case State.AfterClosingTagName:
                    {
                        this.stateAfterClosingTagName(c);
                        break;
                    }
                case State.BeforeSpecialS:
                    {
                        this.stateBeforeSpecialS(c);
                        break;
                    }
                case State.InAttributeValueNq:
                    {
                        this.stateInAttributeValueNoQuotes(c);
                        break;
                    }
                case State.InSelfClosingTag:
                    {
                        this.stateInSelfClosingTag(c);
                        break;
                    }
                case State.InDeclaration:
                    {
                        this.stateInDeclaration(c);
                        break;
                    }
                case State.BeforeDeclaration:
                    {
                        this.stateBeforeDeclaration(c);
                        break;
                    }
                case State.BeforeComment:
                    {
                        this.stateBeforeComment(c);
                        break;
                    }
                case State.InProcessingInstruction:
                    {
                        this.stateInProcessingInstruction(c);
                        break;
                    }
                case State.InNamedEntity:
                    {
                        this.stateInNamedEntity(c);
                        break;
                    }
                case State.BeforeEntity:
                    {
                        this.stateBeforeEntity(c);
                        break;
                    }
                case State.InHexEntity:
                    {
                        this.stateInHexEntity(c);
                        break;
                    }
                case State.InNumericEntity:
                    {
                        this.stateInNumericEntity(c);
                        break;
                    }
                default:
                    {
                        // `this._state === State.BeforeNumericEntity`
                        this.stateBeforeNumericEntity(c);
                    }
            }
            this.index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function() {
        if (this.state === State.InNamedEntity) {
            this.emitNamedEntity();
        }
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this.index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    /** Handle any trailing data. */ Tokenizer.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
        } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
        // All trailing data will have been consumed
        } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
        // All trailing data will have been consumed
        } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
        /*
             * If we are currently in an opening or closing tag, us not calling the
             * respective callback signals that the tag should be ignored.
             */ } else {
            this.cbs.ontext(this.sectionStart, endIndex);
        }
    };
    Tokenizer.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
        } else {
            this.cbs.ontext(start, endIndex);
        }
    };
    Tokenizer.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
            this.cbs.onattribentity(cp);
        } else {
            this.cbs.ontextentity(cp);
        }
    };
    return Tokenizer;
}();
exports["default"] = Tokenizer; //# sourceMappingURL=Tokenizer.js.map


/***/ }),

/***/ 16572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
var Parser_js_1 = __webpack_require__(28727);
var Parser_js_2 = __webpack_require__(28727);
Object.defineProperty(exports, "Parser", ({
    enumerable: true,
    get: function() {
        return Parser_js_2.Parser;
    }
}));
var domhandler_1 = __webpack_require__(22619);
var domhandler_2 = __webpack_require__(22619);
Object.defineProperty(exports, "DomHandler", ({
    enumerable: true,
    get: function() {
        return domhandler_2.DomHandler;
    }
}));
// Old name for DomHandler
Object.defineProperty(exports, "DefaultHandler", ({
    enumerable: true,
    get: function() {
        return domhandler_2.DomHandler;
    }
}));
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */ function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */ function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param callback A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
 */ function createDomStream(callback, options, elementCallback) {
    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
    return new Parser_js_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_js_1 = __webpack_require__(19910);
Object.defineProperty(exports, "Tokenizer", ({
    enumerable: true,
    get: function() {
        return __importDefault(Tokenizer_js_1).default;
    }
}));
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */ exports.ElementType = __importStar(__webpack_require__(39469));
var domutils_1 = __webpack_require__(96670);
var domutils_2 = __webpack_require__(96670);
Object.defineProperty(exports, "getFeed", ({
    enumerable: true,
    get: function() {
        return domutils_2.getFeed;
    }
}));
var parseFeedDefaultOptions = {
    xmlMode: true
};
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */ function parseFeed(feed, options) {
    if (options === void 0) {
        options = parseFeedDefaultOptions;
    }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
}
exports.parseFeed = parseFeed;
exports.DomUtils = __importStar(__webpack_require__(96670)); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 41492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
    var util = __webpack_require__(73837);
    /* istanbul ignore next */ if (typeof util.inherits !== "function") throw "";
    module.exports = util.inherits;
} catch (e) {
    /* istanbul ignore next */ module.exports = __webpack_require__(43668);
}


/***/ }),

/***/ 43668:
/***/ ((module) => {

if (typeof Object.create === "function") {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}


/***/ }),

/***/ 76278:
/***/ ((module) => {

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;
// strings
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
// types
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */ module.exports = function(style, options) {
    if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
    }
    if (!style) return [];
    options = options || {};
    /**
   * Positional.
   */ var lineno = 1;
    var column = 1;
    /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */ function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
    }
    /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */ function position() {
        var start = {
            line: lineno,
            column: column
        };
        return function(node) {
            node.position = new Position(start);
            whitespace();
            return node;
        };
    }
    /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */ function Position(start) {
        this.start = start;
        this.end = {
            line: lineno,
            column: column
        };
        this.source = options.source;
    }
    /**
   * Non-enumerable source string.
   */ Position.prototype.content = style;
    var errorsList = [];
    /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */ function error(msg) {
        var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
            errorsList.push(err);
        } else {
            throw err;
        }
    }
    /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */ function match(re) {
        var m = re.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
    }
    /**
   * Parse whitespace.
   */ function whitespace() {
        match(WHITESPACE_REGEX);
    }
    /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */ function comments(rules) {
        var c;
        rules = rules || [];
        while(c = comment()){
            if (c !== false) {
                rules.push(c);
            }
        }
        return rules;
    }
    /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */ function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
        var i = 2;
        while(EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))){
            ++i;
        }
        i += 2;
        if (EMPTY_STRING === style.charAt(i - 1)) {
            return error("End of comment missing");
        }
        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;
        return pos({
            type: TYPE_COMMENT,
            comment: str
        });
    }
    /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */ function declaration() {
        var pos = position();
        // prop
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment();
        // :
        if (!match(COLON_REGEX)) return error("property missing ':'");
        // val
        var val = match(VALUE_REGEX);
        var ret = pos({
            type: TYPE_DECLARATION,
            property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
            value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        // ;
        match(SEMICOLON_REGEX);
        return ret;
    }
    /**
   * Parse declarations.
   *
   * @return {Object[]}
   */ function declarations() {
        var decls = [];
        comments(decls);
        // declarations
        var decl;
        while(decl = declaration()){
            if (decl !== false) {
                decls.push(decl);
                comments(decls);
            }
        }
        return decls;
    }
    whitespace();
    return declarations();
};
/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */ function trim(str) {
    return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}


/***/ }),

/***/ 43925:
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
}


/***/ }),

/***/ 44386:
/***/ ((module) => {

"use strict";
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ 
module.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
};


/***/ }),

/***/ 99130:
/***/ ((module) => {

"use strict";

const isStream = (stream)=>stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
isStream.writable = (stream)=>isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
isStream.readable = (stream)=>isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
isStream.duplex = (stream)=>isStream.writable(stream) && isStream.readable(stream);
isStream.transform = (stream)=>isStream.duplex(stream) && typeof stream._transform === "function";
module.exports = isStream;


/***/ }),

/***/ 30279:
/***/ ((module) => {

"use strict";
/*!
 * is-whitespace <https://github.com/jonschlinkert/is-whitespace>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ 
var cache;
module.exports = function isWhitespace(str) {
    return typeof str === "string" && regex().test(str);
};
function regex() {
    // ensure that runtime compilation only happens once
    return cache || (cache = new RegExp('^[\\s	\n\v\f\r \xa0 ᠎             　\u2028\u2029\uFEFF"]+$'));
}


/***/ }),

/***/ 45805:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */ /* globals define */ /*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/ 
/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/ function get_beautify(js_beautify, css_beautify, html_beautify) {
    // the default is js
    var beautify = function(src, config) {
        return js_beautify.js_beautify(src, config);
    };
    // short aliases
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    // legacy aliases
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
}
if (true) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(49080),
        __webpack_require__(92019),
        __webpack_require__(36491)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


/***/ }),

/***/ 92019:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>
        https://beautifier.io/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                         — indentation size,
        indent_char (space)                     — character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/ // http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/
(function() {
    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_css;
    /******/ (function() {
        /******/ "use strict";
        /******/ var __webpack_modules__ = [
            ,
            ,
            /* 2 */ /***/ function(module) {
                /*jshint node:true */ /*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function OutputLine(parent) {
                    this.__parent = parent;
                    this.__character_count = 0;
                    // use indent_count as a marker for this.__lines that have preserved indentation
                    this.__indent_count = -1;
                    this.__alignment_count = 0;
                    this.__wrap_point_index = 0;
                    this.__wrap_point_character_count = 0;
                    this.__wrap_point_indent_count = -1;
                    this.__wrap_point_alignment_count = 0;
                    this.__items = [];
                }
                OutputLine.prototype.clone_empty = function() {
                    var line = new OutputLine(this.__parent);
                    line.set_indent(this.__indent_count, this.__alignment_count);
                    return line;
                };
                OutputLine.prototype.item = function(index) {
                    if (index < 0) {
                        return this.__items[this.__items.length + index];
                    } else {
                        return this.__items[index];
                    }
                };
                OutputLine.prototype.has_match = function(pattern) {
                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){
                        if (this.__items[lastCheckedOutput].match(pattern)) {
                            return true;
                        }
                    }
                    return false;
                };
                OutputLine.prototype.set_indent = function(indent, alignment) {
                    if (this.is_empty()) {
                        this.__indent_count = indent || 0;
                        this.__alignment_count = alignment || 0;
                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
                    }
                };
                OutputLine.prototype._set_wrap_point = function() {
                    if (this.__parent.wrap_line_length) {
                        this.__wrap_point_index = this.__items.length;
                        this.__wrap_point_character_count = this.__character_count;
                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
                    }
                };
                OutputLine.prototype._should_wrap = function() {
                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
                };
                OutputLine.prototype._allow_wrap = function() {
                    if (this._should_wrap()) {
                        this.__parent.add_new_line();
                        var next = this.__parent.current_line;
                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
                        next.__items = this.__items.slice(this.__wrap_point_index);
                        this.__items = this.__items.slice(0, this.__wrap_point_index);
                        next.__character_count += this.__character_count - this.__wrap_point_character_count;
                        this.__character_count = this.__wrap_point_character_count;
                        if (next.__items[0] === " ") {
                            next.__items.splice(0, 1);
                            next.__character_count -= 1;
                        }
                        return true;
                    }
                    return false;
                };
                OutputLine.prototype.is_empty = function() {
                    return this.__items.length === 0;
                };
                OutputLine.prototype.last = function() {
                    if (!this.is_empty()) {
                        return this.__items[this.__items.length - 1];
                    } else {
                        return null;
                    }
                };
                OutputLine.prototype.push = function(item) {
                    this.__items.push(item);
                    var last_newline_index = item.lastIndexOf("\n");
                    if (last_newline_index !== -1) {
                        this.__character_count = item.length - last_newline_index;
                    } else {
                        this.__character_count += item.length;
                    }
                };
                OutputLine.prototype.pop = function() {
                    var item = null;
                    if (!this.is_empty()) {
                        item = this.__items.pop();
                        this.__character_count -= item.length;
                    }
                    return item;
                };
                OutputLine.prototype._remove_indent = function() {
                    if (this.__indent_count > 0) {
                        this.__indent_count -= 1;
                        this.__character_count -= this.__parent.indent_size;
                    }
                };
                OutputLine.prototype._remove_wrap_indent = function() {
                    if (this.__wrap_point_indent_count > 0) {
                        this.__wrap_point_indent_count -= 1;
                    }
                };
                OutputLine.prototype.trim = function() {
                    while(this.last() === " "){
                        this.__items.pop();
                        this.__character_count -= 1;
                    }
                };
                OutputLine.prototype.toString = function() {
                    var result = "";
                    if (this.is_empty()) {
                        if (this.__parent.indent_empty_lines) {
                            result = this.__parent.get_indent_string(this.__indent_count);
                        }
                    } else {
                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
                        result += this.__items.join("");
                    }
                    return result;
                };
                function IndentStringCache(options, baseIndentString) {
                    this.__cache = [
                        ""
                    ];
                    this.__indent_size = options.indent_size;
                    this.__indent_string = options.indent_char;
                    if (!options.indent_with_tabs) {
                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
                    }
                    // Set to null to continue support for auto detection of base indent
                    baseIndentString = baseIndentString || "";
                    if (options.indent_level > 0) {
                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
                    }
                    this.__base_string = baseIndentString;
                    this.__base_string_length = baseIndentString.length;
                }
                IndentStringCache.prototype.get_indent_size = function(indent, column) {
                    var result = this.__base_string_length;
                    column = column || 0;
                    if (indent < 0) {
                        result = 0;
                    }
                    result += indent * this.__indent_size;
                    result += column;
                    return result;
                };
                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
                    var result = this.__base_string;
                    column = column || 0;
                    if (indent_level < 0) {
                        indent_level = 0;
                        result = "";
                    }
                    column += indent_level * this.__indent_size;
                    this.__ensure_cache(column);
                    result += this.__cache[column];
                    return result;
                };
                IndentStringCache.prototype.__ensure_cache = function(column) {
                    while(column >= this.__cache.length){
                        this.__add_column();
                    }
                };
                IndentStringCache.prototype.__add_column = function() {
                    var column = this.__cache.length;
                    var indent = 0;
                    var result = "";
                    if (this.__indent_size && column >= this.__indent_size) {
                        indent = Math.floor(column / this.__indent_size);
                        column -= indent * this.__indent_size;
                        result = new Array(indent + 1).join(this.__indent_string);
                    }
                    if (column) {
                        result += new Array(column + 1).join(" ");
                    }
                    this.__cache.push(result);
                };
                function Output(options, baseIndentString) {
                    this.__indent_cache = new IndentStringCache(options, baseIndentString);
                    this.raw = false;
                    this._end_with_newline = options.end_with_newline;
                    this.indent_size = options.indent_size;
                    this.wrap_line_length = options.wrap_line_length;
                    this.indent_empty_lines = options.indent_empty_lines;
                    this.__lines = [];
                    this.previous_line = null;
                    this.current_line = null;
                    this.next_line = new OutputLine(this);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                    // initialize
                    this.__add_outputline();
                }
                Output.prototype.__add_outputline = function() {
                    this.previous_line = this.current_line;
                    this.current_line = this.next_line.clone_empty();
                    this.__lines.push(this.current_line);
                };
                Output.prototype.get_line_number = function() {
                    return this.__lines.length;
                };
                Output.prototype.get_indent_string = function(indent, column) {
                    return this.__indent_cache.get_indent_string(indent, column);
                };
                Output.prototype.get_indent_size = function(indent, column) {
                    return this.__indent_cache.get_indent_size(indent, column);
                };
                Output.prototype.is_empty = function() {
                    return !this.previous_line && this.current_line.is_empty();
                };
                Output.prototype.add_new_line = function(force_newline) {
                    // never newline at the start of file
                    // otherwise, newline only if we didn't just add one or we're forced
                    if (this.is_empty() || !force_newline && this.just_added_newline()) {
                        return false;
                    }
                    // if raw output is enabled, don't print additional newlines,
                    // but still return True as though you had
                    if (!this.raw) {
                        this.__add_outputline();
                    }
                    return true;
                };
                Output.prototype.get_code = function(eol) {
                    this.trim(true);
                    // handle some edge cases where the last tokens
                    // has text that ends with newline(s)
                    var last_item = this.current_line.pop();
                    if (last_item) {
                        if (last_item[last_item.length - 1] === "\n") {
                            last_item = last_item.replace(/\n+$/g, "");
                        }
                        this.current_line.push(last_item);
                    }
                    if (this._end_with_newline) {
                        this.__add_outputline();
                    }
                    var sweet_code = this.__lines.join("\n");
                    if (eol !== "\n") {
                        sweet_code = sweet_code.replace(/[\n]/g, eol);
                    }
                    return sweet_code;
                };
                Output.prototype.set_wrap_point = function() {
                    this.current_line._set_wrap_point();
                };
                Output.prototype.set_indent = function(indent, alignment) {
                    indent = indent || 0;
                    alignment = alignment || 0;
                    // Next line stores alignment values
                    this.next_line.set_indent(indent, alignment);
                    // Never indent your first output indent at the start of the file
                    if (this.__lines.length > 1) {
                        this.current_line.set_indent(indent, alignment);
                        return true;
                    }
                    this.current_line.set_indent();
                    return false;
                };
                Output.prototype.add_raw_token = function(token) {
                    for(var x = 0; x < token.newlines; x++){
                        this.__add_outputline();
                    }
                    this.current_line.set_indent(-1);
                    this.current_line.push(token.whitespace_before);
                    this.current_line.push(token.text);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                };
                Output.prototype.add_token = function(printable_token) {
                    this.__add_space_before_token();
                    this.current_line.push(printable_token);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = this.current_line._allow_wrap();
                };
                Output.prototype.__add_space_before_token = function() {
                    if (this.space_before_token && !this.just_added_newline()) {
                        if (!this.non_breaking_space) {
                            this.set_wrap_point();
                        }
                        this.current_line.push(" ");
                    }
                };
                Output.prototype.remove_indent = function(index) {
                    var output_length = this.__lines.length;
                    while(index < output_length){
                        this.__lines[index]._remove_indent();
                        index++;
                    }
                    this.current_line._remove_wrap_indent();
                };
                Output.prototype.trim = function(eat_newlines) {
                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
                    this.current_line.trim();
                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){
                        this.__lines.pop();
                        this.current_line = this.__lines[this.__lines.length - 1];
                        this.current_line.trim();
                    }
                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
                };
                Output.prototype.just_added_newline = function() {
                    return this.current_line.is_empty();
                };
                Output.prototype.just_added_blankline = function() {
                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
                };
                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
                    var index = this.__lines.length - 2;
                    while(index >= 0){
                        var potentialEmptyLine = this.__lines[index];
                        if (potentialEmptyLine.is_empty()) {
                            break;
                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
                            this.__lines.splice(index + 1, 0, new OutputLine(this));
                            this.previous_line = this.__lines[this.__lines.length - 2];
                            break;
                        }
                        index--;
                    }
                };
                module.exports.Output = Output;
            /***/ },
            ,
            ,
            ,
            /* 6 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Options(options, merge_child_field) {
                    this.raw_options = _mergeOpts(options, merge_child_field);
                    // Support passing the source text back with no change
                    this.disabled = this._get_boolean("disabled");
                    this.eol = this._get_characters("eol", "auto");
                    this.end_with_newline = this._get_boolean("end_with_newline");
                    this.indent_size = this._get_number("indent_size", 4);
                    this.indent_char = this._get_characters("indent_char", " ");
                    this.indent_level = this._get_number("indent_level");
                    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
                    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
                    if (!this.preserve_newlines) {
                        this.max_preserve_newlines = 0;
                    }
                    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
                    if (this.indent_with_tabs) {
                        this.indent_char = "	";
                        // indent_size behavior changed after 1.8.6
                        // It used to be that indent_size would be
                        // set to 1 for indent_with_tabs. That is no longer needed and
                        // actually doesn't make sense - why not use spaces? Further,
                        // that might produce unexpected behavior - tabs being used
                        // for single-column alignment. So, when indent_with_tabs is true
                        // and indent_size is 1, reset indent_size to 4.
                        if (this.indent_size === 1) {
                            this.indent_size = 4;
                        }
                    }
                    // Backwards compat with 1.3.x
                    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
                    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']
                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).
                    // other values ignored
                    this.templating = this._get_selection_list("templating", [
                        "auto",
                        "none",
                        "angular",
                        "django",
                        "erb",
                        "handlebars",
                        "php",
                        "smarty"
                    ], [
                        "auto"
                    ]);
                }
                Options.prototype._get_array = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || [];
                    if (typeof option_value === "object") {
                        if (option_value !== null && typeof option_value.concat === "function") {
                            result = option_value.concat();
                        }
                    } else if (typeof option_value === "string") {
                        result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
                    }
                    return result;
                };
                Options.prototype._get_boolean = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = option_value === undefined ? !!default_value : !!option_value;
                    return result;
                };
                Options.prototype._get_characters = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || "";
                    if (typeof option_value === "string") {
                        result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
                    }
                    return result;
                };
                Options.prototype._get_number = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    default_value = parseInt(default_value, 10);
                    if (isNaN(default_value)) {
                        default_value = 0;
                    }
                    var result = parseInt(option_value, 10);
                    if (isNaN(result)) {
                        result = default_value;
                    }
                    return result;
                };
                Options.prototype._get_selection = function(name, selection_list, default_value) {
                    var result = this._get_selection_list(name, selection_list, default_value);
                    if (result.length !== 1) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result[0];
                };
                Options.prototype._get_selection_list = function(name, selection_list, default_value) {
                    if (!selection_list || selection_list.length === 0) {
                        throw new Error("Selection list cannot be empty.");
                    }
                    default_value = default_value || [
                        selection_list[0]
                    ];
                    if (!this._is_valid_selection(default_value, selection_list)) {
                        throw new Error("Invalid Default Value!");
                    }
                    var result = this._get_array(name, default_value);
                    if (!this._is_valid_selection(result, selection_list)) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result;
                };
                Options.prototype._is_valid_selection = function(result, selection_list) {
                    return result.length && selection_list.length && !result.some(function(item) {
                        return selection_list.indexOf(item) === -1;
                    });
                };
                // merges child options up with the parent options object
                // Example: obj = {a: 1, b: {a: 2}}
                //          mergeOpts(obj, 'b')
                //
                //          Returns: {a: 2}
                function _mergeOpts(allOptions, childFieldName) {
                    var finalOpts = {};
                    allOptions = _normalizeOpts(allOptions);
                    var name;
                    for(name in allOptions){
                        if (name !== childFieldName) {
                            finalOpts[name] = allOptions[name];
                        }
                    }
                    //merge in the per type settings for the childFieldName
                    if (childFieldName && allOptions[childFieldName]) {
                        for(name in allOptions[childFieldName]){
                            finalOpts[name] = allOptions[childFieldName][name];
                        }
                    }
                    return finalOpts;
                }
                function _normalizeOpts(options) {
                    var convertedOpts = {};
                    var key;
                    for(key in options){
                        var newKey = key.replace(/-/g, "_");
                        convertedOpts[newKey] = options[key];
                    }
                    return convertedOpts;
                }
                module.exports.Options = Options;
                module.exports.normalizeOpts = _normalizeOpts;
                module.exports.mergeOpts = _mergeOpts;
            /***/ },
            ,
            /* 8 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
                function InputScanner(input_string) {
                    this.__input = input_string || "";
                    this.__input_length = this.__input.length;
                    this.__position = 0;
                }
                InputScanner.prototype.restart = function() {
                    this.__position = 0;
                };
                InputScanner.prototype.back = function() {
                    if (this.__position > 0) {
                        this.__position -= 1;
                    }
                };
                InputScanner.prototype.hasNext = function() {
                    return this.__position < this.__input_length;
                };
                InputScanner.prototype.next = function() {
                    var val = null;
                    if (this.hasNext()) {
                        val = this.__input.charAt(this.__position);
                        this.__position += 1;
                    }
                    return val;
                };
                InputScanner.prototype.peek = function(index) {
                    var val = null;
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        val = this.__input.charAt(index);
                    }
                    return val;
                };
                // This is a JavaScript only helper function (not in python)
                // Javascript doesn't have a match method
                // and not all implementation support "sticky" flag.
                // If they do not support sticky then both this.match() and this.test() method
                // must get the match and check the index of the match.
                // If sticky is supported and set, this method will use it.
                // Otherwise it will check that global is set, and fall back to the slower method.
                InputScanner.prototype.__match = function(pattern, index) {
                    pattern.lastIndex = index;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
                        if (pattern_match.index !== index) {
                            pattern_match = null;
                        }
                    }
                    return pattern_match;
                };
                InputScanner.prototype.test = function(pattern, index) {
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        return !!this.__match(pattern, index);
                    } else {
                        return false;
                    }
                };
                InputScanner.prototype.testChar = function(pattern, index) {
                    // test one character regex match
                    var val = this.peek(index);
                    pattern.lastIndex = 0;
                    return val !== null && pattern.test(val);
                };
                InputScanner.prototype.match = function(pattern) {
                    var pattern_match = this.__match(pattern, this.__position);
                    if (pattern_match) {
                        this.__position += pattern_match[0].length;
                    } else {
                        pattern_match = null;
                    }
                    return pattern_match;
                };
                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
                    var val = "";
                    var match;
                    if (starting_pattern) {
                        match = this.match(starting_pattern);
                        if (match) {
                            val += match[0];
                        }
                    }
                    if (until_pattern && (match || !starting_pattern)) {
                        val += this.readUntil(until_pattern, until_after);
                    }
                    return val;
                };
                InputScanner.prototype.readUntil = function(pattern, until_after) {
                    var val = "";
                    var match_index = this.__position;
                    pattern.lastIndex = this.__position;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match) {
                        match_index = pattern_match.index;
                        if (until_after) {
                            match_index += pattern_match[0].length;
                        }
                    } else {
                        match_index = this.__input_length;
                    }
                    val = this.__input.substring(this.__position, match_index);
                    this.__position = match_index;
                    return val;
                };
                InputScanner.prototype.readUntilAfter = function(pattern) {
                    return this.readUntil(pattern, true);
                };
                InputScanner.prototype.get_regexp = function(pattern, match_from) {
                    var result = null;
                    var flags = "g";
                    if (match_from && regexp_has_sticky) {
                        flags = "y";
                    }
                    // strings are converted to regexp
                    if (typeof pattern === "string" && pattern !== "") {
                        // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
                        result = new RegExp(pattern, flags);
                    } else if (pattern) {
                        result = new RegExp(pattern.source, flags);
                    }
                    return result;
                };
                InputScanner.prototype.get_literal_regexp = function(literal_string) {
                    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
                };
                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {
                    var start = this.__position;
                    var val = this.readUntilAfter(pattern);
                    this.__position = start;
                    return val;
                };
                InputScanner.prototype.lookBack = function(testVal) {
                    var start = this.__position - 1;
                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
                };
                module.exports.InputScanner = InputScanner;
            /***/ },
            ,
            ,
            ,
            ,
            /* 13 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Directives(start_block_pattern, end_block_pattern) {
                    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
                    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
                    this.__directive_pattern = / (\w+)[:](\w+)/g;
                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
                }
                Directives.prototype.get_directives = function(text) {
                    if (!text.match(this.__directives_block_pattern)) {
                        return null;
                    }
                    var directives = {};
                    this.__directive_pattern.lastIndex = 0;
                    var directive_match = this.__directive_pattern.exec(text);
                    while(directive_match){
                        directives[directive_match[1]] = directive_match[2];
                        directive_match = this.__directive_pattern.exec(text);
                    }
                    return directives;
                };
                Directives.prototype.readIgnored = function(input) {
                    return input.readUntilAfter(this.__directives_end_ignore_pattern);
                };
                module.exports.Directives = Directives;
            /***/ },
            ,
            /* 15 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41634__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Beautifier = __nested_webpack_require_41634__(16).Beautifier, Options = __nested_webpack_require_41634__(17).Options;
                function css_beautify(source_text, options) {
                    var beautifier = new Beautifier(source_text, options);
                    return beautifier.beautify();
                }
                module.exports = css_beautify;
                module.exports.defaultOptions = function() {
                    return new Options();
                };
            /***/ },
            /* 16 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_43420__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Options = __nested_webpack_require_43420__(17).Options;
                var Output = __nested_webpack_require_43420__(2).Output;
                var InputScanner = __nested_webpack_require_43420__(8).InputScanner;
                var Directives = __nested_webpack_require_43420__(13).Directives;
                var directives_core = new Directives(/\/\*/, /\*\//);
                var lineBreak = /\r\n|[\r\n]/;
                var allLineBreaks = /\r\n|[\r\n]/g;
                // tokenizer
                var whitespaceChar = /\s/;
                var whitespacePattern = /(?:\s|\n)+/g;
                var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
                var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
                function Beautifier(source_text, options) {
                    this._source_text = source_text || "";
                    // Allow the setting of language/file-type specific options
                    // with inheritance of overall settings
                    this._options = new Options(options);
                    this._ch = null;
                    this._input = null;
                    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
                    this.NESTED_AT_RULE = {
                        "page": true,
                        "font-face": true,
                        "keyframes": true,
                        // also in CONDITIONAL_GROUP_RULE below
                        "media": true,
                        "supports": true,
                        "document": true
                    };
                    this.CONDITIONAL_GROUP_RULE = {
                        "media": true,
                        "supports": true,
                        "document": true
                    };
                    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
                        "grid-template-areas",
                        "grid-template"
                    ];
                }
                Beautifier.prototype.eatString = function(endChars) {
                    var result = "";
                    this._ch = this._input.next();
                    while(this._ch){
                        result += this._ch;
                        if (this._ch === "\\") {
                            result += this._input.next();
                        } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
                            break;
                        }
                        this._ch = this._input.next();
                    }
                    return result;
                };
                // Skips any white space in the source text from the current position.
                // When allowAtLeastOneNewLine is true, will output new lines for each
                // newline character found; if the user has preserve_newlines off, only
                // the first newline will be output
                Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
                    var result = whitespaceChar.test(this._input.peek());
                    var newline_count = 0;
                    while(whitespaceChar.test(this._input.peek())){
                        this._ch = this._input.next();
                        if (allowAtLeastOneNewLine && this._ch === "\n") {
                            if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
                                newline_count++;
                                this._output.add_new_line(true);
                            }
                        }
                    }
                    return result;
                };
                // Nested pseudo-class if we are insideRule
                // and the next special character found opens
                // a new block
                Beautifier.prototype.foundNestedPseudoClass = function() {
                    var openParen = 0;
                    var i = 1;
                    var ch = this._input.peek(i);
                    while(ch){
                        if (ch === "{") {
                            return true;
                        } else if (ch === "(") {
                            // pseudoclasses can contain ()
                            openParen += 1;
                        } else if (ch === ")") {
                            if (openParen === 0) {
                                return false;
                            }
                            openParen -= 1;
                        } else if (ch === ";" || ch === "}") {
                            return false;
                        }
                        i++;
                        ch = this._input.peek(i);
                    }
                    return false;
                };
                Beautifier.prototype.print_string = function(output_string) {
                    this._output.set_indent(this._indentLevel);
                    this._output.non_breaking_space = true;
                    this._output.add_token(output_string);
                };
                Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
                    if (isAfterSpace) {
                        this._output.space_before_token = true;
                    }
                };
                Beautifier.prototype.indent = function() {
                    this._indentLevel++;
                };
                Beautifier.prototype.outdent = function() {
                    if (this._indentLevel > 0) {
                        this._indentLevel--;
                    }
                };
                /*_____________________--------------------_____________________*/ Beautifier.prototype.beautify = function() {
                    if (this._options.disabled) {
                        return this._source_text;
                    }
                    var source_text = this._source_text;
                    var eol = this._options.eol;
                    if (eol === "auto") {
                        eol = "\n";
                        if (source_text && lineBreak.test(source_text || "")) {
                            eol = source_text.match(lineBreak)[0];
                        }
                    }
                    // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
                    source_text = source_text.replace(allLineBreaks, "\n");
                    // reset
                    var baseIndentString = source_text.match(/^[\t ]*/)[0];
                    this._output = new Output(this._options, baseIndentString);
                    this._input = new InputScanner(source_text);
                    this._indentLevel = 0;
                    this._nestedLevel = 0;
                    this._ch = null;
                    var parenLevel = 0;
                    var insideRule = false;
                    // This is the value side of a property value pair (blue in the following ex)
                    // label { content: blue }
                    var insidePropertyValue = false;
                    var enteringConditionalGroup = false;
                    var insideNonNestedAtRule = false;
                    var insideScssMap = false;
                    var topCharacter = this._ch;
                    var insideNonSemiColonValues = false;
                    var whitespace;
                    var isAfterSpace;
                    var previous_ch;
                    while(true){
                        whitespace = this._input.read(whitespacePattern);
                        isAfterSpace = whitespace !== "";
                        previous_ch = topCharacter;
                        this._ch = this._input.next();
                        if (this._ch === "\\" && this._input.hasNext()) {
                            this._ch += this._input.next();
                        }
                        topCharacter = this._ch;
                        if (!this._ch) {
                            break;
                        } else if (this._ch === "/" && this._input.peek() === "*") {
                            // /* css comment */
                            // Always start block comments on a new line.
                            // This handles scenarios where a block comment immediately
                            // follows a property definition on the same line or where
                            // minified code is being beautified.
                            this._output.add_new_line();
                            this._input.back();
                            var comment = this._input.read(block_comment_pattern);
                            // Handle ignore directive
                            var directives = directives_core.get_directives(comment);
                            if (directives && directives.ignore === "start") {
                                comment += directives_core.readIgnored(this._input);
                            }
                            this.print_string(comment);
                            // Ensures any new lines following the comment are preserved
                            this.eatWhitespace(true);
                            // Block comments are followed by a new line so they don't
                            // share a line with other properties
                            this._output.add_new_line();
                        } else if (this._ch === "/" && this._input.peek() === "/") {
                            // // single line comment
                            // Preserves the space before a comment
                            // on the same line as a rule
                            this._output.space_before_token = true;
                            this._input.back();
                            this.print_string(this._input.read(comment_pattern));
                            // Ensures any new lines following the comment are preserved
                            this.eatWhitespace(true);
                        } else if (this._ch === "$") {
                            this.preserveSingleSpace(isAfterSpace);
                            this.print_string(this._ch);
                            // strip trailing space, if present, for hash property checks
                            var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
                            if (variable.match(/[ :]$/)) {
                                // we have a variable or pseudo-class, add it and insert one space before continuing
                                variable = this.eatString(": ").replace(/\s+$/, "");
                                this.print_string(variable);
                                this._output.space_before_token = true;
                            }
                            // might be sass variable
                            if (parenLevel === 0 && variable.indexOf(":") !== -1) {
                                insidePropertyValue = true;
                                this.indent();
                            }
                        } else if (this._ch === "@") {
                            this.preserveSingleSpace(isAfterSpace);
                            // deal with less property mixins @{...}
                            if (this._input.peek() === "{") {
                                this.print_string(this._ch + this.eatString("}"));
                            } else {
                                this.print_string(this._ch);
                                // strip trailing space, if present, for hash property checks
                                var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
                                if (variableOrRule.match(/[ :]$/)) {
                                    // we have a variable or pseudo-class, add it and insert one space before continuing
                                    variableOrRule = this.eatString(": ").replace(/\s+$/, "");
                                    this.print_string(variableOrRule);
                                    this._output.space_before_token = true;
                                }
                                // might be less variable
                                if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
                                    insidePropertyValue = true;
                                    this.indent();
                                // might be a nesting at-rule
                                } else if (variableOrRule in this.NESTED_AT_RULE) {
                                    this._nestedLevel += 1;
                                    if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                                        enteringConditionalGroup = true;
                                    }
                                // might be a non-nested at-rule
                                } else if (parenLevel === 0 && !insidePropertyValue) {
                                    insideNonNestedAtRule = true;
                                }
                            }
                        } else if (this._ch === "#" && this._input.peek() === "{") {
                            this.preserveSingleSpace(isAfterSpace);
                            this.print_string(this._ch + this.eatString("}"));
                        } else if (this._ch === "{") {
                            if (insidePropertyValue) {
                                insidePropertyValue = false;
                                this.outdent();
                            }
                            // non nested at rule becomes nested
                            insideNonNestedAtRule = false;
                            // when entering conditional groups, only rulesets are allowed
                            if (enteringConditionalGroup) {
                                enteringConditionalGroup = false;
                                insideRule = this._indentLevel >= this._nestedLevel;
                            } else {
                                // otherwise, declarations are also allowed
                                insideRule = this._indentLevel >= this._nestedLevel - 1;
                            }
                            if (this._options.newline_between_rules && insideRule) {
                                if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
                                    this._output.ensure_empty_line_above("/", ",");
                                }
                            }
                            this._output.space_before_token = true;
                            // The difference in print_string and indent order is necessary to indent the '{' correctly
                            if (this._options.brace_style === "expand") {
                                this._output.add_new_line();
                                this.print_string(this._ch);
                                this.indent();
                                this._output.set_indent(this._indentLevel);
                            } else {
                                // inside mixin and first param is object
                                if (previous_ch === "(") {
                                    this._output.space_before_token = false;
                                } else if (previous_ch !== ",") {
                                    this.indent();
                                }
                                this.print_string(this._ch);
                            }
                            this.eatWhitespace(true);
                            this._output.add_new_line();
                        } else if (this._ch === "}") {
                            this.outdent();
                            this._output.add_new_line();
                            if (previous_ch === "{") {
                                this._output.trim(true);
                            }
                            if (insidePropertyValue) {
                                this.outdent();
                                insidePropertyValue = false;
                            }
                            this.print_string(this._ch);
                            insideRule = false;
                            if (this._nestedLevel) {
                                this._nestedLevel--;
                            }
                            this.eatWhitespace(true);
                            this._output.add_new_line();
                            if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
                                if (this._input.peek() !== "}") {
                                    this._output.add_new_line(true);
                                }
                            }
                            if (this._input.peek() === ")") {
                                this._output.trim(true);
                                if (this._options.brace_style === "expand") {
                                    this._output.add_new_line(true);
                                }
                            }
                        } else if (this._ch === ":") {
                            for(var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++){
                                if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
                                    insideNonSemiColonValues = true;
                                    break;
                                }
                            }
                            if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
                                // 'property: value' delimiter
                                // which could be in a conditional group query
                                this.print_string(":");
                                if (!insidePropertyValue) {
                                    insidePropertyValue = true;
                                    this._output.space_before_token = true;
                                    this.eatWhitespace(true);
                                    this.indent();
                                }
                            } else {
                                // sass/less parent reference don't use a space
                                // sass nested pseudo-class don't use a space
                                // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
                                if (this._input.lookBack(" ")) {
                                    this._output.space_before_token = true;
                                }
                                if (this._input.peek() === ":") {
                                    // pseudo-element
                                    this._ch = this._input.next();
                                    this.print_string("::");
                                } else {
                                    // pseudo-class
                                    this.print_string(":");
                                }
                            }
                        } else if (this._ch === '"' || this._ch === "'") {
                            var preserveQuoteSpace = previous_ch === '"' || previous_ch === "'";
                            this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
                            this.print_string(this._ch + this.eatString(this._ch));
                            this.eatWhitespace(true);
                        } else if (this._ch === ";") {
                            insideNonSemiColonValues = false;
                            if (parenLevel === 0) {
                                if (insidePropertyValue) {
                                    this.outdent();
                                    insidePropertyValue = false;
                                }
                                insideNonNestedAtRule = false;
                                this.print_string(this._ch);
                                this.eatWhitespace(true);
                                // This maintains single line comments on the same
                                // line. Block comments are also affected, but
                                // a new line is always output before one inside
                                // that section
                                if (this._input.peek() !== "/") {
                                    this._output.add_new_line();
                                }
                            } else {
                                this.print_string(this._ch);
                                this.eatWhitespace(true);
                                this._output.space_before_token = true;
                            }
                        } else if (this._ch === "(") {
                            if (this._input.lookBack("url")) {
                                this.print_string(this._ch);
                                this.eatWhitespace();
                                parenLevel++;
                                this.indent();
                                this._ch = this._input.next();
                                if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
                                    this._input.back();
                                } else if (this._ch) {
                                    this.print_string(this._ch + this.eatString(")"));
                                    if (parenLevel) {
                                        parenLevel--;
                                        this.outdent();
                                    }
                                }
                            } else {
                                var space_needed = false;
                                if (this._input.lookBack("with")) {
                                    // look back is not an accurate solution, we need tokens to confirm without whitespaces
                                    space_needed = true;
                                }
                                this.preserveSingleSpace(isAfterSpace || space_needed);
                                this.print_string(this._ch);
                                // handle scss/sass map
                                if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
                                    this._output.add_new_line();
                                    insideScssMap = true;
                                } else {
                                    this.eatWhitespace();
                                    parenLevel++;
                                    this.indent();
                                }
                            }
                        } else if (this._ch === ")") {
                            if (parenLevel) {
                                parenLevel--;
                                this.outdent();
                            }
                            if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
                                insideScssMap = false;
                                this.outdent();
                                this._output.add_new_line();
                            }
                            this.print_string(this._ch);
                        } else if (this._ch === ",") {
                            this.print_string(this._ch);
                            this.eatWhitespace(true);
                            if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
                                this._output.add_new_line();
                            } else {
                                this._output.space_before_token = true;
                            }
                        } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
                            //handle combinator spacing
                            if (this._options.space_around_combinator) {
                                this._output.space_before_token = true;
                                this.print_string(this._ch);
                                this._output.space_before_token = true;
                            } else {
                                this.print_string(this._ch);
                                this.eatWhitespace();
                                // squash extra whitespace
                                if (this._ch && whitespaceChar.test(this._ch)) {
                                    this._ch = "";
                                }
                            }
                        } else if (this._ch === "]") {
                            this.print_string(this._ch);
                        } else if (this._ch === "[") {
                            this.preserveSingleSpace(isAfterSpace);
                            this.print_string(this._ch);
                        } else if (this._ch === "=") {
                            this.eatWhitespace();
                            this.print_string("=");
                            if (whitespaceChar.test(this._ch)) {
                                this._ch = "";
                            }
                        } else if (this._ch === "!" && !this._input.lookBack("\\")) {
                            this._output.space_before_token = true;
                            this.print_string(this._ch);
                        } else {
                            var preserveAfterSpace = previous_ch === '"' || previous_ch === "'";
                            this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
                            this.print_string(this._ch);
                            if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
                                this._output.add_new_line();
                            }
                        }
                    }
                    var sweetCode = this._output.get_code(eol);
                    return sweetCode;
                };
                module.exports.Beautifier = Beautifier;
            /***/ },
            /* 17 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71255__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var BaseOptions = __nested_webpack_require_71255__(6).Options;
                function Options(options) {
                    BaseOptions.call(this, options, "css");
                    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
                    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
                    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
                    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
                    var brace_style_split = this._get_selection_list("brace_style", [
                        "collapse",
                        "expand",
                        "end-expand",
                        "none",
                        "preserve-inline"
                    ]);
                    this.brace_style = "collapse";
                    for(var bs = 0; bs < brace_style_split.length; bs++){
                        if (brace_style_split[bs] !== "expand") {
                            // default to collapse, as only collapse|expand is implemented for now
                            this.brace_style = "collapse";
                        } else {
                            this.brace_style = brace_style_split[bs];
                        }
                    }
                }
                Options.prototype = new BaseOptions();
                module.exports.Options = Options;
            /***/ }
        ];
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_74263__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_74263__);
            /******/ /******/ // Return the exports of the module
            /******/ return module.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module is referenced by other modules so it can't be inlined
        /******/ var __nested_webpack_exports__ = __nested_webpack_require_74263__(15);
        /******/ legacy_beautify_css = __nested_webpack_exports__;
    /******/ /******/ })();
    var css_beautify = legacy_beautify_css;
    /* Footer */ if (true) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return {
                css_beautify: css_beautify
            };
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})();


/***/ }),

/***/ 36491:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>
    https://beautifier.io/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)  — indent <head> and <body> sections,
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    inline (defaults to inline tags) - list of tags to be considered inline tags
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to ["pre", "textarea"] tags) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/ (function() {
    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_html;
    /******/ (function() {
        /******/ "use strict";
        /******/ var __webpack_modules__ = [
            ,
            ,
            /* 2 */ /***/ function(module) {
                /*jshint node:true */ /*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function OutputLine(parent) {
                    this.__parent = parent;
                    this.__character_count = 0;
                    // use indent_count as a marker for this.__lines that have preserved indentation
                    this.__indent_count = -1;
                    this.__alignment_count = 0;
                    this.__wrap_point_index = 0;
                    this.__wrap_point_character_count = 0;
                    this.__wrap_point_indent_count = -1;
                    this.__wrap_point_alignment_count = 0;
                    this.__items = [];
                }
                OutputLine.prototype.clone_empty = function() {
                    var line = new OutputLine(this.__parent);
                    line.set_indent(this.__indent_count, this.__alignment_count);
                    return line;
                };
                OutputLine.prototype.item = function(index) {
                    if (index < 0) {
                        return this.__items[this.__items.length + index];
                    } else {
                        return this.__items[index];
                    }
                };
                OutputLine.prototype.has_match = function(pattern) {
                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){
                        if (this.__items[lastCheckedOutput].match(pattern)) {
                            return true;
                        }
                    }
                    return false;
                };
                OutputLine.prototype.set_indent = function(indent, alignment) {
                    if (this.is_empty()) {
                        this.__indent_count = indent || 0;
                        this.__alignment_count = alignment || 0;
                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
                    }
                };
                OutputLine.prototype._set_wrap_point = function() {
                    if (this.__parent.wrap_line_length) {
                        this.__wrap_point_index = this.__items.length;
                        this.__wrap_point_character_count = this.__character_count;
                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
                    }
                };
                OutputLine.prototype._should_wrap = function() {
                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
                };
                OutputLine.prototype._allow_wrap = function() {
                    if (this._should_wrap()) {
                        this.__parent.add_new_line();
                        var next = this.__parent.current_line;
                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
                        next.__items = this.__items.slice(this.__wrap_point_index);
                        this.__items = this.__items.slice(0, this.__wrap_point_index);
                        next.__character_count += this.__character_count - this.__wrap_point_character_count;
                        this.__character_count = this.__wrap_point_character_count;
                        if (next.__items[0] === " ") {
                            next.__items.splice(0, 1);
                            next.__character_count -= 1;
                        }
                        return true;
                    }
                    return false;
                };
                OutputLine.prototype.is_empty = function() {
                    return this.__items.length === 0;
                };
                OutputLine.prototype.last = function() {
                    if (!this.is_empty()) {
                        return this.__items[this.__items.length - 1];
                    } else {
                        return null;
                    }
                };
                OutputLine.prototype.push = function(item) {
                    this.__items.push(item);
                    var last_newline_index = item.lastIndexOf("\n");
                    if (last_newline_index !== -1) {
                        this.__character_count = item.length - last_newline_index;
                    } else {
                        this.__character_count += item.length;
                    }
                };
                OutputLine.prototype.pop = function() {
                    var item = null;
                    if (!this.is_empty()) {
                        item = this.__items.pop();
                        this.__character_count -= item.length;
                    }
                    return item;
                };
                OutputLine.prototype._remove_indent = function() {
                    if (this.__indent_count > 0) {
                        this.__indent_count -= 1;
                        this.__character_count -= this.__parent.indent_size;
                    }
                };
                OutputLine.prototype._remove_wrap_indent = function() {
                    if (this.__wrap_point_indent_count > 0) {
                        this.__wrap_point_indent_count -= 1;
                    }
                };
                OutputLine.prototype.trim = function() {
                    while(this.last() === " "){
                        this.__items.pop();
                        this.__character_count -= 1;
                    }
                };
                OutputLine.prototype.toString = function() {
                    var result = "";
                    if (this.is_empty()) {
                        if (this.__parent.indent_empty_lines) {
                            result = this.__parent.get_indent_string(this.__indent_count);
                        }
                    } else {
                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
                        result += this.__items.join("");
                    }
                    return result;
                };
                function IndentStringCache(options, baseIndentString) {
                    this.__cache = [
                        ""
                    ];
                    this.__indent_size = options.indent_size;
                    this.__indent_string = options.indent_char;
                    if (!options.indent_with_tabs) {
                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
                    }
                    // Set to null to continue support for auto detection of base indent
                    baseIndentString = baseIndentString || "";
                    if (options.indent_level > 0) {
                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
                    }
                    this.__base_string = baseIndentString;
                    this.__base_string_length = baseIndentString.length;
                }
                IndentStringCache.prototype.get_indent_size = function(indent, column) {
                    var result = this.__base_string_length;
                    column = column || 0;
                    if (indent < 0) {
                        result = 0;
                    }
                    result += indent * this.__indent_size;
                    result += column;
                    return result;
                };
                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
                    var result = this.__base_string;
                    column = column || 0;
                    if (indent_level < 0) {
                        indent_level = 0;
                        result = "";
                    }
                    column += indent_level * this.__indent_size;
                    this.__ensure_cache(column);
                    result += this.__cache[column];
                    return result;
                };
                IndentStringCache.prototype.__ensure_cache = function(column) {
                    while(column >= this.__cache.length){
                        this.__add_column();
                    }
                };
                IndentStringCache.prototype.__add_column = function() {
                    var column = this.__cache.length;
                    var indent = 0;
                    var result = "";
                    if (this.__indent_size && column >= this.__indent_size) {
                        indent = Math.floor(column / this.__indent_size);
                        column -= indent * this.__indent_size;
                        result = new Array(indent + 1).join(this.__indent_string);
                    }
                    if (column) {
                        result += new Array(column + 1).join(" ");
                    }
                    this.__cache.push(result);
                };
                function Output(options, baseIndentString) {
                    this.__indent_cache = new IndentStringCache(options, baseIndentString);
                    this.raw = false;
                    this._end_with_newline = options.end_with_newline;
                    this.indent_size = options.indent_size;
                    this.wrap_line_length = options.wrap_line_length;
                    this.indent_empty_lines = options.indent_empty_lines;
                    this.__lines = [];
                    this.previous_line = null;
                    this.current_line = null;
                    this.next_line = new OutputLine(this);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                    // initialize
                    this.__add_outputline();
                }
                Output.prototype.__add_outputline = function() {
                    this.previous_line = this.current_line;
                    this.current_line = this.next_line.clone_empty();
                    this.__lines.push(this.current_line);
                };
                Output.prototype.get_line_number = function() {
                    return this.__lines.length;
                };
                Output.prototype.get_indent_string = function(indent, column) {
                    return this.__indent_cache.get_indent_string(indent, column);
                };
                Output.prototype.get_indent_size = function(indent, column) {
                    return this.__indent_cache.get_indent_size(indent, column);
                };
                Output.prototype.is_empty = function() {
                    return !this.previous_line && this.current_line.is_empty();
                };
                Output.prototype.add_new_line = function(force_newline) {
                    // never newline at the start of file
                    // otherwise, newline only if we didn't just add one or we're forced
                    if (this.is_empty() || !force_newline && this.just_added_newline()) {
                        return false;
                    }
                    // if raw output is enabled, don't print additional newlines,
                    // but still return True as though you had
                    if (!this.raw) {
                        this.__add_outputline();
                    }
                    return true;
                };
                Output.prototype.get_code = function(eol) {
                    this.trim(true);
                    // handle some edge cases where the last tokens
                    // has text that ends with newline(s)
                    var last_item = this.current_line.pop();
                    if (last_item) {
                        if (last_item[last_item.length - 1] === "\n") {
                            last_item = last_item.replace(/\n+$/g, "");
                        }
                        this.current_line.push(last_item);
                    }
                    if (this._end_with_newline) {
                        this.__add_outputline();
                    }
                    var sweet_code = this.__lines.join("\n");
                    if (eol !== "\n") {
                        sweet_code = sweet_code.replace(/[\n]/g, eol);
                    }
                    return sweet_code;
                };
                Output.prototype.set_wrap_point = function() {
                    this.current_line._set_wrap_point();
                };
                Output.prototype.set_indent = function(indent, alignment) {
                    indent = indent || 0;
                    alignment = alignment || 0;
                    // Next line stores alignment values
                    this.next_line.set_indent(indent, alignment);
                    // Never indent your first output indent at the start of the file
                    if (this.__lines.length > 1) {
                        this.current_line.set_indent(indent, alignment);
                        return true;
                    }
                    this.current_line.set_indent();
                    return false;
                };
                Output.prototype.add_raw_token = function(token) {
                    for(var x = 0; x < token.newlines; x++){
                        this.__add_outputline();
                    }
                    this.current_line.set_indent(-1);
                    this.current_line.push(token.whitespace_before);
                    this.current_line.push(token.text);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                };
                Output.prototype.add_token = function(printable_token) {
                    this.__add_space_before_token();
                    this.current_line.push(printable_token);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = this.current_line._allow_wrap();
                };
                Output.prototype.__add_space_before_token = function() {
                    if (this.space_before_token && !this.just_added_newline()) {
                        if (!this.non_breaking_space) {
                            this.set_wrap_point();
                        }
                        this.current_line.push(" ");
                    }
                };
                Output.prototype.remove_indent = function(index) {
                    var output_length = this.__lines.length;
                    while(index < output_length){
                        this.__lines[index]._remove_indent();
                        index++;
                    }
                    this.current_line._remove_wrap_indent();
                };
                Output.prototype.trim = function(eat_newlines) {
                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
                    this.current_line.trim();
                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){
                        this.__lines.pop();
                        this.current_line = this.__lines[this.__lines.length - 1];
                        this.current_line.trim();
                    }
                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
                };
                Output.prototype.just_added_newline = function() {
                    return this.current_line.is_empty();
                };
                Output.prototype.just_added_blankline = function() {
                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
                };
                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
                    var index = this.__lines.length - 2;
                    while(index >= 0){
                        var potentialEmptyLine = this.__lines[index];
                        if (potentialEmptyLine.is_empty()) {
                            break;
                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
                            this.__lines.splice(index + 1, 0, new OutputLine(this));
                            this.previous_line = this.__lines[this.__lines.length - 2];
                            break;
                        }
                        index--;
                    }
                };
                module.exports.Output = Output;
            /***/ },
            /* 3 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Token(type, text, newlines, whitespace_before) {
                    this.type = type;
                    this.text = text;
                    // comments_before are
                    // comments that have a new line before them
                    // and may or may not have a newline after
                    // this is a set of comments before
                    this.comments_before = null; /* inline comment*/ 
                    // this.comments_after =  new TokenStream(); // no new line before and newline after
                    this.newlines = newlines || 0;
                    this.whitespace_before = whitespace_before || "";
                    this.parent = null;
                    this.next = null;
                    this.previous = null;
                    this.opened = null;
                    this.closed = null;
                    this.directives = null;
                }
                module.exports.Token = Token;
            /***/ },
            ,
            ,
            /* 6 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Options(options, merge_child_field) {
                    this.raw_options = _mergeOpts(options, merge_child_field);
                    // Support passing the source text back with no change
                    this.disabled = this._get_boolean("disabled");
                    this.eol = this._get_characters("eol", "auto");
                    this.end_with_newline = this._get_boolean("end_with_newline");
                    this.indent_size = this._get_number("indent_size", 4);
                    this.indent_char = this._get_characters("indent_char", " ");
                    this.indent_level = this._get_number("indent_level");
                    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
                    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
                    if (!this.preserve_newlines) {
                        this.max_preserve_newlines = 0;
                    }
                    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
                    if (this.indent_with_tabs) {
                        this.indent_char = "	";
                        // indent_size behavior changed after 1.8.6
                        // It used to be that indent_size would be
                        // set to 1 for indent_with_tabs. That is no longer needed and
                        // actually doesn't make sense - why not use spaces? Further,
                        // that might produce unexpected behavior - tabs being used
                        // for single-column alignment. So, when indent_with_tabs is true
                        // and indent_size is 1, reset indent_size to 4.
                        if (this.indent_size === 1) {
                            this.indent_size = 4;
                        }
                    }
                    // Backwards compat with 1.3.x
                    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
                    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']
                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).
                    // other values ignored
                    this.templating = this._get_selection_list("templating", [
                        "auto",
                        "none",
                        "angular",
                        "django",
                        "erb",
                        "handlebars",
                        "php",
                        "smarty"
                    ], [
                        "auto"
                    ]);
                }
                Options.prototype._get_array = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || [];
                    if (typeof option_value === "object") {
                        if (option_value !== null && typeof option_value.concat === "function") {
                            result = option_value.concat();
                        }
                    } else if (typeof option_value === "string") {
                        result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
                    }
                    return result;
                };
                Options.prototype._get_boolean = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = option_value === undefined ? !!default_value : !!option_value;
                    return result;
                };
                Options.prototype._get_characters = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || "";
                    if (typeof option_value === "string") {
                        result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
                    }
                    return result;
                };
                Options.prototype._get_number = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    default_value = parseInt(default_value, 10);
                    if (isNaN(default_value)) {
                        default_value = 0;
                    }
                    var result = parseInt(option_value, 10);
                    if (isNaN(result)) {
                        result = default_value;
                    }
                    return result;
                };
                Options.prototype._get_selection = function(name, selection_list, default_value) {
                    var result = this._get_selection_list(name, selection_list, default_value);
                    if (result.length !== 1) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result[0];
                };
                Options.prototype._get_selection_list = function(name, selection_list, default_value) {
                    if (!selection_list || selection_list.length === 0) {
                        throw new Error("Selection list cannot be empty.");
                    }
                    default_value = default_value || [
                        selection_list[0]
                    ];
                    if (!this._is_valid_selection(default_value, selection_list)) {
                        throw new Error("Invalid Default Value!");
                    }
                    var result = this._get_array(name, default_value);
                    if (!this._is_valid_selection(result, selection_list)) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result;
                };
                Options.prototype._is_valid_selection = function(result, selection_list) {
                    return result.length && selection_list.length && !result.some(function(item) {
                        return selection_list.indexOf(item) === -1;
                    });
                };
                // merges child options up with the parent options object
                // Example: obj = {a: 1, b: {a: 2}}
                //          mergeOpts(obj, 'b')
                //
                //          Returns: {a: 2}
                function _mergeOpts(allOptions, childFieldName) {
                    var finalOpts = {};
                    allOptions = _normalizeOpts(allOptions);
                    var name;
                    for(name in allOptions){
                        if (name !== childFieldName) {
                            finalOpts[name] = allOptions[name];
                        }
                    }
                    //merge in the per type settings for the childFieldName
                    if (childFieldName && allOptions[childFieldName]) {
                        for(name in allOptions[childFieldName]){
                            finalOpts[name] = allOptions[childFieldName][name];
                        }
                    }
                    return finalOpts;
                }
                function _normalizeOpts(options) {
                    var convertedOpts = {};
                    var key;
                    for(key in options){
                        var newKey = key.replace(/-/g, "_");
                        convertedOpts[newKey] = options[key];
                    }
                    return convertedOpts;
                }
                module.exports.Options = Options;
                module.exports.normalizeOpts = _normalizeOpts;
                module.exports.mergeOpts = _mergeOpts;
            /***/ },
            ,
            /* 8 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
                function InputScanner(input_string) {
                    this.__input = input_string || "";
                    this.__input_length = this.__input.length;
                    this.__position = 0;
                }
                InputScanner.prototype.restart = function() {
                    this.__position = 0;
                };
                InputScanner.prototype.back = function() {
                    if (this.__position > 0) {
                        this.__position -= 1;
                    }
                };
                InputScanner.prototype.hasNext = function() {
                    return this.__position < this.__input_length;
                };
                InputScanner.prototype.next = function() {
                    var val = null;
                    if (this.hasNext()) {
                        val = this.__input.charAt(this.__position);
                        this.__position += 1;
                    }
                    return val;
                };
                InputScanner.prototype.peek = function(index) {
                    var val = null;
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        val = this.__input.charAt(index);
                    }
                    return val;
                };
                // This is a JavaScript only helper function (not in python)
                // Javascript doesn't have a match method
                // and not all implementation support "sticky" flag.
                // If they do not support sticky then both this.match() and this.test() method
                // must get the match and check the index of the match.
                // If sticky is supported and set, this method will use it.
                // Otherwise it will check that global is set, and fall back to the slower method.
                InputScanner.prototype.__match = function(pattern, index) {
                    pattern.lastIndex = index;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
                        if (pattern_match.index !== index) {
                            pattern_match = null;
                        }
                    }
                    return pattern_match;
                };
                InputScanner.prototype.test = function(pattern, index) {
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        return !!this.__match(pattern, index);
                    } else {
                        return false;
                    }
                };
                InputScanner.prototype.testChar = function(pattern, index) {
                    // test one character regex match
                    var val = this.peek(index);
                    pattern.lastIndex = 0;
                    return val !== null && pattern.test(val);
                };
                InputScanner.prototype.match = function(pattern) {
                    var pattern_match = this.__match(pattern, this.__position);
                    if (pattern_match) {
                        this.__position += pattern_match[0].length;
                    } else {
                        pattern_match = null;
                    }
                    return pattern_match;
                };
                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
                    var val = "";
                    var match;
                    if (starting_pattern) {
                        match = this.match(starting_pattern);
                        if (match) {
                            val += match[0];
                        }
                    }
                    if (until_pattern && (match || !starting_pattern)) {
                        val += this.readUntil(until_pattern, until_after);
                    }
                    return val;
                };
                InputScanner.prototype.readUntil = function(pattern, until_after) {
                    var val = "";
                    var match_index = this.__position;
                    pattern.lastIndex = this.__position;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match) {
                        match_index = pattern_match.index;
                        if (until_after) {
                            match_index += pattern_match[0].length;
                        }
                    } else {
                        match_index = this.__input_length;
                    }
                    val = this.__input.substring(this.__position, match_index);
                    this.__position = match_index;
                    return val;
                };
                InputScanner.prototype.readUntilAfter = function(pattern) {
                    return this.readUntil(pattern, true);
                };
                InputScanner.prototype.get_regexp = function(pattern, match_from) {
                    var result = null;
                    var flags = "g";
                    if (match_from && regexp_has_sticky) {
                        flags = "y";
                    }
                    // strings are converted to regexp
                    if (typeof pattern === "string" && pattern !== "") {
                        // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
                        result = new RegExp(pattern, flags);
                    } else if (pattern) {
                        result = new RegExp(pattern.source, flags);
                    }
                    return result;
                };
                InputScanner.prototype.get_literal_regexp = function(literal_string) {
                    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
                };
                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {
                    var start = this.__position;
                    var val = this.readUntilAfter(pattern);
                    this.__position = start;
                    return val;
                };
                InputScanner.prototype.lookBack = function(testVal) {
                    var start = this.__position - 1;
                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
                };
                module.exports.InputScanner = InputScanner;
            /***/ },
            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41688__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var InputScanner = __nested_webpack_require_41688__(8).InputScanner;
                var Token = __nested_webpack_require_41688__(3).Token;
                var TokenStream = __nested_webpack_require_41688__(10).TokenStream;
                var WhitespacePattern = __nested_webpack_require_41688__(11).WhitespacePattern;
                var TOKEN = {
                    START: "TK_START",
                    RAW: "TK_RAW",
                    EOF: "TK_EOF"
                };
                var Tokenizer = function(input_string, options) {
                    this._input = new InputScanner(input_string);
                    this._options = options || {};
                    this.__tokens = null;
                    this._patterns = {};
                    this._patterns.whitespace = new WhitespacePattern(this._input);
                };
                Tokenizer.prototype.tokenize = function() {
                    this._input.restart();
                    this.__tokens = new TokenStream();
                    this._reset();
                    var current;
                    var previous = new Token(TOKEN.START, "");
                    var open_token = null;
                    var open_stack = [];
                    var comments = new TokenStream();
                    while(previous.type !== TOKEN.EOF){
                        current = this._get_next_token(previous, open_token);
                        while(this._is_comment(current)){
                            comments.add(current);
                            current = this._get_next_token(previous, open_token);
                        }
                        if (!comments.isEmpty()) {
                            current.comments_before = comments;
                            comments = new TokenStream();
                        }
                        current.parent = open_token;
                        if (this._is_opening(current)) {
                            open_stack.push(open_token);
                            open_token = current;
                        } else if (open_token && this._is_closing(current, open_token)) {
                            current.opened = open_token;
                            open_token.closed = current;
                            open_token = open_stack.pop();
                            current.parent = open_token;
                        }
                        current.previous = previous;
                        previous.next = current;
                        this.__tokens.add(current);
                        previous = current;
                    }
                    return this.__tokens;
                };
                Tokenizer.prototype._is_first_token = function() {
                    return this.__tokens.isEmpty();
                };
                Tokenizer.prototype._reset = function() {};
                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
                    this._readWhitespace();
                    var resulting_string = this._input.read(/.+/g);
                    if (resulting_string) {
                        return this._create_token(TOKEN.RAW, resulting_string);
                    } else {
                        return this._create_token(TOKEN.EOF, "");
                    }
                };
                Tokenizer.prototype._is_comment = function(current_token) {
                    return false;
                };
                Tokenizer.prototype._is_opening = function(current_token) {
                    return false;
                };
                Tokenizer.prototype._is_closing = function(current_token, open_token) {
                    return false;
                };
                Tokenizer.prototype._create_token = function(type, text) {
                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
                    return token;
                };
                Tokenizer.prototype._readWhitespace = function() {
                    return this._patterns.whitespace.read();
                };
                module.exports.Tokenizer = Tokenizer;
                module.exports.TOKEN = TOKEN;
            /***/ },
            /* 10 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function TokenStream(parent_token) {
                    // private
                    this.__tokens = [];
                    this.__tokens_length = this.__tokens.length;
                    this.__position = 0;
                    this.__parent_token = parent_token;
                }
                TokenStream.prototype.restart = function() {
                    this.__position = 0;
                };
                TokenStream.prototype.isEmpty = function() {
                    return this.__tokens_length === 0;
                };
                TokenStream.prototype.hasNext = function() {
                    return this.__position < this.__tokens_length;
                };
                TokenStream.prototype.next = function() {
                    var val = null;
                    if (this.hasNext()) {
                        val = this.__tokens[this.__position];
                        this.__position += 1;
                    }
                    return val;
                };
                TokenStream.prototype.peek = function(index) {
                    var val = null;
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__tokens_length) {
                        val = this.__tokens[index];
                    }
                    return val;
                };
                TokenStream.prototype.add = function(token) {
                    if (this.__parent_token) {
                        token.parent = this.__parent_token;
                    }
                    this.__tokens.push(token);
                    this.__tokens_length += 1;
                };
                module.exports.TokenStream = TokenStream;
            /***/ },
            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_50222__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Pattern = __nested_webpack_require_50222__(12).Pattern;
                function WhitespacePattern(input_scanner, parent) {
                    Pattern.call(this, input_scanner, parent);
                    if (parent) {
                        this._line_regexp = this._input.get_regexp(parent._line_regexp);
                    } else {
                        this.__set_whitespace_patterns("", "");
                    }
                    this.newline_count = 0;
                    this.whitespace_before_token = "";
                }
                WhitespacePattern.prototype = new Pattern();
                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
                    whitespace_chars += "\\t ";
                    newline_chars += "\\n\\r";
                    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
                    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
                };
                WhitespacePattern.prototype.read = function() {
                    this.newline_count = 0;
                    this.whitespace_before_token = "";
                    var resulting_string = this._input.read(this._match_pattern);
                    if (resulting_string === " ") {
                        this.whitespace_before_token = " ";
                    } else if (resulting_string) {
                        var matches = this.__split(this._newline_regexp, resulting_string);
                        this.newline_count = matches.length - 1;
                        this.whitespace_before_token = matches[this.newline_count];
                    }
                    return resulting_string;
                };
                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
                    var result = this._create();
                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
                    result._update();
                    return result;
                };
                WhitespacePattern.prototype._create = function() {
                    return new WhitespacePattern(this._input, this);
                };
                WhitespacePattern.prototype.__split = function(regexp, input_string) {
                    regexp.lastIndex = 0;
                    var start_index = 0;
                    var result = [];
                    var next_match = regexp.exec(input_string);
                    while(next_match){
                        result.push(input_string.substring(start_index, next_match.index));
                        start_index = next_match.index + next_match[0].length;
                        next_match = regexp.exec(input_string);
                    }
                    if (start_index < input_string.length) {
                        result.push(input_string.substring(start_index, input_string.length));
                    } else {
                        result.push("");
                    }
                    return result;
                };
                module.exports.WhitespacePattern = WhitespacePattern;
            /***/ },
            /* 12 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Pattern(input_scanner, parent) {
                    this._input = input_scanner;
                    this._starting_pattern = null;
                    this._match_pattern = null;
                    this._until_pattern = null;
                    this._until_after = false;
                    if (parent) {
                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
                        this._until_pattern = this._input.get_regexp(parent._until_pattern);
                        this._until_after = parent._until_after;
                    }
                }
                Pattern.prototype.read = function() {
                    var result = this._input.read(this._starting_pattern);
                    if (!this._starting_pattern || result) {
                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
                    }
                    return result;
                };
                Pattern.prototype.read_match = function() {
                    return this._input.match(this._match_pattern);
                };
                Pattern.prototype.until_after = function(pattern) {
                    var result = this._create();
                    result._until_after = true;
                    result._until_pattern = this._input.get_regexp(pattern);
                    result._update();
                    return result;
                };
                Pattern.prototype.until = function(pattern) {
                    var result = this._create();
                    result._until_after = false;
                    result._until_pattern = this._input.get_regexp(pattern);
                    result._update();
                    return result;
                };
                Pattern.prototype.starting_with = function(pattern) {
                    var result = this._create();
                    result._starting_pattern = this._input.get_regexp(pattern, true);
                    result._update();
                    return result;
                };
                Pattern.prototype.matching = function(pattern) {
                    var result = this._create();
                    result._match_pattern = this._input.get_regexp(pattern, true);
                    result._update();
                    return result;
                };
                Pattern.prototype._create = function() {
                    return new Pattern(this._input, this);
                };
                Pattern.prototype._update = function() {};
                module.exports.Pattern = Pattern;
            /***/ },
            /* 13 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Directives(start_block_pattern, end_block_pattern) {
                    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
                    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
                    this.__directive_pattern = / (\w+)[:](\w+)/g;
                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
                }
                Directives.prototype.get_directives = function(text) {
                    if (!text.match(this.__directives_block_pattern)) {
                        return null;
                    }
                    var directives = {};
                    this.__directive_pattern.lastIndex = 0;
                    var directive_match = this.__directive_pattern.exec(text);
                    while(directive_match){
                        directives[directive_match[1]] = directive_match[2];
                        directive_match = this.__directive_pattern.exec(text);
                    }
                    return directives;
                };
                Directives.prototype.readIgnored = function(input) {
                    return input.readUntilAfter(this.__directives_end_ignore_pattern);
                };
                module.exports.Directives = Directives;
            /***/ },
            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_61614__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Pattern = __nested_webpack_require_61614__(12).Pattern;
                var template_names = {
                    django: false,
                    erb: false,
                    handlebars: false,
                    php: false,
                    smarty: false,
                    angular: false
                };
                // This lets templates appear anywhere we would do a readUntil
                // The cost is higher but it is pay to play.
                function TemplatablePattern(input_scanner, parent) {
                    Pattern.call(this, input_scanner, parent);
                    this.__template_pattern = null;
                    this._disabled = Object.assign({}, template_names);
                    this._excluded = Object.assign({}, template_names);
                    if (parent) {
                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
                        this._excluded = Object.assign(this._excluded, parent._excluded);
                        this._disabled = Object.assign(this._disabled, parent._disabled);
                    }
                    var pattern = new Pattern(input_scanner);
                    this.__patterns = {
                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),
                        php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
                        // django coflicts with handlebars a bit.
                        django: pattern.starting_with(/{%/).until_after(/%}/),
                        django_value: pattern.starting_with(/{{/).until_after(/}}/),
                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),
                        smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
                        smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
                    };
                }
                TemplatablePattern.prototype = new Pattern();
                TemplatablePattern.prototype._create = function() {
                    return new TemplatablePattern(this._input, this);
                };
                TemplatablePattern.prototype._update = function() {
                    this.__set_templated_pattern();
                };
                TemplatablePattern.prototype.disable = function(language) {
                    var result = this._create();
                    result._disabled[language] = true;
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.read_options = function(options) {
                    var result = this._create();
                    for(var language in template_names){
                        result._disabled[language] = options.templating.indexOf(language) === -1;
                    }
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.exclude = function(language) {
                    var result = this._create();
                    result._excluded[language] = true;
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.read = function() {
                    var result = "";
                    if (this._match_pattern) {
                        result = this._input.read(this._starting_pattern);
                    } else {
                        result = this._input.read(this._starting_pattern, this.__template_pattern);
                    }
                    var next = this._read_template();
                    while(next){
                        if (this._match_pattern) {
                            next += this._input.read(this._match_pattern);
                        } else {
                            next += this._input.readUntil(this.__template_pattern);
                        }
                        result += next;
                        next = this._read_template();
                    }
                    if (this._until_after) {
                        result += this._input.readUntilAfter(this._until_pattern);
                    }
                    return result;
                };
                TemplatablePattern.prototype.__set_templated_pattern = function() {
                    var items = [];
                    if (!this._disabled.php) {
                        items.push(this.__patterns.php._starting_pattern.source);
                    }
                    if (!this._disabled.handlebars) {
                        items.push(this.__patterns.handlebars._starting_pattern.source);
                    }
                    if (!this._disabled.erb) {
                        items.push(this.__patterns.erb._starting_pattern.source);
                    }
                    if (!this._disabled.django) {
                        items.push(this.__patterns.django._starting_pattern.source);
                        // The starting pattern for django is more complex because it has different
                        // patterns for value, comment, and other sections
                        items.push(this.__patterns.django_value._starting_pattern.source);
                        items.push(this.__patterns.django_comment._starting_pattern.source);
                    }
                    if (!this._disabled.smarty) {
                        items.push(this.__patterns.smarty._starting_pattern.source);
                    }
                    if (this._until_pattern) {
                        items.push(this._until_pattern.source);
                    }
                    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
                };
                TemplatablePattern.prototype._read_template = function() {
                    var resulting_string = "";
                    var c = this._input.peek();
                    if (c === "<") {
                        var peek1 = this._input.peek(1);
                        //if we're in a comment, do something special
                        // We treat all comments as literals, even more than preformatted tags
                        // we just look for the appropriate close tag
                        if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
                            resulting_string = resulting_string || this.__patterns.php.read();
                        }
                        if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
                            resulting_string = resulting_string || this.__patterns.erb.read();
                        }
                    } else if (c === "{") {
                        if (!this._disabled.handlebars && !this._excluded.handlebars) {
                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
                            resulting_string = resulting_string || this.__patterns.handlebars.read();
                        }
                        if (!this._disabled.django) {
                            // django coflicts with handlebars a bit.
                            if (!this._excluded.django && !this._excluded.handlebars) {
                                resulting_string = resulting_string || this.__patterns.django_value.read();
                            }
                            if (!this._excluded.django) {
                                resulting_string = resulting_string || this.__patterns.django_comment.read();
                                resulting_string = resulting_string || this.__patterns.django.read();
                            }
                        }
                        if (!this._disabled.smarty) {
                            // smarty cannot be enabled with django or handlebars enabled
                            if (this._disabled.django && this._disabled.handlebars) {
                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();
                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();
                                resulting_string = resulting_string || this.__patterns.smarty.read();
                            }
                        }
                    }
                    return resulting_string;
                };
                module.exports.TemplatablePattern = TemplatablePattern;
            /***/ },
            ,
            ,
            ,
            /* 18 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71997__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Beautifier = __nested_webpack_require_71997__(19).Beautifier, Options = __nested_webpack_require_71997__(20).Options;
                function style_html(html_source, options, js_beautify, css_beautify) {
                    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
                    return beautifier.beautify();
                }
                module.exports = style_html;
                module.exports.defaultOptions = function() {
                    return new Options();
                };
            /***/ },
            /* 19 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_73833__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Options = __nested_webpack_require_73833__(20).Options;
                var Output = __nested_webpack_require_73833__(2).Output;
                var Tokenizer = __nested_webpack_require_73833__(21).Tokenizer;
                var TOKEN = __nested_webpack_require_73833__(21).TOKEN;
                var lineBreak = /\r\n|[\r\n]/;
                var allLineBreaks = /\r\n|[\r\n]/g;
                var Printer = function(options, base_indent_string) {
                    this.indent_level = 0;
                    this.alignment_size = 0;
                    this.max_preserve_newlines = options.max_preserve_newlines;
                    this.preserve_newlines = options.preserve_newlines;
                    this._output = new Output(options, base_indent_string);
                };
                Printer.prototype.current_line_has_match = function(pattern) {
                    return this._output.current_line.has_match(pattern);
                };
                Printer.prototype.set_space_before_token = function(value, non_breaking) {
                    this._output.space_before_token = value;
                    this._output.non_breaking_space = non_breaking;
                };
                Printer.prototype.set_wrap_point = function() {
                    this._output.set_indent(this.indent_level, this.alignment_size);
                    this._output.set_wrap_point();
                };
                Printer.prototype.add_raw_token = function(token) {
                    this._output.add_raw_token(token);
                };
                Printer.prototype.print_preserved_newlines = function(raw_token) {
                    var newlines = 0;
                    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
                        newlines = raw_token.newlines ? 1 : 0;
                    }
                    if (this.preserve_newlines) {
                        newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
                    }
                    for(var n = 0; n < newlines; n++){
                        this.print_newline(n > 0);
                    }
                    return newlines !== 0;
                };
                Printer.prototype.traverse_whitespace = function(raw_token) {
                    if (raw_token.whitespace_before || raw_token.newlines) {
                        if (!this.print_preserved_newlines(raw_token)) {
                            this._output.space_before_token = true;
                        }
                        return true;
                    }
                    return false;
                };
                Printer.prototype.previous_token_wrapped = function() {
                    return this._output.previous_token_wrapped;
                };
                Printer.prototype.print_newline = function(force) {
                    this._output.add_new_line(force);
                };
                Printer.prototype.print_token = function(token) {
                    if (token.text) {
                        this._output.set_indent(this.indent_level, this.alignment_size);
                        this._output.add_token(token.text);
                    }
                };
                Printer.prototype.indent = function() {
                    this.indent_level++;
                };
                Printer.prototype.deindent = function() {
                    if (this.indent_level > 0) {
                        this.indent_level--;
                        this._output.set_indent(this.indent_level, this.alignment_size);
                    }
                };
                Printer.prototype.get_full_indent = function(level) {
                    level = this.indent_level + (level || 0);
                    if (level < 1) {
                        return "";
                    }
                    return this._output.get_indent_string(level);
                };
                var get_type_attribute = function(start_token) {
                    var result = null;
                    var raw_token = start_token.next;
                    // Search attributes for a type attribute
                    while(raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token){
                        if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
                            if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
                                result = raw_token.next.next.text;
                            }
                            break;
                        }
                        raw_token = raw_token.next;
                    }
                    return result;
                };
                var get_custom_beautifier_name = function(tag_check, raw_token) {
                    var typeAttribute = null;
                    var result = null;
                    if (!raw_token.closed) {
                        return null;
                    }
                    if (tag_check === "script") {
                        typeAttribute = "text/javascript";
                    } else if (tag_check === "style") {
                        typeAttribute = "text/css";
                    }
                    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
                    // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
                    // For those without a type attribute use default;
                    if (typeAttribute.search("text/css") > -1) {
                        result = "css";
                    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
                        result = "javascript";
                    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
                        result = "html";
                    } else if (typeAttribute.search(/test\/null/) > -1) {
                        // Test only mime-type for testing the beautifier when null is passed as beautifing function
                        result = "null";
                    }
                    return result;
                };
                function in_array(what, arr) {
                    return arr.indexOf(what) !== -1;
                }
                function TagFrame(parent, parser_token, indent_level) {
                    this.parent = parent || null;
                    this.tag = parser_token ? parser_token.tag_name : "";
                    this.indent_level = indent_level || 0;
                    this.parser_token = parser_token || null;
                }
                function TagStack(printer) {
                    this._printer = printer;
                    this._current_frame = null;
                }
                TagStack.prototype.get_parser_token = function() {
                    return this._current_frame ? this._current_frame.parser_token : null;
                };
                TagStack.prototype.record_tag = function(parser_token) {
                    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
                    this._current_frame = new_frame;
                };
                TagStack.prototype._try_pop_frame = function(frame) {
                    var parser_token = null;
                    if (frame) {
                        parser_token = frame.parser_token;
                        this._printer.indent_level = frame.indent_level;
                        this._current_frame = frame.parent;
                    }
                    return parser_token;
                };
                TagStack.prototype._get_frame = function(tag_list, stop_list) {
                    var frame = this._current_frame;
                    while(frame){
                        if (tag_list.indexOf(frame.tag) !== -1) {
                            break;
                        } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
                            frame = null;
                            break;
                        }
                        frame = frame.parent;
                    }
                    return frame;
                };
                TagStack.prototype.try_pop = function(tag, stop_list) {
                    var frame = this._get_frame([
                        tag
                    ], stop_list);
                    return this._try_pop_frame(frame);
                };
                TagStack.prototype.indent_to_tag = function(tag_list) {
                    var frame = this._get_frame(tag_list);
                    if (frame) {
                        this._printer.indent_level = frame.indent_level;
                    }
                };
                function Beautifier(source_text, options, js_beautify, css_beautify) {
                    //Wrapper function to invoke all the necessary constructors and deal with the output.
                    this._source_text = source_text || "";
                    options = options || {};
                    this._js_beautify = js_beautify;
                    this._css_beautify = css_beautify;
                    this._tag_stack = null;
                    // Allow the setting of language/file-type specific options
                    // with inheritance of overall settings
                    var optionHtml = new Options(options, "html");
                    this._options = optionHtml;
                    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
                    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
                    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
                    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
                    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
                    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
                }
                Beautifier.prototype.beautify = function() {
                    // if disabled, return the input unchanged.
                    if (this._options.disabled) {
                        return this._source_text;
                    }
                    var source_text = this._source_text;
                    var eol = this._options.eol;
                    if (this._options.eol === "auto") {
                        eol = "\n";
                        if (source_text && lineBreak.test(source_text)) {
                            eol = source_text.match(lineBreak)[0];
                        }
                    }
                    // HACK: newline parsing inconsistent. This brute force normalizes the input.
                    source_text = source_text.replace(allLineBreaks, "\n");
                    var baseIndentString = source_text.match(/^[\t ]*/)[0];
                    var last_token = {
                        text: "",
                        type: ""
                    };
                    var last_tag_token = new TagOpenParserToken();
                    var printer = new Printer(this._options, baseIndentString);
                    var tokens = new Tokenizer(source_text, this._options).tokenize();
                    this._tag_stack = new TagStack(printer);
                    var parser_token = null;
                    var raw_token = tokens.next();
                    while(raw_token.type !== TOKEN.EOF){
                        if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
                            parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
                            last_tag_token = parser_token;
                        } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
                            parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
                        } else if (raw_token.type === TOKEN.TAG_CLOSE) {
                            parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
                        } else if (raw_token.type === TOKEN.TEXT) {
                            parser_token = this._handle_text(printer, raw_token, last_tag_token);
                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {
                            parser_token = this._handle_control_flow_open(printer, raw_token);
                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {
                            parser_token = this._handle_control_flow_close(printer, raw_token);
                        } else {
                            // This should never happen, but if it does. Print the raw token
                            printer.add_raw_token(raw_token);
                        }
                        last_token = parser_token;
                        raw_token = tokens.next();
                    }
                    var sweet_code = printer._output.get_code(eol);
                    return sweet_code;
                };
                Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {
                    var parser_token = {
                        text: raw_token.text,
                        type: raw_token.type
                    };
                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
                    if (raw_token.newlines) {
                        printer.print_preserved_newlines(raw_token);
                    } else {
                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
                    }
                    printer.print_token(raw_token);
                    printer.indent();
                    return parser_token;
                };
                Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {
                    var parser_token = {
                        text: raw_token.text,
                        type: raw_token.type
                    };
                    printer.deindent();
                    if (raw_token.newlines) {
                        printer.print_preserved_newlines(raw_token);
                    } else {
                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
                    }
                    printer.print_token(raw_token);
                    return parser_token;
                };
                Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
                    var parser_token = {
                        text: raw_token.text,
                        type: raw_token.type
                    };
                    printer.alignment_size = 0;
                    last_tag_token.tag_complete = true;
                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
                    if (last_tag_token.is_unformatted) {
                        printer.add_raw_token(raw_token);
                    } else {
                        if (last_tag_token.tag_start_char === "<") {
                            printer.set_space_before_token(raw_token.text[0] === "/", true); // space before />, no space before >
                            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
                                printer.print_newline(false);
                            }
                        }
                        printer.print_token(raw_token);
                    }
                    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
                        printer.indent();
                        // only indent once per opened tag
                        last_tag_token.indent_content = false;
                    }
                    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
                        printer.set_wrap_point();
                    }
                    return parser_token;
                };
                Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
                    var wrapped = last_tag_token.has_wrapped_attrs;
                    var parser_token = {
                        text: raw_token.text,
                        type: raw_token.type
                    };
                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
                    if (last_tag_token.is_unformatted) {
                        printer.add_raw_token(raw_token);
                    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
                        // For the insides of handlebars allow newlines or a single space between open and contents
                        if (printer.print_preserved_newlines(raw_token)) {
                            raw_token.newlines = 0;
                            printer.add_raw_token(raw_token);
                        } else {
                            printer.print_token(raw_token);
                        }
                    } else {
                        if (raw_token.type === TOKEN.ATTRIBUTE) {
                            printer.set_space_before_token(true);
                        } else if (raw_token.type === TOKEN.EQUALS) {
                            printer.set_space_before_token(false);
                        } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
                            printer.set_space_before_token(false);
                        }
                        if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
                            if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
                                printer.traverse_whitespace(raw_token);
                                wrapped = wrapped || raw_token.newlines !== 0;
                            }
                            // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':
                            // 1. always wrap the second and beyond attributes
                            // 2. wrap the first attribute only if 'force-expand-multiline' is specified
                            if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond
                            this._is_wrap_attributes_force_expand_multiline)) {
                                printer.print_newline(false);
                                wrapped = true;
                            }
                        }
                        printer.print_token(raw_token);
                        wrapped = wrapped || printer.previous_token_wrapped();
                        last_tag_token.has_wrapped_attrs = wrapped;
                    }
                    return parser_token;
                };
                Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
                    var parser_token = {
                        text: raw_token.text,
                        type: "TK_CONTENT"
                    };
                    if (last_tag_token.custom_beautifier_name) {
                        this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
                    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
                        printer.add_raw_token(raw_token);
                    } else {
                        printer.traverse_whitespace(raw_token);
                        printer.print_token(raw_token);
                    }
                    return parser_token;
                };
                Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
                    var local = this;
                    if (raw_token.text !== "") {
                        var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
                        if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
                            _beautifier = this._js_beautify;
                        } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
                            _beautifier = this._css_beautify;
                        } else if (last_tag_token.custom_beautifier_name === "html") {
                            _beautifier = function(html_source, options) {
                                var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
                                return beautifier.beautify();
                            };
                        }
                        if (this._options.indent_scripts === "keep") {
                            script_indent_level = 0;
                        } else if (this._options.indent_scripts === "separate") {
                            script_indent_level = -printer.indent_level;
                        }
                        var indentation = printer.get_full_indent(script_indent_level);
                        // if there is at least one empty line at the end of this text, strip it
                        // we'll be adding one back after the text but before the containing tag.
                        text = text.replace(/\n[ \t]*$/, "");
                        // Handle the case where content is wrapped in a comment or cdata.
                        if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
                            var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
                            // if we start to wrap but don't finish, print raw
                            if (!matched) {
                                printer.add_raw_token(raw_token);
                                return;
                            }
                            pre = indentation + matched[1] + "\n";
                            text = matched[4];
                            if (matched[5]) {
                                post = indentation + matched[5];
                            }
                            // if there is at least one empty line at the end of this text, strip it
                            // we'll be adding one back after the text but before the containing tag.
                            text = text.replace(/\n[ \t]*$/, "");
                            if (matched[2] || matched[3].indexOf("\n") !== -1) {
                                // if the first line of the non-comment text has spaces
                                // use that as the basis for indenting in null case.
                                matched = matched[3].match(/[ \t]+$/);
                                if (matched) {
                                    raw_token.whitespace_before = matched[0];
                                }
                            }
                        }
                        if (text) {
                            if (_beautifier) {
                                // call the Beautifier if avaliable
                                var Child_options = function() {
                                    this.eol = "\n";
                                };
                                Child_options.prototype = this._options.raw_options;
                                var child_options = new Child_options();
                                text = _beautifier(indentation + text, child_options);
                            } else {
                                // simply indent the string otherwise
                                var white = raw_token.whitespace_before;
                                if (white) {
                                    text = text.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
                                }
                                text = indentation + text.replace(/\n/g, "\n" + indentation);
                            }
                        }
                        if (pre) {
                            if (!text) {
                                text = pre + post;
                            } else {
                                text = pre + text + "\n" + post;
                            }
                        }
                        printer.print_newline(false);
                        if (text) {
                            raw_token.text = text;
                            raw_token.whitespace_before = "";
                            raw_token.newlines = 0;
                            printer.add_raw_token(raw_token);
                            printer.print_newline(true);
                        }
                    }
                };
                Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
                    var parser_token = this._get_tag_open_token(raw_token);
                    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
                        // End element tags for unformatted or content_unformatted elements
                        // are printed raw to keep any newlines inside them exactly the same.
                        printer.add_raw_token(raw_token);
                        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
                    } else {
                        printer.traverse_whitespace(raw_token);
                        this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
                        if (!parser_token.is_inline_element) {
                            printer.set_wrap_point();
                        }
                        printer.print_token(raw_token);
                    }
                    // count the number of attributes
                    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
                        var peek_index = 0;
                        var peek_token;
                        do {
                            peek_token = tokens.peek(peek_index);
                            if (peek_token.type === TOKEN.ATTRIBUTE) {
                                parser_token.attr_count += 1;
                            }
                            peek_index += 1;
                        }while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
                    }
                    //indent attributes an auto, forced, aligned or forced-align line-wrap
                    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
                        parser_token.alignment_size = raw_token.text.length + 1;
                    }
                    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
                        printer.alignment_size = parser_token.alignment_size;
                    }
                    return parser_token;
                };
                var TagOpenParserToken = function(parent, raw_token) {
                    this.parent = parent || null;
                    this.text = "";
                    this.type = "TK_TAG_OPEN";
                    this.tag_name = "";
                    this.is_inline_element = false;
                    this.is_unformatted = false;
                    this.is_content_unformatted = false;
                    this.is_empty_element = false;
                    this.is_start_tag = false;
                    this.is_end_tag = false;
                    this.indent_content = false;
                    this.multiline_content = false;
                    this.custom_beautifier_name = null;
                    this.start_tag_token = null;
                    this.attr_count = 0;
                    this.has_wrapped_attrs = false;
                    this.alignment_size = 0;
                    this.tag_complete = false;
                    this.tag_start_char = "";
                    this.tag_check = "";
                    if (!raw_token) {
                        this.tag_complete = true;
                    } else {
                        var tag_check_match;
                        this.tag_start_char = raw_token.text[0];
                        this.text = raw_token.text;
                        if (this.tag_start_char === "<") {
                            tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
                            this.tag_check = tag_check_match ? tag_check_match[1] : "";
                        } else {
                            tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
                            this.tag_check = tag_check_match ? tag_check_match[1] : "";
                            // handle "{{#> myPartial}}" or "{{~#> myPartial}}"
                            if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
                                if (this.tag_check === ">" && raw_token.next !== null) {
                                    this.tag_check = raw_token.next.text.split(" ")[0];
                                } else {
                                    this.tag_check = raw_token.text.split(">")[1];
                                }
                            }
                        }
                        this.tag_check = this.tag_check.toLowerCase();
                        if (raw_token.type === TOKEN.COMMENT) {
                            this.tag_complete = true;
                        }
                        this.is_start_tag = this.tag_check.charAt(0) !== "/";
                        this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
                        this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
                        // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2
                        var handlebar_starts = 2;
                        if (this.tag_start_char === "{" && this.text.length >= 3) {
                            if (this.text.charAt(2) === "~") {
                                handlebar_starts = 3;
                            }
                        }
                        // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
                        this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
                    }
                };
                Beautifier.prototype._get_tag_open_token = function(raw_token) {
                    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
                    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
                    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
                    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
                    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
                    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
                    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
                    return parser_token;
                };
                Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
                    if (!parser_token.is_empty_element) {
                        if (parser_token.is_end_tag) {
                            parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
                        } else {
                            // check if this tag is starting an element that has optional end element
                            // and do an ending needed
                            if (this._do_optional_end_element(parser_token)) {
                                if (!parser_token.is_inline_element) {
                                    printer.print_newline(false);
                                }
                            }
                            this._tag_stack.record_tag(parser_token); //push it on the tag stack
                            if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
                                parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
                            }
                        }
                    }
                    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
                        printer.print_newline(false);
                        if (!printer._output.just_added_blankline()) {
                            printer.print_newline(true);
                        }
                    }
                    if (parser_token.is_empty_element) {
                        // if you hit an else case, reset the indent level if you are inside an:
                        // 'if', 'unless', or 'each' block.
                        if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
                            this._tag_stack.indent_to_tag([
                                "if",
                                "unless",
                                "each"
                            ]);
                            parser_token.indent_content = true;
                            // Don't add a newline if opening {{#if}} tag is on the current line
                            var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
                            if (!foundIfOnCurrentLine) {
                                printer.print_newline(false);
                            }
                        }
                        // Don't add a newline before elements that should remain where they are.
                        if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
                        //Do nothing. Leave comments on same line.
                        } else {
                            if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
                                printer.print_newline(false);
                            }
                            this._calcluate_parent_multiline(printer, parser_token);
                        }
                    } else if (parser_token.is_end_tag) {
                        var do_end_expand = false;
                        // deciding whether a block is multiline should not be this hard
                        do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
                        do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
                        if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
                            do_end_expand = false;
                        }
                        if (do_end_expand) {
                            printer.print_newline(false);
                        }
                    } else {
                        parser_token.indent_content = !parser_token.custom_beautifier_name;
                        if (parser_token.tag_start_char === "<") {
                            if (parser_token.tag_name === "html") {
                                parser_token.indent_content = this._options.indent_inner_html;
                            } else if (parser_token.tag_name === "head") {
                                parser_token.indent_content = this._options.indent_head_inner_html;
                            } else if (parser_token.tag_name === "body") {
                                parser_token.indent_content = this._options.indent_body_inner_html;
                            }
                        }
                        if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
                            printer.print_newline(false);
                        }
                        this._calcluate_parent_multiline(printer, parser_token);
                    }
                };
                Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
                    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
                        parser_token.parent.multiline_content = true;
                    }
                };
                //To be used for <p> tag special case:
                var p_closers = [
                    "address",
                    "article",
                    "aside",
                    "blockquote",
                    "details",
                    "div",
                    "dl",
                    "fieldset",
                    "figcaption",
                    "figure",
                    "footer",
                    "form",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                    "header",
                    "hr",
                    "main",
                    "menu",
                    "nav",
                    "ol",
                    "p",
                    "pre",
                    "section",
                    "table",
                    "ul"
                ];
                var p_parent_excludes = [
                    "a",
                    "audio",
                    "del",
                    "ins",
                    "map",
                    "noscript",
                    "video"
                ];
                Beautifier.prototype._do_optional_end_element = function(parser_token) {
                    var result = null;
                    // NOTE: cases of "if there is no more content in the parent element"
                    // are handled automatically by the beautifier.
                    // It assumes parent or ancestor close tag closes all children.
                    // https://www.w3.org/TR/html5/syntax.html#optional-tags
                    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
                        return;
                    }
                    if (parser_token.tag_name === "body") {
                        // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.
                        result = result || this._tag_stack.try_pop("head");
                    //} else if (parser_token.tag_name === 'body') {
                    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.
                    } else if (parser_token.tag_name === "li") {
                        // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
                        result = result || this._tag_stack.try_pop("li", [
                            "ol",
                            "ul",
                            "menu"
                        ]);
                    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
                        // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
                        // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
                        result = result || this._tag_stack.try_pop("dt", [
                            "dl"
                        ]);
                        result = result || this._tag_stack.try_pop("dd", [
                            "dl"
                        ]);
                    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
                        // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
                        // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
                        // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
                        // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
                        var p_parent = parser_token.parent.parent;
                        if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
                            result = result || this._tag_stack.try_pop("p");
                        }
                    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
                        // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
                        // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
                        result = result || this._tag_stack.try_pop("rt", [
                            "ruby",
                            "rtc"
                        ]);
                        result = result || this._tag_stack.try_pop("rp", [
                            "ruby",
                            "rtc"
                        ]);
                    } else if (parser_token.tag_name === "optgroup") {
                        // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
                        result = result || this._tag_stack.try_pop("optgroup", [
                            "select"
                        ]);
                    //result = result || this._tag_stack.try_pop('option', ['select']);
                    } else if (parser_token.tag_name === "option") {
                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
                        result = result || this._tag_stack.try_pop("option", [
                            "select",
                            "datalist",
                            "optgroup"
                        ]);
                    } else if (parser_token.tag_name === "colgroup") {
                        // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
                        result = result || this._tag_stack.try_pop("caption", [
                            "table"
                        ]);
                    } else if (parser_token.tag_name === "thead") {
                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
                        result = result || this._tag_stack.try_pop("caption", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("colgroup", [
                            "table"
                        ]);
                    //} else if (parser_token.tag_name === 'caption') {
                    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.
                    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
                        // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
                        // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
                        result = result || this._tag_stack.try_pop("caption", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("colgroup", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("thead", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("tbody", [
                            "table"
                        ]);
                    //} else if (parser_token.tag_name === 'tfoot') {
                    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.
                    } else if (parser_token.tag_name === "tr") {
                        // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
                        result = result || this._tag_stack.try_pop("caption", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("colgroup", [
                            "table"
                        ]);
                        result = result || this._tag_stack.try_pop("tr", [
                            "table",
                            "thead",
                            "tbody",
                            "tfoot"
                        ]);
                    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
                        // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
                        // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
                        result = result || this._tag_stack.try_pop("td", [
                            "table",
                            "thead",
                            "tbody",
                            "tfoot",
                            "tr"
                        ]);
                        result = result || this._tag_stack.try_pop("th", [
                            "table",
                            "thead",
                            "tbody",
                            "tfoot",
                            "tr"
                        ]);
                    }
                    // Start element omission not handled currently
                    // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
                    // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
                    // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
                    // Fix up the parent of the parser token
                    parser_token.parent = this._tag_stack.get_parser_token();
                    return result;
                };
                module.exports.Beautifier = Beautifier;
            /***/ },
            /* 20 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_126544__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var BaseOptions = __nested_webpack_require_126544__(6).Options;
                function Options(options) {
                    BaseOptions.call(this, options, "html");
                    if (this.templating.length === 1 && this.templating[0] === "auto") {
                        this.templating = [
                            "django",
                            "erb",
                            "handlebars",
                            "php"
                        ];
                    }
                    this.indent_inner_html = this._get_boolean("indent_inner_html");
                    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
                    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
                    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
                    this.wrap_attributes = this._get_selection("wrap_attributes", [
                        "auto",
                        "force",
                        "force-aligned",
                        "force-expand-multiline",
                        "aligned-multiple",
                        "preserve",
                        "preserve-aligned"
                    ]);
                    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
                    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
                    this.extra_liners = this._get_array("extra_liners", [
                        "head",
                        "body",
                        "/html"
                    ]);
                    // Block vs inline elements
                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
                    // https://www.w3.org/TR/html5/dom.html#phrasing-content
                    this.inline = this._get_array("inline", [
                        "a",
                        "abbr",
                        "area",
                        "audio",
                        "b",
                        "bdi",
                        "bdo",
                        "br",
                        "button",
                        "canvas",
                        "cite",
                        "code",
                        "data",
                        "datalist",
                        "del",
                        "dfn",
                        "em",
                        "embed",
                        "i",
                        "iframe",
                        "img",
                        "input",
                        "ins",
                        "kbd",
                        "keygen",
                        "label",
                        "map",
                        "mark",
                        "math",
                        "meter",
                        "noscript",
                        "object",
                        "output",
                        "progress",
                        "q",
                        "ruby",
                        "s",
                        "samp",
                        /* 'script', */ "select",
                        "small",
                        "span",
                        "strong",
                        "sub",
                        "sup",
                        "svg",
                        "template",
                        "textarea",
                        "time",
                        "u",
                        "var",
                        "video",
                        "wbr",
                        "text",
                        // obsolete inline tags
                        "acronym",
                        "big",
                        "strike",
                        "tt"
                    ]);
                    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
                    this.void_elements = this._get_array("void_elements", [
                        // HTLM void elements - aka self-closing tags - aka singletons
                        // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
                        "area",
                        "base",
                        "br",
                        "col",
                        "embed",
                        "hr",
                        "img",
                        "input",
                        "keygen",
                        "link",
                        "menuitem",
                        "meta",
                        "param",
                        "source",
                        "track",
                        "wbr",
                        // NOTE: Optional tags are too complex for a simple list
                        // they are hard coded in _do_optional_end_element
                        // Doctype and xml elements
                        "!doctype",
                        "?xml",
                        // obsolete tags
                        // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
                        // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
                        "basefont",
                        "isindex"
                    ]);
                    this.unformatted = this._get_array("unformatted", []);
                    this.content_unformatted = this._get_array("content_unformatted", [
                        "pre",
                        "textarea"
                    ]);
                    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
                    this.indent_scripts = this._get_selection("indent_scripts", [
                        "normal",
                        "keep",
                        "separate"
                    ]);
                }
                Options.prototype = new BaseOptions();
                module.exports.Options = Options;
            /***/ },
            /* 21 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_134005__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var BaseTokenizer = __nested_webpack_require_134005__(9).Tokenizer;
                var BASETOKEN = __nested_webpack_require_134005__(9).TOKEN;
                var Directives = __nested_webpack_require_134005__(13).Directives;
                var TemplatablePattern = __nested_webpack_require_134005__(14).TemplatablePattern;
                var Pattern = __nested_webpack_require_134005__(12).Pattern;
                var TOKEN = {
                    TAG_OPEN: "TK_TAG_OPEN",
                    TAG_CLOSE: "TK_TAG_CLOSE",
                    CONTROL_FLOW_OPEN: "TK_CONTROL_FLOW_OPEN",
                    CONTROL_FLOW_CLOSE: "TK_CONTROL_FLOW_CLOSE",
                    ATTRIBUTE: "TK_ATTRIBUTE",
                    EQUALS: "TK_EQUALS",
                    VALUE: "TK_VALUE",
                    COMMENT: "TK_COMMENT",
                    TEXT: "TK_TEXT",
                    UNKNOWN: "TK_UNKNOWN",
                    START: BASETOKEN.START,
                    RAW: BASETOKEN.RAW,
                    EOF: BASETOKEN.EOF
                };
                var directives_core = new Directives(/<\!--/, /-->/);
                var Tokenizer = function(input_string, options) {
                    BaseTokenizer.call(this, input_string, options);
                    this._current_tag_name = "";
                    // Words end at whitespace or when a tag starts
                    // if we are indenting handlebars, they are considered tags
                    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
                    var pattern_reader = new Pattern(this._input);
                    this.__patterns = {
                        word: templatable_reader.until(/[\n\r\t <]/),
                        word_control_flow_close_excluded: templatable_reader.until(/[\n\r\t <}]/),
                        single_quote: templatable_reader.until_after(/'/),
                        double_quote: templatable_reader.until_after(/"/),
                        attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
                        element_name: templatable_reader.until(/[\n\r\t >\/]/),
                        angular_control_flow_start: pattern_reader.matching(/\@[a-zA-Z]+[^({]*[({]/),
                        handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
                        handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
                        handlebars_open: pattern_reader.until(/[\n\r\t }]/),
                        handlebars_raw_close: pattern_reader.until(/}}/),
                        comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
                        cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
                        // https://en.wikipedia.org/wiki/Conditional_comment
                        conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
                        processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
                    };
                    if (this._options.indent_handlebars) {
                        this.__patterns.word = this.__patterns.word.exclude("handlebars");
                        this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude("handlebars");
                    }
                    this._unformatted_content_delimiter = null;
                    if (this._options.unformatted_content_delimiter) {
                        var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
                        this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
                    }
                };
                Tokenizer.prototype = new BaseTokenizer();
                Tokenizer.prototype._is_comment = function(current_token) {
                    return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
                };
                Tokenizer.prototype._is_opening = function(current_token) {
                    return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;
                };
                Tokenizer.prototype._is_closing = function(current_token, open_token) {
                    return current_token.type === TOKEN.TAG_CLOSE && open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{") || current_token.type === TOKEN.CONTROL_FLOW_CLOSE && current_token.text === "}" && open_token.text.endsWith("{");
                };
                Tokenizer.prototype._reset = function() {
                    this._current_tag_name = "";
                };
                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
                    var token = null;
                    this._readWhitespace();
                    var c = this._input.peek();
                    if (c === null) {
                        return this._create_token(TOKEN.EOF, "");
                    }
                    token = token || this._read_open_handlebars(c, open_token);
                    token = token || this._read_attribute(c, previous_token, open_token);
                    token = token || this._read_close(c, open_token);
                    token = token || this._read_control_flows(c, open_token);
                    token = token || this._read_raw_content(c, previous_token, open_token);
                    token = token || this._read_content_word(c, open_token);
                    token = token || this._read_comment_or_cdata(c);
                    token = token || this._read_processing(c);
                    token = token || this._read_open(c, open_token);
                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
                    return token;
                };
                Tokenizer.prototype._read_comment_or_cdata = function(c) {
                    var token = null;
                    var resulting_string = null;
                    var directives = null;
                    if (c === "<") {
                        var peek1 = this._input.peek(1);
                        // We treat all comments as literals, even more than preformatted tags
                        // we only look for the appropriate closing marker
                        if (peek1 === "!") {
                            resulting_string = this.__patterns.comment.read();
                            // only process directive on html comments
                            if (resulting_string) {
                                directives = directives_core.get_directives(resulting_string);
                                if (directives && directives.ignore === "start") {
                                    resulting_string += directives_core.readIgnored(this._input);
                                }
                            } else {
                                resulting_string = this.__patterns.cdata.read();
                            }
                        }
                        if (resulting_string) {
                            token = this._create_token(TOKEN.COMMENT, resulting_string);
                            token.directives = directives;
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_processing = function(c) {
                    var token = null;
                    var resulting_string = null;
                    var directives = null;
                    if (c === "<") {
                        var peek1 = this._input.peek(1);
                        if (peek1 === "!" || peek1 === "?") {
                            resulting_string = this.__patterns.conditional_comment.read();
                            resulting_string = resulting_string || this.__patterns.processing.read();
                        }
                        if (resulting_string) {
                            token = this._create_token(TOKEN.COMMENT, resulting_string);
                            token.directives = directives;
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_open = function(c, open_token) {
                    var resulting_string = null;
                    var token = null;
                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
                        if (c === "<") {
                            resulting_string = this._input.next();
                            if (this._input.peek() === "/") {
                                resulting_string += this._input.next();
                            }
                            resulting_string += this.__patterns.element_name.read();
                            token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
                    var resulting_string = null;
                    var token = null;
                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
                        if (this._options.indent_handlebars && c === "{" && this._input.peek(1) === "{") {
                            if (this._input.peek(2) === "!") {
                                resulting_string = this.__patterns.handlebars_comment.read();
                                resulting_string = resulting_string || this.__patterns.handlebars.read();
                                token = this._create_token(TOKEN.COMMENT, resulting_string);
                            } else {
                                resulting_string = this.__patterns.handlebars_open.read();
                                token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
                            }
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_control_flows = function(c, open_token) {
                    var resulting_string = "";
                    var token = null;
                    // Only check for control flows if angular templating is set AND indenting is set
                    if (!this._options.templating.includes("angular") || !this._options.indent_handlebars) {
                        return token;
                    }
                    if (c === "@") {
                        resulting_string = this.__patterns.angular_control_flow_start.read();
                        if (resulting_string === "") {
                            return token;
                        }
                        var opening_parentheses_count = resulting_string.endsWith("(") ? 1 : 0;
                        var closing_parentheses_count = 0;
                        // The opening brace of the control flow is where the number of opening and closing parentheses equal
                        // e.g. @if({value: true} !== null) { 
                        while(!(resulting_string.endsWith("{") && opening_parentheses_count === closing_parentheses_count)){
                            var next_char = this._input.next();
                            if (next_char === null) {
                                break;
                            } else if (next_char === "(") {
                                opening_parentheses_count++;
                            } else if (next_char === ")") {
                                closing_parentheses_count++;
                            }
                            resulting_string += next_char;
                        }
                        token = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);
                    } else if (c === "}" && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {
                        resulting_string = this._input.next();
                        token = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);
                    }
                    return token;
                };
                Tokenizer.prototype._read_close = function(c, open_token) {
                    var resulting_string = null;
                    var token = null;
                    if (open_token && open_token.type === TOKEN.TAG_OPEN) {
                        if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
                            resulting_string = this._input.next();
                            if (c === "/") {
                                resulting_string += this._input.next();
                            }
                            token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
                        } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
                            this._input.next();
                            this._input.next();
                            token = this._create_token(TOKEN.TAG_CLOSE, "}}");
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
                    var token = null;
                    var resulting_string = "";
                    if (open_token && open_token.text[0] === "<") {
                        if (c === "=") {
                            token = this._create_token(TOKEN.EQUALS, this._input.next());
                        } else if (c === '"' || c === "'") {
                            var content = this._input.next();
                            if (c === '"') {
                                content += this.__patterns.double_quote.read();
                            } else {
                                content += this.__patterns.single_quote.read();
                            }
                            token = this._create_token(TOKEN.VALUE, content);
                        } else {
                            resulting_string = this.__patterns.attribute.read();
                            if (resulting_string) {
                                if (previous_token.type === TOKEN.EQUALS) {
                                    token = this._create_token(TOKEN.VALUE, resulting_string);
                                } else {
                                    token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
                                }
                            }
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._is_content_unformatted = function(tag_name) {
                    // void_elements have no content and so cannot have unformatted content
                    // script and style tags should always be read as unformatted content
                    // finally content_unformatted and unformatted element contents are unformatted
                    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
                };
                Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
                    var resulting_string = "";
                    if (open_token && open_token.text[0] === "{") {
                        resulting_string = this.__patterns.handlebars_raw_close.read();
                    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
                        // ^^ empty tag has no content 
                        var tag_name = previous_token.opened.text.substr(1).toLowerCase();
                        if (tag_name === "script" || tag_name === "style") {
                            // Script and style tags are allowed to have comments wrapping their content
                            // or just have regular content.
                            var token = this._read_comment_or_cdata(c);
                            if (token) {
                                token.type = TOKEN.TEXT;
                                return token;
                            }
                            resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
                        } else if (this._is_content_unformatted(tag_name)) {
                            resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
                        }
                    }
                    if (resulting_string) {
                        return this._create_token(TOKEN.TEXT, resulting_string);
                    }
                    return null;
                };
                Tokenizer.prototype._read_content_word = function(c, open_token) {
                    var resulting_string = "";
                    if (this._options.unformatted_content_delimiter) {
                        if (c === this._options.unformatted_content_delimiter[0]) {
                            resulting_string = this.__patterns.unformatted_content_delimiter.read();
                        }
                    }
                    if (!resulting_string) {
                        resulting_string = open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();
                    }
                    if (resulting_string) {
                        return this._create_token(TOKEN.TEXT, resulting_string);
                    }
                };
                module.exports.Tokenizer = Tokenizer;
                module.exports.TOKEN = TOKEN;
            /***/ }
        ];
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_153612__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_153612__);
            /******/ /******/ // Return the exports of the module
            /******/ return module.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module is referenced by other modules so it can't be inlined
        /******/ var __nested_webpack_exports__ = __nested_webpack_require_153612__(18);
        /******/ legacy_beautify_html = __nested_webpack_exports__;
    /******/ /******/ })();
    var style_html = legacy_beautify_html;
    /* Footer */ if (true) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__,
            __webpack_require__(49080),
            __webpack_require__(92019)
        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {
            var js_beautify = __webpack_require__(49080);
            var css_beautify = __webpack_require__(92019);
            return {
                html_beautify: function(html_source, options) {
                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
                }
            };
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var css_beautify, js_beautify; }
})();


/***/ }),

/***/ 49080:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@beautifier.io>
      https://beautifier.io/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overridden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/ (function() {
    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_js;
    /******/ (function() {
        /******/ "use strict";
        /******/ var __webpack_modules__ = [
            /* 0 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_4010__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Beautifier = __nested_webpack_require_4010__(1).Beautifier, Options = __nested_webpack_require_4010__(5).Options;
                function js_beautify(js_source_text, options) {
                    var beautifier = new Beautifier(js_source_text, options);
                    return beautifier.beautify();
                }
                module.exports = js_beautify;
                module.exports.defaultOptions = function() {
                    return new Options();
                };
            /***/ },
            /* 1 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_5797__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Output = __nested_webpack_require_5797__(2).Output;
                var Token = __nested_webpack_require_5797__(3).Token;
                var acorn = __nested_webpack_require_5797__(4);
                var Options = __nested_webpack_require_5797__(5).Options;
                var Tokenizer = __nested_webpack_require_5797__(7).Tokenizer;
                var line_starters = __nested_webpack_require_5797__(7).line_starters;
                var positionable_operators = __nested_webpack_require_5797__(7).positionable_operators;
                var TOKEN = __nested_webpack_require_5797__(7).TOKEN;
                function in_array(what, arr) {
                    return arr.indexOf(what) !== -1;
                }
                function ltrim(s) {
                    return s.replace(/^\s+/g, "");
                }
                function generateMapFromStrings(list) {
                    var result = {};
                    for(var x = 0; x < list.length; x++){
                        // make the mapped names underscored instead of dash
                        result[list[x].replace(/-/g, "_")] = list[x];
                    }
                    return result;
                }
                function reserved_word(token, word) {
                    return token && token.type === TOKEN.RESERVED && token.text === word;
                }
                function reserved_array(token, words) {
                    return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
                }
                // Unsure of what they mean, but they work. Worth cleaning up in future.
                var special_words = [
                    "case",
                    "return",
                    "do",
                    "if",
                    "throw",
                    "else",
                    "await",
                    "break",
                    "continue",
                    "async"
                ];
                var validPositionValues = [
                    "before-newline",
                    "after-newline",
                    "preserve-newline"
                ];
                // Generate map from array
                var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
                var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [
                    OPERATOR_POSITION.before_newline,
                    OPERATOR_POSITION.preserve_newline
                ];
                var MODE = {
                    BlockStatement: "BlockStatement",
                    Statement: "Statement",
                    ObjectLiteral: "ObjectLiteral",
                    ArrayLiteral: "ArrayLiteral",
                    ForInitializer: "ForInitializer",
                    Conditional: "Conditional",
                    Expression: "Expression" //'(EXPRESSION)'
                };
                function remove_redundant_indentation(output, frame) {
                    // This implementation is effective but has some issues:
                    //     - can cause line wrap to happen too soon due to indent removal
                    //           after wrap points are calculated
                    // These issues are minor compared to ugly indentation.
                    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
                        return;
                    }
                    // remove one indent from each line inside this section
                    output.remove_indent(frame.start_line_index);
                }
                // we could use just string.split, but
                // IE doesn't like returning empty strings
                function split_linebreaks(s) {
                    //return s.split(/\x0d\x0a|\x0a/);
                    s = s.replace(acorn.allLineBreaks, "\n");
                    var out = [], idx = s.indexOf("\n");
                    while(idx !== -1){
                        out.push(s.substring(0, idx));
                        s = s.substring(idx + 1);
                        idx = s.indexOf("\n");
                    }
                    if (s.length) {
                        out.push(s);
                    }
                    return out;
                }
                function is_array(mode) {
                    return mode === MODE.ArrayLiteral;
                }
                function is_expression(mode) {
                    return in_array(mode, [
                        MODE.Expression,
                        MODE.ForInitializer,
                        MODE.Conditional
                    ]);
                }
                function all_lines_start_with(lines, c) {
                    for(var i = 0; i < lines.length; i++){
                        var line = lines[i].trim();
                        if (line.charAt(0) !== c) {
                            return false;
                        }
                    }
                    return true;
                }
                function each_line_matches_indent(lines, indent) {
                    var i = 0, len = lines.length, line;
                    for(; i < len; i++){
                        line = lines[i];
                        // allow empty lines to pass through
                        if (line && line.indexOf(indent) !== 0) {
                            return false;
                        }
                    }
                    return true;
                }
                function Beautifier(source_text, options) {
                    options = options || {};
                    this._source_text = source_text || "";
                    this._output = null;
                    this._tokens = null;
                    this._last_last_text = null;
                    this._flags = null;
                    this._previous_flags = null;
                    this._flag_store = null;
                    this._options = new Options(options);
                }
                Beautifier.prototype.create_flags = function(flags_base, mode) {
                    var next_indent_level = 0;
                    if (flags_base) {
                        next_indent_level = flags_base.indentation_level;
                        if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
                            next_indent_level = flags_base.line_indent_level;
                        }
                    }
                    var next_flags = {
                        mode: mode,
                        parent: flags_base,
                        last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
                        last_word: flags_base ? flags_base.last_word : "",
                        declaration_statement: false,
                        declaration_assignment: false,
                        multiline_frame: false,
                        inline_frame: false,
                        if_block: false,
                        else_block: false,
                        class_start_block: false,
                        do_block: false,
                        do_while: false,
                        import_block: false,
                        in_case_statement: false,
                        in_case: false,
                        case_body: false,
                        case_block: false,
                        indentation_level: next_indent_level,
                        alignment: 0,
                        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
                        start_line_index: this._output.get_line_number(),
                        ternary_depth: 0
                    };
                    return next_flags;
                };
                Beautifier.prototype._reset = function(source_text) {
                    var baseIndentString = source_text.match(/^[\t ]*/)[0];
                    this._last_last_text = ""; // pre-last token text
                    this._output = new Output(this._options, baseIndentString);
                    // If testing the ignore directive, start with output disable set to true
                    this._output.raw = this._options.test_output_raw;
                    // Stack of parsing/formatting states, including MODE.
                    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
                    // and formatted output.  This makes the beautifier less accurate than full parsers
                    // but also far more tolerant of syntax errors.
                    //
                    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
                    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
                    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
                    // most full parsers would die, but the beautifier gracefully falls back to
                    // MODE.BlockStatement and continues on.
                    this._flag_store = [];
                    this.set_mode(MODE.BlockStatement);
                    var tokenizer = new Tokenizer(source_text, this._options);
                    this._tokens = tokenizer.tokenize();
                    return source_text;
                };
                Beautifier.prototype.beautify = function() {
                    // if disabled, return the input unchanged.
                    if (this._options.disabled) {
                        return this._source_text;
                    }
                    var sweet_code;
                    var source_text = this._reset(this._source_text);
                    var eol = this._options.eol;
                    if (this._options.eol === "auto") {
                        eol = "\n";
                        if (source_text && acorn.lineBreak.test(source_text || "")) {
                            eol = source_text.match(acorn.lineBreak)[0];
                        }
                    }
                    var current_token = this._tokens.next();
                    while(current_token){
                        this.handle_token(current_token);
                        this._last_last_text = this._flags.last_token.text;
                        this._flags.last_token = current_token;
                        current_token = this._tokens.next();
                    }
                    sweet_code = this._output.get_code(eol);
                    return sweet_code;
                };
                Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
                    if (current_token.type === TOKEN.START_EXPR) {
                        this.handle_start_expr(current_token);
                    } else if (current_token.type === TOKEN.END_EXPR) {
                        this.handle_end_expr(current_token);
                    } else if (current_token.type === TOKEN.START_BLOCK) {
                        this.handle_start_block(current_token);
                    } else if (current_token.type === TOKEN.END_BLOCK) {
                        this.handle_end_block(current_token);
                    } else if (current_token.type === TOKEN.WORD) {
                        this.handle_word(current_token);
                    } else if (current_token.type === TOKEN.RESERVED) {
                        this.handle_word(current_token);
                    } else if (current_token.type === TOKEN.SEMICOLON) {
                        this.handle_semicolon(current_token);
                    } else if (current_token.type === TOKEN.STRING) {
                        this.handle_string(current_token);
                    } else if (current_token.type === TOKEN.EQUALS) {
                        this.handle_equals(current_token);
                    } else if (current_token.type === TOKEN.OPERATOR) {
                        this.handle_operator(current_token);
                    } else if (current_token.type === TOKEN.COMMA) {
                        this.handle_comma(current_token);
                    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
                        this.handle_block_comment(current_token, preserve_statement_flags);
                    } else if (current_token.type === TOKEN.COMMENT) {
                        this.handle_comment(current_token, preserve_statement_flags);
                    } else if (current_token.type === TOKEN.DOT) {
                        this.handle_dot(current_token);
                    } else if (current_token.type === TOKEN.EOF) {
                        this.handle_eof(current_token);
                    } else if (current_token.type === TOKEN.UNKNOWN) {
                        this.handle_unknown(current_token, preserve_statement_flags);
                    } else {
                        this.handle_unknown(current_token, preserve_statement_flags);
                    }
                };
                Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
                    var newlines = current_token.newlines;
                    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
                    if (current_token.comments_before) {
                        var comment_token = current_token.comments_before.next();
                        while(comment_token){
                            // The cleanest handling of inline comments is to treat them as though they aren't there.
                            // Just continue formatting and the behavior should be logical.
                            // Also ignore unknown tokens.  Again, this should result in better behavior.
                            this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
                            this.handle_token(comment_token, preserve_statement_flags);
                            comment_token = current_token.comments_before.next();
                        }
                    }
                    if (keep_whitespace) {
                        for(var i = 0; i < newlines; i += 1){
                            this.print_newline(i > 0, preserve_statement_flags);
                        }
                    } else {
                        if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
                            newlines = this._options.max_preserve_newlines;
                        }
                        if (this._options.preserve_newlines) {
                            if (newlines > 1) {
                                this.print_newline(false, preserve_statement_flags);
                                for(var j = 1; j < newlines; j += 1){
                                    this.print_newline(true, preserve_statement_flags);
                                }
                            }
                        }
                    }
                };
                var newline_restricted_tokens = [
                    "async",
                    "break",
                    "continue",
                    "return",
                    "throw",
                    "yield"
                ];
                Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
                    force_linewrap = force_linewrap === undefined ? false : force_linewrap;
                    // Never wrap the first token on a line
                    if (this._output.just_added_newline()) {
                        return;
                    }
                    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
                    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
                    if (operatorLogicApplies) {
                        var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
                        shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
                    }
                    if (shouldPreserveOrForce) {
                        this.print_newline(false, true);
                    } else if (this._options.wrap_line_length) {
                        if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
                            // These tokens should never have a newline inserted
                            // between them and the following expression.
                            return;
                        }
                        this._output.set_wrap_point();
                    }
                };
                Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
                    if (!preserve_statement_flags) {
                        if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
                            var next_token = this._tokens.peek();
                            while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block){
                                this.restore_mode();
                            }
                        }
                    }
                    if (this._output.add_new_line(force_newline)) {
                        this._flags.multiline_frame = true;
                    }
                };
                Beautifier.prototype.print_token_line_indentation = function(current_token) {
                    if (this._output.just_added_newline()) {
                        if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
                            this._output.current_line.set_indent(-1);
                            this._output.current_line.push(current_token.whitespace_before);
                            this._output.space_before_token = false;
                        } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
                            this._flags.line_indent_level = this._flags.indentation_level;
                        }
                    }
                };
                Beautifier.prototype.print_token = function(current_token) {
                    if (this._output.raw) {
                        this._output.add_raw_token(current_token);
                        return;
                    }
                    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
                        if (this._output.previous_line.last() === ",") {
                            var popped = this._output.previous_line.pop();
                            // if the comma was already at the start of the line,
                            // pull back onto that line and reprint the indentation
                            if (this._output.previous_line.is_empty()) {
                                this._output.previous_line.push(popped);
                                this._output.trim(true);
                                this._output.current_line.pop();
                                this._output.trim();
                            }
                            // add the comma in front of the next token
                            this.print_token_line_indentation(current_token);
                            this._output.add_token(",");
                            this._output.space_before_token = true;
                        }
                    }
                    this.print_token_line_indentation(current_token);
                    this._output.non_breaking_space = true;
                    this._output.add_token(current_token.text);
                    if (this._output.previous_token_wrapped) {
                        this._flags.multiline_frame = true;
                    }
                };
                Beautifier.prototype.indent = function() {
                    this._flags.indentation_level += 1;
                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
                };
                Beautifier.prototype.deindent = function() {
                    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
                        this._flags.indentation_level -= 1;
                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
                    }
                };
                Beautifier.prototype.set_mode = function(mode) {
                    if (this._flags) {
                        this._flag_store.push(this._flags);
                        this._previous_flags = this._flags;
                    } else {
                        this._previous_flags = this.create_flags(null, mode);
                    }
                    this._flags = this.create_flags(this._previous_flags, mode);
                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
                };
                Beautifier.prototype.restore_mode = function() {
                    if (this._flag_store.length > 0) {
                        this._previous_flags = this._flags;
                        this._flags = this._flag_store.pop();
                        if (this._previous_flags.mode === MODE.Statement) {
                            remove_redundant_indentation(this._output, this._previous_flags);
                        }
                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
                    }
                };
                Beautifier.prototype.start_of_object_property = function() {
                    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [
                        "get",
                        "set"
                    ]));
                };
                Beautifier.prototype.start_of_statement = function(current_token) {
                    var start = false;
                    start = start || reserved_array(this._flags.last_token, [
                        "var",
                        "let",
                        "const"
                    ]) && current_token.type === TOKEN.WORD;
                    start = start || reserved_word(this._flags.last_token, "do");
                    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
                    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
                    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
                    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
                    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [
                        "get",
                        "set"
                    ]));
                    if (start) {
                        this.set_mode(MODE.Statement);
                        this.indent();
                        this.handle_whitespace_and_comments(current_token, true);
                        // Issue #276:
                        // If starting a new statement with [if, for, while, do], push to a new line.
                        // if (a) if (b) if(c) d(); else e(); else f();
                        if (!this.start_of_object_property()) {
                            this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, [
                                "do",
                                "for",
                                "if",
                                "while"
                            ]));
                        }
                        return true;
                    }
                    return false;
                };
                Beautifier.prototype.handle_start_expr = function(current_token) {
                    // The conditional starts the statement if appropriate.
                    if (!this.start_of_statement(current_token)) {
                        this.handle_whitespace_and_comments(current_token);
                    }
                    var next_mode = MODE.Expression;
                    if (current_token.text === "[") {
                        if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
                            // this is array index specifier, break immediately
                            // a[x], fn()[x]
                            if (reserved_array(this._flags.last_token, line_starters)) {
                                this._output.space_before_token = true;
                            }
                            this.print_token(current_token);
                            this.set_mode(next_mode);
                            this.indent();
                            if (this._options.space_in_paren) {
                                this._output.space_before_token = true;
                            }
                            return;
                        }
                        next_mode = MODE.ArrayLiteral;
                        if (is_array(this._flags.mode)) {
                            if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
                                // ], [ goes to new line
                                // }, [ goes to new line
                                if (!this._options.keep_array_indentation) {
                                    this.print_newline();
                                }
                            }
                        }
                        if (!in_array(this._flags.last_token.type, [
                            TOKEN.START_EXPR,
                            TOKEN.END_EXPR,
                            TOKEN.WORD,
                            TOKEN.OPERATOR,
                            TOKEN.DOT
                        ])) {
                            this._output.space_before_token = true;
                        }
                    } else {
                        if (this._flags.last_token.type === TOKEN.RESERVED) {
                            if (this._flags.last_token.text === "for") {
                                this._output.space_before_token = this._options.space_before_conditional;
                                next_mode = MODE.ForInitializer;
                            } else if (in_array(this._flags.last_token.text, [
                                "if",
                                "while",
                                "switch"
                            ])) {
                                this._output.space_before_token = this._options.space_before_conditional;
                                next_mode = MODE.Conditional;
                            } else if (in_array(this._flags.last_word, [
                                "await",
                                "async"
                            ])) {
                                // Should be a space between await and an IIFE, or async and an arrow function
                                this._output.space_before_token = true;
                            } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
                                this._output.space_before_token = false;
                            } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
                                this._output.space_before_token = true;
                            }
                        } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
                            // Support of this kind of newline preservation.
                            // a = (b &&
                            //     (c || d));
                            if (!this.start_of_object_property()) {
                                this.allow_wrap_or_preserved_newline(current_token);
                            }
                        } else if (this._flags.last_token.type === TOKEN.WORD) {
                            this._output.space_before_token = false;
                            // function name() vs function name ()
                            // function* name() vs function* name ()
                            // async name() vs async name ()
                            // In ES6, you can also define the method properties of an object
                            // var obj = {a: function() {}}
                            // It can be abbreviated
                            // var obj = {a() {}}
                            // var obj = { a() {}} vs var obj = { a () {}}
                            // var obj = { * a() {}} vs var obj = { * a () {}}
                            var peek_back_two = this._tokens.peek(-3);
                            if (this._options.space_after_named_function && peek_back_two) {
                                // peek starts at next character so -1 is current token
                                var peek_back_three = this._tokens.peek(-4);
                                if (reserved_array(peek_back_two, [
                                    "async",
                                    "function"
                                ]) || peek_back_two.text === "*" && reserved_array(peek_back_three, [
                                    "async",
                                    "function"
                                ])) {
                                    this._output.space_before_token = true;
                                } else if (this._flags.mode === MODE.ObjectLiteral) {
                                    if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
                                        this._output.space_before_token = true;
                                    }
                                } else if (this._flags.parent && this._flags.parent.class_start_block) {
                                    this._output.space_before_token = true;
                                }
                            }
                        } else {
                            // Support preserving wrapped arrow function expressions
                            // a.b('c',
                            //     () => d.e
                            // )
                            this.allow_wrap_or_preserved_newline(current_token);
                        }
                        // function() vs function ()
                        // yield*() vs yield* ()
                        // function*() vs function* ()
                        if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, [
                            "function",
                            "yield"
                        ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [
                            "{",
                            ","
                        ]))) {
                            this._output.space_before_token = this._options.space_after_anon_function;
                        }
                    }
                    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
                        this.print_newline();
                    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
                        // do nothing on (( and )( and ][ and ]( and .(
                        // TODO: Consider whether forcing this is required.  Review failing tests when removed.
                        this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
                    }
                    this.print_token(current_token);
                    this.set_mode(next_mode);
                    if (this._options.space_in_paren) {
                        this._output.space_before_token = true;
                    }
                    // In all cases, if we newline while inside an expression it should be indented.
                    this.indent();
                };
                Beautifier.prototype.handle_end_expr = function(current_token) {
                    // statements inside expressions are not valid syntax, but...
                    // statements must all be closed when their container closes
                    while(this._flags.mode === MODE.Statement){
                        this.restore_mode();
                    }
                    this.handle_whitespace_and_comments(current_token);
                    if (this._flags.multiline_frame) {
                        this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
                    }
                    if (this._options.space_in_paren) {
                        if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
                            // () [] no inner space in empty parens like these, ever, ref #320
                            this._output.trim();
                            this._output.space_before_token = false;
                        } else {
                            this._output.space_before_token = true;
                        }
                    }
                    this.deindent();
                    this.print_token(current_token);
                    this.restore_mode();
                    remove_redundant_indentation(this._output, this._previous_flags);
                    // do {} while () // no statement required after
                    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
                        this._previous_flags.mode = MODE.Expression;
                        this._flags.do_block = false;
                        this._flags.do_while = false;
                    }
                };
                Beautifier.prototype.handle_start_block = function(current_token) {
                    this.handle_whitespace_and_comments(current_token);
                    // Check if this is should be treated as a ObjectLiteral
                    var next_token = this._tokens.peek();
                    var second_token = this._tokens.peek(1);
                    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
                        this.set_mode(MODE.BlockStatement);
                        this._flags.in_case_statement = true;
                    } else if (this._flags.case_body) {
                        this.set_mode(MODE.BlockStatement);
                    } else if (second_token && (in_array(second_token.text, [
                        ":",
                        ","
                    ]) && in_array(next_token.type, [
                        TOKEN.STRING,
                        TOKEN.WORD,
                        TOKEN.RESERVED
                    ]) || in_array(next_token.text, [
                        "get",
                        "set",
                        "..."
                    ]) && in_array(second_token.type, [
                        TOKEN.WORD,
                        TOKEN.RESERVED
                    ]))) {
                        // We don't support TypeScript,but we didn't break it for a very long time.
                        // We'll try to keep not breaking it.
                        if (in_array(this._last_last_text, [
                            "class",
                            "interface"
                        ]) && !in_array(second_token.text, [
                            ":",
                            ","
                        ])) {
                            this.set_mode(MODE.BlockStatement);
                        } else {
                            this.set_mode(MODE.ObjectLiteral);
                        }
                    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
                        // arrow function: (param1, paramN) => { statements }
                        this.set_mode(MODE.BlockStatement);
                    } else if (in_array(this._flags.last_token.type, [
                        TOKEN.EQUALS,
                        TOKEN.START_EXPR,
                        TOKEN.COMMA,
                        TOKEN.OPERATOR
                    ]) || reserved_array(this._flags.last_token, [
                        "return",
                        "throw",
                        "import",
                        "default"
                    ])) {
                        // Detecting shorthand function syntax is difficult by scanning forward,
                        //     so check the surrounding context.
                        // If the block is being returned, imported, export default, passed as arg,
                        //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
                        this.set_mode(MODE.ObjectLiteral);
                    } else {
                        this.set_mode(MODE.BlockStatement);
                    }
                    if (this._flags.last_token) {
                        if (reserved_array(this._flags.last_token.previous, [
                            "class",
                            "extends"
                        ])) {
                            this._flags.class_start_block = true;
                        }
                    }
                    var empty_braces = !next_token.comments_before && next_token.text === "}";
                    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
                    if (this._options.brace_preserve_inline) {
                        // search forward for a newline wanted inside this block
                        var index = 0;
                        var check_token = null;
                        this._flags.inline_frame = true;
                        do {
                            index += 1;
                            check_token = this._tokens.peek(index - 1);
                            if (check_token.newlines) {
                                this._flags.inline_frame = false;
                                break;
                            }
                        }while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
                    }
                    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
                        if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
                            this._output.space_before_token = true;
                        } else {
                            this.print_newline(false, true);
                        }
                    } else {
                        if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
                            if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
                                this._output.space_before_token = true;
                            }
                            if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
                                this.allow_wrap_or_preserved_newline(current_token);
                                this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
                                this._flags.multiline_frame = false;
                            }
                        }
                        if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
                            if (in_array(this._flags.last_token.type, [
                                TOKEN.START_BLOCK,
                                TOKEN.SEMICOLON
                            ]) && !this._flags.inline_frame) {
                                this.print_newline();
                            } else {
                                this._output.space_before_token = true;
                            }
                        }
                    }
                    this.print_token(current_token);
                    this.indent();
                    // Except for specific cases, open braces are followed by a new line.
                    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
                        this.print_newline();
                    }
                };
                Beautifier.prototype.handle_end_block = function(current_token) {
                    // statements must all be closed when their container closes
                    this.handle_whitespace_and_comments(current_token);
                    while(this._flags.mode === MODE.Statement){
                        this.restore_mode();
                    }
                    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
                    if (this._flags.inline_frame && !empty_braces) {
                        this._output.space_before_token = true;
                    } else if (this._options.brace_style === "expand") {
                        if (!empty_braces) {
                            this.print_newline();
                        }
                    } else {
                        // skip {}
                        if (!empty_braces) {
                            if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
                                // we REALLY need a newline here, but newliner would skip that
                                this._options.keep_array_indentation = false;
                                this.print_newline();
                                this._options.keep_array_indentation = true;
                            } else {
                                this.print_newline();
                            }
                        }
                    }
                    this.restore_mode();
                    this.print_token(current_token);
                };
                Beautifier.prototype.handle_word = function(current_token) {
                    if (current_token.type === TOKEN.RESERVED) {
                        if (in_array(current_token.text, [
                            "set",
                            "get"
                        ]) && this._flags.mode !== MODE.ObjectLiteral) {
                            current_token.type = TOKEN.WORD;
                        } else if (current_token.text === "import" && in_array(this._tokens.peek().text, [
                            "(",
                            "."
                        ])) {
                            current_token.type = TOKEN.WORD;
                        } else if (in_array(current_token.text, [
                            "as",
                            "from"
                        ]) && !this._flags.import_block) {
                            current_token.type = TOKEN.WORD;
                        } else if (this._flags.mode === MODE.ObjectLiteral) {
                            var next_token = this._tokens.peek();
                            if (next_token.text === ":") {
                                current_token.type = TOKEN.WORD;
                            }
                        }
                    }
                    if (this.start_of_statement(current_token)) {
                        // The conditional starts the statement if appropriate.
                        if (reserved_array(this._flags.last_token, [
                            "var",
                            "let",
                            "const"
                        ]) && current_token.type === TOKEN.WORD) {
                            this._flags.declaration_statement = true;
                        }
                    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++") && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, [
                        "var",
                        "let",
                        "const",
                        "set",
                        "get"
                    ]))) {
                        this.handle_whitespace_and_comments(current_token);
                        this.print_newline();
                    } else {
                        this.handle_whitespace_and_comments(current_token);
                    }
                    if (this._flags.do_block && !this._flags.do_while) {
                        if (reserved_word(current_token, "while")) {
                            // do {} ## while ()
                            this._output.space_before_token = true;
                            this.print_token(current_token);
                            this._output.space_before_token = true;
                            this._flags.do_while = true;
                            return;
                        } else {
                            // do {} should always have while as the next word.
                            // if we don't see the expected while, recover
                            this.print_newline();
                            this._flags.do_block = false;
                        }
                    }
                    // if may be followed by else, or not
                    // Bare/inline ifs are tricky
                    // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
                    if (this._flags.if_block) {
                        if (!this._flags.else_block && reserved_word(current_token, "else")) {
                            this._flags.else_block = true;
                        } else {
                            while(this._flags.mode === MODE.Statement){
                                this.restore_mode();
                            }
                            this._flags.if_block = false;
                            this._flags.else_block = false;
                        }
                    }
                    if (this._flags.in_case_statement && reserved_array(current_token, [
                        "case",
                        "default"
                    ])) {
                        this.print_newline();
                        if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
                            // switch cases following one another
                            this.deindent();
                        }
                        this._flags.case_body = false;
                        this.print_token(current_token);
                        this._flags.in_case = true;
                        return;
                    }
                    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
                        if (!this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators
                        (in_array(this._flags.last_token.text, [
                            "+",
                            "-"
                        ]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
                            this.allow_wrap_or_preserved_newline(current_token);
                        }
                    }
                    if (reserved_word(current_token, "function")) {
                        if (in_array(this._flags.last_token.text, [
                            "}",
                            ";"
                        ]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, [
                            "(",
                            "[",
                            "{",
                            ":",
                            "=",
                            ","
                        ]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
                            // make sure there is a nice clean space of at least one blank line
                            // before a new function definition
                            if (!this._output.just_added_blankline() && !current_token.comments_before) {
                                this.print_newline();
                                this.print_newline(true);
                            }
                        }
                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
                            if (reserved_array(this._flags.last_token, [
                                "get",
                                "set",
                                "new",
                                "export"
                            ]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
                                this._output.space_before_token = true;
                            } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
                                this._output.space_before_token = true;
                            } else if (this._flags.last_token.text === "declare") {
                                // accomodates Typescript declare function formatting
                                this._output.space_before_token = true;
                            } else {
                                this.print_newline();
                            }
                        } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
                            // foo = function
                            this._output.space_before_token = true;
                        } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
                        // (function
                        } else {
                            this.print_newline();
                        }
                        this.print_token(current_token);
                        this._flags.last_word = current_token.text;
                        return;
                    }
                    var prefix = "NONE";
                    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
                        if (this._previous_flags.inline_frame) {
                            prefix = "SPACE";
                        } else if (!reserved_array(current_token, [
                            "else",
                            "catch",
                            "finally",
                            "from"
                        ])) {
                            prefix = "NEWLINE";
                        } else {
                            if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
                                prefix = "NEWLINE";
                            } else {
                                prefix = "SPACE";
                                this._output.space_before_token = true;
                            }
                        }
                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
                        // TODO: Should this be for STATEMENT as well?
                        prefix = "NEWLINE";
                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
                        prefix = "SPACE";
                    } else if (this._flags.last_token.type === TOKEN.STRING) {
                        prefix = "NEWLINE";
                    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, [
                        "function",
                        "yield"
                    ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [
                        "{",
                        ","
                    ]))) {
                        prefix = "SPACE";
                    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
                        if (this._flags.inline_frame) {
                            prefix = "SPACE";
                        } else {
                            prefix = "NEWLINE";
                        }
                    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
                        this._output.space_before_token = true;
                        prefix = "NEWLINE";
                    }
                    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
                        if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
                            prefix = "SPACE";
                        } else {
                            prefix = "NEWLINE";
                        }
                    }
                    if (reserved_array(current_token, [
                        "else",
                        "catch",
                        "finally"
                    ])) {
                        if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
                            this.print_newline();
                        } else {
                            this._output.trim(true);
                            var line = this._output.current_line;
                            // If we trimmed and there's something other than a close block before us
                            // put a newline back in.  Handles '} // comment' scenario.
                            if (line.last() !== "}") {
                                this.print_newline();
                            }
                            this._output.space_before_token = true;
                        }
                    } else if (prefix === "NEWLINE") {
                        if (reserved_array(this._flags.last_token, special_words)) {
                            // no newline between 'return nnn'
                            this._output.space_before_token = true;
                        } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, [
                            "var",
                            "let",
                            "const"
                        ])) {
                            // accomodates Typescript declare formatting
                            this._output.space_before_token = true;
                        } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
                            if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, [
                                "var",
                                "let",
                                "const"
                            ])) && this._flags.last_token.text !== ":") {
                                // no need to force newline on 'var': for (var x = 0...)
                                if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
                                    // no newline for } else if {
                                    this._output.space_before_token = true;
                                } else {
                                    this.print_newline();
                                }
                            }
                        } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
                            this.print_newline();
                        }
                    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
                        this.print_newline(); // }, in lists get a newline treatment
                    } else if (prefix === "SPACE") {
                        this._output.space_before_token = true;
                    }
                    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
                        this._output.space_before_token = true;
                    }
                    this.print_token(current_token);
                    this._flags.last_word = current_token.text;
                    if (current_token.type === TOKEN.RESERVED) {
                        if (current_token.text === "do") {
                            this._flags.do_block = true;
                        } else if (current_token.text === "if") {
                            this._flags.if_block = true;
                        } else if (current_token.text === "import") {
                            this._flags.import_block = true;
                        } else if (this._flags.import_block && reserved_word(current_token, "from")) {
                            this._flags.import_block = false;
                        }
                    }
                };
                Beautifier.prototype.handle_semicolon = function(current_token) {
                    if (this.start_of_statement(current_token)) {
                        // The conditional starts the statement if appropriate.
                        // Semicolon can be the start (and end) of a statement
                        this._output.space_before_token = false;
                    } else {
                        this.handle_whitespace_and_comments(current_token);
                    }
                    var next_token = this._tokens.peek();
                    while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block){
                        this.restore_mode();
                    }
                    // hacky but effective for the moment
                    if (this._flags.import_block) {
                        this._flags.import_block = false;
                    }
                    this.print_token(current_token);
                };
                Beautifier.prototype.handle_string = function(current_token) {
                    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) {
                    //Conditional for detectign backtick strings
                    } else if (this.start_of_statement(current_token)) {
                        // The conditional starts the statement if appropriate.
                        // One difference - strings want at least a space before
                        this._output.space_before_token = true;
                    } else {
                        this.handle_whitespace_and_comments(current_token);
                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
                            this._output.space_before_token = true;
                        } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
                            if (!this.start_of_object_property()) {
                                this.allow_wrap_or_preserved_newline(current_token);
                            }
                        } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
                            this._output.space_before_token = true;
                        } else {
                            this.print_newline();
                        }
                    }
                    this.print_token(current_token);
                };
                Beautifier.prototype.handle_equals = function(current_token) {
                    if (this.start_of_statement(current_token)) {
                    // The conditional starts the statement if appropriate.
                    } else {
                        this.handle_whitespace_and_comments(current_token);
                    }
                    if (this._flags.declaration_statement) {
                        // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
                        this._flags.declaration_assignment = true;
                    }
                    this._output.space_before_token = true;
                    this.print_token(current_token);
                    this._output.space_before_token = true;
                };
                Beautifier.prototype.handle_comma = function(current_token) {
                    this.handle_whitespace_and_comments(current_token, true);
                    this.print_token(current_token);
                    this._output.space_before_token = true;
                    if (this._flags.declaration_statement) {
                        if (is_expression(this._flags.parent.mode)) {
                            // do not break on comma, for(var a = 1, b = 2)
                            this._flags.declaration_assignment = false;
                        }
                        if (this._flags.declaration_assignment) {
                            this._flags.declaration_assignment = false;
                            this.print_newline(false, true);
                        } else if (this._options.comma_first) {
                            // for comma-first, we want to allow a newline before the comma
                            // to turn into a newline after the comma, which we will fixup later
                            this.allow_wrap_or_preserved_newline(current_token);
                        }
                    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
                        if (this._flags.mode === MODE.Statement) {
                            this.restore_mode();
                        }
                        if (!this._flags.inline_frame) {
                            this.print_newline();
                        }
                    } else if (this._options.comma_first) {
                        // EXPR or DO_BLOCK
                        // for comma-first, we want to allow a newline before the comma
                        // to turn into a newline after the comma, which we will fixup later
                        this.allow_wrap_or_preserved_newline(current_token);
                    }
                };
                Beautifier.prototype.handle_operator = function(current_token) {
                    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, [
                        "function",
                        "yield"
                    ]) || in_array(this._flags.last_token.type, [
                        TOKEN.START_BLOCK,
                        TOKEN.COMMA,
                        TOKEN.END_BLOCK,
                        TOKEN.SEMICOLON
                    ]));
                    var isUnary = in_array(current_token.text, [
                        "-",
                        "+"
                    ]) && (in_array(this._flags.last_token.type, [
                        TOKEN.START_BLOCK,
                        TOKEN.START_EXPR,
                        TOKEN.EQUALS,
                        TOKEN.OPERATOR
                    ]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
                    if (this.start_of_statement(current_token)) {
                    // The conditional starts the statement if appropriate.
                    } else {
                        var preserve_statement_flags = !isGeneratorAsterisk;
                        this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
                    }
                    // hack for actionscript's import .*;
                    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
                        this.print_token(current_token);
                        return;
                    }
                    if (current_token.text === "::") {
                        // no spaces around exotic namespacing syntax operator
                        this.print_token(current_token);
                        return;
                    }
                    if (in_array(current_token.text, [
                        "-",
                        "+"
                    ]) && this.start_of_object_property()) {
                        // numeric value with +/- symbol in front as a property
                        this.print_token(current_token);
                        return;
                    }
                    // Allow line wrapping between operators when operator_position is
                    //   set to before or preserve
                    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
                        this.allow_wrap_or_preserved_newline(current_token);
                    }
                    if (current_token.text === ":" && this._flags.in_case) {
                        this.print_token(current_token);
                        this._flags.in_case = false;
                        this._flags.case_body = true;
                        if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
                            this.indent();
                            this.print_newline();
                            this._flags.case_block = false;
                        } else {
                            this._flags.case_block = true;
                            this._output.space_before_token = true;
                        }
                        return;
                    }
                    var space_before = true;
                    var space_after = true;
                    var in_ternary = false;
                    if (current_token.text === ":") {
                        if (this._flags.ternary_depth === 0) {
                            // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
                            space_before = false;
                        } else {
                            this._flags.ternary_depth -= 1;
                            in_ternary = true;
                        }
                    } else if (current_token.text === "?") {
                        this._flags.ternary_depth += 1;
                    }
                    // let's handle the operator_position option prior to any conflicting logic
                    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
                        var isColon = current_token.text === ":";
                        var isTernaryColon = isColon && in_ternary;
                        var isOtherColon = isColon && !in_ternary;
                        switch(this._options.operator_position){
                            case OPERATOR_POSITION.before_newline:
                                // if the current token is : and it's not a ternary statement then we set space_before to false
                                this._output.space_before_token = !isOtherColon;
                                this.print_token(current_token);
                                if (!isColon || isTernaryColon) {
                                    this.allow_wrap_or_preserved_newline(current_token);
                                }
                                this._output.space_before_token = true;
                                return;
                            case OPERATOR_POSITION.after_newline:
                                // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
                                //   then print a newline.
                                this._output.space_before_token = true;
                                if (!isColon || isTernaryColon) {
                                    if (this._tokens.peek().newlines) {
                                        this.print_newline(false, true);
                                    } else {
                                        this.allow_wrap_or_preserved_newline(current_token);
                                    }
                                } else {
                                    this._output.space_before_token = false;
                                }
                                this.print_token(current_token);
                                this._output.space_before_token = true;
                                return;
                            case OPERATOR_POSITION.preserve_newline:
                                if (!isOtherColon) {
                                    this.allow_wrap_or_preserved_newline(current_token);
                                }
                                // if we just added a newline, or the current token is : and it's not a ternary statement,
                                //   then we set space_before to false
                                space_before = !(this._output.just_added_newline() || isOtherColon);
                                this._output.space_before_token = space_before;
                                this.print_token(current_token);
                                this._output.space_before_token = true;
                                return;
                        }
                    }
                    if (isGeneratorAsterisk) {
                        this.allow_wrap_or_preserved_newline(current_token);
                        space_before = false;
                        var next_token = this._tokens.peek();
                        space_after = next_token && in_array(next_token.type, [
                            TOKEN.WORD,
                            TOKEN.RESERVED
                        ]);
                    } else if (current_token.text === "...") {
                        this.allow_wrap_or_preserved_newline(current_token);
                        space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
                        space_after = false;
                    } else if (in_array(current_token.text, [
                        "--",
                        "++",
                        "!",
                        "~"
                    ]) || isUnary) {
                        // unary operators (and binary +/- pretending to be unary) special cases
                        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
                            this.allow_wrap_or_preserved_newline(current_token);
                        }
                        space_before = false;
                        space_after = false;
                        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
                        // if there is a newline between -- or ++ and anything else we should preserve it.
                        if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
                            var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
                            if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
                                this.restore_mode();
                            }
                            this.print_newline(new_line_needed, true);
                        }
                        if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
                            // for (;; ++i)
                            //        ^^^
                            space_before = true;
                        }
                        if (this._flags.last_token.type === TOKEN.RESERVED) {
                            space_before = true;
                        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
                            space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
                        } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
                            // a++ + ++b;
                            // a - -b
                            space_before = in_array(current_token.text, [
                                "--",
                                "-",
                                "++",
                                "+"
                            ]) && in_array(this._flags.last_token.text, [
                                "--",
                                "-",
                                "++",
                                "+"
                            ]);
                            // + and - are not unary when preceeded by -- or ++ operator
                            // a-- + b
                            // a * +b
                            // a - -b
                            if (in_array(current_token.text, [
                                "+",
                                "-"
                            ]) && in_array(this._flags.last_token.text, [
                                "--",
                                "++"
                            ])) {
                                space_after = true;
                            }
                        }
                        if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
                            // { foo; --i }
                            // foo(); --bar;
                            this.print_newline();
                        }
                    }
                    this._output.space_before_token = this._output.space_before_token || space_before;
                    this.print_token(current_token);
                    this._output.space_before_token = space_after;
                };
                Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
                    if (this._output.raw) {
                        this._output.add_raw_token(current_token);
                        if (current_token.directives && current_token.directives.preserve === "end") {
                            // If we're testing the raw output behavior, do not allow a directive to turn it off.
                            this._output.raw = this._options.test_output_raw;
                        }
                        return;
                    }
                    if (current_token.directives) {
                        this.print_newline(false, preserve_statement_flags);
                        this.print_token(current_token);
                        if (current_token.directives.preserve === "start") {
                            this._output.raw = true;
                        }
                        this.print_newline(false, true);
                        return;
                    }
                    // inline block
                    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
                        this._output.space_before_token = true;
                        this.print_token(current_token);
                        this._output.space_before_token = true;
                        return;
                    } else {
                        this.print_block_commment(current_token, preserve_statement_flags);
                    }
                };
                Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
                    var lines = split_linebreaks(current_token.text);
                    var j; // iterator for this case
                    var javadoc = false;
                    var starless = false;
                    var lastIndent = current_token.whitespace_before;
                    var lastIndentLength = lastIndent.length;
                    // block comment starts with a new line
                    this.print_newline(false, preserve_statement_flags);
                    // first line always indented
                    this.print_token_line_indentation(current_token);
                    this._output.add_token(lines[0]);
                    this.print_newline(false, preserve_statement_flags);
                    if (lines.length > 1) {
                        lines = lines.slice(1);
                        javadoc = all_lines_start_with(lines, "*");
                        starless = each_line_matches_indent(lines, lastIndent);
                        if (javadoc) {
                            this._flags.alignment = 1;
                        }
                        for(j = 0; j < lines.length; j++){
                            if (javadoc) {
                                // javadoc: reformat and re-indent
                                this.print_token_line_indentation(current_token);
                                this._output.add_token(ltrim(lines[j]));
                            } else if (starless && lines[j]) {
                                // starless: re-indent non-empty content, avoiding trim
                                this.print_token_line_indentation(current_token);
                                this._output.add_token(lines[j].substring(lastIndentLength));
                            } else {
                                // normal comments output raw
                                this._output.current_line.set_indent(-1);
                                this._output.add_token(lines[j]);
                            }
                            // for comments on their own line or  more than one line, make sure there's a new line after
                            this.print_newline(false, preserve_statement_flags);
                        }
                        this._flags.alignment = 0;
                    }
                };
                Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
                    if (current_token.newlines) {
                        this.print_newline(false, preserve_statement_flags);
                    } else {
                        this._output.trim(true);
                    }
                    this._output.space_before_token = true;
                    this.print_token(current_token);
                    this.print_newline(false, preserve_statement_flags);
                };
                Beautifier.prototype.handle_dot = function(current_token) {
                    if (this.start_of_statement(current_token)) {
                    // The conditional starts the statement if appropriate.
                    } else {
                        this.handle_whitespace_and_comments(current_token, true);
                    }
                    if (this._flags.last_token.text.match("^[0-9]+$")) {
                        this._output.space_before_token = true;
                    }
                    if (reserved_array(this._flags.last_token, special_words)) {
                        this._output.space_before_token = false;
                    } else {
                        // allow preserved newlines before dots in general
                        // force newlines on dots after close paren when break_chained - for bar().baz()
                        this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
                    }
                    // Only unindent chained method dot if this dot starts a new line.
                    // Otherwise the automatic extra indentation removal will handle the over indent
                    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
                        this.deindent();
                    }
                    this.print_token(current_token);
                };
                Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
                    this.print_token(current_token);
                    if (current_token.text[current_token.text.length - 1] === "\n") {
                        this.print_newline(false, preserve_statement_flags);
                    }
                };
                Beautifier.prototype.handle_eof = function(current_token) {
                    // Unwind any open statements
                    while(this._flags.mode === MODE.Statement){
                        this.restore_mode();
                    }
                    this.handle_whitespace_and_comments(current_token);
                };
                module.exports.Beautifier = Beautifier;
            /***/ },
            /* 2 */ /***/ function(module) {
                /*jshint node:true */ /*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function OutputLine(parent) {
                    this.__parent = parent;
                    this.__character_count = 0;
                    // use indent_count as a marker for this.__lines that have preserved indentation
                    this.__indent_count = -1;
                    this.__alignment_count = 0;
                    this.__wrap_point_index = 0;
                    this.__wrap_point_character_count = 0;
                    this.__wrap_point_indent_count = -1;
                    this.__wrap_point_alignment_count = 0;
                    this.__items = [];
                }
                OutputLine.prototype.clone_empty = function() {
                    var line = new OutputLine(this.__parent);
                    line.set_indent(this.__indent_count, this.__alignment_count);
                    return line;
                };
                OutputLine.prototype.item = function(index) {
                    if (index < 0) {
                        return this.__items[this.__items.length + index];
                    } else {
                        return this.__items[index];
                    }
                };
                OutputLine.prototype.has_match = function(pattern) {
                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){
                        if (this.__items[lastCheckedOutput].match(pattern)) {
                            return true;
                        }
                    }
                    return false;
                };
                OutputLine.prototype.set_indent = function(indent, alignment) {
                    if (this.is_empty()) {
                        this.__indent_count = indent || 0;
                        this.__alignment_count = alignment || 0;
                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
                    }
                };
                OutputLine.prototype._set_wrap_point = function() {
                    if (this.__parent.wrap_line_length) {
                        this.__wrap_point_index = this.__items.length;
                        this.__wrap_point_character_count = this.__character_count;
                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
                    }
                };
                OutputLine.prototype._should_wrap = function() {
                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
                };
                OutputLine.prototype._allow_wrap = function() {
                    if (this._should_wrap()) {
                        this.__parent.add_new_line();
                        var next = this.__parent.current_line;
                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
                        next.__items = this.__items.slice(this.__wrap_point_index);
                        this.__items = this.__items.slice(0, this.__wrap_point_index);
                        next.__character_count += this.__character_count - this.__wrap_point_character_count;
                        this.__character_count = this.__wrap_point_character_count;
                        if (next.__items[0] === " ") {
                            next.__items.splice(0, 1);
                            next.__character_count -= 1;
                        }
                        return true;
                    }
                    return false;
                };
                OutputLine.prototype.is_empty = function() {
                    return this.__items.length === 0;
                };
                OutputLine.prototype.last = function() {
                    if (!this.is_empty()) {
                        return this.__items[this.__items.length - 1];
                    } else {
                        return null;
                    }
                };
                OutputLine.prototype.push = function(item) {
                    this.__items.push(item);
                    var last_newline_index = item.lastIndexOf("\n");
                    if (last_newline_index !== -1) {
                        this.__character_count = item.length - last_newline_index;
                    } else {
                        this.__character_count += item.length;
                    }
                };
                OutputLine.prototype.pop = function() {
                    var item = null;
                    if (!this.is_empty()) {
                        item = this.__items.pop();
                        this.__character_count -= item.length;
                    }
                    return item;
                };
                OutputLine.prototype._remove_indent = function() {
                    if (this.__indent_count > 0) {
                        this.__indent_count -= 1;
                        this.__character_count -= this.__parent.indent_size;
                    }
                };
                OutputLine.prototype._remove_wrap_indent = function() {
                    if (this.__wrap_point_indent_count > 0) {
                        this.__wrap_point_indent_count -= 1;
                    }
                };
                OutputLine.prototype.trim = function() {
                    while(this.last() === " "){
                        this.__items.pop();
                        this.__character_count -= 1;
                    }
                };
                OutputLine.prototype.toString = function() {
                    var result = "";
                    if (this.is_empty()) {
                        if (this.__parent.indent_empty_lines) {
                            result = this.__parent.get_indent_string(this.__indent_count);
                        }
                    } else {
                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
                        result += this.__items.join("");
                    }
                    return result;
                };
                function IndentStringCache(options, baseIndentString) {
                    this.__cache = [
                        ""
                    ];
                    this.__indent_size = options.indent_size;
                    this.__indent_string = options.indent_char;
                    if (!options.indent_with_tabs) {
                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
                    }
                    // Set to null to continue support for auto detection of base indent
                    baseIndentString = baseIndentString || "";
                    if (options.indent_level > 0) {
                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
                    }
                    this.__base_string = baseIndentString;
                    this.__base_string_length = baseIndentString.length;
                }
                IndentStringCache.prototype.get_indent_size = function(indent, column) {
                    var result = this.__base_string_length;
                    column = column || 0;
                    if (indent < 0) {
                        result = 0;
                    }
                    result += indent * this.__indent_size;
                    result += column;
                    return result;
                };
                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
                    var result = this.__base_string;
                    column = column || 0;
                    if (indent_level < 0) {
                        indent_level = 0;
                        result = "";
                    }
                    column += indent_level * this.__indent_size;
                    this.__ensure_cache(column);
                    result += this.__cache[column];
                    return result;
                };
                IndentStringCache.prototype.__ensure_cache = function(column) {
                    while(column >= this.__cache.length){
                        this.__add_column();
                    }
                };
                IndentStringCache.prototype.__add_column = function() {
                    var column = this.__cache.length;
                    var indent = 0;
                    var result = "";
                    if (this.__indent_size && column >= this.__indent_size) {
                        indent = Math.floor(column / this.__indent_size);
                        column -= indent * this.__indent_size;
                        result = new Array(indent + 1).join(this.__indent_string);
                    }
                    if (column) {
                        result += new Array(column + 1).join(" ");
                    }
                    this.__cache.push(result);
                };
                function Output(options, baseIndentString) {
                    this.__indent_cache = new IndentStringCache(options, baseIndentString);
                    this.raw = false;
                    this._end_with_newline = options.end_with_newline;
                    this.indent_size = options.indent_size;
                    this.wrap_line_length = options.wrap_line_length;
                    this.indent_empty_lines = options.indent_empty_lines;
                    this.__lines = [];
                    this.previous_line = null;
                    this.current_line = null;
                    this.next_line = new OutputLine(this);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                    // initialize
                    this.__add_outputline();
                }
                Output.prototype.__add_outputline = function() {
                    this.previous_line = this.current_line;
                    this.current_line = this.next_line.clone_empty();
                    this.__lines.push(this.current_line);
                };
                Output.prototype.get_line_number = function() {
                    return this.__lines.length;
                };
                Output.prototype.get_indent_string = function(indent, column) {
                    return this.__indent_cache.get_indent_string(indent, column);
                };
                Output.prototype.get_indent_size = function(indent, column) {
                    return this.__indent_cache.get_indent_size(indent, column);
                };
                Output.prototype.is_empty = function() {
                    return !this.previous_line && this.current_line.is_empty();
                };
                Output.prototype.add_new_line = function(force_newline) {
                    // never newline at the start of file
                    // otherwise, newline only if we didn't just add one or we're forced
                    if (this.is_empty() || !force_newline && this.just_added_newline()) {
                        return false;
                    }
                    // if raw output is enabled, don't print additional newlines,
                    // but still return True as though you had
                    if (!this.raw) {
                        this.__add_outputline();
                    }
                    return true;
                };
                Output.prototype.get_code = function(eol) {
                    this.trim(true);
                    // handle some edge cases where the last tokens
                    // has text that ends with newline(s)
                    var last_item = this.current_line.pop();
                    if (last_item) {
                        if (last_item[last_item.length - 1] === "\n") {
                            last_item = last_item.replace(/\n+$/g, "");
                        }
                        this.current_line.push(last_item);
                    }
                    if (this._end_with_newline) {
                        this.__add_outputline();
                    }
                    var sweet_code = this.__lines.join("\n");
                    if (eol !== "\n") {
                        sweet_code = sweet_code.replace(/[\n]/g, eol);
                    }
                    return sweet_code;
                };
                Output.prototype.set_wrap_point = function() {
                    this.current_line._set_wrap_point();
                };
                Output.prototype.set_indent = function(indent, alignment) {
                    indent = indent || 0;
                    alignment = alignment || 0;
                    // Next line stores alignment values
                    this.next_line.set_indent(indent, alignment);
                    // Never indent your first output indent at the start of the file
                    if (this.__lines.length > 1) {
                        this.current_line.set_indent(indent, alignment);
                        return true;
                    }
                    this.current_line.set_indent();
                    return false;
                };
                Output.prototype.add_raw_token = function(token) {
                    for(var x = 0; x < token.newlines; x++){
                        this.__add_outputline();
                    }
                    this.current_line.set_indent(-1);
                    this.current_line.push(token.whitespace_before);
                    this.current_line.push(token.text);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = false;
                };
                Output.prototype.add_token = function(printable_token) {
                    this.__add_space_before_token();
                    this.current_line.push(printable_token);
                    this.space_before_token = false;
                    this.non_breaking_space = false;
                    this.previous_token_wrapped = this.current_line._allow_wrap();
                };
                Output.prototype.__add_space_before_token = function() {
                    if (this.space_before_token && !this.just_added_newline()) {
                        if (!this.non_breaking_space) {
                            this.set_wrap_point();
                        }
                        this.current_line.push(" ");
                    }
                };
                Output.prototype.remove_indent = function(index) {
                    var output_length = this.__lines.length;
                    while(index < output_length){
                        this.__lines[index]._remove_indent();
                        index++;
                    }
                    this.current_line._remove_wrap_indent();
                };
                Output.prototype.trim = function(eat_newlines) {
                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
                    this.current_line.trim();
                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){
                        this.__lines.pop();
                        this.current_line = this.__lines[this.__lines.length - 1];
                        this.current_line.trim();
                    }
                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
                };
                Output.prototype.just_added_newline = function() {
                    return this.current_line.is_empty();
                };
                Output.prototype.just_added_blankline = function() {
                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
                };
                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
                    var index = this.__lines.length - 2;
                    while(index >= 0){
                        var potentialEmptyLine = this.__lines[index];
                        if (potentialEmptyLine.is_empty()) {
                            break;
                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
                            this.__lines.splice(index + 1, 0, new OutputLine(this));
                            this.previous_line = this.__lines[this.__lines.length - 2];
                            break;
                        }
                        index--;
                    }
                };
                module.exports.Output = Output;
            /***/ },
            /* 3 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Token(type, text, newlines, whitespace_before) {
                    this.type = type;
                    this.text = text;
                    // comments_before are
                    // comments that have a new line before them
                    // and may or may not have a newline after
                    // this is a set of comments before
                    this.comments_before = null; /* inline comment*/ 
                    // this.comments_after =  new TokenStream(); // no new line before and newline after
                    this.newlines = newlines || 0;
                    this.whitespace_before = whitespace_before || "";
                    this.parent = null;
                    this.next = null;
                    this.previous = null;
                    this.opened = null;
                    this.closed = null;
                    this.directives = null;
                }
                module.exports.Token = Token;
            /***/ },
            /* 4 */ /***/ function(__unused_webpack_module, exports1) {
                /* jshint node: true, curly: false */ // Parts of this section of code is taken from acorn.
                //
                // Acorn was written by Marijn Haverbeke and released under an MIT
                // license. The Unicode regexps (for identifiers and whitespace) were
                // taken from [Esprima](http://esprima.org) by Ariya Hidayat.
                //
                // Git repositories for Acorn are available at
                //
                //     http://marijnhaverbeke.nl/git/acorn
                //     https://github.com/marijnh/acorn.git
                // ## Character categories
                // acorn used char codes to squeeze the last bit of performance out
                // Beautifier is okay without that, so we're using regex
                // permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
                // 65 through 91 are uppercase letters.
                // permit _ (95).
                // 97 through 123 are lowercase letters.
                var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
                // inside an identifier @ is not allowed but 0-9 are.
                var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
                // Big ugly regular expressions that match characters in the
                // whitespace, identifier, and identifier-start categories. These
                // are only applied when a character is found to actually have a
                // code point above 128.
                var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
                var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
                //var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
                //var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
                var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
                var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
                var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
                exports1.identifier = new RegExp(identifierStart + identifierChars, "g");
                exports1.identifierStart = new RegExp(identifierStart);
                exports1.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
                var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line
                // Whether a single character denotes a newline.
                exports1.newline = /[\n\r\u2028\u2029]/;
                // Matches a whole line break (where CRLF is considered a single
                // line break). Used to count lines.
                // in javascript, these two differ
                // in python they are the same, different methods are called on them
                exports1.lineBreak = new RegExp("\r\n|" + exports1.newline.source);
                exports1.allLineBreaks = new RegExp(exports1.lineBreak.source, "g");
            /***/ },
            /* 5 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_122901__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var BaseOptions = __nested_webpack_require_122901__(6).Options;
                var validPositionValues = [
                    "before-newline",
                    "after-newline",
                    "preserve-newline"
                ];
                function Options(options) {
                    BaseOptions.call(this, options, "js");
                    // compatibility, re
                    var raw_brace_style = this.raw_options.brace_style || null;
                    if (raw_brace_style === "expand-strict") {
                        this.raw_options.brace_style = "expand";
                    } else if (raw_brace_style === "collapse-preserve-inline") {
                        this.raw_options.brace_style = "collapse,preserve-inline";
                    } else if (this.raw_options.braces_on_own_line !== undefined) {
                        this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
                    // } else if (!raw_brace_style) { //Nothing exists to set it
                    //   raw_brace_style = "collapse";
                    }
                    //preserve-inline in delimited string will trigger brace_preserve_inline, everything
                    //else is considered a brace_style and the last one only will have an effect
                    var brace_style_split = this._get_selection_list("brace_style", [
                        "collapse",
                        "expand",
                        "end-expand",
                        "none",
                        "preserve-inline"
                    ]);
                    this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
                    this.brace_style = "collapse";
                    for(var bs = 0; bs < brace_style_split.length; bs++){
                        if (brace_style_split[bs] === "preserve-inline") {
                            this.brace_preserve_inline = true;
                        } else {
                            this.brace_style = brace_style_split[bs];
                        }
                    }
                    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
                    this.break_chained_methods = this._get_boolean("break_chained_methods");
                    this.space_in_paren = this._get_boolean("space_in_paren");
                    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
                    this.jslint_happy = this._get_boolean("jslint_happy");
                    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
                    this.space_after_named_function = this._get_boolean("space_after_named_function");
                    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
                    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
                    this.unescape_strings = this._get_boolean("unescape_strings");
                    this.e4x = this._get_boolean("e4x");
                    this.comma_first = this._get_boolean("comma_first");
                    this.operator_position = this._get_selection("operator_position", validPositionValues);
                    // For testing of beautify preserve:start directive
                    this.test_output_raw = this._get_boolean("test_output_raw");
                    // force this._options.space_after_anon_function to true if this._options.jslint_happy
                    if (this.jslint_happy) {
                        this.space_after_anon_function = true;
                    }
                }
                Options.prototype = new BaseOptions();
                module.exports.Options = Options;
            /***/ },
            /* 6 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Options(options, merge_child_field) {
                    this.raw_options = _mergeOpts(options, merge_child_field);
                    // Support passing the source text back with no change
                    this.disabled = this._get_boolean("disabled");
                    this.eol = this._get_characters("eol", "auto");
                    this.end_with_newline = this._get_boolean("end_with_newline");
                    this.indent_size = this._get_number("indent_size", 4);
                    this.indent_char = this._get_characters("indent_char", " ");
                    this.indent_level = this._get_number("indent_level");
                    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
                    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
                    if (!this.preserve_newlines) {
                        this.max_preserve_newlines = 0;
                    }
                    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
                    if (this.indent_with_tabs) {
                        this.indent_char = "	";
                        // indent_size behavior changed after 1.8.6
                        // It used to be that indent_size would be
                        // set to 1 for indent_with_tabs. That is no longer needed and
                        // actually doesn't make sense - why not use spaces? Further,
                        // that might produce unexpected behavior - tabs being used
                        // for single-column alignment. So, when indent_with_tabs is true
                        // and indent_size is 1, reset indent_size to 4.
                        if (this.indent_size === 1) {
                            this.indent_size = 4;
                        }
                    }
                    // Backwards compat with 1.3.x
                    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
                    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']
                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).
                    // other values ignored
                    this.templating = this._get_selection_list("templating", [
                        "auto",
                        "none",
                        "angular",
                        "django",
                        "erb",
                        "handlebars",
                        "php",
                        "smarty"
                    ], [
                        "auto"
                    ]);
                }
                Options.prototype._get_array = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || [];
                    if (typeof option_value === "object") {
                        if (option_value !== null && typeof option_value.concat === "function") {
                            result = option_value.concat();
                        }
                    } else if (typeof option_value === "string") {
                        result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
                    }
                    return result;
                };
                Options.prototype._get_boolean = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = option_value === undefined ? !!default_value : !!option_value;
                    return result;
                };
                Options.prototype._get_characters = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    var result = default_value || "";
                    if (typeof option_value === "string") {
                        result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
                    }
                    return result;
                };
                Options.prototype._get_number = function(name, default_value) {
                    var option_value = this.raw_options[name];
                    default_value = parseInt(default_value, 10);
                    if (isNaN(default_value)) {
                        default_value = 0;
                    }
                    var result = parseInt(option_value, 10);
                    if (isNaN(result)) {
                        result = default_value;
                    }
                    return result;
                };
                Options.prototype._get_selection = function(name, selection_list, default_value) {
                    var result = this._get_selection_list(name, selection_list, default_value);
                    if (result.length !== 1) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result[0];
                };
                Options.prototype._get_selection_list = function(name, selection_list, default_value) {
                    if (!selection_list || selection_list.length === 0) {
                        throw new Error("Selection list cannot be empty.");
                    }
                    default_value = default_value || [
                        selection_list[0]
                    ];
                    if (!this._is_valid_selection(default_value, selection_list)) {
                        throw new Error("Invalid Default Value!");
                    }
                    var result = this._get_array(name, default_value);
                    if (!this._is_valid_selection(result, selection_list)) {
                        throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
                    }
                    return result;
                };
                Options.prototype._is_valid_selection = function(result, selection_list) {
                    return result.length && selection_list.length && !result.some(function(item) {
                        return selection_list.indexOf(item) === -1;
                    });
                };
                // merges child options up with the parent options object
                // Example: obj = {a: 1, b: {a: 2}}
                //          mergeOpts(obj, 'b')
                //
                //          Returns: {a: 2}
                function _mergeOpts(allOptions, childFieldName) {
                    var finalOpts = {};
                    allOptions = _normalizeOpts(allOptions);
                    var name;
                    for(name in allOptions){
                        if (name !== childFieldName) {
                            finalOpts[name] = allOptions[name];
                        }
                    }
                    //merge in the per type settings for the childFieldName
                    if (childFieldName && allOptions[childFieldName]) {
                        for(name in allOptions[childFieldName]){
                            finalOpts[name] = allOptions[childFieldName][name];
                        }
                    }
                    return finalOpts;
                }
                function _normalizeOpts(options) {
                    var convertedOpts = {};
                    var key;
                    for(key in options){
                        var newKey = key.replace(/-/g, "_");
                        convertedOpts[newKey] = options[key];
                    }
                    return convertedOpts;
                }
                module.exports.Options = Options;
                module.exports.normalizeOpts = _normalizeOpts;
                module.exports.mergeOpts = _mergeOpts;
            /***/ },
            /* 7 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_137493__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var InputScanner = __nested_webpack_require_137493__(8).InputScanner;
                var BaseTokenizer = __nested_webpack_require_137493__(9).Tokenizer;
                var BASETOKEN = __nested_webpack_require_137493__(9).TOKEN;
                var Directives = __nested_webpack_require_137493__(13).Directives;
                var acorn = __nested_webpack_require_137493__(4);
                var Pattern = __nested_webpack_require_137493__(12).Pattern;
                var TemplatablePattern = __nested_webpack_require_137493__(14).TemplatablePattern;
                function in_array(what, arr) {
                    return arr.indexOf(what) !== -1;
                }
                var TOKEN = {
                    START_EXPR: "TK_START_EXPR",
                    END_EXPR: "TK_END_EXPR",
                    START_BLOCK: "TK_START_BLOCK",
                    END_BLOCK: "TK_END_BLOCK",
                    WORD: "TK_WORD",
                    RESERVED: "TK_RESERVED",
                    SEMICOLON: "TK_SEMICOLON",
                    STRING: "TK_STRING",
                    EQUALS: "TK_EQUALS",
                    OPERATOR: "TK_OPERATOR",
                    COMMA: "TK_COMMA",
                    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
                    COMMENT: "TK_COMMENT",
                    DOT: "TK_DOT",
                    UNKNOWN: "TK_UNKNOWN",
                    START: BASETOKEN.START,
                    RAW: BASETOKEN.RAW,
                    EOF: BASETOKEN.EOF
                };
                var directives_core = new Directives(/\/\*/, /\*\//);
                var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
                var digit = /[0-9]/;
                // Dot "." must be distinguished from "..." and decimal
                var dot_pattern = /[^\d\.]/;
                var positionable_operators = (">>> === !== &&= ??= ||= " + "<< && >= ** != == <= >> || ?? |> " + "< / - + > : & % ? ^ | *").split(" ");
                // IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
                // Also, you must update possitionable operators separately from punct
                var punct = ">>>= " + "... >>= <<= === >>> !== **= &&= ??= ||= " + "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " + "= ! ? > < : / ^ - + * & % ~ |";
                punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
                // ?. but not if followed by a number 
                punct = "\\?\\.(?!\\d) " + punct;
                punct = punct.replace(/ /g, "|");
                var punct_pattern = new RegExp(punct);
                // words which should always start on new line.
                var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
                var reserved_words = line_starters.concat([
                    "do",
                    "in",
                    "of",
                    "else",
                    "get",
                    "set",
                    "new",
                    "catch",
                    "finally",
                    "typeof",
                    "yield",
                    "async",
                    "await",
                    "from",
                    "as",
                    "class",
                    "extends"
                ]);
                var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
                // var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;
                var in_html_comment;
                var Tokenizer = function(input_string, options) {
                    BaseTokenizer.call(this, input_string, options);
                    this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
                    var pattern_reader = new Pattern(this._input);
                    var templatable = new TemplatablePattern(this._input).read_options(this._options);
                    this.__patterns = {
                        template: templatable,
                        identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
                        number: pattern_reader.matching(number_pattern),
                        punct: pattern_reader.matching(punct_pattern),
                        // comment ends just before nearest linefeed or end of file
                        comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
                        //  /* ... */ comment ends with nearest */ or end of file
                        block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
                        html_comment_start: pattern_reader.matching(/<!--/),
                        html_comment_end: pattern_reader.matching(/-->/),
                        include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
                        shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
                        xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
                        single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
                        double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
                        template_text: templatable.until(/[`\\$]/),
                        template_expression: templatable.until(/[`}\\]/)
                    };
                };
                Tokenizer.prototype = new BaseTokenizer();
                Tokenizer.prototype._is_comment = function(current_token) {
                    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
                };
                Tokenizer.prototype._is_opening = function(current_token) {
                    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
                };
                Tokenizer.prototype._is_closing = function(current_token, open_token) {
                    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{");
                };
                Tokenizer.prototype._reset = function() {
                    in_html_comment = false;
                };
                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
                    var token = null;
                    this._readWhitespace();
                    var c = this._input.peek();
                    if (c === null) {
                        return this._create_token(TOKEN.EOF, "");
                    }
                    token = token || this._read_non_javascript(c);
                    token = token || this._read_string(c);
                    token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'
                    token = token || this._read_word(previous_token);
                    token = token || this._read_singles(c);
                    token = token || this._read_comment(c);
                    token = token || this._read_regexp(c, previous_token);
                    token = token || this._read_xml(c, previous_token);
                    token = token || this._read_punctuation();
                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
                    return token;
                };
                Tokenizer.prototype._read_word = function(previous_token) {
                    var resulting_string;
                    resulting_string = this.__patterns.identifier.read();
                    if (resulting_string !== "") {
                        resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
                        if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
                            if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
                                return this._create_token(TOKEN.OPERATOR, resulting_string);
                            }
                            return this._create_token(TOKEN.RESERVED, resulting_string);
                        }
                        return this._create_token(TOKEN.WORD, resulting_string);
                    }
                    resulting_string = this.__patterns.number.read();
                    if (resulting_string !== "") {
                        return this._create_token(TOKEN.WORD, resulting_string);
                    }
                };
                Tokenizer.prototype._read_singles = function(c) {
                    var token = null;
                    if (c === "(" || c === "[") {
                        token = this._create_token(TOKEN.START_EXPR, c);
                    } else if (c === ")" || c === "]") {
                        token = this._create_token(TOKEN.END_EXPR, c);
                    } else if (c === "{") {
                        token = this._create_token(TOKEN.START_BLOCK, c);
                    } else if (c === "}") {
                        token = this._create_token(TOKEN.END_BLOCK, c);
                    } else if (c === ";") {
                        token = this._create_token(TOKEN.SEMICOLON, c);
                    } else if (c === "." && dot_pattern.test(this._input.peek(1))) {
                        token = this._create_token(TOKEN.DOT, c);
                    } else if (c === ",") {
                        token = this._create_token(TOKEN.COMMA, c);
                    }
                    if (token) {
                        this._input.next();
                    }
                    return token;
                };
                Tokenizer.prototype._read_pair = function(c, d) {
                    var token = null;
                    if (c === "#" && d === "{") {
                        token = this._create_token(TOKEN.START_BLOCK, c + d);
                    }
                    if (token) {
                        this._input.next();
                        this._input.next();
                    }
                    return token;
                };
                Tokenizer.prototype._read_punctuation = function() {
                    var resulting_string = this.__patterns.punct.read();
                    if (resulting_string !== "") {
                        if (resulting_string === "=") {
                            return this._create_token(TOKEN.EQUALS, resulting_string);
                        } else if (resulting_string === "?.") {
                            return this._create_token(TOKEN.DOT, resulting_string);
                        } else {
                            return this._create_token(TOKEN.OPERATOR, resulting_string);
                        }
                    }
                };
                Tokenizer.prototype._read_non_javascript = function(c) {
                    var resulting_string = "";
                    if (c === "#") {
                        if (this._is_first_token()) {
                            resulting_string = this.__patterns.shebang.read();
                            if (resulting_string) {
                                return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
                            }
                        }
                        // handles extendscript #includes
                        resulting_string = this.__patterns.include.read();
                        if (resulting_string) {
                            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
                        }
                        c = this._input.next();
                        // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
                        var sharp = "#";
                        if (this._input.hasNext() && this._input.testChar(digit)) {
                            do {
                                c = this._input.next();
                                sharp += c;
                            }while (this._input.hasNext() && c !== "#" && c !== "=");
                            if (c === "#") {
                            //
                            } else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
                                sharp += "[]";
                                this._input.next();
                                this._input.next();
                            } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
                                sharp += "{}";
                                this._input.next();
                                this._input.next();
                            }
                            return this._create_token(TOKEN.WORD, sharp);
                        }
                        this._input.back();
                    } else if (c === "<" && this._is_first_token()) {
                        resulting_string = this.__patterns.html_comment_start.read();
                        if (resulting_string) {
                            while(this._input.hasNext() && !this._input.testChar(acorn.newline)){
                                resulting_string += this._input.next();
                            }
                            in_html_comment = true;
                            return this._create_token(TOKEN.COMMENT, resulting_string);
                        }
                    } else if (in_html_comment && c === "-") {
                        resulting_string = this.__patterns.html_comment_end.read();
                        if (resulting_string) {
                            in_html_comment = false;
                            return this._create_token(TOKEN.COMMENT, resulting_string);
                        }
                    }
                    return null;
                };
                Tokenizer.prototype._read_comment = function(c) {
                    var token = null;
                    if (c === "/") {
                        var comment = "";
                        if (this._input.peek(1) === "*") {
                            // peek for comment /* ... */
                            comment = this.__patterns.block_comment.read();
                            var directives = directives_core.get_directives(comment);
                            if (directives && directives.ignore === "start") {
                                comment += directives_core.readIgnored(this._input);
                            }
                            comment = comment.replace(acorn.allLineBreaks, "\n");
                            token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
                            token.directives = directives;
                        } else if (this._input.peek(1) === "/") {
                            // peek for comment // ...
                            comment = this.__patterns.comment.read();
                            token = this._create_token(TOKEN.COMMENT, comment);
                        }
                    }
                    return token;
                };
                Tokenizer.prototype._read_string = function(c) {
                    if (c === "`" || c === "'" || c === '"') {
                        var resulting_string = this._input.next();
                        this.has_char_escapes = false;
                        if (c === "`") {
                            resulting_string += this._read_string_recursive("`", true, "${");
                        } else {
                            resulting_string += this._read_string_recursive(c);
                        }
                        if (this.has_char_escapes && this._options.unescape_strings) {
                            resulting_string = unescape_string(resulting_string);
                        }
                        if (this._input.peek() === c) {
                            resulting_string += this._input.next();
                        }
                        resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
                        return this._create_token(TOKEN.STRING, resulting_string);
                    }
                    return null;
                };
                Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
                    // regex and xml can only appear in specific locations during parsing
                    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, [
                        "return",
                        "case",
                        "throw",
                        "else",
                        "do",
                        "typeof",
                        "yield"
                    ]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, [
                        "if",
                        "while",
                        "for"
                    ]) || in_array(previous_token.type, [
                        TOKEN.COMMENT,
                        TOKEN.START_EXPR,
                        TOKEN.START_BLOCK,
                        TOKEN.START,
                        TOKEN.END_BLOCK,
                        TOKEN.OPERATOR,
                        TOKEN.EQUALS,
                        TOKEN.EOF,
                        TOKEN.SEMICOLON,
                        TOKEN.COMMA
                    ]);
                };
                Tokenizer.prototype._read_regexp = function(c, previous_token) {
                    if (c === "/" && this._allow_regexp_or_xml(previous_token)) {
                        // handle regexp
                        //
                        var resulting_string = this._input.next();
                        var esc = false;
                        var in_char_class = false;
                        while(this._input.hasNext() && (esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn.newline)){
                            resulting_string += this._input.peek();
                            if (!esc) {
                                esc = this._input.peek() === "\\";
                                if (this._input.peek() === "[") {
                                    in_char_class = true;
                                } else if (this._input.peek() === "]") {
                                    in_char_class = false;
                                }
                            } else {
                                esc = false;
                            }
                            this._input.next();
                        }
                        if (this._input.peek() === c) {
                            resulting_string += this._input.next();
                            // regexps may have modifiers /regexp/MOD , so fetch those, too
                            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
                            resulting_string += this._input.read(acorn.identifier);
                        }
                        return this._create_token(TOKEN.STRING, resulting_string);
                    }
                    return null;
                };
                Tokenizer.prototype._read_xml = function(c, previous_token) {
                    if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
                        var xmlStr = "";
                        var match = this.__patterns.xml.read_match();
                        // handle e4x xml literals
                        //
                        if (match) {
                            // Trim root tag to attempt to
                            var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
                            var isCurlyRoot = rootTag.indexOf("{") === 0;
                            var depth = 0;
                            while(match){
                                var isEndTag = !!match[1];
                                var tagName = match[2];
                                var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
                                if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
                                    if (isEndTag) {
                                        --depth;
                                    } else {
                                        ++depth;
                                    }
                                }
                                xmlStr += match[0];
                                if (depth <= 0) {
                                    break;
                                }
                                match = this.__patterns.xml.read_match();
                            }
                            // if we didn't close correctly, keep unformatted.
                            if (!match) {
                                xmlStr += this._input.match(/[\s\S]*/g)[0];
                            }
                            xmlStr = xmlStr.replace(acorn.allLineBreaks, "\n");
                            return this._create_token(TOKEN.STRING, xmlStr);
                        }
                    }
                    return null;
                };
                function unescape_string(s) {
                    // You think that a regex would work for this
                    // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
                    //         return String.fromCharCode(parseInt(val, 16));
                    //     })
                    // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
                    var out = "", escaped = 0;
                    var input_scan = new InputScanner(s);
                    var matched = null;
                    while(input_scan.hasNext()){
                        // Keep any whitespace, non-slash characters
                        // also keep slash pairs.
                        matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
                        if (matched) {
                            out += matched[0];
                        }
                        if (input_scan.peek() === "\\") {
                            input_scan.next();
                            if (input_scan.peek() === "x") {
                                matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
                            } else if (input_scan.peek() === "u") {
                                matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
                                if (!matched) {
                                    matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
                                }
                            } else {
                                out += "\\";
                                if (input_scan.hasNext()) {
                                    out += input_scan.next();
                                }
                                continue;
                            }
                            // If there's some error decoding, return the original string
                            if (!matched) {
                                return s;
                            }
                            escaped = parseInt(matched[1], 16);
                            if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf("x") === 0) {
                                // we bail out on \x7f..\xff,
                                // leaving whole string escaped,
                                // as it's probably completely binary
                                return s;
                            } else if (escaped >= 0x00 && escaped < 0x20) {
                                // leave 0x00...0x1f escaped
                                out += "\\" + matched[0];
                            } else if (escaped > 0x10FFFF) {
                                // If the escape sequence is out of bounds, keep the original sequence and continue conversion
                                out += "\\" + matched[0];
                            } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                                // single-quote, apostrophe, backslash - escape these
                                out += "\\" + String.fromCharCode(escaped);
                            } else {
                                out += String.fromCharCode(escaped);
                            }
                        }
                    }
                    return out;
                }
                // handle string
                //
                Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
                    var current_char;
                    var pattern;
                    if (delimiter === "'") {
                        pattern = this.__patterns.single_quote;
                    } else if (delimiter === '"') {
                        pattern = this.__patterns.double_quote;
                    } else if (delimiter === "`") {
                        pattern = this.__patterns.template_text;
                    } else if (delimiter === "}") {
                        pattern = this.__patterns.template_expression;
                    }
                    var resulting_string = pattern.read();
                    var next = "";
                    while(this._input.hasNext()){
                        next = this._input.next();
                        if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {
                            this._input.back();
                            break;
                        } else if (next === "\\" && this._input.hasNext()) {
                            current_char = this._input.peek();
                            if (current_char === "x" || current_char === "u") {
                                this.has_char_escapes = true;
                            } else if (current_char === "\r" && this._input.peek(1) === "\n") {
                                this._input.next();
                            }
                            next += this._input.next();
                        } else if (start_sub) {
                            if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
                                next += this._input.next();
                            }
                            if (start_sub === next) {
                                if (delimiter === "`") {
                                    next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
                                } else {
                                    next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
                                }
                                if (this._input.hasNext()) {
                                    next += this._input.next();
                                }
                            }
                        }
                        next += pattern.read();
                        resulting_string += next;
                    }
                    return resulting_string;
                };
                module.exports.Tokenizer = Tokenizer;
                module.exports.TOKEN = TOKEN;
                module.exports.positionable_operators = positionable_operators.slice();
                module.exports.line_starters = line_starters.slice();
            /***/ },
            /* 8 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
                function InputScanner(input_string) {
                    this.__input = input_string || "";
                    this.__input_length = this.__input.length;
                    this.__position = 0;
                }
                InputScanner.prototype.restart = function() {
                    this.__position = 0;
                };
                InputScanner.prototype.back = function() {
                    if (this.__position > 0) {
                        this.__position -= 1;
                    }
                };
                InputScanner.prototype.hasNext = function() {
                    return this.__position < this.__input_length;
                };
                InputScanner.prototype.next = function() {
                    var val = null;
                    if (this.hasNext()) {
                        val = this.__input.charAt(this.__position);
                        this.__position += 1;
                    }
                    return val;
                };
                InputScanner.prototype.peek = function(index) {
                    var val = null;
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        val = this.__input.charAt(index);
                    }
                    return val;
                };
                // This is a JavaScript only helper function (not in python)
                // Javascript doesn't have a match method
                // and not all implementation support "sticky" flag.
                // If they do not support sticky then both this.match() and this.test() method
                // must get the match and check the index of the match.
                // If sticky is supported and set, this method will use it.
                // Otherwise it will check that global is set, and fall back to the slower method.
                InputScanner.prototype.__match = function(pattern, index) {
                    pattern.lastIndex = index;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
                        if (pattern_match.index !== index) {
                            pattern_match = null;
                        }
                    }
                    return pattern_match;
                };
                InputScanner.prototype.test = function(pattern, index) {
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__input_length) {
                        return !!this.__match(pattern, index);
                    } else {
                        return false;
                    }
                };
                InputScanner.prototype.testChar = function(pattern, index) {
                    // test one character regex match
                    var val = this.peek(index);
                    pattern.lastIndex = 0;
                    return val !== null && pattern.test(val);
                };
                InputScanner.prototype.match = function(pattern) {
                    var pattern_match = this.__match(pattern, this.__position);
                    if (pattern_match) {
                        this.__position += pattern_match[0].length;
                    } else {
                        pattern_match = null;
                    }
                    return pattern_match;
                };
                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
                    var val = "";
                    var match;
                    if (starting_pattern) {
                        match = this.match(starting_pattern);
                        if (match) {
                            val += match[0];
                        }
                    }
                    if (until_pattern && (match || !starting_pattern)) {
                        val += this.readUntil(until_pattern, until_after);
                    }
                    return val;
                };
                InputScanner.prototype.readUntil = function(pattern, until_after) {
                    var val = "";
                    var match_index = this.__position;
                    pattern.lastIndex = this.__position;
                    var pattern_match = pattern.exec(this.__input);
                    if (pattern_match) {
                        match_index = pattern_match.index;
                        if (until_after) {
                            match_index += pattern_match[0].length;
                        }
                    } else {
                        match_index = this.__input_length;
                    }
                    val = this.__input.substring(this.__position, match_index);
                    this.__position = match_index;
                    return val;
                };
                InputScanner.prototype.readUntilAfter = function(pattern) {
                    return this.readUntil(pattern, true);
                };
                InputScanner.prototype.get_regexp = function(pattern, match_from) {
                    var result = null;
                    var flags = "g";
                    if (match_from && regexp_has_sticky) {
                        flags = "y";
                    }
                    // strings are converted to regexp
                    if (typeof pattern === "string" && pattern !== "") {
                        // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
                        result = new RegExp(pattern, flags);
                    } else if (pattern) {
                        result = new RegExp(pattern.source, flags);
                    }
                    return result;
                };
                InputScanner.prototype.get_literal_regexp = function(literal_string) {
                    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
                };
                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {
                    var start = this.__position;
                    var val = this.readUntilAfter(pattern);
                    this.__position = start;
                    return val;
                };
                InputScanner.prototype.lookBack = function(testVal) {
                    var start = this.__position - 1;
                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
                };
                module.exports.InputScanner = InputScanner;
            /***/ },
            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_175339__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var InputScanner = __nested_webpack_require_175339__(8).InputScanner;
                var Token = __nested_webpack_require_175339__(3).Token;
                var TokenStream = __nested_webpack_require_175339__(10).TokenStream;
                var WhitespacePattern = __nested_webpack_require_175339__(11).WhitespacePattern;
                var TOKEN = {
                    START: "TK_START",
                    RAW: "TK_RAW",
                    EOF: "TK_EOF"
                };
                var Tokenizer = function(input_string, options) {
                    this._input = new InputScanner(input_string);
                    this._options = options || {};
                    this.__tokens = null;
                    this._patterns = {};
                    this._patterns.whitespace = new WhitespacePattern(this._input);
                };
                Tokenizer.prototype.tokenize = function() {
                    this._input.restart();
                    this.__tokens = new TokenStream();
                    this._reset();
                    var current;
                    var previous = new Token(TOKEN.START, "");
                    var open_token = null;
                    var open_stack = [];
                    var comments = new TokenStream();
                    while(previous.type !== TOKEN.EOF){
                        current = this._get_next_token(previous, open_token);
                        while(this._is_comment(current)){
                            comments.add(current);
                            current = this._get_next_token(previous, open_token);
                        }
                        if (!comments.isEmpty()) {
                            current.comments_before = comments;
                            comments = new TokenStream();
                        }
                        current.parent = open_token;
                        if (this._is_opening(current)) {
                            open_stack.push(open_token);
                            open_token = current;
                        } else if (open_token && this._is_closing(current, open_token)) {
                            current.opened = open_token;
                            open_token.closed = current;
                            open_token = open_stack.pop();
                            current.parent = open_token;
                        }
                        current.previous = previous;
                        previous.next = current;
                        this.__tokens.add(current);
                        previous = current;
                    }
                    return this.__tokens;
                };
                Tokenizer.prototype._is_first_token = function() {
                    return this.__tokens.isEmpty();
                };
                Tokenizer.prototype._reset = function() {};
                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
                    this._readWhitespace();
                    var resulting_string = this._input.read(/.+/g);
                    if (resulting_string) {
                        return this._create_token(TOKEN.RAW, resulting_string);
                    } else {
                        return this._create_token(TOKEN.EOF, "");
                    }
                };
                Tokenizer.prototype._is_comment = function(current_token) {
                    return false;
                };
                Tokenizer.prototype._is_opening = function(current_token) {
                    return false;
                };
                Tokenizer.prototype._is_closing = function(current_token, open_token) {
                    return false;
                };
                Tokenizer.prototype._create_token = function(type, text) {
                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
                    return token;
                };
                Tokenizer.prototype._readWhitespace = function() {
                    return this._patterns.whitespace.read();
                };
                module.exports.Tokenizer = Tokenizer;
                module.exports.TOKEN = TOKEN;
            /***/ },
            /* 10 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function TokenStream(parent_token) {
                    // private
                    this.__tokens = [];
                    this.__tokens_length = this.__tokens.length;
                    this.__position = 0;
                    this.__parent_token = parent_token;
                }
                TokenStream.prototype.restart = function() {
                    this.__position = 0;
                };
                TokenStream.prototype.isEmpty = function() {
                    return this.__tokens_length === 0;
                };
                TokenStream.prototype.hasNext = function() {
                    return this.__position < this.__tokens_length;
                };
                TokenStream.prototype.next = function() {
                    var val = null;
                    if (this.hasNext()) {
                        val = this.__tokens[this.__position];
                        this.__position += 1;
                    }
                    return val;
                };
                TokenStream.prototype.peek = function(index) {
                    var val = null;
                    index = index || 0;
                    index += this.__position;
                    if (index >= 0 && index < this.__tokens_length) {
                        val = this.__tokens[index];
                    }
                    return val;
                };
                TokenStream.prototype.add = function(token) {
                    if (this.__parent_token) {
                        token.parent = this.__parent_token;
                    }
                    this.__tokens.push(token);
                    this.__tokens_length += 1;
                };
                module.exports.TokenStream = TokenStream;
            /***/ },
            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_183873__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Pattern = __nested_webpack_require_183873__(12).Pattern;
                function WhitespacePattern(input_scanner, parent) {
                    Pattern.call(this, input_scanner, parent);
                    if (parent) {
                        this._line_regexp = this._input.get_regexp(parent._line_regexp);
                    } else {
                        this.__set_whitespace_patterns("", "");
                    }
                    this.newline_count = 0;
                    this.whitespace_before_token = "";
                }
                WhitespacePattern.prototype = new Pattern();
                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
                    whitespace_chars += "\\t ";
                    newline_chars += "\\n\\r";
                    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
                    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
                };
                WhitespacePattern.prototype.read = function() {
                    this.newline_count = 0;
                    this.whitespace_before_token = "";
                    var resulting_string = this._input.read(this._match_pattern);
                    if (resulting_string === " ") {
                        this.whitespace_before_token = " ";
                    } else if (resulting_string) {
                        var matches = this.__split(this._newline_regexp, resulting_string);
                        this.newline_count = matches.length - 1;
                        this.whitespace_before_token = matches[this.newline_count];
                    }
                    return resulting_string;
                };
                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
                    var result = this._create();
                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
                    result._update();
                    return result;
                };
                WhitespacePattern.prototype._create = function() {
                    return new WhitespacePattern(this._input, this);
                };
                WhitespacePattern.prototype.__split = function(regexp, input_string) {
                    regexp.lastIndex = 0;
                    var start_index = 0;
                    var result = [];
                    var next_match = regexp.exec(input_string);
                    while(next_match){
                        result.push(input_string.substring(start_index, next_match.index));
                        start_index = next_match.index + next_match[0].length;
                        next_match = regexp.exec(input_string);
                    }
                    if (start_index < input_string.length) {
                        result.push(input_string.substring(start_index, input_string.length));
                    } else {
                        result.push("");
                    }
                    return result;
                };
                module.exports.WhitespacePattern = WhitespacePattern;
            /***/ },
            /* 12 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Pattern(input_scanner, parent) {
                    this._input = input_scanner;
                    this._starting_pattern = null;
                    this._match_pattern = null;
                    this._until_pattern = null;
                    this._until_after = false;
                    if (parent) {
                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
                        this._until_pattern = this._input.get_regexp(parent._until_pattern);
                        this._until_after = parent._until_after;
                    }
                }
                Pattern.prototype.read = function() {
                    var result = this._input.read(this._starting_pattern);
                    if (!this._starting_pattern || result) {
                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
                    }
                    return result;
                };
                Pattern.prototype.read_match = function() {
                    return this._input.match(this._match_pattern);
                };
                Pattern.prototype.until_after = function(pattern) {
                    var result = this._create();
                    result._until_after = true;
                    result._until_pattern = this._input.get_regexp(pattern);
                    result._update();
                    return result;
                };
                Pattern.prototype.until = function(pattern) {
                    var result = this._create();
                    result._until_after = false;
                    result._until_pattern = this._input.get_regexp(pattern);
                    result._update();
                    return result;
                };
                Pattern.prototype.starting_with = function(pattern) {
                    var result = this._create();
                    result._starting_pattern = this._input.get_regexp(pattern, true);
                    result._update();
                    return result;
                };
                Pattern.prototype.matching = function(pattern) {
                    var result = this._create();
                    result._match_pattern = this._input.get_regexp(pattern, true);
                    result._update();
                    return result;
                };
                Pattern.prototype._create = function() {
                    return new Pattern(this._input, this);
                };
                Pattern.prototype._update = function() {};
                module.exports.Pattern = Pattern;
            /***/ },
            /* 13 */ /***/ function(module) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ function Directives(start_block_pattern, end_block_pattern) {
                    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
                    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
                    this.__directive_pattern = / (\w+)[:](\w+)/g;
                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
                }
                Directives.prototype.get_directives = function(text) {
                    if (!text.match(this.__directives_block_pattern)) {
                        return null;
                    }
                    var directives = {};
                    this.__directive_pattern.lastIndex = 0;
                    var directive_match = this.__directive_pattern.exec(text);
                    while(directive_match){
                        directives[directive_match[1]] = directive_match[2];
                        directive_match = this.__directive_pattern.exec(text);
                    }
                    return directives;
                };
                Directives.prototype.readIgnored = function(input) {
                    return input.readUntilAfter(this.__directives_end_ignore_pattern);
                };
                module.exports.Directives = Directives;
            /***/ },
            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_195265__) {
                /*jshint node:true */ /*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/ var Pattern = __nested_webpack_require_195265__(12).Pattern;
                var template_names = {
                    django: false,
                    erb: false,
                    handlebars: false,
                    php: false,
                    smarty: false,
                    angular: false
                };
                // This lets templates appear anywhere we would do a readUntil
                // The cost is higher but it is pay to play.
                function TemplatablePattern(input_scanner, parent) {
                    Pattern.call(this, input_scanner, parent);
                    this.__template_pattern = null;
                    this._disabled = Object.assign({}, template_names);
                    this._excluded = Object.assign({}, template_names);
                    if (parent) {
                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
                        this._excluded = Object.assign(this._excluded, parent._excluded);
                        this._disabled = Object.assign(this._disabled, parent._disabled);
                    }
                    var pattern = new Pattern(input_scanner);
                    this.__patterns = {
                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),
                        php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
                        // django coflicts with handlebars a bit.
                        django: pattern.starting_with(/{%/).until_after(/%}/),
                        django_value: pattern.starting_with(/{{/).until_after(/}}/),
                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),
                        smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
                        smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
                    };
                }
                TemplatablePattern.prototype = new Pattern();
                TemplatablePattern.prototype._create = function() {
                    return new TemplatablePattern(this._input, this);
                };
                TemplatablePattern.prototype._update = function() {
                    this.__set_templated_pattern();
                };
                TemplatablePattern.prototype.disable = function(language) {
                    var result = this._create();
                    result._disabled[language] = true;
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.read_options = function(options) {
                    var result = this._create();
                    for(var language in template_names){
                        result._disabled[language] = options.templating.indexOf(language) === -1;
                    }
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.exclude = function(language) {
                    var result = this._create();
                    result._excluded[language] = true;
                    result._update();
                    return result;
                };
                TemplatablePattern.prototype.read = function() {
                    var result = "";
                    if (this._match_pattern) {
                        result = this._input.read(this._starting_pattern);
                    } else {
                        result = this._input.read(this._starting_pattern, this.__template_pattern);
                    }
                    var next = this._read_template();
                    while(next){
                        if (this._match_pattern) {
                            next += this._input.read(this._match_pattern);
                        } else {
                            next += this._input.readUntil(this.__template_pattern);
                        }
                        result += next;
                        next = this._read_template();
                    }
                    if (this._until_after) {
                        result += this._input.readUntilAfter(this._until_pattern);
                    }
                    return result;
                };
                TemplatablePattern.prototype.__set_templated_pattern = function() {
                    var items = [];
                    if (!this._disabled.php) {
                        items.push(this.__patterns.php._starting_pattern.source);
                    }
                    if (!this._disabled.handlebars) {
                        items.push(this.__patterns.handlebars._starting_pattern.source);
                    }
                    if (!this._disabled.erb) {
                        items.push(this.__patterns.erb._starting_pattern.source);
                    }
                    if (!this._disabled.django) {
                        items.push(this.__patterns.django._starting_pattern.source);
                        // The starting pattern for django is more complex because it has different
                        // patterns for value, comment, and other sections
                        items.push(this.__patterns.django_value._starting_pattern.source);
                        items.push(this.__patterns.django_comment._starting_pattern.source);
                    }
                    if (!this._disabled.smarty) {
                        items.push(this.__patterns.smarty._starting_pattern.source);
                    }
                    if (this._until_pattern) {
                        items.push(this._until_pattern.source);
                    }
                    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
                };
                TemplatablePattern.prototype._read_template = function() {
                    var resulting_string = "";
                    var c = this._input.peek();
                    if (c === "<") {
                        var peek1 = this._input.peek(1);
                        //if we're in a comment, do something special
                        // We treat all comments as literals, even more than preformatted tags
                        // we just look for the appropriate close tag
                        if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
                            resulting_string = resulting_string || this.__patterns.php.read();
                        }
                        if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
                            resulting_string = resulting_string || this.__patterns.erb.read();
                        }
                    } else if (c === "{") {
                        if (!this._disabled.handlebars && !this._excluded.handlebars) {
                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
                            resulting_string = resulting_string || this.__patterns.handlebars.read();
                        }
                        if (!this._disabled.django) {
                            // django coflicts with handlebars a bit.
                            if (!this._excluded.django && !this._excluded.handlebars) {
                                resulting_string = resulting_string || this.__patterns.django_value.read();
                            }
                            if (!this._excluded.django) {
                                resulting_string = resulting_string || this.__patterns.django_comment.read();
                                resulting_string = resulting_string || this.__patterns.django.read();
                            }
                        }
                        if (!this._disabled.smarty) {
                            // smarty cannot be enabled with django or handlebars enabled
                            if (this._disabled.django && this._disabled.handlebars) {
                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();
                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();
                                resulting_string = resulting_string || this.__patterns.smarty.read();
                            }
                        }
                    }
                    return resulting_string;
                };
                module.exports.TemplatablePattern = TemplatablePattern;
            /***/ }
        ];
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_205777__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_205777__);
            /******/ /******/ // Return the exports of the module
            /******/ return module.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module is referenced by other modules so it can't be inlined
        /******/ var __nested_webpack_exports__ = __nested_webpack_require_205777__(0);
        /******/ legacy_beautify_js = __nested_webpack_exports__;
    /******/ /******/ })();
    var js_beautify = legacy_beautify_js;
    /* Footer */ if (true) {
        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return {
                js_beautify: js_beautify
            };
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})();


/***/ }),

/***/ 58648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isBuffer = __webpack_require__(43925);
var toString = Object.prototype.toString;
/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */ module.exports = function kindOf(val) {
    // primitivies
    if (typeof val === "undefined") {
        return "undefined";
    }
    if (val === null) {
        return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
        return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
        return "number";
    }
    // functions
    if (typeof val === "function" || val instanceof Function) {
        return "function";
    }
    // array
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
    }
    // check for instances of RegExp and Date before calling `toString`
    if (val instanceof RegExp) {
        return "regexp";
    }
    if (val instanceof Date) {
        return "date";
    }
    // other objects
    var type = toString.call(val);
    if (type === "[object RegExp]") {
        return "regexp";
    }
    if (type === "[object Date]") {
        return "date";
    }
    if (type === "[object Arguments]") {
        return "arguments";
    }
    if (type === "[object Error]") {
        return "error";
    }
    // buffer
    if (isBuffer(val)) {
        return "buffer";
    }
    // es6: Map, WeakMap, Set, WeakSet
    if (type === "[object Set]") {
        return "set";
    }
    if (type === "[object WeakSet]") {
        return "weakset";
    }
    if (type === "[object Map]") {
        return "map";
    }
    if (type === "[object WeakMap]") {
        return "weakmap";
    }
    if (type === "[object Symbol]") {
        return "symbol";
    }
    // typed arrays
    if (type === "[object Int8Array]") {
        return "int8array";
    }
    if (type === "[object Uint8Array]") {
        return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
        return "int16array";
    }
    if (type === "[object Uint16Array]") {
        return "uint16array";
    }
    if (type === "[object Int32Array]") {
        return "int32array";
    }
    if (type === "[object Uint32Array]") {
        return "uint32array";
    }
    if (type === "[object Float32Array]") {
        return "float32array";
    }
    if (type === "[object Float64Array]") {
        return "float64array";
    }
    // must be a plain object
    return "object";
};


/***/ }),

/***/ 73764:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
/*
 * function align (info)
 * Returns a new instance of the align Format which adds a `\t`
 * delimiter before the message to properly align it in the same place.
 * It was previously { align: true } in winston < 3.0.0
 */ module.exports = format((info)=>{
    info.message = `\t${info.message}`;
    return info;
});


/***/ }),

/***/ 31890:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Colorizer } = __webpack_require__(85795);
const { Padder } = __webpack_require__(38556);
const { configs, MESSAGE } = __webpack_require__(68635);
/**
 * Cli format class that handles initial state for a a separate
 * Colorizer and Padder instance.
 */ class CliFormat {
    constructor(opts = {}){
        if (!opts.levels) {
            opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
    }
    /*
   * function transform (info, opts)
   * Attempts to both:
   * 1. Pad the { level }
   * 2. Colorize the { level, message }
   * of the given `logform` info object depending on the `opts`.
   */ transform(info, opts) {
        this.colorizer.transform(this.padder.transform(info, opts), opts);
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
    }
}
/*
 * function cli (opts)
 * Returns a new instance of the CLI format that turns a log
 * `info` object into the same format previously available
 * in `winston.cli()` in `winston < 3.0.0`.
 */ module.exports = (opts)=>new CliFormat(opts);
//
// Attach the CliFormat for registration purposes
//
module.exports.Format = CliFormat;


/***/ }),

/***/ 85795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colors = __webpack_require__(13945);
const { LEVEL, MESSAGE } = __webpack_require__(68635);
//
// Fix colors not appearing in non-tty environments
//
colors.enabled = true;
/**
 * @property {RegExp} hasSpace
 * Simple regex to check for presence of spaces.
 */ const hasSpace = /\s+/;
/*
 * Colorizer format. Wraps the `level` and/or `message` properties
 * of the `info` objects with ANSI color codes based on a few options.
 */ class Colorizer {
    constructor(opts = {}){
        if (opts.colors) {
            this.addColors(opts.colors);
        }
        this.options = opts;
    }
    /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */ static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level)=>{
            acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
            return acc;
        }, {});
        Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
        return Colorizer.allColors;
    }
    /*
   * Adds the colors Object to the set of allColors
   * known by the Colorizer
   *
   * @param {Object} colors Set of color mappings to add.
   */ addColors(clrs) {
        return Colorizer.addColors(clrs);
    }
    /*
   * function colorize (lookup, level, message)
   * Performs multi-step colorization using @colors/colors/safe
   */ colorize(lookup, level, message) {
        if (typeof message === "undefined") {
            message = level;
        }
        //
        // If the color for the level is just a string
        // then attempt to colorize the message with it.
        //
        if (!Array.isArray(Colorizer.allColors[lookup])) {
            return colors[Colorizer.allColors[lookup]](message);
        }
        //
        // If it is an Array then iterate over that Array, applying
        // the colors function for each item.
        //
        for(let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++){
            message = colors[Colorizer.allColors[lookup][i]](message);
        }
        return message;
    }
    /*
   * function transform (info, opts)
   * Attempts to colorize the { level, message } of the given
   * `logform` info object.
   */ transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
            info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
            info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
            info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
    }
}
/*
 * function colorize (info)
 * Returns a new instance of the colorize Format that applies
 * level colors to `info` objects. This was previously exposed
 * as { colorize: true } to transports in `winston < 3.0.0`.
 */ module.exports = (opts)=>new Colorizer(opts);
//
// Attach the Colorizer for registration purposes
//
module.exports.Colorizer = module.exports.Format = Colorizer;


/***/ }),

/***/ 5728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
/*
 * function cascade(formats)
 * Returns a function that invokes the `._format` function in-order
 * for the specified set of `formats`. In this manner we say that Formats
 * are "pipe-like", but not a pure pumpify implementation. Since there is no back
 * pressure we can remove all of the "readable" plumbing in Node streams.
 */ function cascade(formats) {
    if (!formats.every(isValidFormat)) {
        return;
    }
    return (info)=>{
        let obj = info;
        for(let i = 0; i < formats.length; i++){
            obj = formats[i].transform(obj, formats[i].options);
            if (!obj) {
                return false;
            }
        }
        return obj;
    };
}
/*
 * function isValidFormat(format)
 * If the format does not define a `transform` function throw an error
 * with more detailed usage.
 */ function isValidFormat(fmt) {
    if (typeof fmt.transform !== "function") {
        throw new Error([
            "No transform function found on format. Did you create a format instance?",
            "const myFormat = format(formatFn);",
            "const instance = myFormat();"
        ].join("\n"));
    }
    return true;
}
/*
 * function combine (info)
 * Returns a new instance of the combine Format which combines the specified
 * formats into a new format. This is similar to a pipe-chain in transform streams.
 * We choose to combine the prototypes this way because there is no back pressure in
 * an in-memory transform chain.
 */ module.exports = (...formats)=>{
    const combinedFormat = format(cascade(formats));
    const instance = combinedFormat();
    instance.Format = combinedFormat.Format;
    return instance;
};
//
// Export the cascade method for use in cli and other
// combined formats that should not be assumed to be
// singletons.
//
module.exports.cascade = cascade;


/***/ }),

/***/ 62678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */ 
const format = __webpack_require__(74531);
const { LEVEL, MESSAGE } = __webpack_require__(68635);
/*
 * function errors (info)
 * If the `message` property of the `info` object is an instance of `Error`,
 * replace the `Error` object its own `message` property.
 *
 * Optionally, the Error's `stack` and/or `cause` properties can also be appended to the `info` object.
 */ module.exports = format((einfo, { stack, cause })=>{
    if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
            level: einfo.level,
            [LEVEL]: einfo[LEVEL] || einfo.level,
            message: einfo.message,
            [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack) info.stack = einfo.stack;
        if (cause) info.cause = einfo.cause;
        return info;
    }
    if (!(einfo.message instanceof Error)) return einfo;
    // Assign all enumerable properties and the
    // message property from the error provided.
    const err = einfo.message;
    Object.assign(einfo, err);
    einfo.message = err.message;
    einfo[MESSAGE] = err.message;
    // Assign the stack and/or cause if requested.
    if (stack) einfo.stack = err.stack;
    if (cause) einfo.cause = err.cause;
    return einfo;
});


/***/ }),

/***/ 74531:
/***/ ((module) => {

"use strict";

/*
 * Displays a helpful message and the source of
 * the format when it is invalid.
 */ class InvalidFormatError extends Error {
    constructor(formatFn){
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}\n`);
        Error.captureStackTrace(this, InvalidFormatError);
    }
}
/*
 * function format (formatFn)
 * Returns a create function for the `formatFn`.
 */ module.exports = (formatFn)=>{
    if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
    }
    /*
   * function Format (options)
   * Base prototype which calls a `_format`
   * function and pushes the result.
   */ function Format(options = {}) {
        this.options = options;
    }
    Format.prototype.transform = formatFn;
    //
    // Create a function which returns new instances of
    // FormatWrap for simple syntax like:
    //
    // require('winston').formats.json();
    //
    function createFormatWrap(opts) {
        return new Format(opts);
    }
    //
    // Expose the FormatWrap through the create function
    // for testability.
    //
    createFormatWrap.Format = Format;
    return createFormatWrap;
};


/***/ }),

/***/ 57030:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * @api public
 * @property {function} format
 * Both the construction method and set of exposed
 * formats.
 */ const format = exports.format = __webpack_require__(74531);
/*
 * @api public
 * @method {function} levels
 * Registers the specified levels with logform.
 */ exports.levels = __webpack_require__(60539);
/*
 * @api private
 * method {function} exposeFormat
 * Exposes a sub-format on the main format object
 * as a lazy-loaded getter.
 */ function exposeFormat(name, requireFormat) {
    Object.defineProperty(format, name, {
        get () {
            return requireFormat();
        },
        configurable: true
    });
}
//
// Setup all transports as lazy-loaded getters.
//
exposeFormat("align", function() {
    return __webpack_require__(73764);
});
exposeFormat("errors", function() {
    return __webpack_require__(62678);
});
exposeFormat("cli", function() {
    return __webpack_require__(31890);
});
exposeFormat("combine", function() {
    return __webpack_require__(5728);
});
exposeFormat("colorize", function() {
    return __webpack_require__(85795);
});
exposeFormat("json", function() {
    return __webpack_require__(53781);
});
exposeFormat("label", function() {
    return __webpack_require__(86546);
});
exposeFormat("logstash", function() {
    return __webpack_require__(36166);
});
exposeFormat("metadata", function() {
    return __webpack_require__(7822);
});
exposeFormat("ms", function() {
    return __webpack_require__(67863);
});
exposeFormat("padLevels", function() {
    return __webpack_require__(38556);
});
exposeFormat("prettyPrint", function() {
    return __webpack_require__(35790);
});
exposeFormat("printf", function() {
    return __webpack_require__(36031);
});
exposeFormat("simple", function() {
    return __webpack_require__(95396);
});
exposeFormat("splat", function() {
    return __webpack_require__(3296);
});
exposeFormat("timestamp", function() {
    return __webpack_require__(233);
});
exposeFormat("uncolorize", function() {
    return __webpack_require__(20330);
});


/***/ }),

/***/ 53781:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
const { MESSAGE } = __webpack_require__(68635);
const stringify = __webpack_require__(69380);
/*
 * function replacer (key, value)
 * Handles proper stringification of Buffer and bigint output.
 */ function replacer(key, value) {
    // safe-stable-stringify does support BigInt, however, it doesn't wrap the value in quotes.
    // Leading to a loss in fidelity if the resulting string is parsed.
    // It would also be a breaking change for logform.
    if (typeof value === "bigint") return value.toString();
    return value;
}
/*
 * function json (info)
 * Returns a new instance of the JSON format that turns a log `info`
 * object into pure JSON. This was previously exposed as { json: true }
 * to transports in `winston < 3.0.0`.
 */ module.exports = format((info, opts)=>{
    const jsonStringify = stringify.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
    return info;
});


/***/ }),

/***/ 86546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
/*
 * function label (info)
 * Returns a new instance of the label Format which adds the specified
 * `opts.label` before the message. This was previously exposed as
 * { label: 'my label' } to transports in `winston < 3.0.0`.
 */ module.exports = format((info, opts)=>{
    if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
    }
    info.label = opts.label;
    return info;
});


/***/ }),

/***/ 60539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Colorizer } = __webpack_require__(85795);
/*
 * Simple method to register colors with a simpler require
 * path within the module.
 */ module.exports = (config)=>{
    Colorizer.addColors(config.colors || config);
    return config;
};


/***/ }),

/***/ 36166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
const { MESSAGE } = __webpack_require__(68635);
const jsonStringify = __webpack_require__(69380);
/*
 * function logstash (info)
 * Returns a new instance of the LogStash Format that turns a
 * log `info` object into pure JSON with the appropriate logstash
 * options. This was previously exposed as { logstash: true }
 * to transports in `winston < 3.0.0`.
 */ module.exports = format((info)=>{
    const logstash = {};
    if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
    }
    if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
    }
    logstash["@fields"] = info;
    info[MESSAGE] = jsonStringify(logstash);
    return info;
});


/***/ }),

/***/ 7822:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const format = __webpack_require__(74531);
function fillExcept(info, fillExceptKeys, metadataKey) {
    const savedKeys = fillExceptKeys.reduce((acc, key)=>{
        acc[key] = info[key];
        delete info[key];
        return acc;
    }, {});
    const metadata = Object.keys(info).reduce((acc, key)=>{
        acc[key] = info[key];
        delete info[key];
        return acc;
    }, {});
    Object.assign(info, savedKeys, {
        [metadataKey]: metadata
    });
    return info;
}
function fillWith(info, fillWithKeys, metadataKey) {
    info[metadataKey] = fillWithKeys.reduce((acc, key)=>{
        acc[key] = info[key];
        delete info[key];
        return acc;
    }, {});
    return info;
}
/**
 * Adds in a "metadata" object to collect extraneous data, similar to the metadata
 * object in winston 2.x.
 */ module.exports = format((info, opts = {})=>{
    let metadataKey = "metadata";
    if (opts.key) {
        metadataKey = opts.key;
    }
    let fillExceptKeys = [];
    if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
    }
    if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
    }
    if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
    }
    if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
    }
    return info;
});


/***/ }),

/***/ 67863:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

const format = __webpack_require__(74531);
const ms = __webpack_require__(40194);
/*
 * function ms (info)
 * Returns an `info` with a `ms` property. The `ms` property holds the Value
 * of the time difference between two calls in milliseconds.
 */ module.exports = format((info)=>{
    const curr = +new Date();
    this.diff = curr - (this.prevTime || curr);
    this.prevTime = curr;
    info.ms = `+${ms(this.diff)}`;
    return info;
});


/***/ }),

/***/ 80280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*

The MIT License (MIT)

Original Library
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/ var colors = {};
module["exports"] = colors;
colors.themes = {};
var util = __webpack_require__(73837);
var ansiStyles = colors.styles = __webpack_require__(65513);
var defineProps = Object.defineProperties;
var newLineRegex = new RegExp(/[\r\n]+/g);
colors.supportsColor = (__webpack_require__(82485).supportsColor);
if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
}
colors.enable = function() {
    colors.enabled = true;
};
colors.disable = function() {
    colors.enabled = false;
};
colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
};
// eslint-disable-next-line no-unused-vars
var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
        return str + "";
    }
    var styleMap = ansiStyles[style];
    // Stylize should work for non-ANSI styles, too
    if (!styleMap && style in colors) {
        // Style maps like trap operate as functions on strings;
        // they don't have properties like open or close.
        return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
};
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
        throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
};
function build(_styles) {
    var builder = function builder() {
        return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    // __proto__ is used because we must return a function, but there is
    // no way to create a function with a different prototype.
    builder.__proto__ = proto;
    return builder;
}
var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
            get: function() {
                return build(this._styles.concat(key));
            }
        };
    });
    return ret;
}();
var proto = defineProps(function colors() {}, styles);
function applyStyle() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
        // Use weak equality check so we can colorize null/undefined in safe mode
        if (arg != null && arg.constructor === String) {
            return arg;
        } else {
            return util.inspect(arg);
        }
    }).join(" ");
    if (!colors.enabled || !str) {
        return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while(i--){
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
            str = str.replace(newLineRegex, function(match) {
                return code.close + match + code.open;
            });
        }
    }
    return str;
}
colors.setTheme = function(theme) {
    if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  " + "If you are trying to set a theme from a file, it is now your (the " + "caller's) responsibility to require the file.  The old syntax " + "looked like colors.setTheme(__dirname + " + "'/../themes/generic-logging.js'); The new syntax looks like " + "colors.setTheme(require(__dirname + " + "'/../themes/generic-logging.js'));");
        return;
    }
    for(var style in theme){
        (function(style) {
            colors[style] = function(str) {
                if (typeof theme[style] === "object") {
                    var out = str;
                    for(var i in theme[style]){
                        out = colors[theme[style][i]](out);
                    }
                    return out;
                }
                return colors[theme[style]](str);
            };
        })(style);
    }
};
function init() {
    var ret = {};
    Object.keys(styles).forEach(function(name) {
        ret[name] = {
            get: function() {
                return build([
                    name
                ]);
            }
        };
    });
    return ret;
}
var sequencer = function sequencer(map, str) {
    var exploded = str.split("");
    exploded = exploded.map(map);
    return exploded.join("");
};
// custom formatter methods
colors.trap = __webpack_require__(76657);
colors.zalgo = __webpack_require__(17307);
// maps
colors.maps = {};
colors.maps.america = __webpack_require__(42745)(colors);
colors.maps.zebra = __webpack_require__(51288)(colors);
colors.maps.rainbow = __webpack_require__(44215)(colors);
colors.maps.random = __webpack_require__(25187)(colors);
for(var map in colors.maps){
    (function(map) {
        colors[map] = function(str) {
            return sequencer(colors.maps[map], str);
        };
    })(map);
}
defineProps(colors, init());


/***/ }),

/***/ 76657:
/***/ ((module) => {

module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
        a: [
            "@",
            "Ą",
            "Ⱥ",
            "Ʌ",
            "Δ",
            "Λ",
            "Д"
        ],
        b: [
            "\xdf",
            "Ɓ",
            "Ƀ",
            "ɮ",
            "β",
            "฿"
        ],
        c: [
            "\xa9",
            "Ȼ",
            "Ͼ"
        ],
        d: [
            "\xd0",
            "Ɗ",
            "Ԁ",
            "ԁ",
            "Ԃ",
            "ԃ"
        ],
        e: [
            "\xcb",
            "ĕ",
            "Ǝ",
            "ɘ",
            "Σ",
            "ξ",
            "Ҽ",
            "੬"
        ],
        f: [
            "Ӻ"
        ],
        g: [
            "ɢ"
        ],
        h: [
            "Ħ",
            "ƕ",
            "Ң",
            "Һ",
            "Ӈ",
            "Ԋ"
        ],
        i: [
            "༏"
        ],
        j: [
            "Ĵ"
        ],
        k: [
            "ĸ",
            "Ҡ",
            "Ӄ",
            "Ԟ"
        ],
        l: [
            "Ĺ"
        ],
        m: [
            "ʍ",
            "Ӎ",
            "ӎ",
            "Ԡ",
            "ԡ",
            "൩"
        ],
        n: [
            "\xd1",
            "ŋ",
            "Ɲ",
            "Ͷ",
            "Π",
            "Ҋ"
        ],
        o: [
            "\xd8",
            "\xf5",
            "\xf8",
            "Ǿ",
            "ʘ",
            "Ѻ",
            "ם",
            "۝",
            "๏"
        ],
        p: [
            "Ƿ",
            "Ҏ"
        ],
        q: [
            "্"
        ],
        r: [
            "\xae",
            "Ʀ",
            "Ȑ",
            "Ɍ",
            "ʀ",
            "Я"
        ],
        s: [
            "\xa7",
            "Ϟ",
            "ϟ",
            "Ϩ"
        ],
        t: [
            "Ł",
            "Ŧ",
            "ͳ"
        ],
        u: [
            "Ʊ",
            "Ս"
        ],
        v: [
            "ט"
        ],
        w: [
            "Ш",
            "Ѡ",
            "Ѽ",
            "൰"
        ],
        x: [
            "Ҳ",
            "Ӿ",
            "Ӽ",
            "ӽ"
        ],
        y: [
            "\xa5",
            "Ұ",
            "Ӌ"
        ],
        z: [
            "Ƶ",
            "ɀ"
        ]
    };
    text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [
            " "
        ];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
            result += trap[c][rand];
        } else {
            result += c;
        }
    });
    return result;
};


/***/ }),

/***/ 17307:
/***/ ((module) => {

// please no
module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
        "up": [
            "̍",
            "̎",
            "̄",
            "̅",
            "̿",
            "̑",
            "̆",
            "̐",
            "͒",
            "͗",
            "͑",
            "̇",
            "̈",
            "̊",
            "͂",
            "̓",
            "̈",
            "͊",
            "͋",
            "͌",
            "̃",
            "̂",
            "̌",
            "͐",
            "̀",
            "́",
            "̋",
            "̏",
            "̒",
            "̓",
            "̔",
            "̽",
            "̉",
            "ͣ",
            "ͤ",
            "ͥ",
            "ͦ",
            "ͧ",
            "ͨ",
            "ͩ",
            "ͪ",
            "ͫ",
            "ͬ",
            "ͭ",
            "ͮ",
            "ͯ",
            "̾",
            "͛",
            "͆",
            "̚"
        ],
        "down": [
            "̖",
            "̗",
            "̘",
            "̙",
            "̜",
            "̝",
            "̞",
            "̟",
            "̠",
            "̤",
            "̥",
            "̦",
            "̩",
            "̪",
            "̫",
            "̬",
            "̭",
            "̮",
            "̯",
            "̰",
            "̱",
            "̲",
            "̳",
            "̹",
            "̺",
            "̻",
            "̼",
            "ͅ",
            "͇",
            "͈",
            "͉",
            "͍",
            "͎",
            "͓",
            "͔",
            "͕",
            "͖",
            "͙",
            "͚",
            "̣"
        ],
        "mid": [
            "̕",
            "̛",
            "̀",
            "́",
            "͘",
            "̡",
            "̢",
            "̧",
            "̨",
            "̴",
            "̵",
            "̶",
            "͜",
            "͝",
            "͞",
            "͟",
            "͠",
            "͢",
            "̸",
            "̷",
            "͡",
            " ҉"
        ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
    }
    function isChar(character) {
        var bool = false;
        all.filter(function(i) {
            bool = i === character;
        });
        return bool;
    }
    function heComes(text, options) {
        var result = "";
        var counts;
        var l;
        options = options || {};
        options["up"] = typeof options["up"] !== "undefined" ? options["up"] : true;
        options["mid"] = typeof options["mid"] !== "undefined" ? options["mid"] : true;
        options["down"] = typeof options["down"] !== "undefined" ? options["down"] : true;
        options["size"] = typeof options["size"] !== "undefined" ? options["size"] : "maxi";
        text = text.split("");
        for(l in text){
            if (isChar(l)) {
                continue;
            }
            result = result + text[l];
            counts = {
                "up": 0,
                "down": 0,
                "mid": 0
            };
            switch(options.size){
                case "mini":
                    counts.up = randomNumber(8);
                    counts.mid = randomNumber(2);
                    counts.down = randomNumber(8);
                    break;
                case "maxi":
                    counts.up = randomNumber(16) + 3;
                    counts.mid = randomNumber(4) + 1;
                    counts.down = randomNumber(64) + 3;
                    break;
                default:
                    counts.up = randomNumber(8) + 1;
                    counts.mid = randomNumber(6) / 2;
                    counts.down = randomNumber(8) + 1;
                    break;
            }
            var arr = [
                "up",
                "mid",
                "down"
            ];
            for(var d in arr){
                var index = arr[d];
                for(var i = 0; i <= counts[index]; i++){
                    if (options[index]) {
                        result = result + soul[index][randomNumber(soul[index].length)];
                    }
                }
            }
        }
        return result;
    }
    // don't summon him
    return heComes(text, options);
};


/***/ }),

/***/ 42745:
/***/ ((module) => {

module["exports"] = function(colors) {
    return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch(i % 3){
            case 0:
                return colors.red(letter);
            case 1:
                return colors.white(letter);
            case 2:
                return colors.blue(letter);
        }
    };
};


/***/ }),

/***/ 44215:
/***/ ((module) => {

module["exports"] = function(colors) {
    // RoY G BiV
    var rainbowColors = [
        "red",
        "yellow",
        "green",
        "blue",
        "magenta"
    ];
    return function(letter, i, exploded) {
        if (letter === " ") {
            return letter;
        } else {
            return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
    };
};


/***/ }),

/***/ 25187:
/***/ ((module) => {

module["exports"] = function(colors) {
    var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
    ];
    return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
};


/***/ }),

/***/ 51288:
/***/ ((module) => {

module["exports"] = function(colors) {
    return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
    };
};


/***/ }),

/***/ 65513:
/***/ ((module) => {

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/ var styles = {};
module["exports"] = styles;
var codes = {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    black: [
        30,
        39
    ],
    red: [
        31,
        39
    ],
    green: [
        32,
        39
    ],
    yellow: [
        33,
        39
    ],
    blue: [
        34,
        39
    ],
    magenta: [
        35,
        39
    ],
    cyan: [
        36,
        39
    ],
    white: [
        37,
        39
    ],
    gray: [
        90,
        39
    ],
    grey: [
        90,
        39
    ],
    brightRed: [
        91,
        39
    ],
    brightGreen: [
        92,
        39
    ],
    brightYellow: [
        93,
        39
    ],
    brightBlue: [
        94,
        39
    ],
    brightMagenta: [
        95,
        39
    ],
    brightCyan: [
        96,
        39
    ],
    brightWhite: [
        97,
        39
    ],
    bgBlack: [
        40,
        49
    ],
    bgRed: [
        41,
        49
    ],
    bgGreen: [
        42,
        49
    ],
    bgYellow: [
        43,
        49
    ],
    bgBlue: [
        44,
        49
    ],
    bgMagenta: [
        45,
        49
    ],
    bgCyan: [
        46,
        49
    ],
    bgWhite: [
        47,
        49
    ],
    bgGray: [
        100,
        49
    ],
    bgGrey: [
        100,
        49
    ],
    bgBrightRed: [
        101,
        49
    ],
    bgBrightGreen: [
        102,
        49
    ],
    bgBrightYellow: [
        103,
        49
    ],
    bgBrightBlue: [
        104,
        49
    ],
    bgBrightMagenta: [
        105,
        49
    ],
    bgBrightCyan: [
        106,
        49
    ],
    bgBrightWhite: [
        107,
        49
    ],
    // legacy styles for colors pre v1.0.0
    blackBG: [
        40,
        49
    ],
    redBG: [
        41,
        49
    ],
    greenBG: [
        42,
        49
    ],
    yellowBG: [
        43,
        49
    ],
    blueBG: [
        44,
        49
    ],
    magentaBG: [
        45,
        49
    ],
    cyanBG: [
        46,
        49
    ],
    whiteBG: [
        47,
        49
    ]
};
Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1b[" + val[0] + "m";
    style.close = "\x1b[" + val[1] + "m";
});


/***/ }),

/***/ 67846:
/***/ ((module) => {

"use strict";
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ 
module.exports = function(flag, argv) {
    argv = argv || process.argv || [];
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ 82485:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/ 
var os = __webpack_require__(22037);
var hasFlag = __webpack_require__(67846);
var env = process.env;
var forceColor = void 0;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
}
if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level: level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(stream) {
    if (forceColor === false) {
        return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
    }
    if (hasFlag("color=256")) {
        return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
        // Node.js 7.5.0 is the first version of Node.js to include a patch to
        // libuv that enables 256 color output on Windows. Anything earlier and it
        // won't work. However, here we target Node.js 8 at minimum as it is an LTS
        // release, and Node.js 7 is not. Windows 10 build 10586 is the first
        // Windows release that supports 256 colors. Windows 10 build 14931 is the
        // first release that supports 16m/TrueColor.
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
    }
    if ("CI" in env) {
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI"
        ].some(function(sign) {
            return sign in env;
        }) || env.CI_NAME === "codeship") {
            return 1;
        }
        return min;
    }
    if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch(env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Hyper":
                return 3;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ("COLORTERM" in env) {
        return 1;
    }
    if (env.TERM === "dumb") {
        return min;
    }
    return min;
}
function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ 13945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

//
// Remark: Requiring this file will use the "safe" colors API,
// which will not touch String.prototype.
//
//   var colors = require('colors/safe');
//   colors.red("foo")
//
//
var colors = __webpack_require__(80280);
module["exports"] = colors;


/***/ }),

/***/ 38556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: 0 */ 
const { configs, LEVEL, MESSAGE } = __webpack_require__(68635);
class Padder {
    constructor(opts = {
        levels: configs.npm.levels
    }){
        this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
    }
    /**
   * Returns the maximum length of keys in the specified `levels` Object.
   * @param  {Object} levels Set of all levels to calculate longest level against.
   * @returns {Number} Maximum length of the longest level string.
   */ static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level)=>level.length);
        return Math.max(...lvls);
    }
    /**
   * Returns the padding for the specified `level` assuming that the
   * maximum length of all levels it's associated with is `maxLength`.
   * @param  {String} level Level to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @param  {Number} maxLength Length of the longest level
   * @returns {String} Padding string for the `level`
   */ static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
    }
    /**
   * Returns an object with the string paddings for the given `levels`
   * using the specified `filler`.
   * @param  {Object} levels Set of all levels to calculate padding for.
   * @param  {String} filler Repeatable text to use for padding.
   * @returns {Object} Mapping of level to desired padding.
   */ static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level)=>{
            acc[level] = Padder.paddingForLevel(level, filler, maxLength);
            return acc;
        }, {});
    }
    /**
   * Prepends the padding onto the `message` based on the `LEVEL` of
   * the `info`. This is based on the behavior of `winston@2` which also
   * prepended the level onto the message.
   *
   * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
   *
   * @param  {Info} info Logform info object
   * @param  {Object} opts Options passed along to this instance.
   * @returns {Info} Modified logform info object.
   */ transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
            info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
    }
}
/*
 * function padLevels (info)
 * Returns a new instance of the padLevels Format which pads
 * levels to be the same length. This was previously exposed as
 * { padLevels: true } to transports in `winston < 3.0.0`.
 */ module.exports = (opts)=>new Padder(opts);
module.exports.Padder = module.exports.Format = Padder;


/***/ }),

/***/ 35790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const inspect = (__webpack_require__(73837).inspect);
const format = __webpack_require__(74531);
const { LEVEL, MESSAGE, SPLAT } = __webpack_require__(68635);
/*
 * function prettyPrint (info)
 * Returns a new instance of the prettyPrint Format that "prettyPrint"
 * serializes `info` objects. This was previously exposed as
 * { prettyPrint: true } to transports in `winston < 3.0.0`.
 */ module.exports = format((info, opts = {})=>{
    //
    // info[{LEVEL, MESSAGE, SPLAT}] are enumerable here. Since they
    // are internal, we remove them before util.inspect so they
    // are not printed.
    //
    const stripped = Object.assign({}, info);
    // Remark (indexzero): update this technique in April 2019
    // when node@6 is EOL
    delete stripped[LEVEL];
    delete stripped[MESSAGE];
    delete stripped[SPLAT];
    info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
    return info;
});


/***/ }),

/***/ 36031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { MESSAGE } = __webpack_require__(68635);
class Printf {
    constructor(templateFn){
        this.template = templateFn;
    }
    transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
    }
}
/*
 * function printf (templateFn)
 * Returns a new instance of the printf Format that creates an
 * intermediate prototype to store the template string-based formatter
 * function.
 */ module.exports = (opts)=>new Printf(opts);
module.exports.Printf = module.exports.Format = Printf;


/***/ }),

/***/ 95396:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */ 
const format = __webpack_require__(74531);
const { MESSAGE } = __webpack_require__(68635);
const jsonStringify = __webpack_require__(69380);
/*
 * function simple (info)
 * Returns a new instance of the simple format TransformStream
 * which writes a simple representation of logs.
 *
 *    const { level, message, splat, ...rest } = info;
 *
 *    ${level}: ${message}                            if rest is empty
 *    ${level}: ${message} ${JSON.stringify(rest)}    otherwise
 */ module.exports = format((info)=>{
    const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: undefined,
        message: undefined,
        splat: undefined
    }));
    const padding = info.padding && info.padding[info.level] || "";
    if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
    } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
    }
    return info;
});


/***/ }),

/***/ 3296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
const { SPLAT } = __webpack_require__(68635);
/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */ const formatRegExp = /%[scdjifoO%]/g;
/**
 * Captures the number of escaped % signs in a format string (i.e. %s strings).
 * @type {RegExp}
 */ const escapedPercent = /%%/g;
class Splatter {
    constructor(opts){
        this.options = opts;
    }
    /**
     * Check to see if tokens <= splat.length, assign { splat, meta } into the
     * `info` accordingly, and write to this instance.
     *
     * @param  {Info} info Logform info message.
     * @param  {String[]} tokens Set of string interpolation tokens.
     * @returns {Info} Modified info message
     * @private
     */ _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        // The expected splat is the number of tokens minus the number of escapes
        // e.g.
        // - { expectedSplat: 3 } '%d %s %j'
        // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'
        //
        // Any "meta" will be arugments in addition to the expected splat size
        // regardless of type. e.g.
        //
        // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });
        // would result in splat of four (4), but only three (3) are expected. Therefore:
        //
        // extraSplat = 3 - 4 = -1
        // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);
        // splat = [100, 'wow', { such: 'js' }]
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        // Now that { splat } has been separated from any potential { meta }. we
        // can assign this to the `info` object and write it to our format stream.
        // If the additional metas are **NOT** objects or **LACK** enumerable properties
        // you are going to have a bad time.
        const metalen = metas.length;
        if (metalen) {
            for(let i = 0; i < metalen; i++){
                Object.assign(info, metas[i]);
            }
        }
        info.message = util.format(msg, ...splat);
        return info;
    }
    /**
    * Transforms the `info` message by using `util.format` to complete
    * any `info.message` provided it has string interpolation tokens.
    * If no tokens exist then `info` is immutable.
    *
    * @param  {Info} info Logform info message.
    * @param  {Object} opts Options for this instance.
    * @returns {Info} Modified info message
    */ transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        // No need to process anything if splat is undefined
        if (!splat || !splat.length) {
            return info;
        }
        // Extract tokens, if none available default to empty array to
        // ensure consistancy in expected results
        const tokens = msg && msg.match && msg.match(formatRegExp);
        // This condition will take care of inputs with info[SPLAT]
        // but no tokens present
        if (!tokens && (splat || splat.length)) {
            const metas = splat.length > 1 ? splat.splice(0) : splat;
            // Now that { splat } has been separated from any potential { meta }. we
            // can assign this to the `info` object and write it to our format stream.
            // If the additional metas are **NOT** objects or **LACK** enumerable properties
            // you are going to have a bad time.
            const metalen = metas.length;
            if (metalen) {
                for(let i = 0; i < metalen; i++){
                    Object.assign(info, metas[i]);
                }
            }
            return info;
        }
        if (tokens) {
            return this._splat(info, tokens);
        }
        return info;
    }
}
/*
 * function splat (info)
 * Returns a new instance of the splat format TransformStream
 * which performs string interpolation from `info` objects. This was
 * previously exposed implicitly in `winston < 3.0.0`.
 */ module.exports = (opts)=>new Splatter(opts);


/***/ }),

/***/ 233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fecha = __webpack_require__(23607);
const format = __webpack_require__(74531);
/*
 * function timestamp (info)
 * Returns a new instance of the timestamp Format which adds a timestamp
 * to the info. It was previously available in winston < 3.0.0 as:
 *
 * - { timestamp: true }             // `new Date.toISOString()`
 * - { timestamp: function:String }  // Value returned by `timestamp()`
 */ module.exports = format((info, opts = {})=>{
    if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date(), opts.format);
    }
    if (!info.timestamp) {
        info.timestamp = new Date().toISOString();
    }
    if (opts.alias) {
        info[opts.alias] = info.timestamp;
    }
    return info;
});


/***/ }),

/***/ 20330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colors = __webpack_require__(13945);
const format = __webpack_require__(74531);
const { MESSAGE } = __webpack_require__(68635);
/*
 * function uncolorize (info)
 * Returns a new instance of the uncolorize Format that strips colors
 * from `info` objects. This was previously exposed as { stripColors: true }
 * to transports in `winston < 3.0.0`.
 */ module.exports = format((info, opts)=>{
    if (opts.level !== false) {
        info.level = colors.strip(info.level);
    }
    if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
    }
    if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
    }
    return info;
});


/***/ }),

/***/ 84222:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom-server-legacy.node.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var aa = __webpack_require__(32308), ba = __webpack_require__(98), ca = __webpack_require__(12781), p = Object.assign, t = Object.prototype.hasOwnProperty, da = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), ea = {}, fa = {};
function ka(a) {
    if (t.call(fa, a)) return !0;
    if (t.call(ea, a)) return !1;
    if (da.test(a)) return fa[a] = !0;
    ea[a] = !0;
    return !1;
}
var la = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), ma = new Map([
    [
        "acceptCharset",
        "accept-charset"
    ],
    [
        "htmlFor",
        "for"
    ],
    [
        "httpEquiv",
        "http-equiv"
    ],
    [
        "crossOrigin",
        "crossorigin"
    ],
    [
        "accentHeight",
        "accent-height"
    ],
    [
        "alignmentBaseline",
        "alignment-baseline"
    ],
    [
        "arabicForm",
        "arabic-form"
    ],
    [
        "baselineShift",
        "baseline-shift"
    ],
    [
        "capHeight",
        "cap-height"
    ],
    [
        "clipPath",
        "clip-path"
    ],
    [
        "clipRule",
        "clip-rule"
    ],
    [
        "colorInterpolation",
        "color-interpolation"
    ],
    [
        "colorInterpolationFilters",
        "color-interpolation-filters"
    ],
    [
        "colorProfile",
        "color-profile"
    ],
    [
        "colorRendering",
        "color-rendering"
    ],
    [
        "dominantBaseline",
        "dominant-baseline"
    ],
    [
        "enableBackground",
        "enable-background"
    ],
    [
        "fillOpacity",
        "fill-opacity"
    ],
    [
        "fillRule",
        "fill-rule"
    ],
    [
        "floodColor",
        "flood-color"
    ],
    [
        "floodOpacity",
        "flood-opacity"
    ],
    [
        "fontFamily",
        "font-family"
    ],
    [
        "fontSize",
        "font-size"
    ],
    [
        "fontSizeAdjust",
        "font-size-adjust"
    ],
    [
        "fontStretch",
        "font-stretch"
    ],
    [
        "fontStyle",
        "font-style"
    ],
    [
        "fontVariant",
        "font-variant"
    ],
    [
        "fontWeight",
        "font-weight"
    ],
    [
        "glyphName",
        "glyph-name"
    ],
    [
        "glyphOrientationHorizontal",
        "glyph-orientation-horizontal"
    ],
    [
        "glyphOrientationVertical",
        "glyph-orientation-vertical"
    ],
    [
        "horizAdvX",
        "horiz-adv-x"
    ],
    [
        "horizOriginX",
        "horiz-origin-x"
    ],
    [
        "imageRendering",
        "image-rendering"
    ],
    [
        "letterSpacing",
        "letter-spacing"
    ],
    [
        "lightingColor",
        "lighting-color"
    ],
    [
        "markerEnd",
        "marker-end"
    ],
    [
        "markerMid",
        "marker-mid"
    ],
    [
        "markerStart",
        "marker-start"
    ],
    [
        "overlinePosition",
        "overline-position"
    ],
    [
        "overlineThickness",
        "overline-thickness"
    ],
    [
        "paintOrder",
        "paint-order"
    ],
    [
        "panose-1",
        "panose-1"
    ],
    [
        "pointerEvents",
        "pointer-events"
    ],
    [
        "renderingIntent",
        "rendering-intent"
    ],
    [
        "shapeRendering",
        "shape-rendering"
    ],
    [
        "stopColor",
        "stop-color"
    ],
    [
        "stopOpacity",
        "stop-opacity"
    ],
    [
        "strikethroughPosition",
        "strikethrough-position"
    ],
    [
        "strikethroughThickness",
        "strikethrough-thickness"
    ],
    [
        "strokeDasharray",
        "stroke-dasharray"
    ],
    [
        "strokeDashoffset",
        "stroke-dashoffset"
    ],
    [
        "strokeLinecap",
        "stroke-linecap"
    ],
    [
        "strokeLinejoin",
        "stroke-linejoin"
    ],
    [
        "strokeMiterlimit",
        "stroke-miterlimit"
    ],
    [
        "strokeOpacity",
        "stroke-opacity"
    ],
    [
        "strokeWidth",
        "stroke-width"
    ],
    [
        "textAnchor",
        "text-anchor"
    ],
    [
        "textDecoration",
        "text-decoration"
    ],
    [
        "textRendering",
        "text-rendering"
    ],
    [
        "transformOrigin",
        "transform-origin"
    ],
    [
        "underlinePosition",
        "underline-position"
    ],
    [
        "underlineThickness",
        "underline-thickness"
    ],
    [
        "unicodeBidi",
        "unicode-bidi"
    ],
    [
        "unicodeRange",
        "unicode-range"
    ],
    [
        "unitsPerEm",
        "units-per-em"
    ],
    [
        "vAlphabetic",
        "v-alphabetic"
    ],
    [
        "vHanging",
        "v-hanging"
    ],
    [
        "vIdeographic",
        "v-ideographic"
    ],
    [
        "vMathematical",
        "v-mathematical"
    ],
    [
        "vectorEffect",
        "vector-effect"
    ],
    [
        "vertAdvY",
        "vert-adv-y"
    ],
    [
        "vertOriginX",
        "vert-origin-x"
    ],
    [
        "vertOriginY",
        "vert-origin-y"
    ],
    [
        "wordSpacing",
        "word-spacing"
    ],
    [
        "writingMode",
        "writing-mode"
    ],
    [
        "xmlnsXlink",
        "xmlns:xlink"
    ],
    [
        "xHeight",
        "x-height"
    ]
]), na = /["'&<>]/;
function u(a) {
    if ("boolean" === typeof a || "number" === typeof a) return "" + a;
    a = "" + a;
    var b = na.exec(a);
    if (b) {
        var c = "", d, e = 0;
        for(d = b.index; d < a.length; d++){
            switch(a.charCodeAt(d)){
                case 34:
                    b = "&quot;";
                    break;
                case 38:
                    b = "&amp;";
                    break;
                case 39:
                    b = "&#x27;";
                    break;
                case 60:
                    b = "&lt;";
                    break;
                case 62:
                    b = "&gt;";
                    break;
                default:
                    continue;
            }
            e !== d && (c += a.slice(e, d));
            e = d + 1;
            c += b;
        }
        a = e !== d ? c + a.slice(e, d) : c;
    }
    return a;
}
var oa = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray, ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Dispatcher, xa = {
    prefetchDNS: ta,
    preconnect: ua,
    preload: va,
    preinit: wa
};
function v(a, b, c) {
    return {
        insertionMode: a,
        selectedValue: b,
        noscriptTagInScope: c
    };
}
function ya(a, b, c) {
    switch(b){
        case "noscript":
            return v(2, null, !0);
        case "select":
            return v(2, null != c.value ? c.value : c.defaultValue, a.noscriptTagInScope);
        case "svg":
            return v(3, null, a.noscriptTagInScope);
        case "math":
            return v(4, null, a.noscriptTagInScope);
        case "foreignObject":
            return v(2, null, a.noscriptTagInScope);
        case "table":
            return v(5, null, a.noscriptTagInScope);
        case "thead":
        case "tbody":
        case "tfoot":
            return v(6, null, a.noscriptTagInScope);
        case "colgroup":
            return v(8, null, a.noscriptTagInScope);
        case "tr":
            return v(7, null, a.noscriptTagInScope);
    }
    return 5 <= a.insertionMode ? v(2, null, a.noscriptTagInScope) : 0 === a.insertionMode ? "html" === b ? v(1, null, !1) : v(2, null, !1) : 1 === a.insertionMode ? v(2, null, !1) : a;
}
var za = new Map;
function Aa(a, b) {
    if ("object" !== typeof b) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    var c = !0, d;
    for(d in b)if (t.call(b, d)) {
        var e = b[d];
        if (null != e && "boolean" !== typeof e && "" !== e) {
            if (0 === d.indexOf("--")) {
                var g = u(d);
                e = u(("" + e).trim());
            } else g = za.get(d), void 0 === g && (g = u(d.replace(oa, "-$1").toLowerCase().replace(pa, "-ms-")), za.set(d, g)), e = "number" === typeof e ? 0 === e || la.has(d) ? "" + e : e + "px" : u(("" + e).trim());
            c ? (c = !1, a.push(' style="', g, ":", e)) : a.push(";", g, ":", e);
        }
    }
    c || a.push('"');
}
function Ba(a, b, c) {
    c && "function" !== typeof c && "symbol" !== typeof c && a.push(" ", b, '=""');
}
function x(a, b, c) {
    "function" !== typeof c && "symbol" !== typeof c && "boolean" !== typeof c && a.push(" ", b, '="', u(c), '"');
}
u("javascript:throw new Error('A React form was unexpectedly submitted.')");
function Ia(a, b) {
    this.push('<input type="hidden"');
    if ("string" !== typeof a) throw Error("File/Blob fields are not yet supported in progressive forms. It probably means you are closing over binary data or FormData in a Server Action.");
    x(this, "name", b);
    x(this, "value", a);
    this.push("/>");
}
function Ja(a, b, c, d, e, g, f) {
    null != f && z(a, "name", f);
    null != c && z(a, "formAction", c);
    null != d && z(a, "formEncType", d);
    null != e && z(a, "formMethod", e);
    null != g && z(a, "formTarget", g);
    return null;
}
function z(a, b, c) {
    switch(b){
        case "className":
            x(a, "class", c);
            break;
        case "tabIndex":
            x(a, "tabindex", c);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            x(a, b, c);
            break;
        case "style":
            Aa(a, c);
            break;
        case "src":
        case "href":
        case "action":
        case "formAction":
            if (null == c || "function" === typeof c || "symbol" === typeof c || "boolean" === typeof c) break;
            a.push(" ", b, '="', u("" + c), '"');
            break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
            break;
        case "autoFocus":
        case "multiple":
        case "muted":
            Ba(a, b.toLowerCase(), c);
            break;
        case "xlinkHref":
            if ("function" === typeof c || "symbol" === typeof c || "boolean" === typeof c) break;
            a.push(" ", "xlink:href", '="', u("" + c), '"');
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            "function" !== typeof c && "symbol" !== typeof c && a.push(" ", b, '="', u(c), '"');
            break;
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            c && "function" !== typeof c && "symbol" !== typeof c && a.push(" ", b, '=""');
            break;
        case "capture":
        case "download":
            !0 === c ? a.push(" ", b, '=""') : !1 !== c && "function" !== typeof c && "symbol" !== typeof c && a.push(" ", b, '="', u(c), '"');
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            "function" !== typeof c && "symbol" !== typeof c && !isNaN(c) && 1 <= c && a.push(" ", b, '="', u(c), '"');
            break;
        case "rowSpan":
        case "start":
            "function" === typeof c || "symbol" === typeof c || isNaN(c) || a.push(" ", b, '="', u(c), '"');
            break;
        case "xlinkActuate":
            x(a, "xlink:actuate", c);
            break;
        case "xlinkArcrole":
            x(a, "xlink:arcrole", c);
            break;
        case "xlinkRole":
            x(a, "xlink:role", c);
            break;
        case "xlinkShow":
            x(a, "xlink:show", c);
            break;
        case "xlinkTitle":
            x(a, "xlink:title", c);
            break;
        case "xlinkType":
            x(a, "xlink:type", c);
            break;
        case "xmlBase":
            x(a, "xml:base", c);
            break;
        case "xmlLang":
            x(a, "xml:lang", c);
            break;
        case "xmlSpace":
            x(a, "xml:space", c);
            break;
        default:
            if (!(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) {
                if (b = ma.get(b) || b, ka(b)) {
                    switch(typeof c){
                        case "function":
                        case "symbol":
                            return;
                        case "boolean":
                            var d = b.toLowerCase().slice(0, 5);
                            if ("data-" !== d && "aria-" !== d) return;
                    }
                    a.push(" ", b, '="', u(c), '"');
                }
            }
    }
}
function A(a, b, c) {
    if (null != b) {
        if (null != c) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if ("object" !== typeof b || !("__html" in b)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html;
        null !== b && void 0 !== b && a.push("" + b);
    }
}
function Ka(a) {
    var b = "";
    aa.Children.forEach(a, function(c) {
        null != c && (b += c);
    });
    return b;
}
function La(a, b, c, d, e, g, f) {
    var k = b.rel, h = b.href, l = b.precedence;
    if (3 === g || f || null != b.itemProp || "string" !== typeof k || "string" !== typeof h || "" === h) return D(a, b), null;
    if ("stylesheet" === b.rel) {
        c = "[style]" + h;
        if ("string" !== typeof l || null != b.disabled || b.onLoad || b.onError) return D(a, b);
        g = d.stylesMap.get(c);
        g || (b = p({}, b, {
            "data-precedence": b.precedence,
            precedence: null
        }), g = d.preloadsMap.get(c), f = 0, g && (g.state |= 4, k = g.props, null == b.crossOrigin && (b.crossOrigin = k.crossOrigin), null == b.integrity && (b.integrity = k.integrity), g.state & 3 && (f = 8)), g = {
            type: "stylesheet",
            chunks: [],
            state: f,
            props: b
        }, d.stylesMap.set(c, g), b = d.precedences.get(l), b || (b = new Set, d.precedences.set(l, b), c = {
            type: "style",
            chunks: [],
            state: 0,
            props: {
                precedence: l,
                hrefs: []
            }
        }, b.add(c), d.stylePrecedences.set(l, c)), b.add(g));
        d.boundaryResources && d.boundaryResources.add(g);
        e && a.push("<!-- -->");
        return null;
    }
    if (b.onLoad || b.onError) return D(a, b);
    e && a.push("<!-- -->");
    switch(b.rel){
        case "preconnect":
        case "dns-prefetch":
            return D(c.preconnectChunks, b);
        case "preload":
            return D(c.preloadChunks, b);
        default:
            return D(c.hoistableChunks, b);
    }
}
function D(a, b) {
    a.push(F("link"));
    for(var c in b)if (t.call(b, c)) {
        var d = b[c];
        if (null != d) switch(c){
            case "children":
            case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
                z(a, c, d);
        }
    }
    a.push("/>");
    return null;
}
function Ma(a, b, c) {
    a.push(F(c));
    for(var d in b)if (t.call(b, d)) {
        var e = b[d];
        if (null != e) switch(d){
            case "children":
            case "dangerouslySetInnerHTML":
                throw Error(c + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
                z(a, d, e);
        }
    }
    a.push("/>");
    return null;
}
function Na(a, b) {
    a.push(F("title"));
    var c = null, d = null, e;
    for(e in b)if (t.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                z(a, e, g);
        }
    }
    a.push(">");
    b = Array.isArray(c) ? 2 > c.length ? c[0] : null : c;
    "function" !== typeof b && "symbol" !== typeof b && null !== b && void 0 !== b && a.push(u("" + b));
    A(a, d, c);
    a.push("</", "title", ">");
    return null;
}
function H(a, b) {
    a.push(F("script"));
    var c = null, d = null, e;
    for(e in b)if (t.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                z(a, e, g);
        }
    }
    a.push(">");
    A(a, d, c);
    "string" === typeof c && a.push(u(c));
    a.push("</", "script", ">");
    return null;
}
function J(a, b, c) {
    a.push(F(c));
    var d = c = null, e;
    for(e in b)if (t.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                z(a, e, g);
        }
    }
    a.push(">");
    A(a, d, c);
    return "string" === typeof c ? (a.push(u(c)), null) : c;
}
var Oa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Pa = new Map;
function F(a) {
    var b = Pa.get(a);
    if (void 0 === b) {
        if (!Oa.test(a)) throw Error("Invalid tag: " + a);
        b = "<" + a;
        Pa.set(a, b);
    }
    return b;
}
function Qa(a, b, c, d, e, g, f) {
    switch(b){
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "select":
            a.push(F("select"));
            f = e = null;
            for(var k in c)if (t.call(c, k)) {
                var h = c[k];
                if (null != h) switch(k){
                    case "children":
                        e = h;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = h;
                        break;
                    case "defaultValue":
                    case "value":
                        break;
                    default:
                        z(a, k, h);
                }
            }
            a.push(">");
            A(a, f, e);
            return e;
        case "option":
            e = g.selectedValue;
            a.push(F("option"));
            var l = d = f = null;
            h = null;
            for(var q in c)if (t.call(c, q)) {
                var m = c[q];
                if (null != m) switch(q){
                    case "children":
                        f = m;
                        break;
                    case "selected":
                        l = m;
                        break;
                    case "dangerouslySetInnerHTML":
                        h = m;
                        break;
                    case "value":
                        d = m;
                    default:
                        z(a, q, m);
                }
            }
            if (null != e) if (c = null !== d ? "" + d : Ka(f), qa(e)) for(d = 0; d < e.length; d++){
                if ("" + e[d] === c) {
                    a.push(' selected=""');
                    break;
                }
            }
            else "" + e === c && a.push(' selected=""');
            else l && a.push(' selected=""');
            a.push(">");
            A(a, h, f);
            return f;
        case "textarea":
            a.push(F("textarea"));
            h = f = e = null;
            for(var w in c)if (t.call(c, w) && (d = c[w], null != d)) switch(w){
                case "children":
                    h = d;
                    break;
                case "value":
                    e = d;
                    break;
                case "defaultValue":
                    f = d;
                    break;
                case "dangerouslySetInnerHTML":
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                    z(a, w, d);
            }
            null === e && null !== f && (e = f);
            a.push(">");
            if (null != h) {
                if (null != e) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (qa(h) && 1 < h.length) throw Error("<textarea> can only have at most one child.");
                e = "" + h;
            }
            "string" === typeof e && "\n" === e[0] && a.push("\n");
            null !== e && a.push(u("" + e));
            return null;
        case "input":
            a.push(F("input"));
            var r = null, y = q = null;
            m = l = d = f = g = w = null;
            for(h in c)if (t.call(c, h) && (k = c[h], null != k)) switch(h){
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "name":
                    r = k;
                    break;
                case "formAction":
                    q = k;
                    break;
                case "formEncType":
                    y = k;
                    break;
                case "formMethod":
                    w = k;
                    break;
                case "formTarget":
                    g = k;
                    break;
                case "defaultChecked":
                    m = k;
                    break;
                case "defaultValue":
                    d = k;
                    break;
                case "checked":
                    l = k;
                    break;
                case "value":
                    f = k;
                    break;
                default:
                    z(a, h, k);
            }
            c = Ja(a, e, q, y, w, g, r);
            null !== l ? Ba(a, "checked", l) : null !== m && Ba(a, "checked", m);
            null !== f ? z(a, "value", f) : null !== d && z(a, "value", d);
            a.push("/>");
            null !== c && c.forEach(Ia, a);
            return null;
        case "button":
            a.push(F("button"));
            y = q = r = l = d = h = f = null;
            for(m in c)if (t.call(c, m) && (w = c[m], null != w)) switch(m){
                case "children":
                    f = w;
                    break;
                case "dangerouslySetInnerHTML":
                    h = w;
                    break;
                case "name":
                    d = w;
                    break;
                case "formAction":
                    l = w;
                    break;
                case "formEncType":
                    r = w;
                    break;
                case "formMethod":
                    q = w;
                    break;
                case "formTarget":
                    y = w;
                    break;
                default:
                    z(a, m, w);
            }
            c = Ja(a, e, l, r, q, y, d);
            a.push(">");
            null !== c && c.forEach(Ia, a);
            A(a, h, f);
            "string" === typeof f ? (a.push(u(f)), a = null) : a = f;
            return a;
        case "form":
            a.push(F("form"));
            m = l = d = h = f = e = null;
            for(r in c)if (t.call(c, r) && (q = c[r], null != q)) switch(r){
                case "children":
                    e = q;
                    break;
                case "dangerouslySetInnerHTML":
                    f = q;
                    break;
                case "action":
                    h = q;
                    break;
                case "encType":
                    d = q;
                    break;
                case "method":
                    l = q;
                    break;
                case "target":
                    m = q;
                    break;
                default:
                    z(a, r, q);
            }
            null != h && z(a, "action", h);
            null != d && z(a, "encType", d);
            null != l && z(a, "method", l);
            null != m && z(a, "target", m);
            a.push(">");
            A(a, f, e);
            "string" === typeof e ? (a.push(u(e)), a = null) : a = e;
            return a;
        case "menuitem":
            a.push(F("menuitem"));
            for(var B in c)if (t.call(c, B) && (e = c[B], null != e)) switch(B){
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                    z(a, B, e);
            }
            a.push(">");
            return null;
        case "title":
            return 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp ? a = Na(a, c) : (Na(e.hoistableChunks, c), a = null), a;
        case "link":
            return La(a, c, e, d, f, g.insertionMode, g.noscriptTagInScope);
        case "script":
            e = c.async;
            if ("string" !== typeof c.src || !c.src || !e || "function" === typeof e || "symbol" === typeof e || c.onLoad || c.onError || 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp) a = H(a, c);
            else {
                l = "[script]" + c.src;
                e = d.scriptsMap.get(l);
                if (!e) {
                    e = {
                        type: "script",
                        chunks: [],
                        state: 0,
                        props: null
                    };
                    d.scriptsMap.set(l, e);
                    d.scripts.add(e);
                    h = c;
                    if (d = d.preloadsMap.get(l)) d.state |= 4, c = h = p({}, c), d = d.props, null == c.crossOrigin && (c.crossOrigin = d.crossOrigin), null == c.integrity && (c.integrity = d.integrity);
                    H(e.chunks, h);
                }
                f && a.push("<!-- -->");
                a = null;
            }
            return a;
        case "style":
            e = c.precedence;
            h = c.href;
            if (3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp || "string" !== typeof e || "string" !== typeof h || "" === h) {
                a.push(F("style"));
                f = e = null;
                for(y in c)if (t.call(c, y) && (h = c[y], null != h)) switch(y){
                    case "children":
                        e = h;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = h;
                        break;
                    default:
                        z(a, y, h);
                }
                a.push(">");
                c = Array.isArray(e) ? 2 > e.length ? e[0] : null : e;
                "function" !== typeof c && "symbol" !== typeof c && null !== c && void 0 !== c && a.push(u("" + c));
                A(a, f, e);
                a.push("</", "style", ">");
                a = null;
            } else {
                m = "[style]" + h;
                r = d.stylesMap.get(m);
                if (!r) {
                    (r = d.stylePrecedences.get(e)) ? r.props.hrefs.push(h) : (r = {
                        type: "style",
                        chunks: [],
                        state: 0,
                        props: {
                            precedence: e,
                            hrefs: [
                                h
                            ]
                        }
                    }, d.stylePrecedences.set(e, r), h = new Set, h.add(r), d.precedences.set(e, h));
                    d.stylesMap.set(m, r);
                    d.boundaryResources && d.boundaryResources.add(r);
                    e = r.chunks;
                    d = h = null;
                    for(l in c)if (t.call(c, l) && (m = c[l], null != m)) switch(l){
                        case "children":
                            h = m;
                            break;
                        case "dangerouslySetInnerHTML":
                            d = m;
                    }
                    c = Array.isArray(h) ? 2 > h.length ? h[0] : null : h;
                    "function" !== typeof c && "symbol" !== typeof c && null !== c && void 0 !== c && e.push(u("" + c));
                    A(e, d, h);
                }
                f && a.push("<!-- -->");
                a = void 0;
            }
            return a;
        case "meta":
            return 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp ? a = Ma(a, c, "meta") : (f && a.push("<!-- -->"), a = "string" === typeof c.charSet ? Ma(e.charsetChunks, c, "meta") : Ma(e.hoistableChunks, c, "meta")), a;
        case "listing":
        case "pre":
            a.push(F(b));
            f = e = null;
            for(var G in c)if (t.call(c, G) && (h = c[G], null != h)) switch(G){
                case "children":
                    e = h;
                    break;
                case "dangerouslySetInnerHTML":
                    f = h;
                    break;
                default:
                    z(a, G, h);
            }
            a.push(">");
            if (null != f) {
                if (null != e) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                if ("object" !== typeof f || !("__html" in f)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
                c = f.__html;
                null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push("\n", c) : a.push("" + c));
            }
            "string" === typeof e && "\n" === e[0] && a.push("\n");
            return e;
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
            return Ma(a, c, b);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            break;
        case "head":
            return 2 > g.insertionMode && null === e.headChunks ? (e.headChunks = [], a = J(e.headChunks, c, "head")) : a = J(a, c, "head"), a;
        case "html":
            return 0 === g.insertionMode && null === e.htmlChunks ? (e.htmlChunks = [
                "<!DOCTYPE html>"
            ], a = J(e.htmlChunks, c, "html")) : a = J(a, c, "html"), a;
        default:
            if (-1 !== b.indexOf("-")) {
                a.push(F(b));
                f = e = null;
                for(var n in c)if (t.call(c, n) && (h = c[n], null != h)) switch(n){
                    case "children":
                        e = h;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = h;
                        break;
                    case "style":
                        Aa(a, h);
                        break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                        break;
                    default:
                        ka(n) && "function" !== typeof h && "symbol" !== typeof h && a.push(" ", n, '="', u(h), '"');
                }
                a.push(">");
                A(a, f, e);
                return e;
            }
    }
    return J(a, c, b);
}
function Ra(a, b) {
    b = b.bootstrapChunks;
    for(var c = 0; c < b.length - 1; c++)a.push(b[c]);
    return c < b.length ? (c = b[c], b.length = 0, a.push(c)) : !0;
}
function Sa(a, b, c) {
    a.push('<!--$?--><template id="');
    if (null === c) throw Error("An ID must have been assigned before we can complete the boundary.");
    a.push(c);
    return a.push('"></template>');
}
function Ta(a, b, c, d) {
    switch(c.insertionMode){
        case 0:
        case 1:
        case 2:
            return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 3:
            return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 4:
            return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 5:
            return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 6:
            return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 7:
            return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 8:
            return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        default:
            throw Error("Unknown insertion mode. This is a bug in React.");
    }
}
function Ua(a, b) {
    switch(b.insertionMode){
        case 0:
        case 1:
        case 2:
            return a.push("</div>");
        case 3:
            return a.push("</svg>");
        case 4:
            return a.push("</math>");
        case 5:
            return a.push("</table>");
        case 6:
            return a.push("</tbody></table>");
        case 7:
            return a.push("</tr></table>");
        case 8:
            return a.push("</colgroup></table>");
        default:
            throw Error("Unknown insertion mode. This is a bug in React.");
    }
}
var Va = /[<\u2028\u2029]/g;
function Wa(a) {
    return JSON.stringify(a).replace(Va, function(b) {
        switch(b){
            case "<":
                return "\\u003c";
            case "\u2028":
                return "\\u2028";
            case "\u2029":
                return "\\u2029";
            default:
                throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
    });
}
var Xa = /[&><\u2028\u2029]/g;
function K(a) {
    return JSON.stringify(a).replace(Xa, function(b) {
        switch(b){
            case "&":
                return "\\u0026";
            case ">":
                return "\\u003e";
            case "<":
                return "\\u003c";
            case "\u2028":
                return "\\u2028";
            case "\u2029":
                return "\\u2029";
            default:
                throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
    });
}
var Ya = !1, Za = !0;
function $a(a) {
    if ("stylesheet" === a.type && 0 === (a.state & 1)) Ya = !0;
    else if ("style" === a.type) {
        var b = a.chunks, c = a.props.hrefs, d = 0;
        if (b.length) {
            this.push('<style media="not all" data-precedence="');
            a = u(a.props.precedence);
            this.push(a);
            if (c.length) {
                for(this.push('" data-href="'); d < c.length - 1; d++)a = u(c[d]), this.push(a), this.push(" ");
                d = u(c[d]);
                this.push(d);
            }
            this.push('">');
            for(d = 0; d < b.length; d++)this.push(b[d]);
            Za = this.push("</style>");
            Ya = !0;
            b.length = 0;
            c.length = 0;
        }
    }
}
function bb(a, b, c) {
    Ya = !1;
    Za = !0;
    b.forEach($a, a);
    Ya && (c.stylesToHoist = !0);
    return Za;
}
function L(a) {
    if (0 === (a.state & 7)) {
        for(var b = a.chunks, c = 0; c < b.length; c++)this.push(b[c]);
        a.state |= 1;
    }
}
function M(a) {
    if (0 === (a.state & 7)) {
        for(var b = a.chunks, c = 0; c < b.length; c++)this.push(b[c]);
        a.state |= 2;
    }
}
var cb = null, db = !1;
function eb(a, b, c) {
    b = a.chunks;
    if (a.state & 3) c.delete(a);
    else if ("style" === a.type) cb = a;
    else {
        D(b, a.props);
        for(c = 0; c < b.length; c++)this.push(b[c]);
        a.state |= 1;
        db = !0;
    }
}
function fb(a, b) {
    db = !1;
    a.forEach(eb, this);
    a.clear();
    a = cb.chunks;
    var c = cb.props.hrefs;
    if (!1 === db || a.length) {
        this.push('<style data-precedence="');
        b = u(b);
        this.push(b);
        b = 0;
        if (c.length) {
            for(this.push('" data-href="'); b < c.length - 1; b++){
                var d = u(c[b]);
                this.push(d);
                this.push(" ");
            }
            b = u(c[b]);
            this.push(b);
        }
        this.push('">');
        for(b = 0; b < a.length; b++)this.push(a[b]);
        this.push("</style>");
        a.length = 0;
        c.length = 0;
    }
}
function gb(a) {
    if (!(a.state & 8) && "style" !== a.type) {
        var b = a.chunks, c = a.props;
        D(b, {
            rel: "preload",
            as: "style",
            href: a.props.href,
            crossOrigin: c.crossOrigin,
            fetchPriority: c.fetchPriority,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
        });
        for(c = 0; c < b.length; c++)this.push(b[c]);
        a.state |= 8;
        b.length = 0;
    }
}
function hb(a) {
    a.forEach(gb, this);
    a.clear();
}
function ib(a, b) {
    a.push("[");
    var c = "[";
    b.forEach(function(d) {
        if ("style" !== d.type && !(d.state & 1)) {
            if (d.state & 3) a.push(c), d = K("" + d.props.href), a.push(d), a.push("]"), c = ",[";
            else if ("stylesheet" === d.type) {
                a.push(c);
                var e = d.props["data-precedence"], g = d.props, f = K("" + d.props.href);
                a.push(f);
                e = "" + e;
                a.push(",");
                e = K(e);
                a.push(e);
                for(var k in g)if (t.call(g, k) && (f = g[k], null != f)) switch(k){
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                    default:
                        a: {
                            e = a;
                            var h = k.toLowerCase();
                            switch(typeof f){
                                case "function":
                                case "symbol":
                                    break a;
                            }
                            switch(k){
                                case "innerHTML":
                                case "dangerouslySetInnerHTML":
                                case "suppressContentEditableWarning":
                                case "suppressHydrationWarning":
                                case "style":
                                    break a;
                                case "className":
                                    h = "class";
                                    f = "" + f;
                                    break;
                                case "hidden":
                                    if (!1 === f) break a;
                                    f = "";
                                    break;
                                case "src":
                                case "href":
                                    f = "" + f;
                                    break;
                                default:
                                    if (2 < k.length && ("o" === k[0] || "O" === k[0]) && ("n" === k[1] || "N" === k[1]) || !ka(k)) break a;
                                    f = "" + f;
                            }
                            e.push(",");
                            h = K(h);
                            e.push(h);
                            e.push(",");
                            f = K(f);
                            e.push(f);
                        }
                }
                a.push("]");
                c = ",[";
                d.state |= 2;
            }
        }
    });
    a.push("]");
}
function jb(a, b) {
    a.push("[");
    var c = "[";
    b.forEach(function(d) {
        if ("style" !== d.type && !(d.state & 1)) {
            if (d.state & 3) a.push(c), d = u(JSON.stringify("" + d.props.href)), a.push(d), a.push("]"), c = ",[";
            else if ("stylesheet" === d.type) {
                a.push(c);
                var e = d.props["data-precedence"], g = d.props, f = u(JSON.stringify("" + d.props.href));
                a.push(f);
                e = "" + e;
                a.push(",");
                e = u(JSON.stringify(e));
                a.push(e);
                for(var k in g)if (t.call(g, k) && (f = g[k], null != f)) switch(k){
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                    default:
                        a: {
                            e = a;
                            var h = k.toLowerCase();
                            switch(typeof f){
                                case "function":
                                case "symbol":
                                    break a;
                            }
                            switch(k){
                                case "innerHTML":
                                case "dangerouslySetInnerHTML":
                                case "suppressContentEditableWarning":
                                case "suppressHydrationWarning":
                                case "style":
                                    break a;
                                case "className":
                                    h = "class";
                                    f = "" + f;
                                    break;
                                case "hidden":
                                    if (!1 === f) break a;
                                    f = "";
                                    break;
                                case "src":
                                case "href":
                                    f = "" + f;
                                    break;
                                default:
                                    if (2 < k.length && ("o" === k[0] || "O" === k[0]) && ("n" === k[1] || "N" === k[1]) || !ka(k)) break a;
                                    f = "" + f;
                            }
                            e.push(",");
                            h = u(JSON.stringify(h));
                            e.push(h);
                            e.push(",");
                            f = u(JSON.stringify(f));
                            e.push(f);
                        }
                }
                a.push("]");
                c = ",[";
                d.state |= 2;
            }
        }
    });
    a.push("]");
}
function kb() {
    return {
        preloadsMap: new Map,
        preconnectsMap: new Map,
        stylesMap: new Map,
        scriptsMap: new Map,
        preconnects: new Set,
        fontPreloads: new Set,
        precedences: new Map,
        stylePrecedences: new Map,
        scripts: new Set,
        explicitStylesheetPreloads: new Set,
        explicitScriptPreloads: new Set,
        explicitOtherPreloads: new Set,
        boundaryResources: null
    };
}
function ta(a) {
    var b = N ? N : null;
    if (b) {
        var c = b.resources;
        if ("string" === typeof a && a) {
            var d = "[prefetchDNS]" + a, e = c.preconnectsMap.get(d);
            e || (e = {
                type: "preconnect",
                chunks: [],
                state: 0,
                props: null
            }, c.preconnectsMap.set(d, e), D(e.chunks, {
                href: a,
                rel: "dns-prefetch"
            }));
            c.preconnects.add(e);
            lb(b);
        }
    }
}
function ua(a, b) {
    var c = N ? N : null;
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a) {
            b = null == b || "string" !== typeof b.crossOrigin ? null : "use-credentials" === b.crossOrigin ? "use-credentials" : "";
            var e = "[preconnect][" + (null === b ? "null" : b) + "]" + a, g = d.preconnectsMap.get(e);
            g || (g = {
                type: "preconnect",
                chunks: [],
                state: 0,
                props: null
            }, d.preconnectsMap.set(e, g), D(g.chunks, {
                rel: "preconnect",
                href: a,
                crossOrigin: b
            }));
            d.preconnects.add(g);
            lb(c);
        }
    }
}
function va(a, b) {
    var c = N ? N : null;
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a && "object" === typeof b && null !== b && "string" === typeof b.as && b.as) {
            var e = b.as;
            if ("image" === e) {
                var g = b.imageSrcSet;
                var f = b.imageSizes, k = "";
                "string" === typeof g && "" !== g ? (k += "[" + g + "]", "string" === typeof f && (k += "[" + f + "]")) : k += "[][]" + a;
                g = "[" + e + "]" + k;
            } else g = "[" + e + "]" + a;
            f = d.preloadsMap.get(g);
            f || (f = {
                type: "preload",
                chunks: [],
                state: 0,
                props: {
                    rel: "preload",
                    as: e,
                    href: "image" === e && b.imageSrcSet ? void 0 : a,
                    crossOrigin: "font" === e ? "" : b.crossOrigin,
                    integrity: b.integrity,
                    type: b.type,
                    nonce: b.nonce,
                    fetchPriority: b.fetchPriority,
                    imageSrcSet: b.imageSrcSet,
                    imageSizes: b.imageSizes,
                    referrerPolicy: b.referrerPolicy
                }
            }, d.preloadsMap.set(g, f), D(f.chunks, f.props));
            switch(e){
                case "font":
                    d.fontPreloads.add(f);
                    break;
                case "style":
                    d.explicitStylesheetPreloads.add(f);
                    break;
                case "script":
                    d.explicitScriptPreloads.add(f);
                    break;
                default:
                    d.explicitOtherPreloads.add(f);
            }
            lb(c);
        }
    }
}
function wa(a, b) {
    var c = N ? N : null;
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a && "object" === typeof b && null !== b) {
            var e = b.as;
            switch(e){
                case "style":
                    var g = "[" + e + "]" + a, f = d.stylesMap.get(g);
                    e = b.precedence || "default";
                    if (!f) {
                        f = 0;
                        var k = d.preloadsMap.get(g);
                        k && k.state & 3 && (f = 8);
                        f = {
                            type: "stylesheet",
                            chunks: [],
                            state: f,
                            props: {
                                rel: "stylesheet",
                                href: a,
                                "data-precedence": e,
                                crossOrigin: b.crossOrigin,
                                integrity: b.integrity,
                                fetchPriority: b.fetchPriority
                            }
                        };
                        d.stylesMap.set(g, f);
                        a = d.precedences.get(e);
                        a || (a = new Set, d.precedences.set(e, a), b = {
                            type: "style",
                            chunks: [],
                            state: 0,
                            props: {
                                precedence: e,
                                hrefs: []
                            }
                        }, a.add(b), d.stylePrecedences.set(e, b));
                        a.add(f);
                        lb(c);
                    }
                    break;
                case "script":
                    g = "[" + e + "]" + a, e = d.scriptsMap.get(g), e || (e = {
                        type: "script",
                        chunks: [],
                        state: 0,
                        props: null
                    }, d.scriptsMap.set(g, e), a = {
                        src: a,
                        async: !0,
                        crossOrigin: b.crossOrigin,
                        integrity: b.integrity,
                        nonce: b.nonce,
                        fetchPriority: b.fetchPriority
                    }, d.scripts.add(e), H(e.chunks, a), lb(c));
            }
        }
    }
}
function mb(a) {
    this.add(a);
}
function nb(a, b, c, d) {
    a = void 0 === c ? "" : c;
    c = null;
    var e = 0;
    void 0 !== d && (e = 1, "string" === typeof d ? (c = {
        src: d,
        chunks: []
    }, H(c.chunks, {
        src: d,
        async: !0,
        integrity: void 0,
        nonce: void 0
    })) : (c = {
        src: d.src,
        chunks: []
    }, H(c.chunks, {
        src: d.src,
        async: !0,
        integrity: d.integrity,
        nonce: void 0
    })));
    return {
        bootstrapChunks: [],
        placeholderPrefix: a + "P:",
        segmentPrefix: a + "S:",
        boundaryPrefix: a + "B:",
        idPrefix: a,
        nextSuspenseID: 0,
        streamingFormat: e,
        startInlineScript: "<script>",
        instructions: 0,
        externalRuntimeScript: c,
        htmlChunks: null,
        headChunks: null,
        hasBody: !1,
        charsetChunks: [],
        preconnectChunks: [],
        preloadChunks: [],
        hoistableChunks: [],
        stylesToHoist: !1,
        generateStaticMarkup: b
    };
}
function ob() {
    return {
        insertionMode: 2,
        selectedValue: null,
        noscriptTagInScope: !1
    };
}
function pb(a, b, c, d) {
    if (c.generateStaticMarkup) return a.push(u(b)), !1;
    "" === b ? a = d : (d && a.push("<!-- -->"), a.push(u(b)), a = !0);
    return a;
}
var qb = Symbol.for("react.element"), rb = Symbol.for("react.portal"), sb = Symbol.for("react.fragment"), tb = Symbol.for("react.strict_mode"), ub = Symbol.for("react.profiler"), vb = Symbol.for("react.provider"), wb = Symbol.for("react.context"), xb = Symbol.for("react.server_context"), yb = Symbol.for("react.forward_ref"), zb = Symbol.for("react.suspense"), Ab = Symbol.for("react.suspense_list"), Bb = Symbol.for("react.memo"), Cb = Symbol.for("react.lazy"), Db = Symbol.for("react.scope"), Eb = Symbol.for("react.debug_trace_mode"), Fb = Symbol.for("react.offscreen"), Gb = Symbol.for("react.legacy_hidden"), Hb = Symbol.for("react.cache"), Ib = Symbol.for("react.default_value"), Jb = Symbol.iterator;
function Kb(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch(a){
        case sb:
            return "Fragment";
        case rb:
            return "Portal";
        case ub:
            return "Profiler";
        case tb:
            return "StrictMode";
        case zb:
            return "Suspense";
        case Ab:
            return "SuspenseList";
        case Hb:
            return "Cache";
    }
    if ("object" === typeof a) switch(a.$$typeof){
        case wb:
            return (a.displayName || "Context") + ".Consumer";
        case vb:
            return (a._context.displayName || "Context") + ".Provider";
        case yb:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
        case Bb:
            return b = a.displayName || null, null !== b ? b : Kb(a.type) || "Memo";
        case Cb:
            b = a._payload;
            a = a._init;
            try {
                return Kb(a(b));
            } catch (c) {
                break;
            }
        case xb:
            return (a.displayName || a._globalName) + ".Provider";
    }
    return null;
}
var Lb = {};
function Mb(a, b) {
    a = a.contextTypes;
    if (!a) return Lb;
    var c = {}, d;
    for(d in a)c[d] = b[d];
    return c;
}
var O = null;
function Nb(a, b) {
    if (a !== b) {
        a.context._currentValue2 = a.parentValue;
        a = a.parent;
        var c = b.parent;
        if (null === a) {
            if (null !== c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
            if (null === c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
            Nb(a, c);
        }
        b.context._currentValue2 = b.value;
    }
}
function Ob(a) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    null !== a && Ob(a);
}
function Pb(a) {
    var b = a.parent;
    null !== b && Pb(b);
    a.context._currentValue2 = a.value;
}
function Qb(a, b) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === b.depth ? Nb(a, b) : Qb(a, b);
}
function Rb(a, b) {
    var c = b.parent;
    if (null === c) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === c.depth ? Nb(a, c) : Rb(a, c);
    b.context._currentValue2 = b.value;
}
function Sb(a) {
    var b = O;
    b !== a && (null === b ? Pb(a) : null === a ? Ob(b) : b.depth === a.depth ? Nb(b, a) : b.depth > a.depth ? Qb(b, a) : Rb(b, a), O = a);
}
var Tb = {
    isMounted: function() {
        return !1;
    },
    enqueueSetState: function(a, b) {
        a = a._reactInternals;
        null !== a.queue && a.queue.push(b);
    },
    enqueueReplaceState: function(a, b) {
        a = a._reactInternals;
        a.replace = !0;
        a.queue = [
            b
        ];
    },
    enqueueForceUpdate: function() {}
};
function Ub(a, b, c, d) {
    var e = void 0 !== a.state ? a.state : null;
    a.updater = Tb;
    a.props = c;
    a.state = e;
    var g = {
        queue: [],
        replace: !1
    };
    a._reactInternals = g;
    var f = b.contextType;
    a.context = "object" === typeof f && null !== f ? f._currentValue2 : d;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (f = f(c, e), e = null === f || void 0 === f ? e : p({}, e, f), a.state = e);
    if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && Tb.enqueueReplaceState(a, a.state, null), null !== g.queue && 0 < g.queue.length) if (b = g.queue, f = g.replace, g.queue = null, g.replace = !1, f && 1 === b.length) a.state = b[0];
    else {
        g = f ? b[0] : a.state;
        e = !0;
        for(f = f ? 1 : 0; f < b.length; f++){
            var k = b[f];
            k = "function" === typeof k ? k.call(a, g, c, d) : k;
            null != k && (e ? (e = !1, g = p({}, g, k)) : p(g, k));
        }
        a.state = g;
    }
    else g.queue = null;
}
var Vb = {
    id: 1,
    overflow: ""
};
function Wb(a, b, c) {
    var d = a.id;
    a = a.overflow;
    var e = 32 - Xb(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var g = 32 - Xb(b) + e;
    if (30 < g) {
        var f = e - e % 5;
        g = (d & (1 << f) - 1).toString(32);
        d >>= f;
        e -= f;
        return {
            id: 1 << 32 - Xb(b) + e | c << e | d,
            overflow: g + a
        };
    }
    return {
        id: 1 << g | c << e | d,
        overflow: a
    };
}
var Xb = Math.clz32 ? Math.clz32 : Yb, Zb = Math.log, $b = Math.LN2;
function Yb(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (Zb(a) / $b | 0) | 0;
}
var ac = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`");
function bc() {}
function cc(a, b, c) {
    c = a[c];
    void 0 === c ? a.push(b) : c !== b && (b.then(bc, bc), b = c);
    switch(b.status){
        case "fulfilled":
            return b.value;
        case "rejected":
            throw b.reason;
        default:
            if ("string" !== typeof b.status) switch(a = b, a.status = "pending", a.then(function(d) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "fulfilled";
                    e.value = d;
                }
            }, function(d) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "rejected";
                    e.reason = d;
                }
            }), b.status){
                case "fulfilled":
                    return b.value;
                case "rejected":
                    throw b.reason;
            }
            fc = b;
            throw ac;
    }
}
var fc = null;
function gc() {
    if (null === fc) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
    var a = fc;
    fc = null;
    return a;
}
function hc(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var ic = "function" === typeof Object.is ? Object.is : hc, Q = null, jc = null, kc = null, R = null, lc = !1, mc = !1, S = 0, nc = 0, T = null, U = null, oc = 0;
function X() {
    if (null === Q) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return Q;
}
function pc() {
    if (0 < oc) throw Error("Rendered more hooks than during the previous render");
    return {
        memoizedState: null,
        queue: null,
        next: null
    };
}
function qc() {
    null === R ? null === kc ? (lc = !1, kc = R = pc()) : (lc = !0, R = kc) : null === R.next ? (lc = !1, R = R.next = pc()) : (lc = !0, R = R.next);
    return R;
}
function rc(a, b, c, d) {
    for(; mc;)mc = !1, nc = S = 0, oc += 1, R = null, c = a(b, d);
    sc();
    return c;
}
function tc() {
    var a = T;
    T = null;
    return a;
}
function sc() {
    jc = Q = null;
    mc = !1;
    kc = null;
    oc = 0;
    R = U = null;
}
function uc(a, b) {
    return "function" === typeof b ? b(a) : b;
}
function vc(a, b, c) {
    Q = X();
    R = qc();
    if (lc) {
        var d = R.queue;
        b = d.dispatch;
        if (null !== U && (c = U.get(d), void 0 !== c)) {
            U.delete(d);
            d = R.memoizedState;
            do d = a(d, c.action), c = c.next;
            while (null !== c);
            R.memoizedState = d;
            return [
                d,
                b
            ];
        }
        return [
            R.memoizedState,
            b
        ];
    }
    a = a === uc ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
    R.memoizedState = a;
    a = R.queue = {
        last: null,
        dispatch: null
    };
    a = a.dispatch = wc.bind(null, Q, a);
    return [
        R.memoizedState,
        a
    ];
}
function xc(a, b) {
    Q = X();
    R = qc();
    b = void 0 === b ? null : b;
    if (null !== R) {
        var c = R.memoizedState;
        if (null !== c && null !== b) {
            var d = c[1];
            a: if (null === d) d = !1;
            else {
                for(var e = 0; e < d.length && e < b.length; e++)if (!ic(b[e], d[e])) {
                    d = !1;
                    break a;
                }
                d = !0;
            }
            if (d) return c[0];
        }
    }
    a = a();
    R.memoizedState = [
        a,
        b
    ];
    return a;
}
function wc(a, b, c) {
    if (25 <= oc) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    if (a === Q) if (mc = !0, a = {
        action: c,
        next: null
    }, null === U && (U = new Map), c = U.get(b), void 0 === c) U.set(b, a);
    else {
        for(b = c; null !== b.next;)b = b.next;
        b.next = a;
    }
}
function yc() {
    throw Error("startTransition cannot be called during server rendering.");
}
function zc(a) {
    var b = nc;
    nc += 1;
    null === T && (T = []);
    return cc(T, a, b);
}
function Ac() {
    throw Error("Cache cannot be refreshed during server rendering.");
}
function Bc() {}
var Dc = {
    readContext: function(a) {
        return a._currentValue2;
    },
    use: function(a) {
        if (null !== a && "object" === typeof a) {
            if ("function" === typeof a.then) return zc(a);
            if (a.$$typeof === wb || a.$$typeof === xb) return a._currentValue2;
        }
        throw Error("An unsupported type was passed to use(): " + String(a));
    },
    useContext: function(a) {
        X();
        return a._currentValue2;
    },
    useMemo: xc,
    useReducer: vc,
    useRef: function(a) {
        Q = X();
        R = qc();
        var b = R.memoizedState;
        return null === b ? (a = {
            current: a
        }, R.memoizedState = a) : b;
    },
    useState: function(a) {
        return vc(uc, a);
    },
    useInsertionEffect: Bc,
    useLayoutEffect: Bc,
    useCallback: function(a, b) {
        return xc(function() {
            return a;
        }, b);
    },
    useImperativeHandle: Bc,
    useEffect: Bc,
    useDebugValue: Bc,
    useDeferredValue: function(a) {
        X();
        return a;
    },
    useTransition: function() {
        X();
        return [
            !1,
            yc
        ];
    },
    useId: function() {
        var a = jc.treeContext;
        var b = a.overflow;
        a = a.id;
        a = (a & ~(1 << 32 - Xb(a) - 1)).toString(32) + b;
        var c = Cc;
        if (null === c) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        b = S++;
        a = ":" + c.idPrefix + "R" + a;
        0 < b && (a += "H" + b.toString(32));
        return a + ":";
    },
    useSyncExternalStore: function(a, b, c) {
        if (void 0 === c) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return c();
    },
    useCacheRefresh: function() {
        return Ac;
    }
}, Cc = null, Ec = {
    getCacheSignal: function() {
        throw Error("Not implemented.");
    },
    getCacheForType: function() {
        throw Error("Not implemented.");
    }
}, Fc = ra.ReactCurrentDispatcher, Gc = ra.ReactCurrentCache;
function Hc(a) {
    console.error(a);
    return null;
}
function Ic() {}
function Jc(a, b, c, d, e, g, f, k, h, l) {
    sa.current = xa;
    var q = [], m = new Set;
    b = {
        destination: null,
        flushScheduled: !1,
        responseState: c,
        progressiveChunkSize: void 0 === e ? 12800 : e,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        resources: b,
        completedRootSegment: null,
        abortableTasks: m,
        pingedTasks: q,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: void 0 === g ? Hc : g,
        onAllReady: void 0 === f ? Ic : f,
        onShellReady: void 0 === k ? Ic : k,
        onShellError: void 0 === h ? Ic : h,
        onFatalError: void 0 === l ? Ic : l
    };
    d = Kc(b, 0, null, d, !1, !1);
    d.parentFlushed = !0;
    a = Lc(b, null, a, null, d, m, Lb, null, Vb);
    q.push(a);
    return b;
}
var N = null;
function Lc(a, b, c, d, e, g, f, k, h) {
    a.allPendingTasks++;
    null === d ? a.pendingRootTasks++ : d.pendingTasks++;
    var l = {
        node: c,
        ping: function() {
            a.pingedTasks.push(l);
            1 === a.pingedTasks.length && (a.flushScheduled = null !== a.destination, Mc(a));
        },
        blockedBoundary: d,
        blockedSegment: e,
        abortSet: g,
        legacyContext: f,
        context: k,
        treeContext: h,
        thenableState: b
    };
    g.add(l);
    return l;
}
function Kc(a, b, c, d, e, g) {
    return {
        status: 0,
        id: -1,
        index: b,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: d,
        boundary: c,
        lastPushedText: e,
        textEmbedded: g
    };
}
function Y(a, b) {
    a = a.onError(b);
    if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
    return a;
}
function Nc(a, b) {
    var c = a.onShellError;
    c(b);
    c = a.onFatalError;
    c(b);
    null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
}
function Oc(a, b, c, d) {
    var e = c.render(), g = d.childContextTypes;
    if (null !== g && void 0 !== g) {
        var f = b.legacyContext;
        if ("function" !== typeof c.getChildContext) d = f;
        else {
            c = c.getChildContext();
            for(var k in c)if (!(k in g)) throw Error((Kb(d) || "Unknown") + '.getChildContext(): key "' + k + '" is not defined in childContextTypes.');
            d = p({}, f, c);
        }
        b.legacyContext = d;
        Z(a, b, null, e);
        b.legacyContext = f;
    } else Z(a, b, null, e);
}
function Pc(a, b) {
    if (a && a.defaultProps) {
        b = p({}, b);
        a = a.defaultProps;
        for(var c in a)void 0 === b[c] && (b[c] = a[c]);
        return b;
    }
    return b;
}
function Qc(a, b, c, d, e, g) {
    if ("function" === typeof d) if (d.prototype && d.prototype.isReactComponent) c = Mb(d, b.legacyContext), g = d.contextType, g = new d(e, "object" === typeof g && null !== g ? g._currentValue2 : c), Ub(g, d, e, c), Oc(a, b, g, d);
    else {
        g = Mb(d, b.legacyContext);
        Q = {};
        jc = b;
        nc = S = 0;
        T = c;
        c = d(e, g);
        c = rc(d, e, c, g);
        var f = 0 !== S;
        if ("object" === typeof c && null !== c && "function" === typeof c.render && void 0 === c.$$typeof) Ub(c, d, e, g), Oc(a, b, c, d);
        else if (f) {
            e = b.treeContext;
            b.treeContext = Wb(e, 1, 0);
            try {
                Z(a, b, null, c);
            } finally{
                b.treeContext = e;
            }
        } else Z(a, b, null, c);
    }
    else if ("string" === typeof d) {
        c = b.blockedSegment;
        f = Qa(c.chunks, d, e, a.resources, a.responseState, c.formatContext, c.lastPushedText);
        c.lastPushedText = !1;
        g = c.formatContext;
        c.formatContext = ya(g, d, e);
        Rc(a, b, f);
        c.formatContext = g;
        a: {
            b = c.chunks;
            switch(d){
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                    break a;
                case "body":
                    if (1 >= g.insertionMode) {
                        a.responseState.hasBody = !0;
                        break a;
                    }
                    break;
                case "html":
                    if (0 === g.insertionMode) break a;
            }
            b.push("</", d, ">");
        }
        c.lastPushedText = !1;
    } else {
        switch(d){
            case Gb:
            case Eb:
            case tb:
            case ub:
            case sb:
                Z(a, b, null, e.children);
                return;
            case Fb:
                "hidden" !== e.mode && Z(a, b, null, e.children);
                return;
            case Ab:
                Z(a, b, null, e.children);
                return;
            case Db:
                throw Error("ReactDOMServer does not yet support scope components.");
            case zb:
                a: {
                    d = b.blockedBoundary;
                    c = b.blockedSegment;
                    g = e.fallback;
                    e = e.children;
                    f = new Set;
                    var k = {
                        id: null,
                        rootSegmentID: -1,
                        parentFlushed: !1,
                        pendingTasks: 0,
                        forceClientRender: !1,
                        completedSegments: [],
                        byteSize: 0,
                        fallbackAbortableTasks: f,
                        errorDigest: null,
                        resources: new Set
                    }, h = Kc(a, c.chunks.length, k, c.formatContext, !1, !1);
                    c.children.push(h);
                    c.lastPushedText = !1;
                    var l = Kc(a, 0, null, c.formatContext, !1, !1);
                    l.parentFlushed = !0;
                    b.blockedBoundary = k;
                    b.blockedSegment = l;
                    a.resources.boundaryResources = k.resources;
                    try {
                        if (Rc(a, b, e), a.responseState.generateStaticMarkup || l.lastPushedText && l.textEmbedded && l.chunks.push("<!-- -->"), l.status = 1, Sc(k, l), 0 === k.pendingTasks) break a;
                    } catch (q) {
                        l.status = 4, k.forceClientRender = !0, k.errorDigest = Y(a, q);
                    } finally{
                        a.resources.boundaryResources = d ? d.resources : null, b.blockedBoundary = d, b.blockedSegment = c;
                    }
                    b = Lc(a, null, g, d, h, f, b.legacyContext, b.context, b.treeContext);
                    a.pingedTasks.push(b);
                }
                return;
        }
        if ("object" === typeof d && null !== d) switch(d.$$typeof){
            case yb:
                d = d.render;
                Q = {};
                jc = b;
                nc = S = 0;
                T = c;
                c = d(e, g);
                e = rc(d, e, c, g);
                if (0 !== S) {
                    d = b.treeContext;
                    b.treeContext = Wb(d, 1, 0);
                    try {
                        Z(a, b, null, e);
                    } finally{
                        b.treeContext = d;
                    }
                } else Z(a, b, null, e);
                return;
            case Bb:
                d = d.type;
                e = Pc(d, e);
                Qc(a, b, c, d, e, g);
                return;
            case vb:
                c = e.children;
                d = d._context;
                e = e.value;
                g = d._currentValue2;
                d._currentValue2 = e;
                f = O;
                O = e = {
                    parent: f,
                    depth: null === f ? 0 : f.depth + 1,
                    context: d,
                    parentValue: g,
                    value: e
                };
                b.context = e;
                Z(a, b, null, c);
                a = O;
                if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
                e = a.parentValue;
                a.context._currentValue2 = e === Ib ? a.context._defaultValue : e;
                a = O = a.parent;
                b.context = a;
                return;
            case wb:
                e = e.children;
                e = e(d._currentValue2);
                Z(a, b, null, e);
                return;
            case Cb:
                g = d._init;
                d = g(d._payload);
                e = Pc(d, e);
                Qc(a, b, c, d, e, void 0);
                return;
        }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == d ? d : typeof d) + "."));
    }
}
function Z(a, b, c, d) {
    b.node = d;
    if ("object" === typeof d && null !== d) {
        switch(d.$$typeof){
            case qb:
                Qc(a, b, c, d.type, d.props, d.ref);
                return;
            case rb:
                throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case Cb:
                c = d._init;
                d = c(d._payload);
                Z(a, b, null, d);
                return;
        }
        if (qa(d)) {
            Tc(a, b, d);
            return;
        }
        null === d || "object" !== typeof d ? c = null : (c = Jb && d[Jb] || d["@@iterator"], c = "function" === typeof c ? c : null);
        if (c && (c = c.call(d))) {
            d = c.next();
            if (!d.done) {
                var e = [];
                do e.push(d.value), d = c.next();
                while (!d.done);
                Tc(a, b, e);
            }
            return;
        }
        if ("function" === typeof d.then) return Z(a, b, null, zc(d));
        if (d.$$typeof === wb || d.$$typeof === xb) return Z(a, b, null, d._currentValue2);
        a = Object.prototype.toString.call(d);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a ? "object with keys {" + Object.keys(d).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    "string" === typeof d ? (c = b.blockedSegment, c.lastPushedText = pb(b.blockedSegment.chunks, d, a.responseState, c.lastPushedText)) : "number" === typeof d && (c = b.blockedSegment, c.lastPushedText = pb(b.blockedSegment.chunks, "" + d, a.responseState, c.lastPushedText));
}
function Tc(a, b, c) {
    for(var d = c.length, e = 0; e < d; e++){
        var g = b.treeContext;
        b.treeContext = Wb(g, d, e);
        try {
            Rc(a, b, c[e]);
        } finally{
            b.treeContext = g;
        }
    }
}
function Rc(a, b, c) {
    var d = b.blockedSegment, e = d.children.length, g = d.chunks.length, f = b.blockedSegment.formatContext, k = b.legacyContext, h = b.context;
    try {
        return Z(a, b, null, c);
    } catch (l) {
        if (sc(), d.children.length = e, d.chunks.length = g, c = l === ac ? gc() : l, "object" === typeof c && null !== c && "function" === typeof c.then) d = tc(), e = b.blockedSegment, g = Kc(a, e.chunks.length, null, e.formatContext, e.lastPushedText, !0), e.children.push(g), e.lastPushedText = !1, a = Lc(a, d, b.node, b.blockedBoundary, g, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = f, b.legacyContext = k, b.context = h, Sb(h);
        else throw b.blockedSegment.formatContext = f, b.legacyContext = k, b.context = h, Sb(h), c;
    }
}
function Uc(a) {
    var b = a.blockedBoundary;
    a = a.blockedSegment;
    a.status = 3;
    Vc(this, b, a);
}
function Wc(a, b, c) {
    var d = a.blockedBoundary;
    a.blockedSegment.status = 3;
    null === d ? (b.allPendingTasks--, 1 !== b.status && 2 !== b.status && (Y(b, c), Nc(b, c))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(e) {
        return Wc(e, b, c);
    }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (a = b.onAllReady, a()));
}
function Sc(a, b) {
    if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
        var c = b.children[0];
        c.id = b.id;
        c.parentFlushed = !0;
        1 === c.status && Sc(a, c);
    } else a.completedSegments.push(b);
}
function Vc(a, b, c) {
    if (null === b) {
        if (c.parentFlushed) {
            if (null !== a.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
            a.completedRootSegment = c;
        }
        a.pendingRootTasks--;
        0 === a.pendingRootTasks && (a.onShellError = Ic, b = a.onShellReady, b());
    } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && Sc(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Uc, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (Sc(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
    a.allPendingTasks--;
    0 === a.allPendingTasks && (a = a.onAllReady, a());
}
function Mc(a) {
    if (2 !== a.status) {
        var b = O, c = Fc.current;
        Fc.current = Dc;
        var d = Gc.current;
        Gc.current = Ec;
        var e = N;
        N = a;
        var g = Cc;
        Cc = a.responseState;
        try {
            var f = a.pingedTasks, k;
            for(k = 0; k < f.length; k++){
                var h = f[k];
                var l = a, q = h.blockedBoundary;
                l.resources.boundaryResources = q ? q.resources : null;
                var m = h.blockedSegment;
                if (0 === m.status) {
                    Sb(h.context);
                    var w = m.children.length, r = m.chunks.length;
                    try {
                        var y = h.thenableState;
                        h.thenableState = null;
                        Z(l, h, y, h.node);
                        l.responseState.generateStaticMarkup || m.lastPushedText && m.textEmbedded && m.chunks.push("<!-- -->");
                        h.abortSet.delete(h);
                        m.status = 1;
                        Vc(l, h.blockedBoundary, m);
                    } catch (C) {
                        sc();
                        m.children.length = w;
                        m.chunks.length = r;
                        var B = C === ac ? gc() : C;
                        if ("object" === typeof B && null !== B && "function" === typeof B.then) {
                            var G = h.ping;
                            B.then(G, G);
                            h.thenableState = tc();
                        } else {
                            h.abortSet.delete(h);
                            m.status = 4;
                            var n = l, I = h.blockedBoundary, V = B, ha = Y(n, V);
                            null === I ? Nc(n, V) : (I.pendingTasks--, I.forceClientRender || (I.forceClientRender = !0, I.errorDigest = ha, I.parentFlushed && n.clientRenderedBoundaries.push(I)));
                            n.allPendingTasks--;
                            if (0 === n.allPendingTasks) {
                                var ia = n.onAllReady;
                                ia();
                            }
                        }
                    } finally{
                        l.resources.boundaryResources = null;
                    }
                }
            }
            f.splice(0, k);
            null !== a.destination && Xc(a, a.destination);
        } catch (C) {
            Y(a, C), Nc(a, C);
        } finally{
            Cc = g, Fc.current = c, Gc.current = d, c === Dc && Sb(b), N = e;
        }
    }
}
function Yc(a, b, c) {
    c.parentFlushed = !0;
    switch(c.status){
        case 0:
            var d = c.id = a.nextSegmentId++;
            c.lastPushedText = !1;
            c.textEmbedded = !1;
            a = a.responseState;
            b.push('<template id="');
            b.push(a.placeholderPrefix);
            a = d.toString(16);
            b.push(a);
            return b.push('"></template>');
        case 1:
            c.status = 2;
            var e = !0;
            d = c.chunks;
            var g = 0;
            c = c.children;
            for(var f = 0; f < c.length; f++){
                for(e = c[f]; g < e.index; g++)b.push(d[g]);
                e = Zc(a, b, e);
            }
            for(; g < d.length - 1; g++)b.push(d[g]);
            g < d.length && (e = b.push(d[g]));
            return e;
        default:
            throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
    }
}
function Zc(a, b, c) {
    var d = c.boundary;
    if (null === d) return Yc(a, b, c);
    d.parentFlushed = !0;
    if (d.forceClientRender) return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = u(d), b.push(d), b.push('"')), b.push("></template>")), Yc(a, b, c), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
    if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++;
        0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var e = a.responseState;
        var g = e.nextSuspenseID++;
        e = e.boundaryPrefix + g.toString(16);
        d = d.id = e;
        Sa(b, a.responseState, d);
        Yc(a, b, c);
        return b.push("<!--/$-->");
    }
    if (d.byteSize > a.progressiveChunkSize) return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Sa(b, a.responseState, d.id), Yc(a, b, c), b.push("<!--/$-->");
    (c = a.resources.boundaryResources) && d.resources.forEach(mb, c);
    a.responseState.generateStaticMarkup || b.push("<!--$-->");
    c = d.completedSegments;
    if (1 !== c.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
    Zc(a, b, c[0]);
    a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->");
    return a;
}
function $c(a, b, c) {
    Ta(b, a.responseState, c.formatContext, c.id);
    Zc(a, b, c);
    return Ua(b, c.formatContext);
}
function ad(a, b, c) {
    a.resources.boundaryResources = c.resources;
    for(var d = c.completedSegments, e = 0; e < d.length; e++)bd(a, b, c, d[e]);
    d.length = 0;
    bb(b, c.resources, a.responseState);
    a = a.responseState;
    d = c.id;
    e = c.rootSegmentID;
    c = c.resources;
    var g = a.stylesToHoist;
    a.stylesToHoist = !1;
    var f = 0 === a.streamingFormat;
    f ? (b.push(a.startInlineScript), g ? 0 === (a.instructions & 2) ? (a.instructions |= 10, b.push('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&n.set(b.getAttribute("href"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement("link");a.href=d;a.rel="stylesheet";for(a.dataset.precedence=\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute("media");!e||"l"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,""),u.bind(null,r,t,"Resource failed to load"))};$RR("')) : 0 === (a.instructions & 8) ? (a.instructions |= 8, b.push('$RM=new Map;\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&n.set(b.getAttribute("href"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement("link");a.href=d;a.rel="stylesheet";for(a.dataset.precedence=\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute("media");!e||"l"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,""),u.bind(null,r,t,"Resource failed to load"))};$RR("')) : b.push('$RR("') : 0 === (a.instructions & 2) ? (a.instructions |= 2, b.push('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("')) : b.push('$RC("')) : g ? b.push('<template data-rri="" data-bid="') : b.push('<template data-rci="" data-bid="');
    if (null === d) throw Error("An ID must have been assigned before we can complete the boundary.");
    e = e.toString(16);
    b.push(d);
    f ? b.push('","') : b.push('" data-sid="');
    b.push(a.segmentPrefix);
    b.push(e);
    g ? f ? (b.push('",'), ib(b, c)) : (b.push('" data-sty="'), jb(b, c)) : f && b.push('"');
    d = f ? b.push(")</script>") : b.push('"></template>');
    return Ra(b, a) && d;
}
function bd(a, b, c, d) {
    if (2 === d.status) return !0;
    var e = d.id;
    if (-1 === e) {
        if (-1 === (d.id = c.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return $c(a, b, d);
    }
    $c(a, b, d);
    a = a.responseState;
    (c = 0 === a.streamingFormat) ? (b.push(a.startInlineScript), 0 === (a.instructions & 1) ? (a.instructions |= 1, b.push('$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};;$RS("')) : b.push('$RS("')) : b.push('<template data-rsi="" data-sid="');
    b.push(a.segmentPrefix);
    e = e.toString(16);
    b.push(e);
    c ? b.push('","') : b.push('" data-pid="');
    b.push(a.placeholderPrefix);
    b.push(e);
    b = c ? b.push('")</script>') : b.push('"></template>');
    return b;
}
function Xc(a, b) {
    try {
        var c, d = a.completedRootSegment;
        if (null !== d) if (0 === a.pendingRootTasks) {
            var e = a.resources, g = a.responseState;
            if (0 !== a.allPendingTasks && g.externalRuntimeScript) {
                var f = g.externalRuntimeScript, k = f.chunks, h = "[script]" + f.src, l = e.scriptsMap.get(h);
                l || (l = {
                    type: "script",
                    chunks: k,
                    state: 0,
                    props: null
                }, e.scriptsMap.set(h, l), e.scripts.add(l));
            }
            var q = g.htmlChunks, m = g.headChunks;
            f = 0;
            if (q) {
                for(f = 0; f < q.length; f++)b.push(q[f]);
                if (m) for(f = 0; f < m.length; f++)b.push(m[f]);
                else {
                    var w = F("head");
                    b.push(w);
                    b.push(">");
                }
            } else if (m) for(f = 0; f < m.length; f++)b.push(m[f]);
            var r = g.charsetChunks;
            for(f = 0; f < r.length; f++)b.push(r[f]);
            r.length = 0;
            e.preconnects.forEach(L, b);
            e.preconnects.clear();
            var y = g.preconnectChunks;
            for(f = 0; f < y.length; f++)b.push(y[f]);
            y.length = 0;
            e.fontPreloads.forEach(L, b);
            e.fontPreloads.clear();
            e.precedences.forEach(fb, b);
            e.scripts.forEach(L, b);
            e.scripts.clear();
            e.explicitStylesheetPreloads.forEach(L, b);
            e.explicitStylesheetPreloads.clear();
            e.explicitScriptPreloads.forEach(L, b);
            e.explicitScriptPreloads.clear();
            e.explicitOtherPreloads.forEach(L, b);
            e.explicitOtherPreloads.clear();
            var B = g.preloadChunks;
            for(f = 0; f < B.length; f++)b.push(B[f]);
            B.length = 0;
            var G = g.hoistableChunks;
            for(f = 0; f < G.length; f++)b.push(G[f]);
            G.length = 0;
            q && null === m && (b.push("</"), b.push("head"), b.push(">"));
            Zc(a, b, d);
            a.completedRootSegment = null;
            Ra(b, a.responseState);
        } else return;
        else if (0 < a.pendingRootTasks) return;
        var n = a.resources, I = a.responseState;
        d = 0;
        n.preconnects.forEach(M, b);
        n.preconnects.clear();
        var V = I.preconnectChunks;
        for(d = 0; d < V.length; d++)b.push(V[d]);
        V.length = 0;
        n.fontPreloads.forEach(M, b);
        n.fontPreloads.clear();
        n.precedences.forEach(hb, b);
        n.scripts.forEach(M, b);
        n.scripts.clear();
        n.explicitStylesheetPreloads.forEach(M, b);
        n.explicitStylesheetPreloads.clear();
        n.explicitScriptPreloads.forEach(M, b);
        n.explicitScriptPreloads.clear();
        n.explicitOtherPreloads.forEach(M, b);
        n.explicitOtherPreloads.clear();
        var ha = I.preloadChunks;
        for(d = 0; d < ha.length; d++)b.push(ha[d]);
        ha.length = 0;
        var ia = I.hoistableChunks;
        for(d = 0; d < ia.length; d++)b.push(ia[d]);
        ia.length = 0;
        var C = a.clientRenderedBoundaries;
        for(c = 0; c < C.length; c++){
            var P = C[c];
            n = b;
            var E = a.responseState, dc = P.id, ab = P.errorDigest, Ca = P.errorMessage, ja = P.errorComponentStack, W = 0 === E.streamingFormat;
            W ? (n.push(E.startInlineScript), 0 === (E.instructions & 4) ? (E.instructions |= 4, n.push('$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};;$RX("')) : n.push('$RX("')) : n.push('<template data-rxi="" data-bid="');
            if (null === dc) throw Error("An ID must have been assigned before we can complete the boundary.");
            n.push(dc);
            W && n.push('"');
            if (ab || Ca || ja) if (W) {
                n.push(",");
                var gd = Wa(ab || "");
                n.push(gd);
            } else {
                n.push('" data-dgst="');
                var hd = u(ab || "");
                n.push(hd);
            }
            if (Ca || ja) if (W) {
                n.push(",");
                var id = Wa(Ca || "");
                n.push(id);
            } else {
                n.push('" data-msg="');
                var jd = u(Ca || "");
                n.push(jd);
            }
            if (ja) if (W) {
                n.push(",");
                var kd = Wa(ja);
                n.push(kd);
            } else {
                n.push('" data-stck="');
                var ld = u(ja);
                n.push(ld);
            }
            if (W ? !n.push(")</script>") : !n.push('"></template>')) {
                a.destination = null;
                c++;
                C.splice(0, c);
                return;
            }
        }
        C.splice(0, c);
        var Da = a.completedBoundaries;
        for(c = 0; c < Da.length; c++)if (!ad(a, b, Da[c])) {
            a.destination = null;
            c++;
            Da.splice(0, c);
            return;
        }
        Da.splice(0, c);
        var Ea = a.partialBoundaries;
        for(c = 0; c < Ea.length; c++){
            var Fa = Ea[c];
            a: {
                C = a;
                P = b;
                C.resources.boundaryResources = Fa.resources;
                var Ga = Fa.completedSegments;
                for(E = 0; E < Ga.length; E++)if (!bd(C, P, Fa, Ga[E])) {
                    E++;
                    Ga.splice(0, E);
                    var ec = !1;
                    break a;
                }
                Ga.splice(0, E);
                ec = bb(P, Fa.resources, C.responseState);
            }
            if (!ec) {
                a.destination = null;
                c++;
                Ea.splice(0, c);
                return;
            }
        }
        Ea.splice(0, c);
        var Ha = a.completedBoundaries;
        for(c = 0; c < Ha.length; c++)if (!ad(a, b, Ha[c])) {
            a.destination = null;
            c++;
            Ha.splice(0, c);
            return;
        }
        Ha.splice(0, c);
    } finally{
        0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && (a.flushScheduled = !1, a = a.responseState, a.hasBody && (b.push("</"), b.push("body"), b.push(">")), a.htmlChunks && (b.push("</"), b.push("html"), b.push(">")), b.push(null));
    }
}
function lb(a) {
    if (!1 === a.flushScheduled && 0 === a.pingedTasks.length && null !== a.destination) {
        var b = a.destination;
        a.flushScheduled = !0;
        Xc(a, b);
    }
}
function cd(a, b) {
    if (1 === a.status) a.status = 2, b.destroy(a.fatalError);
    else if (2 !== a.status && null === a.destination) {
        a.destination = b;
        try {
            Xc(a, b);
        } catch (c) {
            Y(a, c), Nc(a, c);
        }
    }
}
function dd(a, b) {
    try {
        var c = a.abortableTasks;
        if (0 < c.size) {
            var d = void 0 === b ? Error("The render was aborted by the server without a reason.") : b;
            c.forEach(function(e) {
                return Wc(e, a, d);
            });
            c.clear();
        }
        null !== a.destination && Xc(a, a.destination);
    } catch (e) {
        Y(a, e), Nc(a, e);
    }
}
function ed() {}
function fd(a, b, c, d, e) {
    var g = !1, f = null, k = "", h = !1, l = kb();
    a = Jc(a, l, nb(l, c, b ? b.identifierPrefix : void 0, e), ob(), Infinity, ed, void 0, function() {
        h = !0;
    }, void 0, void 0);
    a.flushScheduled = null !== a.destination;
    Mc(a);
    dd(a, d);
    cd(a, {
        push: function(q) {
            null !== q && (k += q);
            return !0;
        },
        destroy: function(q) {
            g = !0;
            f = q;
        }
    });
    if (g && f !== d) throw f;
    if (!h) throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
    return k;
}
function md(a, b) {
    a.prototype = Object.create(b.prototype);
    a.prototype.constructor = a;
    a.__proto__ = b;
}
var nd = function(a) {
    function b() {
        var d = a.call(this, {}) || this;
        d.request = null;
        d.startedFlowing = !1;
        return d;
    }
    md(b, a);
    var c = b.prototype;
    c._destroy = function(d, e) {
        dd(this.request);
        e(d);
    };
    c._read = function() {
        this.startedFlowing && cd(this.request, this);
    };
    return b;
}(ca.Readable);
function od() {}
function pd(a, b) {
    var c = new nd, d = kb(), e = Jc(a, d, nb(d, !1, b ? b.identifierPrefix : void 0), ob(), Infinity, od, function() {
        c.startedFlowing = !0;
        cd(e, c);
    }, void 0, void 0);
    c.request = e;
    e.flushScheduled = null !== e.destination;
    Mc(e);
    return c;
}
exports.renderToNodeStream = function(a, b) {
    return pd(a, b);
};
exports.renderToStaticMarkup = function(a, b) {
    return fd(a, b, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
};
exports.renderToStaticNodeStream = function(a, b) {
    return pd(a, b);
};
exports.renderToString = function(a, b) {
    return fd(a, b, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
};
exports.version = "18.3.0-canary-9377e1010-20230712";


/***/ }),

/***/ 70284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom-server.node.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var aa = __webpack_require__(73837), ba = __webpack_require__(50852), ca = __webpack_require__(32308), da = __webpack_require__(98);
function ea(a) {
    "function" === typeof a.flush && a.flush();
}
var h = null, l = 0, fa = !0;
function q(a, b) {
    if ("string" === typeof b) {
        if (0 !== b.length) if (2048 < 3 * b.length) 0 < l && (w(a, h.subarray(0, l)), h = new Uint8Array(2048), l = 0), w(a, ha.encode(b));
        else {
            var c = h;
            0 < l && (c = h.subarray(l));
            c = ha.encodeInto(b, c);
            var d = c.read;
            l += c.written;
            d < b.length && (w(a, h.subarray(0, l)), h = new Uint8Array(2048), l = ha.encodeInto(b.slice(d), h).written);
            2048 === l && (w(a, h), h = new Uint8Array(2048), l = 0);
        }
    } else 0 !== b.byteLength && (2048 < b.byteLength ? (0 < l && (w(a, h.subarray(0, l)), h = new Uint8Array(2048), l = 0), w(a, b)) : (c = h.length - l, c < b.byteLength && (0 === c ? w(a, h) : (h.set(b.subarray(0, c), l), l += c, w(a, h), b = b.subarray(c)), h = new Uint8Array(2048), l = 0), h.set(b, l), l += b.byteLength, 2048 === l && (w(a, h), h = new Uint8Array(2048), l = 0)));
}
function w(a, b) {
    a = a.write(b);
    fa = fa && a;
}
function y(a, b) {
    q(a, b);
    return fa;
}
function ia(a) {
    h && 0 < l && a.write(h.subarray(0, l));
    h = null;
    l = 0;
    fa = !0;
}
var ha = new aa.TextEncoder;
function z(a) {
    return ha.encode(a);
}
var A = Object.assign, B = Object.prototype.hasOwnProperty, ja = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), ka = {}, na = {};
function oa(a) {
    if (B.call(na, a)) return !0;
    if (B.call(ka, a)) return !1;
    if (ja.test(a)) return na[a] = !0;
    ka[a] = !0;
    return !1;
}
var pa = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), qa = new Map([
    [
        "acceptCharset",
        "accept-charset"
    ],
    [
        "htmlFor",
        "for"
    ],
    [
        "httpEquiv",
        "http-equiv"
    ],
    [
        "crossOrigin",
        "crossorigin"
    ],
    [
        "accentHeight",
        "accent-height"
    ],
    [
        "alignmentBaseline",
        "alignment-baseline"
    ],
    [
        "arabicForm",
        "arabic-form"
    ],
    [
        "baselineShift",
        "baseline-shift"
    ],
    [
        "capHeight",
        "cap-height"
    ],
    [
        "clipPath",
        "clip-path"
    ],
    [
        "clipRule",
        "clip-rule"
    ],
    [
        "colorInterpolation",
        "color-interpolation"
    ],
    [
        "colorInterpolationFilters",
        "color-interpolation-filters"
    ],
    [
        "colorProfile",
        "color-profile"
    ],
    [
        "colorRendering",
        "color-rendering"
    ],
    [
        "dominantBaseline",
        "dominant-baseline"
    ],
    [
        "enableBackground",
        "enable-background"
    ],
    [
        "fillOpacity",
        "fill-opacity"
    ],
    [
        "fillRule",
        "fill-rule"
    ],
    [
        "floodColor",
        "flood-color"
    ],
    [
        "floodOpacity",
        "flood-opacity"
    ],
    [
        "fontFamily",
        "font-family"
    ],
    [
        "fontSize",
        "font-size"
    ],
    [
        "fontSizeAdjust",
        "font-size-adjust"
    ],
    [
        "fontStretch",
        "font-stretch"
    ],
    [
        "fontStyle",
        "font-style"
    ],
    [
        "fontVariant",
        "font-variant"
    ],
    [
        "fontWeight",
        "font-weight"
    ],
    [
        "glyphName",
        "glyph-name"
    ],
    [
        "glyphOrientationHorizontal",
        "glyph-orientation-horizontal"
    ],
    [
        "glyphOrientationVertical",
        "glyph-orientation-vertical"
    ],
    [
        "horizAdvX",
        "horiz-adv-x"
    ],
    [
        "horizOriginX",
        "horiz-origin-x"
    ],
    [
        "imageRendering",
        "image-rendering"
    ],
    [
        "letterSpacing",
        "letter-spacing"
    ],
    [
        "lightingColor",
        "lighting-color"
    ],
    [
        "markerEnd",
        "marker-end"
    ],
    [
        "markerMid",
        "marker-mid"
    ],
    [
        "markerStart",
        "marker-start"
    ],
    [
        "overlinePosition",
        "overline-position"
    ],
    [
        "overlineThickness",
        "overline-thickness"
    ],
    [
        "paintOrder",
        "paint-order"
    ],
    [
        "panose-1",
        "panose-1"
    ],
    [
        "pointerEvents",
        "pointer-events"
    ],
    [
        "renderingIntent",
        "rendering-intent"
    ],
    [
        "shapeRendering",
        "shape-rendering"
    ],
    [
        "stopColor",
        "stop-color"
    ],
    [
        "stopOpacity",
        "stop-opacity"
    ],
    [
        "strikethroughPosition",
        "strikethrough-position"
    ],
    [
        "strikethroughThickness",
        "strikethrough-thickness"
    ],
    [
        "strokeDasharray",
        "stroke-dasharray"
    ],
    [
        "strokeDashoffset",
        "stroke-dashoffset"
    ],
    [
        "strokeLinecap",
        "stroke-linecap"
    ],
    [
        "strokeLinejoin",
        "stroke-linejoin"
    ],
    [
        "strokeMiterlimit",
        "stroke-miterlimit"
    ],
    [
        "strokeOpacity",
        "stroke-opacity"
    ],
    [
        "strokeWidth",
        "stroke-width"
    ],
    [
        "textAnchor",
        "text-anchor"
    ],
    [
        "textDecoration",
        "text-decoration"
    ],
    [
        "textRendering",
        "text-rendering"
    ],
    [
        "transformOrigin",
        "transform-origin"
    ],
    [
        "underlinePosition",
        "underline-position"
    ],
    [
        "underlineThickness",
        "underline-thickness"
    ],
    [
        "unicodeBidi",
        "unicode-bidi"
    ],
    [
        "unicodeRange",
        "unicode-range"
    ],
    [
        "unitsPerEm",
        "units-per-em"
    ],
    [
        "vAlphabetic",
        "v-alphabetic"
    ],
    [
        "vHanging",
        "v-hanging"
    ],
    [
        "vIdeographic",
        "v-ideographic"
    ],
    [
        "vMathematical",
        "v-mathematical"
    ],
    [
        "vectorEffect",
        "vector-effect"
    ],
    [
        "vertAdvY",
        "vert-adv-y"
    ],
    [
        "vertOriginX",
        "vert-origin-x"
    ],
    [
        "vertOriginY",
        "vert-origin-y"
    ],
    [
        "wordSpacing",
        "word-spacing"
    ],
    [
        "writingMode",
        "writing-mode"
    ],
    [
        "xmlnsXlink",
        "xmlns:xlink"
    ],
    [
        "xHeight",
        "x-height"
    ]
]), ra = /["'&<>]/;
function C(a) {
    if ("boolean" === typeof a || "number" === typeof a) return "" + a;
    a = "" + a;
    var b = ra.exec(a);
    if (b) {
        var c = "", d, e = 0;
        for(d = b.index; d < a.length; d++){
            switch(a.charCodeAt(d)){
                case 34:
                    b = "&quot;";
                    break;
                case 38:
                    b = "&amp;";
                    break;
                case 39:
                    b = "&#x27;";
                    break;
                case 60:
                    b = "&lt;";
                    break;
                case 62:
                    b = "&gt;";
                    break;
                default:
                    continue;
            }
            e !== d && (c += a.slice(e, d));
            e = d + 1;
            c += b;
        }
        a = e !== d ? c + a.slice(e, d) : c;
    }
    return a;
}
var sa = /([A-Z])/g, ta = /^ms-/, ua = Array.isArray, va = ca.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, wa = da.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Dispatcher, Da = {
    prefetchDNS: za,
    preconnect: Aa,
    preload: Ba,
    preinit: Ca
}, Ea = z('"></template>'), Fa = z("<script>"), Ga = z("</script>"), Ha = z('<script src="'), Ia = z('<script type="module" src="'), Ja = z('" nonce="'), Ka = z('" integrity="'), La = z('" crossorigin="'), Ma = z('" async=""></script>'), Na = /(<\/|<)(s)(cript)/gi;
function Oa(a, b, c, d) {
    return "" + b + ("s" === c ? "\\u0073" : "\\u0053") + d;
}
function E(a, b, c) {
    return {
        insertionMode: a,
        selectedValue: b,
        noscriptTagInScope: c
    };
}
function Pa(a, b, c) {
    switch(b){
        case "noscript":
            return E(2, null, !0);
        case "select":
            return E(2, null != c.value ? c.value : c.defaultValue, a.noscriptTagInScope);
        case "svg":
            return E(3, null, a.noscriptTagInScope);
        case "math":
            return E(4, null, a.noscriptTagInScope);
        case "foreignObject":
            return E(2, null, a.noscriptTagInScope);
        case "table":
            return E(5, null, a.noscriptTagInScope);
        case "thead":
        case "tbody":
        case "tfoot":
            return E(6, null, a.noscriptTagInScope);
        case "colgroup":
            return E(8, null, a.noscriptTagInScope);
        case "tr":
            return E(7, null, a.noscriptTagInScope);
    }
    return 5 <= a.insertionMode ? E(2, null, a.noscriptTagInScope) : 0 === a.insertionMode ? "html" === b ? E(1, null, !1) : E(2, null, !1) : 1 === a.insertionMode ? E(2, null, !1) : a;
}
var G = z("<!-- -->");
function Qa(a, b, c, d) {
    if ("" === b) return d;
    d && a.push(G);
    a.push(C(b));
    return !0;
}
var Ra = new Map, Sa = z(' style="'), Ta = z(":"), Ua = z(";");
function Va(a, b) {
    if ("object" !== typeof b) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    var c = !0, d;
    for(d in b)if (B.call(b, d)) {
        var e = b[d];
        if (null != e && "boolean" !== typeof e && "" !== e) {
            if (0 === d.indexOf("--")) {
                var g = C(d);
                e = C(("" + e).trim());
            } else g = Ra.get(d), void 0 === g && (g = z(C(d.replace(sa, "-$1").toLowerCase().replace(ta, "-ms-"))), Ra.set(d, g)), e = "number" === typeof e ? 0 === e || pa.has(d) ? "" + e : e + "px" : C(("" + e).trim());
            c ? (c = !1, a.push(Sa, g, Ta, e)) : a.push(Ua, g, Ta, e);
        }
    }
    c || a.push(H);
}
var I = z(" "), J = z('="'), H = z('"'), bb = z('=""');
function cb(a, b, c) {
    c && "function" !== typeof c && "symbol" !== typeof c && a.push(I, b, bb);
}
function K(a, b, c) {
    "function" !== typeof c && "symbol" !== typeof c && "boolean" !== typeof c && a.push(I, b, J, C(c), H);
}
z(C("javascript:throw new Error('A React form was unexpectedly submitted.')"));
var db = z('<input type="hidden"');
function eb(a, b) {
    this.push(db);
    if ("string" !== typeof a) throw Error("File/Blob fields are not yet supported in progressive forms. It probably means you are closing over binary data or FormData in a Server Action.");
    K(this, "name", b);
    K(this, "value", a);
    this.push(fb);
}
function gb(a, b, c, d, e, g, f) {
    null != f && M(a, "name", f);
    null != c && M(a, "formAction", c);
    null != d && M(a, "formEncType", d);
    null != e && M(a, "formMethod", e);
    null != g && M(a, "formTarget", g);
    return null;
}
function M(a, b, c) {
    switch(b){
        case "className":
            K(a, "class", c);
            break;
        case "tabIndex":
            K(a, "tabindex", c);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            K(a, b, c);
            break;
        case "style":
            Va(a, c);
            break;
        case "src":
        case "href":
        case "action":
        case "formAction":
            if (null == c || "function" === typeof c || "symbol" === typeof c || "boolean" === typeof c) break;
            a.push(I, b, J, C("" + c), H);
            break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
            break;
        case "autoFocus":
        case "multiple":
        case "muted":
            cb(a, b.toLowerCase(), c);
            break;
        case "xlinkHref":
            if ("function" === typeof c || "symbol" === typeof c || "boolean" === typeof c) break;
            a.push(I, "xlink:href", J, C("" + c), H);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            "function" !== typeof c && "symbol" !== typeof c && a.push(I, b, J, C(c), H);
            break;
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            c && "function" !== typeof c && "symbol" !== typeof c && a.push(I, b, bb);
            break;
        case "capture":
        case "download":
            !0 === c ? a.push(I, b, bb) : !1 !== c && "function" !== typeof c && "symbol" !== typeof c && a.push(I, b, J, C(c), H);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            "function" !== typeof c && "symbol" !== typeof c && !isNaN(c) && 1 <= c && a.push(I, b, J, C(c), H);
            break;
        case "rowSpan":
        case "start":
            "function" === typeof c || "symbol" === typeof c || isNaN(c) || a.push(I, b, J, C(c), H);
            break;
        case "xlinkActuate":
            K(a, "xlink:actuate", c);
            break;
        case "xlinkArcrole":
            K(a, "xlink:arcrole", c);
            break;
        case "xlinkRole":
            K(a, "xlink:role", c);
            break;
        case "xlinkShow":
            K(a, "xlink:show", c);
            break;
        case "xlinkTitle":
            K(a, "xlink:title", c);
            break;
        case "xlinkType":
            K(a, "xlink:type", c);
            break;
        case "xmlBase":
            K(a, "xml:base", c);
            break;
        case "xmlLang":
            K(a, "xml:lang", c);
            break;
        case "xmlSpace":
            K(a, "xml:space", c);
            break;
        default:
            if (!(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) {
                if (b = qa.get(b) || b, oa(b)) {
                    switch(typeof c){
                        case "function":
                        case "symbol":
                            return;
                        case "boolean":
                            var d = b.toLowerCase().slice(0, 5);
                            if ("data-" !== d && "aria-" !== d) return;
                    }
                    a.push(I, b, J, C(c), H);
                }
            }
    }
}
var P = z(">"), fb = z("/>");
function Q(a, b, c) {
    if (null != b) {
        if (null != c) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if ("object" !== typeof b || !("__html" in b)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html;
        null !== b && void 0 !== b && a.push("" + b);
    }
}
function hb(a) {
    var b = "";
    ca.Children.forEach(a, function(c) {
        null != c && (b += c);
    });
    return b;
}
var ib = z(' selected=""');
z('addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error(\'A React form was unexpectedly submitted.\')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.getRootNode(),(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,\nd,b))}});');
function jb(a, b, c, d, e, g, f) {
    var m = b.rel, k = b.href, n = b.precedence;
    if (3 === g || f || null != b.itemProp || "string" !== typeof m || "string" !== typeof k || "" === k) return R(a, b), null;
    if ("stylesheet" === b.rel) {
        c = "[style]" + k;
        if ("string" !== typeof n || null != b.disabled || b.onLoad || b.onError) return R(a, b);
        g = d.stylesMap.get(c);
        g || (b = A({}, b, {
            "data-precedence": b.precedence,
            precedence: null
        }), g = d.preloadsMap.get(c), f = 0, g && (g.state |= 4, m = g.props, null == b.crossOrigin && (b.crossOrigin = m.crossOrigin), null == b.integrity && (b.integrity = m.integrity), g.state & 3 && (f = 8)), g = {
            type: "stylesheet",
            chunks: [],
            state: f,
            props: b
        }, d.stylesMap.set(c, g), b = d.precedences.get(n), b || (b = new Set, d.precedences.set(n, b), c = {
            type: "style",
            chunks: [],
            state: 0,
            props: {
                precedence: n,
                hrefs: []
            }
        }, b.add(c), d.stylePrecedences.set(n, c)), b.add(g));
        d.boundaryResources && d.boundaryResources.add(g);
        e && a.push(G);
        return null;
    }
    if (b.onLoad || b.onError) return R(a, b);
    e && a.push(G);
    switch(b.rel){
        case "preconnect":
        case "dns-prefetch":
            return R(c.preconnectChunks, b);
        case "preload":
            return R(c.preloadChunks, b);
        default:
            return R(c.hoistableChunks, b);
    }
}
function R(a, b) {
    a.push(T("link"));
    for(var c in b)if (B.call(b, c)) {
        var d = b[c];
        if (null != d) switch(c){
            case "children":
            case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
                M(a, c, d);
        }
    }
    a.push(fb);
    return null;
}
function kb(a, b, c) {
    a.push(T(c));
    for(var d in b)if (B.call(b, d)) {
        var e = b[d];
        if (null != e) switch(d){
            case "children":
            case "dangerouslySetInnerHTML":
                throw Error(c + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
                M(a, d, e);
        }
    }
    a.push(fb);
    return null;
}
function lb(a, b) {
    a.push(T("title"));
    var c = null, d = null, e;
    for(e in b)if (B.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                M(a, e, g);
        }
    }
    a.push(P);
    b = Array.isArray(c) ? 2 > c.length ? c[0] : null : c;
    "function" !== typeof b && "symbol" !== typeof b && null !== b && void 0 !== b && a.push(C("" + b));
    Q(a, d, c);
    a.push(U, "title", V);
    return null;
}
function mb(a, b) {
    a.push(T("script"));
    var c = null, d = null, e;
    for(e in b)if (B.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                M(a, e, g);
        }
    }
    a.push(P);
    Q(a, d, c);
    "string" === typeof c && a.push(C(c));
    a.push(U, "script", V);
    return null;
}
function nb(a, b, c) {
    a.push(T(c));
    var d = c = null, e;
    for(e in b)if (B.call(b, e)) {
        var g = b[e];
        if (null != g) switch(e){
            case "children":
                c = g;
                break;
            case "dangerouslySetInnerHTML":
                d = g;
                break;
            default:
                M(a, e, g);
        }
    }
    a.push(P);
    Q(a, d, c);
    return "string" === typeof c ? (a.push(C(c)), null) : c;
}
var ob = z("\n"), pb = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, qb = new Map;
function T(a) {
    var b = qb.get(a);
    if (void 0 === b) {
        if (!pb.test(a)) throw Error("Invalid tag: " + a);
        b = z("<" + a);
        qb.set(a, b);
    }
    return b;
}
var rb = z("<!DOCTYPE html>");
function sb(a, b, c, d, e, g, f) {
    switch(b){
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "select":
            a.push(T("select"));
            f = e = null;
            for(var m in c)if (B.call(c, m)) {
                var k = c[m];
                if (null != k) switch(m){
                    case "children":
                        e = k;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = k;
                        break;
                    case "defaultValue":
                    case "value":
                        break;
                    default:
                        M(a, m, k);
                }
            }
            a.push(P);
            Q(a, f, e);
            return e;
        case "option":
            e = g.selectedValue;
            a.push(T("option"));
            var n = d = f = null;
            k = null;
            for(var t in c)if (B.call(c, t)) {
                var p = c[t];
                if (null != p) switch(t){
                    case "children":
                        f = p;
                        break;
                    case "selected":
                        n = p;
                        break;
                    case "dangerouslySetInnerHTML":
                        k = p;
                        break;
                    case "value":
                        d = p;
                    default:
                        M(a, t, p);
                }
            }
            if (null != e) if (c = null !== d ? "" + d : hb(f), ua(e)) for(d = 0; d < e.length; d++){
                if ("" + e[d] === c) {
                    a.push(ib);
                    break;
                }
            }
            else "" + e === c && a.push(ib);
            else n && a.push(ib);
            a.push(P);
            Q(a, k, f);
            return f;
        case "textarea":
            a.push(T("textarea"));
            k = f = e = null;
            for(var x in c)if (B.call(c, x) && (d = c[x], null != d)) switch(x){
                case "children":
                    k = d;
                    break;
                case "value":
                    e = d;
                    break;
                case "defaultValue":
                    f = d;
                    break;
                case "dangerouslySetInnerHTML":
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                    M(a, x, d);
            }
            null === e && null !== f && (e = f);
            a.push(P);
            if (null != k) {
                if (null != e) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (ua(k) && 1 < k.length) throw Error("<textarea> can only have at most one child.");
                e = "" + k;
            }
            "string" === typeof e && "\n" === e[0] && a.push(ob);
            null !== e && a.push(C("" + e));
            return null;
        case "input":
            a.push(T("input"));
            var u = null, v = t = null;
            p = n = d = f = g = x = null;
            for(k in c)if (B.call(c, k) && (m = c[k], null != m)) switch(k){
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "name":
                    u = m;
                    break;
                case "formAction":
                    t = m;
                    break;
                case "formEncType":
                    v = m;
                    break;
                case "formMethod":
                    x = m;
                    break;
                case "formTarget":
                    g = m;
                    break;
                case "defaultChecked":
                    p = m;
                    break;
                case "defaultValue":
                    d = m;
                    break;
                case "checked":
                    n = m;
                    break;
                case "value":
                    f = m;
                    break;
                default:
                    M(a, k, m);
            }
            c = gb(a, e, t, v, x, g, u);
            null !== n ? cb(a, "checked", n) : null !== p && cb(a, "checked", p);
            null !== f ? M(a, "value", f) : null !== d && M(a, "value", d);
            a.push(fb);
            null !== c && c.forEach(eb, a);
            return null;
        case "button":
            a.push(T("button"));
            v = t = u = n = d = k = f = null;
            for(p in c)if (B.call(c, p) && (x = c[p], null != x)) switch(p){
                case "children":
                    f = x;
                    break;
                case "dangerouslySetInnerHTML":
                    k = x;
                    break;
                case "name":
                    d = x;
                    break;
                case "formAction":
                    n = x;
                    break;
                case "formEncType":
                    u = x;
                    break;
                case "formMethod":
                    t = x;
                    break;
                case "formTarget":
                    v = x;
                    break;
                default:
                    M(a, p, x);
            }
            c = gb(a, e, n, u, t, v, d);
            a.push(P);
            null !== c && c.forEach(eb, a);
            Q(a, k, f);
            "string" === typeof f ? (a.push(C(f)), a = null) : a = f;
            return a;
        case "form":
            a.push(T("form"));
            p = n = d = k = f = e = null;
            for(u in c)if (B.call(c, u) && (t = c[u], null != t)) switch(u){
                case "children":
                    e = t;
                    break;
                case "dangerouslySetInnerHTML":
                    f = t;
                    break;
                case "action":
                    k = t;
                    break;
                case "encType":
                    d = t;
                    break;
                case "method":
                    n = t;
                    break;
                case "target":
                    p = t;
                    break;
                default:
                    M(a, u, t);
            }
            null != k && M(a, "action", k);
            null != d && M(a, "encType", d);
            null != n && M(a, "method", n);
            null != p && M(a, "target", p);
            a.push(P);
            Q(a, f, e);
            "string" === typeof e ? (a.push(C(e)), a = null) : a = e;
            return a;
        case "menuitem":
            a.push(T("menuitem"));
            for(var D in c)if (B.call(c, D) && (e = c[D], null != e)) switch(D){
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                    M(a, D, e);
            }
            a.push(P);
            return null;
        case "title":
            return 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp ? a = lb(a, c) : (lb(e.hoistableChunks, c), a = null), a;
        case "link":
            return jb(a, c, e, d, f, g.insertionMode, g.noscriptTagInScope);
        case "script":
            e = c.async;
            if ("string" !== typeof c.src || !c.src || !e || "function" === typeof e || "symbol" === typeof e || c.onLoad || c.onError || 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp) a = mb(a, c);
            else {
                n = "[script]" + c.src;
                e = d.scriptsMap.get(n);
                if (!e) {
                    e = {
                        type: "script",
                        chunks: [],
                        state: 0,
                        props: null
                    };
                    d.scriptsMap.set(n, e);
                    d.scripts.add(e);
                    k = c;
                    if (d = d.preloadsMap.get(n)) d.state |= 4, c = k = A({}, c), d = d.props, null == c.crossOrigin && (c.crossOrigin = d.crossOrigin), null == c.integrity && (c.integrity = d.integrity);
                    mb(e.chunks, k);
                }
                f && a.push(G);
                a = null;
            }
            return a;
        case "style":
            e = c.precedence;
            k = c.href;
            if (3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp || "string" !== typeof e || "string" !== typeof k || "" === k) {
                a.push(T("style"));
                f = e = null;
                for(v in c)if (B.call(c, v) && (k = c[v], null != k)) switch(v){
                    case "children":
                        e = k;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = k;
                        break;
                    default:
                        M(a, v, k);
                }
                a.push(P);
                c = Array.isArray(e) ? 2 > e.length ? e[0] : null : e;
                "function" !== typeof c && "symbol" !== typeof c && null !== c && void 0 !== c && a.push(C("" + c));
                Q(a, f, e);
                a.push(U, "style", V);
                a = null;
            } else {
                p = "[style]" + k;
                u = d.stylesMap.get(p);
                if (!u) {
                    (u = d.stylePrecedences.get(e)) ? u.props.hrefs.push(k) : (u = {
                        type: "style",
                        chunks: [],
                        state: 0,
                        props: {
                            precedence: e,
                            hrefs: [
                                k
                            ]
                        }
                    }, d.stylePrecedences.set(e, u), k = new Set, k.add(u), d.precedences.set(e, k));
                    d.stylesMap.set(p, u);
                    d.boundaryResources && d.boundaryResources.add(u);
                    e = u.chunks;
                    d = k = null;
                    for(n in c)if (B.call(c, n) && (p = c[n], null != p)) switch(n){
                        case "children":
                            k = p;
                            break;
                        case "dangerouslySetInnerHTML":
                            d = p;
                    }
                    c = Array.isArray(k) ? 2 > k.length ? k[0] : null : k;
                    "function" !== typeof c && "symbol" !== typeof c && null !== c && void 0 !== c && e.push(C("" + c));
                    Q(e, d, k);
                }
                f && a.push(G);
                a = void 0;
            }
            return a;
        case "meta":
            return 3 === g.insertionMode || g.noscriptTagInScope || null != c.itemProp ? a = kb(a, c, "meta") : (f && a.push(G), a = "string" === typeof c.charSet ? kb(e.charsetChunks, c, "meta") : kb(e.hoistableChunks, c, "meta")), a;
        case "listing":
        case "pre":
            a.push(T(b));
            f = e = null;
            for(var r in c)if (B.call(c, r) && (k = c[r], null != k)) switch(r){
                case "children":
                    e = k;
                    break;
                case "dangerouslySetInnerHTML":
                    f = k;
                    break;
                default:
                    M(a, r, k);
            }
            a.push(P);
            if (null != f) {
                if (null != e) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                if ("object" !== typeof f || !("__html" in f)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
                c = f.__html;
                null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push(ob, c) : a.push("" + c));
            }
            "string" === typeof e && "\n" === e[0] && a.push(ob);
            return e;
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
            return kb(a, c, b);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            break;
        case "head":
            return 2 > g.insertionMode && null === e.headChunks ? (e.headChunks = [], a = nb(e.headChunks, c, "head")) : a = nb(a, c, "head"), a;
        case "html":
            return 0 === g.insertionMode && null === e.htmlChunks ? (e.htmlChunks = [
                rb
            ], a = nb(e.htmlChunks, c, "html")) : a = nb(a, c, "html"), a;
        default:
            if (-1 !== b.indexOf("-")) {
                a.push(T(b));
                f = e = null;
                for(var F in c)if (B.call(c, F) && (k = c[F], null != k)) switch(F){
                    case "children":
                        e = k;
                        break;
                    case "dangerouslySetInnerHTML":
                        f = k;
                        break;
                    case "style":
                        Va(a, k);
                        break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                        break;
                    default:
                        oa(F) && "function" !== typeof k && "symbol" !== typeof k && a.push(I, F, J, C(k), H);
                }
                a.push(P);
                Q(a, f, e);
                return e;
            }
    }
    return nb(a, c, b);
}
var U = z("</"), V = z(">");
function tb(a, b) {
    b = b.bootstrapChunks;
    for(var c = 0; c < b.length - 1; c++)q(a, b[c]);
    return c < b.length ? (c = b[c], b.length = 0, y(a, c)) : !0;
}
var ub = z('<template id="'), vb = z('"></template>'), wb = z("<!--$-->"), xb = z('<!--$?--><template id="'), yb = z('"></template>'), zb = z("<!--$!-->"), Bb = z("<!--/$-->"), Cb = z("<template"), Db = z('"'), Eb = z(' data-dgst="');
z(' data-msg="');
z(' data-stck="');
var Fb = z("></template>");
function Gb(a, b, c) {
    q(a, xb);
    if (null === c) throw Error("An ID must have been assigned before we can complete the boundary.");
    q(a, c);
    return y(a, yb);
}
var Hb = z('<div hidden id="'), Ib = z('">'), Jb = z("</div>"), Kb = z('<svg aria-hidden="true" style="display:none" id="'), Lb = z('">'), Mb = z("</svg>"), Nb = z('<math aria-hidden="true" style="display:none" id="'), Ob = z('">'), Pb = z("</math>"), Qb = z('<table hidden id="'), Rb = z('">'), Sb = z("</table>"), Tb = z('<table hidden><tbody id="'), Ub = z('">'), Vb = z("</tbody></table>"), Wb = z('<table hidden><tr id="'), Xb = z('">'), Yb = z("</tr></table>"), Zb = z('<table hidden><colgroup id="'), $b = z('">'), ac = z("</colgroup></table>");
function bc(a, b, c, d) {
    switch(c.insertionMode){
        case 0:
        case 1:
        case 2:
            return q(a, Hb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Ib);
        case 3:
            return q(a, Kb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Lb);
        case 4:
            return q(a, Nb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Ob);
        case 5:
            return q(a, Qb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Rb);
        case 6:
            return q(a, Tb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Ub);
        case 7:
            return q(a, Wb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, Xb);
        case 8:
            return q(a, Zb), q(a, b.segmentPrefix), q(a, d.toString(16)), y(a, $b);
        default:
            throw Error("Unknown insertion mode. This is a bug in React.");
    }
}
function cc(a, b) {
    switch(b.insertionMode){
        case 0:
        case 1:
        case 2:
            return y(a, Jb);
        case 3:
            return y(a, Mb);
        case 4:
            return y(a, Pb);
        case 5:
            return y(a, Sb);
        case 6:
            return y(a, Vb);
        case 7:
            return y(a, Yb);
        case 8:
            return y(a, ac);
        default:
            throw Error("Unknown insertion mode. This is a bug in React.");
    }
}
var dc = z('$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};;$RS("'), ec = z('$RS("'), fc = z('","'), gc = z('")</script>'), hc = z('<template data-rsi="" data-sid="'), ic = z('" data-pid="'), jc = z('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'), kc = z('$RC("'), lc = z('$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&n.set(b.getAttribute("href"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement("link");a.href=d;a.rel="stylesheet";for(a.dataset.precedence=\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute("media");!e||"l"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,""),u.bind(null,r,t,"Resource failed to load"))};$RR("'), mc = z('$RM=new Map;\n$RR=function(r,t,w){for(var u=$RC,n=$RM,p=new Map,q=document,g,b,h=q.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&n.set(b.getAttribute("href"),b),p.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var f=w[b++];if(!f){k=!1;b=0;continue}var c=!1,m=0;var d=f[m++];if(a=n.get(d)){var e=a._p;c=!0}else{a=q.createElement("link");a.href=d;a.rel="stylesheet";for(a.dataset.precedence=\nl=f[m++];e=f[m++];)a.setAttribute(e,f[m++]);e=a._p=new Promise(function(x,y){a.onload=x;a.onerror=y});n.set(d,a)}d=a.getAttribute("media");!e||"l"===e.s||d&&!matchMedia(d).matches||h.push(e);if(c)continue}else{a=v[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=p.get(l)||g;c===g&&(g=a);p.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=q.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(u.bind(null,r,t,""),u.bind(null,r,t,"Resource failed to load"))};$RR("'), nc = z('$RR("'), oc = z('","'), pc = z('",'), qc = z('"'), rc = z(")</script>"), sc = z('<template data-rci="" data-bid="'), tc = z('<template data-rri="" data-bid="'), uc = z('" data-sid="'), vc = z('" data-sty="'), wc = z('$RX=function(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};;$RX("'), xc = z('$RX("'), yc = z('"'), zc = z(","), Ac = z(")</script>"), Bc = z('<template data-rxi="" data-bid="'), Cc = z('" data-dgst="'), Dc = z('" data-msg="'), Ec = z('" data-stck="'), Fc = /[<\u2028\u2029]/g;
function Gc(a) {
    return JSON.stringify(a).replace(Fc, function(b) {
        switch(b){
            case "<":
                return "\\u003c";
            case "\u2028":
                return "\\u2028";
            case "\u2029":
                return "\\u2029";
            default:
                throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
    });
}
var Jc = /[&><\u2028\u2029]/g;
function Kc(a) {
    return JSON.stringify(a).replace(Jc, function(b) {
        switch(b){
            case "&":
                return "\\u0026";
            case ">":
                return "\\u003e";
            case "<":
                return "\\u003c";
            case "\u2028":
                return "\\u2028";
            case "\u2029":
                return "\\u2029";
            default:
                throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
    });
}
var Lc = z('<style media="not all" data-precedence="'), Mc = z('" data-href="'), Nc = z('">'), Oc = z("</style>"), Pc = !1, Qc = !0;
function Rc(a) {
    if ("stylesheet" === a.type && 0 === (a.state & 1)) Pc = !0;
    else if ("style" === a.type) {
        var b = a.chunks, c = a.props.hrefs, d = 0;
        if (b.length) {
            q(this, Lc);
            q(this, C(a.props.precedence));
            if (c.length) {
                for(q(this, Mc); d < c.length - 1; d++)q(this, C(c[d])), q(this, Sc);
                q(this, C(c[d]));
            }
            q(this, Nc);
            for(d = 0; d < b.length; d++)q(this, b[d]);
            Qc = y(this, Oc);
            Pc = !0;
            b.length = 0;
            c.length = 0;
        }
    }
}
function Tc(a, b, c) {
    Pc = !1;
    Qc = !0;
    b.forEach(Rc, a);
    Pc && (c.stylesToHoist = !0);
    return Qc;
}
function Uc(a) {
    if (0 === (a.state & 7)) {
        for(var b = a.chunks, c = 0; c < b.length; c++)q(this, b[c]);
        a.state |= 1;
    }
}
function Vc(a) {
    if (0 === (a.state & 7)) {
        for(var b = a.chunks, c = 0; c < b.length; c++)q(this, b[c]);
        a.state |= 2;
    }
}
var Wc = null, Xc = !1;
function Yc(a, b, c) {
    b = a.chunks;
    if (a.state & 3) c.delete(a);
    else if ("style" === a.type) Wc = a;
    else {
        R(b, a.props);
        for(c = 0; c < b.length; c++)q(this, b[c]);
        a.state |= 1;
        Xc = !0;
    }
}
var Zc = z('<style data-precedence="'), $c = z('" data-href="'), Sc = z(" "), ad = z('">'), bd = z("</style>");
function cd(a, b) {
    Xc = !1;
    a.forEach(Yc, this);
    a.clear();
    a = Wc.chunks;
    var c = Wc.props.hrefs;
    if (!1 === Xc || a.length) {
        q(this, Zc);
        q(this, C(b));
        b = 0;
        if (c.length) {
            for(q(this, $c); b < c.length - 1; b++)q(this, C(c[b])), q(this, Sc);
            q(this, C(c[b]));
        }
        q(this, ad);
        for(b = 0; b < a.length; b++)q(this, a[b]);
        q(this, bd);
        a.length = 0;
        c.length = 0;
    }
}
function dd(a) {
    if (!(a.state & 8) && "style" !== a.type) {
        var b = a.chunks, c = a.props;
        R(b, {
            rel: "preload",
            as: "style",
            href: a.props.href,
            crossOrigin: c.crossOrigin,
            fetchPriority: c.fetchPriority,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
        });
        for(c = 0; c < b.length; c++)q(this, b[c]);
        a.state |= 8;
        b.length = 0;
    }
}
function ed(a) {
    a.forEach(dd, this);
    a.clear();
}
var fd = z("["), gd = z(",["), hd = z(","), id = z("]");
function jd(a, b) {
    q(a, fd);
    var c = fd;
    b.forEach(function(d) {
        if ("style" !== d.type && !(d.state & 1)) {
            if (d.state & 3) q(a, c), q(a, Kc("" + d.props.href)), q(a, id), c = gd;
            else if ("stylesheet" === d.type) {
                q(a, c);
                var e = d.props["data-precedence"], g = d.props;
                q(a, Kc("" + d.props.href));
                e = "" + e;
                q(a, hd);
                q(a, Kc(e));
                for(var f in g)if (B.call(g, f)) {
                    var m = g[f];
                    if (null != m) switch(f){
                        case "href":
                        case "rel":
                        case "precedence":
                        case "data-precedence":
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                        default:
                            a: {
                                e = a;
                                var k = f.toLowerCase();
                                switch(typeof m){
                                    case "function":
                                    case "symbol":
                                        break a;
                                }
                                switch(f){
                                    case "innerHTML":
                                    case "dangerouslySetInnerHTML":
                                    case "suppressContentEditableWarning":
                                    case "suppressHydrationWarning":
                                    case "style":
                                        break a;
                                    case "className":
                                        k = "class";
                                        m = "" + m;
                                        break;
                                    case "hidden":
                                        if (!1 === m) break a;
                                        m = "";
                                        break;
                                    case "src":
                                    case "href":
                                        m = "" + m;
                                        break;
                                    default:
                                        if (2 < f.length && ("o" === f[0] || "O" === f[0]) && ("n" === f[1] || "N" === f[1]) || !oa(f)) break a;
                                        m = "" + m;
                                }
                                q(e, hd);
                                q(e, Kc(k));
                                q(e, hd);
                                q(e, Kc(m));
                            }
                    }
                }
                q(a, id);
                c = gd;
                d.state |= 2;
            }
        }
    });
    q(a, id);
}
function kd(a, b) {
    q(a, fd);
    var c = fd;
    b.forEach(function(d) {
        if ("style" !== d.type && !(d.state & 1)) {
            if (d.state & 3) q(a, c), q(a, C(JSON.stringify("" + d.props.href))), q(a, id), c = gd;
            else if ("stylesheet" === d.type) {
                q(a, c);
                var e = d.props["data-precedence"], g = d.props;
                q(a, C(JSON.stringify("" + d.props.href)));
                e = "" + e;
                q(a, hd);
                q(a, C(JSON.stringify(e)));
                for(var f in g)if (B.call(g, f)) {
                    var m = g[f];
                    if (null != m) switch(f){
                        case "href":
                        case "rel":
                        case "precedence":
                        case "data-precedence":
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                        default:
                            a: {
                                e = a;
                                var k = f.toLowerCase();
                                switch(typeof m){
                                    case "function":
                                    case "symbol":
                                        break a;
                                }
                                switch(f){
                                    case "innerHTML":
                                    case "dangerouslySetInnerHTML":
                                    case "suppressContentEditableWarning":
                                    case "suppressHydrationWarning":
                                    case "style":
                                        break a;
                                    case "className":
                                        k = "class";
                                        m = "" + m;
                                        break;
                                    case "hidden":
                                        if (!1 === m) break a;
                                        m = "";
                                        break;
                                    case "src":
                                    case "href":
                                        m = "" + m;
                                        break;
                                    default:
                                        if (2 < f.length && ("o" === f[0] || "O" === f[0]) && ("n" === f[1] || "N" === f[1]) || !oa(f)) break a;
                                        m = "" + m;
                                }
                                q(e, hd);
                                q(e, C(JSON.stringify(k)));
                                q(e, hd);
                                q(e, C(JSON.stringify(m)));
                            }
                    }
                }
                q(a, id);
                c = gd;
                d.state |= 2;
            }
        }
    });
    q(a, id);
}
function za(a) {
    var b = ld();
    if (b) {
        var c = b.resources;
        if ("string" === typeof a && a) {
            var d = "[prefetchDNS]" + a, e = c.preconnectsMap.get(d);
            e || (e = {
                type: "preconnect",
                chunks: [],
                state: 0,
                props: null
            }, c.preconnectsMap.set(d, e), R(e.chunks, {
                href: a,
                rel: "dns-prefetch"
            }));
            c.preconnects.add(e);
            md(b);
        }
    }
}
function Aa(a, b) {
    var c = ld();
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a) {
            b = null == b || "string" !== typeof b.crossOrigin ? null : "use-credentials" === b.crossOrigin ? "use-credentials" : "";
            var e = "[preconnect][" + (null === b ? "null" : b) + "]" + a, g = d.preconnectsMap.get(e);
            g || (g = {
                type: "preconnect",
                chunks: [],
                state: 0,
                props: null
            }, d.preconnectsMap.set(e, g), R(g.chunks, {
                rel: "preconnect",
                href: a,
                crossOrigin: b
            }));
            d.preconnects.add(g);
            md(c);
        }
    }
}
function Ba(a, b) {
    var c = ld();
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a && "object" === typeof b && null !== b && "string" === typeof b.as && b.as) {
            var e = b.as;
            if ("image" === e) {
                var g = b.imageSrcSet;
                var f = b.imageSizes, m = "";
                "string" === typeof g && "" !== g ? (m += "[" + g + "]", "string" === typeof f && (m += "[" + f + "]")) : m += "[][]" + a;
                g = "[" + e + "]" + m;
            } else g = "[" + e + "]" + a;
            f = d.preloadsMap.get(g);
            f || (f = {
                type: "preload",
                chunks: [],
                state: 0,
                props: {
                    rel: "preload",
                    as: e,
                    href: "image" === e && b.imageSrcSet ? void 0 : a,
                    crossOrigin: "font" === e ? "" : b.crossOrigin,
                    integrity: b.integrity,
                    type: b.type,
                    nonce: b.nonce,
                    fetchPriority: b.fetchPriority,
                    imageSrcSet: b.imageSrcSet,
                    imageSizes: b.imageSizes,
                    referrerPolicy: b.referrerPolicy
                }
            }, d.preloadsMap.set(g, f), R(f.chunks, f.props));
            switch(e){
                case "font":
                    d.fontPreloads.add(f);
                    break;
                case "style":
                    d.explicitStylesheetPreloads.add(f);
                    break;
                case "script":
                    d.explicitScriptPreloads.add(f);
                    break;
                default:
                    d.explicitOtherPreloads.add(f);
            }
            md(c);
        }
    }
}
function Ca(a, b) {
    var c = ld();
    if (c) {
        var d = c.resources;
        if ("string" === typeof a && a && "object" === typeof b && null !== b) {
            var e = b.as;
            switch(e){
                case "style":
                    var g = "[" + e + "]" + a, f = d.stylesMap.get(g);
                    e = b.precedence || "default";
                    if (!f) {
                        f = 0;
                        var m = d.preloadsMap.get(g);
                        m && m.state & 3 && (f = 8);
                        f = {
                            type: "stylesheet",
                            chunks: [],
                            state: f,
                            props: {
                                rel: "stylesheet",
                                href: a,
                                "data-precedence": e,
                                crossOrigin: b.crossOrigin,
                                integrity: b.integrity,
                                fetchPriority: b.fetchPriority
                            }
                        };
                        d.stylesMap.set(g, f);
                        a = d.precedences.get(e);
                        a || (a = new Set, d.precedences.set(e, a), b = {
                            type: "style",
                            chunks: [],
                            state: 0,
                            props: {
                                precedence: e,
                                hrefs: []
                            }
                        }, a.add(b), d.stylePrecedences.set(e, b));
                        a.add(f);
                        md(c);
                    }
                    break;
                case "script":
                    g = "[" + e + "]" + a, e = d.scriptsMap.get(g), e || (e = {
                        type: "script",
                        chunks: [],
                        state: 0,
                        props: null
                    }, d.scriptsMap.set(g, e), a = {
                        src: a,
                        async: !0,
                        crossOrigin: b.crossOrigin,
                        integrity: b.integrity,
                        nonce: b.nonce,
                        fetchPriority: b.fetchPriority
                    }, d.scripts.add(e), mb(e.chunks, a), md(c));
            }
        }
    }
}
function nd(a) {
    this.add(a);
}
var od = new ba.AsyncLocalStorage, pd = Symbol.for("react.element"), qd = Symbol.for("react.portal"), rd = Symbol.for("react.fragment"), sd = Symbol.for("react.strict_mode"), td = Symbol.for("react.profiler"), ud = Symbol.for("react.provider"), vd = Symbol.for("react.context"), wd = Symbol.for("react.server_context"), xd = Symbol.for("react.forward_ref"), yd = Symbol.for("react.suspense"), zd = Symbol.for("react.suspense_list"), Ad = Symbol.for("react.memo"), Bd = Symbol.for("react.lazy"), Cd = Symbol.for("react.scope"), Dd = Symbol.for("react.debug_trace_mode"), Ed = Symbol.for("react.offscreen"), Fd = Symbol.for("react.legacy_hidden"), Gd = Symbol.for("react.cache"), Hd = Symbol.for("react.default_value"), Id = Symbol.iterator;
function Jd(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch(a){
        case rd:
            return "Fragment";
        case qd:
            return "Portal";
        case td:
            return "Profiler";
        case sd:
            return "StrictMode";
        case yd:
            return "Suspense";
        case zd:
            return "SuspenseList";
        case Gd:
            return "Cache";
    }
    if ("object" === typeof a) switch(a.$$typeof){
        case vd:
            return (a.displayName || "Context") + ".Consumer";
        case ud:
            return (a._context.displayName || "Context") + ".Provider";
        case xd:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
        case Ad:
            return b = a.displayName || null, null !== b ? b : Jd(a.type) || "Memo";
        case Bd:
            b = a._payload;
            a = a._init;
            try {
                return Jd(a(b));
            } catch (c) {
                break;
            }
        case wd:
            return (a.displayName || a._globalName) + ".Provider";
    }
    return null;
}
var Kd = {};
function Ld(a, b) {
    a = a.contextTypes;
    if (!a) return Kd;
    var c = {}, d;
    for(d in a)c[d] = b[d];
    return c;
}
var Md = null;
function Nd(a, b) {
    if (a !== b) {
        a.context._currentValue = a.parentValue;
        a = a.parent;
        var c = b.parent;
        if (null === a) {
            if (null !== c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
            if (null === c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
            Nd(a, c);
        }
        b.context._currentValue = b.value;
    }
}
function Od(a) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    null !== a && Od(a);
}
function Pd(a) {
    var b = a.parent;
    null !== b && Pd(b);
    a.context._currentValue = a.value;
}
function Qd(a, b) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === b.depth ? Nd(a, b) : Qd(a, b);
}
function Rd(a, b) {
    var c = b.parent;
    if (null === c) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === c.depth ? Nd(a, c) : Rd(a, c);
    b.context._currentValue = b.value;
}
function Sd(a) {
    var b = Md;
    b !== a && (null === b ? Pd(a) : null === a ? Od(b) : b.depth === a.depth ? Nd(b, a) : b.depth > a.depth ? Qd(b, a) : Rd(b, a), Md = a);
}
var Td = {
    isMounted: function() {
        return !1;
    },
    enqueueSetState: function(a, b) {
        a = a._reactInternals;
        null !== a.queue && a.queue.push(b);
    },
    enqueueReplaceState: function(a, b) {
        a = a._reactInternals;
        a.replace = !0;
        a.queue = [
            b
        ];
    },
    enqueueForceUpdate: function() {}
};
function Ud(a, b, c, d) {
    var e = void 0 !== a.state ? a.state : null;
    a.updater = Td;
    a.props = c;
    a.state = e;
    var g = {
        queue: [],
        replace: !1
    };
    a._reactInternals = g;
    var f = b.contextType;
    a.context = "object" === typeof f && null !== f ? f._currentValue : d;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (f = f(c, e), e = null === f || void 0 === f ? e : A({}, e, f), a.state = e);
    if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && Td.enqueueReplaceState(a, a.state, null), null !== g.queue && 0 < g.queue.length) if (b = g.queue, f = g.replace, g.queue = null, g.replace = !1, f && 1 === b.length) a.state = b[0];
    else {
        g = f ? b[0] : a.state;
        e = !0;
        for(f = f ? 1 : 0; f < b.length; f++){
            var m = b[f];
            m = "function" === typeof m ? m.call(a, g, c, d) : m;
            null != m && (e ? (e = !1, g = A({}, g, m)) : A(g, m));
        }
        a.state = g;
    }
    else g.queue = null;
}
var Vd = {
    id: 1,
    overflow: ""
};
function Wd(a, b, c) {
    var d = a.id;
    a = a.overflow;
    var e = 32 - Xd(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var g = 32 - Xd(b) + e;
    if (30 < g) {
        var f = e - e % 5;
        g = (d & (1 << f) - 1).toString(32);
        d >>= f;
        e -= f;
        return {
            id: 1 << 32 - Xd(b) + e | c << e | d,
            overflow: g + a
        };
    }
    return {
        id: 1 << g | c << e | d,
        overflow: a
    };
}
var Xd = Math.clz32 ? Math.clz32 : Yd, Zd = Math.log, $d = Math.LN2;
function Yd(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (Zd(a) / $d | 0) | 0;
}
var ae = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`");
function be() {}
function ce(a, b, c) {
    c = a[c];
    void 0 === c ? a.push(b) : c !== b && (b.then(be, be), b = c);
    switch(b.status){
        case "fulfilled":
            return b.value;
        case "rejected":
            throw b.reason;
        default:
            if ("string" !== typeof b.status) switch(a = b, a.status = "pending", a.then(function(d) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "fulfilled";
                    e.value = d;
                }
            }, function(d) {
                if ("pending" === b.status) {
                    var e = b;
                    e.status = "rejected";
                    e.reason = d;
                }
            }), b.status){
                case "fulfilled":
                    return b.value;
                case "rejected":
                    throw b.reason;
            }
            de = b;
            throw ae;
    }
}
var de = null;
function ee() {
    if (null === de) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
    var a = de;
    de = null;
    return a;
}
function fe(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var ge = "function" === typeof Object.is ? Object.is : fe, W = null, he = null, ie = null, X = null, je = !1, ke = !1, le = 0, me = 0, ne = null, Y = null, oe = 0;
function pe() {
    if (null === W) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return W;
}
function qe() {
    if (0 < oe) throw Error("Rendered more hooks than during the previous render");
    return {
        memoizedState: null,
        queue: null,
        next: null
    };
}
function re() {
    null === X ? null === ie ? (je = !1, ie = X = qe()) : (je = !0, X = ie) : null === X.next ? (je = !1, X = X.next = qe()) : (je = !0, X = X.next);
    return X;
}
function se(a, b, c, d) {
    for(; ke;)ke = !1, me = le = 0, oe += 1, X = null, c = a(b, d);
    te();
    return c;
}
function ue() {
    var a = ne;
    ne = null;
    return a;
}
function te() {
    he = W = null;
    ke = !1;
    ie = null;
    oe = 0;
    X = Y = null;
}
function ve(a, b) {
    return "function" === typeof b ? b(a) : b;
}
function we(a, b, c) {
    W = pe();
    X = re();
    if (je) {
        var d = X.queue;
        b = d.dispatch;
        if (null !== Y && (c = Y.get(d), void 0 !== c)) {
            Y.delete(d);
            d = X.memoizedState;
            do d = a(d, c.action), c = c.next;
            while (null !== c);
            X.memoizedState = d;
            return [
                d,
                b
            ];
        }
        return [
            X.memoizedState,
            b
        ];
    }
    a = a === ve ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
    X.memoizedState = a;
    a = X.queue = {
        last: null,
        dispatch: null
    };
    a = a.dispatch = xe.bind(null, W, a);
    return [
        X.memoizedState,
        a
    ];
}
function ye(a, b) {
    W = pe();
    X = re();
    b = void 0 === b ? null : b;
    if (null !== X) {
        var c = X.memoizedState;
        if (null !== c && null !== b) {
            var d = c[1];
            a: if (null === d) d = !1;
            else {
                for(var e = 0; e < d.length && e < b.length; e++)if (!ge(b[e], d[e])) {
                    d = !1;
                    break a;
                }
                d = !0;
            }
            if (d) return c[0];
        }
    }
    a = a();
    X.memoizedState = [
        a,
        b
    ];
    return a;
}
function xe(a, b, c) {
    if (25 <= oe) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    if (a === W) if (ke = !0, a = {
        action: c,
        next: null
    }, null === Y && (Y = new Map), c = Y.get(b), void 0 === c) Y.set(b, a);
    else {
        for(b = c; null !== b.next;)b = b.next;
        b.next = a;
    }
}
function ze() {
    throw Error("startTransition cannot be called during server rendering.");
}
function Ae(a) {
    var b = me;
    me += 1;
    null === ne && (ne = []);
    return ce(ne, a, b);
}
function Be() {
    throw Error("Cache cannot be refreshed during server rendering.");
}
function Ce() {}
var Ee = {
    readContext: function(a) {
        return a._currentValue;
    },
    use: function(a) {
        if (null !== a && "object" === typeof a) {
            if ("function" === typeof a.then) return Ae(a);
            if (a.$$typeof === vd || a.$$typeof === wd) return a._currentValue;
        }
        throw Error("An unsupported type was passed to use(): " + String(a));
    },
    useContext: function(a) {
        pe();
        return a._currentValue;
    },
    useMemo: ye,
    useReducer: we,
    useRef: function(a) {
        W = pe();
        X = re();
        var b = X.memoizedState;
        return null === b ? (a = {
            current: a
        }, X.memoizedState = a) : b;
    },
    useState: function(a) {
        return we(ve, a);
    },
    useInsertionEffect: Ce,
    useLayoutEffect: Ce,
    useCallback: function(a, b) {
        return ye(function() {
            return a;
        }, b);
    },
    useImperativeHandle: Ce,
    useEffect: Ce,
    useDebugValue: Ce,
    useDeferredValue: function(a) {
        pe();
        return a;
    },
    useTransition: function() {
        pe();
        return [
            !1,
            ze
        ];
    },
    useId: function() {
        var a = he.treeContext;
        var b = a.overflow;
        a = a.id;
        a = (a & ~(1 << 32 - Xd(a) - 1)).toString(32) + b;
        var c = De;
        if (null === c) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        b = le++;
        a = ":" + c.idPrefix + "R" + a;
        0 < b && (a += "H" + b.toString(32));
        return a + ":";
    },
    useSyncExternalStore: function(a, b, c) {
        if (void 0 === c) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return c();
    },
    useCacheRefresh: function() {
        return Be;
    }
}, De = null, Fe = {
    getCacheSignal: function() {
        throw Error("Not implemented.");
    },
    getCacheForType: function() {
        throw Error("Not implemented.");
    }
}, Ge = va.ReactCurrentDispatcher, He = va.ReactCurrentCache;
function Ie(a) {
    console.error(a);
    return null;
}
function Je() {}
var Ke = null;
function ld() {
    if (Ke) return Ke;
    var a = od.getStore();
    return a ? a : null;
}
function Le(a, b) {
    a.pingedTasks.push(b);
    1 === a.pingedTasks.length && (a.flushScheduled = null !== a.destination, setImmediate(function() {
        return Me(a);
    }));
}
function Ne(a, b, c, d, e, g, f, m, k) {
    a.allPendingTasks++;
    null === d ? a.pendingRootTasks++ : d.pendingTasks++;
    var n = {
        node: c,
        ping: function() {
            return Le(a, n);
        },
        blockedBoundary: d,
        blockedSegment: e,
        abortSet: g,
        legacyContext: f,
        context: m,
        treeContext: k,
        thenableState: b
    };
    g.add(n);
    return n;
}
function Oe(a, b, c, d, e, g) {
    return {
        status: 0,
        id: -1,
        index: b,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: d,
        boundary: c,
        lastPushedText: e,
        textEmbedded: g
    };
}
function Pe(a, b) {
    a = a.onError(b);
    if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
    return a;
}
function Qe(a, b) {
    var c = a.onShellError;
    c(b);
    c = a.onFatalError;
    c(b);
    null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
}
function Re(a, b, c, d) {
    var e = c.render(), g = d.childContextTypes;
    if (null !== g && void 0 !== g) {
        var f = b.legacyContext;
        if ("function" !== typeof c.getChildContext) d = f;
        else {
            c = c.getChildContext();
            for(var m in c)if (!(m in g)) throw Error((Jd(d) || "Unknown") + '.getChildContext(): key "' + m + '" is not defined in childContextTypes.');
            d = A({}, f, c);
        }
        b.legacyContext = d;
        Z(a, b, null, e);
        b.legacyContext = f;
    } else Z(a, b, null, e);
}
function Se(a, b) {
    if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for(var c in a)void 0 === b[c] && (b[c] = a[c]);
        return b;
    }
    return b;
}
function Te(a, b, c, d, e, g) {
    if ("function" === typeof d) if (d.prototype && d.prototype.isReactComponent) c = Ld(d, b.legacyContext), g = d.contextType, g = new d(e, "object" === typeof g && null !== g ? g._currentValue : c), Ud(g, d, e, c), Re(a, b, g, d);
    else {
        g = Ld(d, b.legacyContext);
        W = {};
        he = b;
        me = le = 0;
        ne = c;
        c = d(e, g);
        c = se(d, e, c, g);
        var f = 0 !== le;
        if ("object" === typeof c && null !== c && "function" === typeof c.render && void 0 === c.$$typeof) Ud(c, d, e, g), Re(a, b, c, d);
        else if (f) {
            e = b.treeContext;
            b.treeContext = Wd(e, 1, 0);
            try {
                Z(a, b, null, c);
            } finally{
                b.treeContext = e;
            }
        } else Z(a, b, null, c);
    }
    else if ("string" === typeof d) {
        c = b.blockedSegment;
        f = sb(c.chunks, d, e, a.resources, a.responseState, c.formatContext, c.lastPushedText);
        c.lastPushedText = !1;
        g = c.formatContext;
        c.formatContext = Pa(g, d, e);
        Ue(a, b, f);
        c.formatContext = g;
        a: {
            b = c.chunks;
            switch(d){
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                    break a;
                case "body":
                    if (1 >= g.insertionMode) {
                        a.responseState.hasBody = !0;
                        break a;
                    }
                    break;
                case "html":
                    if (0 === g.insertionMode) break a;
            }
            b.push(U, d, V);
        }
        c.lastPushedText = !1;
    } else {
        switch(d){
            case Fd:
            case Dd:
            case sd:
            case td:
            case rd:
                Z(a, b, null, e.children);
                return;
            case Ed:
                "hidden" !== e.mode && Z(a, b, null, e.children);
                return;
            case zd:
                Z(a, b, null, e.children);
                return;
            case Cd:
                throw Error("ReactDOMServer does not yet support scope components.");
            case yd:
                a: {
                    d = b.blockedBoundary;
                    c = b.blockedSegment;
                    g = e.fallback;
                    e = e.children;
                    f = new Set;
                    var m = {
                        id: null,
                        rootSegmentID: -1,
                        parentFlushed: !1,
                        pendingTasks: 0,
                        forceClientRender: !1,
                        completedSegments: [],
                        byteSize: 0,
                        fallbackAbortableTasks: f,
                        errorDigest: null,
                        resources: new Set
                    }, k = Oe(a, c.chunks.length, m, c.formatContext, !1, !1);
                    c.children.push(k);
                    c.lastPushedText = !1;
                    var n = Oe(a, 0, null, c.formatContext, !1, !1);
                    n.parentFlushed = !0;
                    b.blockedBoundary = m;
                    b.blockedSegment = n;
                    a.resources.boundaryResources = m.resources;
                    try {
                        if (Ue(a, b, e), n.lastPushedText && n.textEmbedded && n.chunks.push(G), n.status = 1, Ve(m, n), 0 === m.pendingTasks) break a;
                    } catch (t) {
                        n.status = 4, m.forceClientRender = !0, m.errorDigest = Pe(a, t);
                    } finally{
                        a.resources.boundaryResources = d ? d.resources : null, b.blockedBoundary = d, b.blockedSegment = c;
                    }
                    b = Ne(a, null, g, d, k, f, b.legacyContext, b.context, b.treeContext);
                    a.pingedTasks.push(b);
                }
                return;
        }
        if ("object" === typeof d && null !== d) switch(d.$$typeof){
            case xd:
                d = d.render;
                W = {};
                he = b;
                me = le = 0;
                ne = c;
                c = d(e, g);
                e = se(d, e, c, g);
                if (0 !== le) {
                    d = b.treeContext;
                    b.treeContext = Wd(d, 1, 0);
                    try {
                        Z(a, b, null, e);
                    } finally{
                        b.treeContext = d;
                    }
                } else Z(a, b, null, e);
                return;
            case Ad:
                d = d.type;
                e = Se(d, e);
                Te(a, b, c, d, e, g);
                return;
            case ud:
                c = e.children;
                d = d._context;
                e = e.value;
                g = d._currentValue;
                d._currentValue = e;
                f = Md;
                Md = e = {
                    parent: f,
                    depth: null === f ? 0 : f.depth + 1,
                    context: d,
                    parentValue: g,
                    value: e
                };
                b.context = e;
                Z(a, b, null, c);
                a = Md;
                if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
                e = a.parentValue;
                a.context._currentValue = e === Hd ? a.context._defaultValue : e;
                a = Md = a.parent;
                b.context = a;
                return;
            case vd:
                e = e.children;
                e = e(d._currentValue);
                Z(a, b, null, e);
                return;
            case Bd:
                g = d._init;
                d = g(d._payload);
                e = Se(d, e);
                Te(a, b, c, d, e, void 0);
                return;
        }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == d ? d : typeof d) + "."));
    }
}
function Z(a, b, c, d) {
    b.node = d;
    if ("object" === typeof d && null !== d) {
        switch(d.$$typeof){
            case pd:
                Te(a, b, c, d.type, d.props, d.ref);
                return;
            case qd:
                throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case Bd:
                c = d._init;
                d = c(d._payload);
                Z(a, b, null, d);
                return;
        }
        if (ua(d)) {
            We(a, b, d);
            return;
        }
        null === d || "object" !== typeof d ? c = null : (c = Id && d[Id] || d["@@iterator"], c = "function" === typeof c ? c : null);
        if (c && (c = c.call(d))) {
            d = c.next();
            if (!d.done) {
                var e = [];
                do e.push(d.value), d = c.next();
                while (!d.done);
                We(a, b, e);
            }
            return;
        }
        if ("function" === typeof d.then) return Z(a, b, null, Ae(d));
        if (d.$$typeof === vd || d.$$typeof === wd) return Z(a, b, null, d._currentValue);
        a = Object.prototype.toString.call(d);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a ? "object with keys {" + Object.keys(d).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    "string" === typeof d ? (c = b.blockedSegment, c.lastPushedText = Qa(b.blockedSegment.chunks, d, a.responseState, c.lastPushedText)) : "number" === typeof d && (c = b.blockedSegment, c.lastPushedText = Qa(b.blockedSegment.chunks, "" + d, a.responseState, c.lastPushedText));
}
function We(a, b, c) {
    for(var d = c.length, e = 0; e < d; e++){
        var g = b.treeContext;
        b.treeContext = Wd(g, d, e);
        try {
            Ue(a, b, c[e]);
        } finally{
            b.treeContext = g;
        }
    }
}
function Ue(a, b, c) {
    var d = b.blockedSegment, e = d.children.length, g = d.chunks.length, f = b.blockedSegment.formatContext, m = b.legacyContext, k = b.context;
    try {
        return Z(a, b, null, c);
    } catch (n) {
        if (te(), d.children.length = e, d.chunks.length = g, c = n === ae ? ee() : n, "object" === typeof c && null !== c && "function" === typeof c.then) d = ue(), e = b.blockedSegment, g = Oe(a, e.chunks.length, null, e.formatContext, e.lastPushedText, !0), e.children.push(g), e.lastPushedText = !1, a = Ne(a, d, b.node, b.blockedBoundary, g, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = f, b.legacyContext = m, b.context = k, Sd(k);
        else throw b.blockedSegment.formatContext = f, b.legacyContext = m, b.context = k, Sd(k), c;
    }
}
function Xe(a) {
    var b = a.blockedBoundary;
    a = a.blockedSegment;
    a.status = 3;
    Ye(this, b, a);
}
function Ze(a, b, c) {
    var d = a.blockedBoundary;
    a.blockedSegment.status = 3;
    null === d ? (b.allPendingTasks--, 1 !== b.status && 2 !== b.status && (Pe(b, c), Qe(b, c))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(e) {
        return Ze(e, b, c);
    }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (a = b.onAllReady, a()));
}
function Ve(a, b) {
    if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
        var c = b.children[0];
        c.id = b.id;
        c.parentFlushed = !0;
        1 === c.status && Ve(a, c);
    } else a.completedSegments.push(b);
}
function Ye(a, b, c) {
    if (null === b) {
        if (c.parentFlushed) {
            if (null !== a.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
            a.completedRootSegment = c;
        }
        a.pendingRootTasks--;
        0 === a.pendingRootTasks && (a.onShellError = Je, b = a.onShellReady, b());
    } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && Ve(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Xe, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (Ve(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
    a.allPendingTasks--;
    0 === a.allPendingTasks && (a = a.onAllReady, a());
}
function Me(a) {
    if (2 !== a.status) {
        var b = Md, c = Ge.current;
        Ge.current = Ee;
        var d = He.current;
        He.current = Fe;
        var e = Ke;
        Ke = a;
        var g = De;
        De = a.responseState;
        try {
            var f = a.pingedTasks, m;
            for(m = 0; m < f.length; m++){
                var k = f[m];
                var n = a, t = k.blockedBoundary;
                n.resources.boundaryResources = t ? t.resources : null;
                var p = k.blockedSegment;
                if (0 === p.status) {
                    Sd(k.context);
                    var x = p.children.length, u = p.chunks.length;
                    try {
                        var v = k.thenableState;
                        k.thenableState = null;
                        Z(n, k, v, k.node);
                        p.lastPushedText && p.textEmbedded && p.chunks.push(G);
                        k.abortSet.delete(k);
                        p.status = 1;
                        Ye(n, k.blockedBoundary, p);
                    } catch (L) {
                        te();
                        p.children.length = x;
                        p.chunks.length = u;
                        var D = L === ae ? ee() : L;
                        if ("object" === typeof D && null !== D && "function" === typeof D.then) {
                            var r = k.ping;
                            D.then(r, r);
                            k.thenableState = ue();
                        } else {
                            k.abortSet.delete(k);
                            p.status = 4;
                            var F = n, O = k.blockedBoundary, la = D, xa = Pe(F, la);
                            null === O ? Qe(F, la) : (O.pendingTasks--, O.forceClientRender || (O.forceClientRender = !0, O.errorDigest = xa, O.parentFlushed && F.clientRenderedBoundaries.push(O)));
                            F.allPendingTasks--;
                            if (0 === F.allPendingTasks) {
                                var S = F.onAllReady;
                                S();
                            }
                        }
                    } finally{
                        n.resources.boundaryResources = null;
                    }
                }
            }
            f.splice(0, m);
            null !== a.destination && $e(a, a.destination);
        } catch (L) {
            Pe(a, L), Qe(a, L);
        } finally{
            De = g, Ge.current = c, He.current = d, c === Ee && Sd(b), Ke = e;
        }
    }
}
function af(a, b, c) {
    c.parentFlushed = !0;
    switch(c.status){
        case 0:
            var d = c.id = a.nextSegmentId++;
            c.lastPushedText = !1;
            c.textEmbedded = !1;
            a = a.responseState;
            q(b, ub);
            q(b, a.placeholderPrefix);
            a = d.toString(16);
            q(b, a);
            return y(b, vb);
        case 1:
            c.status = 2;
            var e = !0;
            d = c.chunks;
            var g = 0;
            c = c.children;
            for(var f = 0; f < c.length; f++){
                for(e = c[f]; g < e.index; g++)q(b, d[g]);
                e = bf(a, b, e);
            }
            for(; g < d.length - 1; g++)q(b, d[g]);
            g < d.length && (e = y(b, d[g]));
            return e;
        default:
            throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
    }
}
function bf(a, b, c) {
    var d = c.boundary;
    if (null === d) return af(a, b, c);
    d.parentFlushed = !0;
    if (d.forceClientRender) d = d.errorDigest, y(b, zb), q(b, Cb), d && (q(b, Eb), q(b, C(d)), q(b, Db)), y(b, Fb), af(a, b, c);
    else if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++;
        0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var e = a.responseState;
        var g = e.nextSuspenseID++;
        e = z(e.boundaryPrefix + g.toString(16));
        d = d.id = e;
        Gb(b, a.responseState, d);
        af(a, b, c);
    } else if (d.byteSize > a.progressiveChunkSize) d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Gb(b, a.responseState, d.id), af(a, b, c);
    else {
        (c = a.resources.boundaryResources) && d.resources.forEach(nd, c);
        y(b, wb);
        c = d.completedSegments;
        if (1 !== c.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        bf(a, b, c[0]);
    }
    return y(b, Bb);
}
function cf(a, b, c) {
    bc(b, a.responseState, c.formatContext, c.id);
    bf(a, b, c);
    return cc(b, c.formatContext);
}
function df(a, b, c) {
    a.resources.boundaryResources = c.resources;
    for(var d = c.completedSegments, e = 0; e < d.length; e++)ef(a, b, c, d[e]);
    d.length = 0;
    Tc(b, c.resources, a.responseState);
    a = a.responseState;
    d = c.id;
    e = c.rootSegmentID;
    c = c.resources;
    var g = a.stylesToHoist;
    a.stylesToHoist = !1;
    var f = 0 === a.streamingFormat;
    f ? (q(b, a.startInlineScript), g ? 0 === (a.instructions & 2) ? (a.instructions |= 10, q(b, 2048 < lc.length ? lc.slice() : lc)) : 0 === (a.instructions & 8) ? (a.instructions |= 8, q(b, mc)) : q(b, nc) : 0 === (a.instructions & 2) ? (a.instructions |= 2, q(b, jc)) : q(b, kc)) : g ? q(b, tc) : q(b, sc);
    if (null === d) throw Error("An ID must have been assigned before we can complete the boundary.");
    e = e.toString(16);
    q(b, d);
    f ? q(b, oc) : q(b, uc);
    q(b, a.segmentPrefix);
    q(b, e);
    g ? f ? (q(b, pc), jd(b, c)) : (q(b, vc), kd(b, c)) : f && q(b, qc);
    d = f ? y(b, rc) : y(b, Ea);
    return tb(b, a) && d;
}
function ef(a, b, c, d) {
    if (2 === d.status) return !0;
    var e = d.id;
    if (-1 === e) {
        if (-1 === (d.id = c.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return cf(a, b, d);
    }
    cf(a, b, d);
    a = a.responseState;
    (c = 0 === a.streamingFormat) ? (q(b, a.startInlineScript), 0 === (a.instructions & 1) ? (a.instructions |= 1, q(b, dc)) : q(b, ec)) : q(b, hc);
    q(b, a.segmentPrefix);
    e = e.toString(16);
    q(b, e);
    c ? q(b, fc) : q(b, ic);
    q(b, a.placeholderPrefix);
    q(b, e);
    b = c ? y(b, gc) : y(b, Ea);
    return b;
}
function $e(a, b) {
    h = new Uint8Array(2048);
    l = 0;
    fa = !0;
    try {
        var c, d = a.completedRootSegment;
        if (null !== d) if (0 === a.pendingRootTasks) {
            var e = a.resources, g = a.responseState;
            if (0 !== a.allPendingTasks && g.externalRuntimeScript) {
                var f = g.externalRuntimeScript, m = f.chunks, k = "[script]" + f.src, n = e.scriptsMap.get(k);
                n || (n = {
                    type: "script",
                    chunks: m,
                    state: 0,
                    props: null
                }, e.scriptsMap.set(k, n), e.scripts.add(n));
            }
            var t = g.htmlChunks, p = g.headChunks;
            f = 0;
            if (t) {
                for(f = 0; f < t.length; f++)q(b, t[f]);
                if (p) for(f = 0; f < p.length; f++)q(b, p[f]);
                else q(b, T("head")), q(b, P);
            } else if (p) for(f = 0; f < p.length; f++)q(b, p[f]);
            var x = g.charsetChunks;
            for(f = 0; f < x.length; f++)q(b, x[f]);
            x.length = 0;
            e.preconnects.forEach(Uc, b);
            e.preconnects.clear();
            var u = g.preconnectChunks;
            for(f = 0; f < u.length; f++)q(b, u[f]);
            u.length = 0;
            e.fontPreloads.forEach(Uc, b);
            e.fontPreloads.clear();
            e.precedences.forEach(cd, b);
            e.scripts.forEach(Uc, b);
            e.scripts.clear();
            e.explicitStylesheetPreloads.forEach(Uc, b);
            e.explicitStylesheetPreloads.clear();
            e.explicitScriptPreloads.forEach(Uc, b);
            e.explicitScriptPreloads.clear();
            e.explicitOtherPreloads.forEach(Uc, b);
            e.explicitOtherPreloads.clear();
            var v = g.preloadChunks;
            for(f = 0; f < v.length; f++)q(b, v[f]);
            v.length = 0;
            var D = g.hoistableChunks;
            for(f = 0; f < D.length; f++)q(b, D[f]);
            D.length = 0;
            t && null === p && (q(b, U), q(b, "head"), q(b, V));
            bf(a, b, d);
            a.completedRootSegment = null;
            tb(b, a.responseState);
        } else return;
        else if (0 < a.pendingRootTasks) return;
        var r = a.resources, F = a.responseState;
        d = 0;
        r.preconnects.forEach(Vc, b);
        r.preconnects.clear();
        var O = F.preconnectChunks;
        for(d = 0; d < O.length; d++)q(b, O[d]);
        O.length = 0;
        r.fontPreloads.forEach(Vc, b);
        r.fontPreloads.clear();
        r.precedences.forEach(ed, b);
        r.scripts.forEach(Vc, b);
        r.scripts.clear();
        r.explicitStylesheetPreloads.forEach(Vc, b);
        r.explicitStylesheetPreloads.clear();
        r.explicitScriptPreloads.forEach(Vc, b);
        r.explicitScriptPreloads.clear();
        r.explicitOtherPreloads.forEach(Vc, b);
        r.explicitOtherPreloads.clear();
        var la = F.preloadChunks;
        for(d = 0; d < la.length; d++)q(b, la[d]);
        la.length = 0;
        var xa = F.hoistableChunks;
        for(d = 0; d < xa.length; d++)q(b, xa[d]);
        xa.length = 0;
        var S = a.clientRenderedBoundaries;
        for(c = 0; c < S.length; c++){
            var L = S[c];
            r = b;
            var N = a.responseState, Hc = L.id, Ab = L.errorDigest, Wa = L.errorMessage, ya = L.errorComponentStack, ma = 0 === N.streamingFormat;
            ma ? (q(r, N.startInlineScript), 0 === (N.instructions & 4) ? (N.instructions |= 4, q(r, wc)) : q(r, xc)) : q(r, Bc);
            if (null === Hc) throw Error("An ID must have been assigned before we can complete the boundary.");
            q(r, Hc);
            ma && q(r, yc);
            if (Ab || Wa || ya) ma ? (q(r, zc), q(r, Gc(Ab || ""))) : (q(r, Cc), q(r, C(Ab || "")));
            if (Wa || ya) ma ? (q(r, zc), q(r, Gc(Wa || ""))) : (q(r, Dc), q(r, C(Wa || "")));
            ya && (ma ? (q(r, zc), q(r, Gc(ya))) : (q(r, Ec), q(r, C(ya))));
            if (ma ? !y(r, Ac) : !y(r, Ea)) {
                a.destination = null;
                c++;
                S.splice(0, c);
                return;
            }
        }
        S.splice(0, c);
        var Xa = a.completedBoundaries;
        for(c = 0; c < Xa.length; c++)if (!df(a, b, Xa[c])) {
            a.destination = null;
            c++;
            Xa.splice(0, c);
            return;
        }
        Xa.splice(0, c);
        ia(b);
        h = new Uint8Array(2048);
        l = 0;
        fa = !0;
        var Ya = a.partialBoundaries;
        for(c = 0; c < Ya.length; c++){
            var Za = Ya[c];
            a: {
                S = a;
                L = b;
                S.resources.boundaryResources = Za.resources;
                var $a = Za.completedSegments;
                for(N = 0; N < $a.length; N++)if (!ef(S, L, Za, $a[N])) {
                    N++;
                    $a.splice(0, N);
                    var Ic = !1;
                    break a;
                }
                $a.splice(0, N);
                Ic = Tc(L, Za.resources, S.responseState);
            }
            if (!Ic) {
                a.destination = null;
                c++;
                Ya.splice(0, c);
                return;
            }
        }
        Ya.splice(0, c);
        var ab = a.completedBoundaries;
        for(c = 0; c < ab.length; c++)if (!df(a, b, ab[c])) {
            a.destination = null;
            c++;
            ab.splice(0, c);
            return;
        }
        ab.splice(0, c);
    } finally{
        0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length ? (a.flushScheduled = !1, a = a.responseState, a.hasBody && (q(b, U), q(b, "body"), q(b, V)), a.htmlChunks && (q(b, U), q(b, "html"), q(b, V)), ia(b), ea(b), b.end()) : (ia(b), ea(b));
    }
}
function ff(a) {
    a.flushScheduled = null !== a.destination;
    setImmediate(function() {
        return od.run(a, Me, a);
    });
}
function md(a) {
    if (!1 === a.flushScheduled && 0 === a.pingedTasks.length && null !== a.destination) {
        var b = a.destination;
        a.flushScheduled = !0;
        setImmediate(function() {
            return $e(a, b);
        });
    }
}
function gf(a, b) {
    if (1 === a.status) a.status = 2, b.destroy(a.fatalError);
    else if (2 !== a.status && null === a.destination) {
        a.destination = b;
        try {
            $e(a, b);
        } catch (c) {
            Pe(a, c), Qe(a, c);
        }
    }
}
function hf(a, b) {
    try {
        var c = a.abortableTasks;
        if (0 < c.size) {
            var d = void 0 === b ? Error("The render was aborted by the server without a reason.") : b;
            c.forEach(function(e) {
                return Ze(e, a, d);
            });
            c.clear();
        }
        null !== a.destination && $e(a, a.destination);
    } catch (e) {
        Pe(a, e), Qe(a, e);
    }
}
function jf(a, b) {
    return function() {
        return gf(b, a);
    };
}
function kf(a, b) {
    return function() {
        return hf(a, Error(b));
    };
}
function lf(a, b) {
    var c = {
        preloadsMap: new Map,
        preconnectsMap: new Map,
        stylesMap: new Map,
        scriptsMap: new Map,
        preconnects: new Set,
        fontPreloads: new Set,
        precedences: new Map,
        stylePrecedences: new Map,
        scripts: new Set,
        explicitStylesheetPreloads: new Set,
        explicitScriptPreloads: new Set,
        explicitOtherPreloads: new Set,
        boundaryResources: null
    }, d = b ? b.identifierPrefix : void 0;
    var e = b ? b.nonce : void 0;
    var g = b ? b.bootstrapScriptContent : void 0, f = b ? b.bootstrapScripts : void 0, m = b ? b.bootstrapModules : void 0, k = b ? b.unstable_externalRuntimeSrc : void 0;
    d = void 0 === d ? "" : d;
    var n = void 0 === e ? Fa : z('<script nonce="' + C(e) + '">'), t = [], p = null, x = 0;
    void 0 !== g && t.push(n, ("" + g).replace(Na, Oa), Ga);
    void 0 !== k && (x = 1, "string" === typeof k ? (p = {
        src: k,
        chunks: []
    }, mb(p.chunks, {
        src: k,
        async: !0,
        integrity: void 0,
        nonce: e
    })) : (p = {
        src: k.src,
        chunks: []
    }, mb(p.chunks, {
        src: k.src,
        async: !0,
        integrity: k.integrity,
        nonce: e
    })));
    if (void 0 !== f) for(g = 0; g < f.length; g++){
        var u = f[g];
        k = "string" === typeof u ? u : u.src;
        var v = "string" === typeof u ? void 0 : u.integrity;
        u = "string" === typeof u || null == u.crossOrigin ? void 0 : "use-credentials" === u.crossOrigin ? "use-credentials" : "";
        var D = {
            rel: "preload",
            href: k,
            as: "script",
            nonce: e,
            integrity: v,
            crossOrigin: u
        }, r = {
            type: "preload",
            chunks: [],
            state: 0,
            props: D
        };
        c.preloadsMap.set("[script]" + k, r);
        c.explicitScriptPreloads.add(r);
        R(r.chunks, D);
        t.push(Ha, C(k));
        e && t.push(Ja, C(e));
        v && t.push(Ka, C(v));
        "string" === typeof u && t.push(La, C(u));
        t.push(Ma);
    }
    if (void 0 !== m) for(f = 0; f < m.length; f++)v = m[f], g = "string" === typeof v ? v : v.src, k = "string" === typeof v ? void 0 : v.integrity, v = "string" === typeof v || null == v.crossOrigin ? void 0 : "use-credentials" === v.crossOrigin ? "use-credentials" : "", u = {
        rel: "modulepreload",
        href: g,
        nonce: e,
        integrity: k,
        crossOrigin: v
    }, D = {
        type: "preload",
        chunks: [],
        state: 0,
        props: u
    }, c.preloadsMap.set("[script]" + g, D), c.explicitScriptPreloads.add(D), R(D.chunks, u), t.push(Ia, C(g)), e && t.push(Ja, C(e)), k && t.push(Ka, C(k)), "string" === typeof v && t.push(La, C(v)), t.push(Ma);
    e = {
        bootstrapChunks: t,
        placeholderPrefix: z(d + "P:"),
        segmentPrefix: z(d + "S:"),
        boundaryPrefix: d + "B:",
        idPrefix: d,
        nextSuspenseID: 0,
        streamingFormat: x,
        startInlineScript: n,
        instructions: 0,
        externalRuntimeScript: p,
        htmlChunks: null,
        headChunks: null,
        hasBody: !1,
        charsetChunks: [],
        preconnectChunks: [],
        preloadChunks: [],
        hoistableChunks: [],
        stylesToHoist: !1,
        nonce: e
    };
    m = b ? b.namespaceURI : void 0;
    m = E("http://www.w3.org/2000/svg" === m ? 3 : "http://www.w3.org/1998/Math/MathML" === m ? 4 : 0, null, !1);
    n = b ? b.progressiveChunkSize : void 0;
    t = b ? b.onError : void 0;
    p = b ? b.onAllReady : void 0;
    x = b ? b.onShellReady : void 0;
    f = b ? b.onShellError : void 0;
    wa.current = Da;
    b = [];
    d = new Set;
    c = {
        destination: null,
        flushScheduled: !1,
        responseState: e,
        progressiveChunkSize: void 0 === n ? 12800 : n,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        resources: c,
        completedRootSegment: null,
        abortableTasks: d,
        pingedTasks: b,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: void 0 === t ? Ie : t,
        onAllReady: void 0 === p ? Je : p,
        onShellReady: void 0 === x ? Je : x,
        onShellError: void 0 === f ? Je : f,
        onFatalError: Je
    };
    e = Oe(c, 0, null, m, !1, !1);
    e.parentFlushed = !0;
    a = Ne(c, null, a, null, e, d, Kd, null, Vd);
    b.push(a);
    return c;
}
exports.renderToPipeableStream = function(a, b) {
    var c = lf(a, b), d = !1;
    ff(c);
    return {
        pipe: function(e) {
            if (d) throw Error("React currently only supports piping to one writable stream.");
            d = !0;
            gf(c, e);
            e.on("drain", jf(e, c));
            e.on("error", kf(c, "The destination stream errored while writing data."));
            e.on("close", kf(c, "The destination stream closed early."));
            return e;
        },
        abort: function(e) {
            hf(c, e);
        }
    };
};
exports.version = "18.3.0-canary-9377e1010-20230712";


/***/ }),

/***/ 3473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(6624);


/***/ }),

/***/ 6624:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var l, s;
if (true) {
    l = __webpack_require__(84222);
    s = __webpack_require__(70284);
} else {}
exports.version = l.version;
exports.renderToString = l.renderToString;
exports.renderToStaticMarkup = l.renderToStaticMarkup;
exports.renderToNodeStream = l.renderToNodeStream;
exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
exports.renderToPipeableStream = s.renderToPipeableStream;


/***/ }),

/***/ 59984:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.server_context"), w = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), y = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), A = Symbol.for("react.default_value"), B = Symbol.iterator;
function C(a) {
    if (null === a || "object" !== typeof a) return null;
    a = B && a[B] || a["@@iterator"];
    return "function" === typeof a ? a : null;
}
var D = {
    isMounted: function() {
        return !1;
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}, E = Object.assign, F = {};
function G(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = c || D;
}
G.prototype.isReactComponent = {};
G.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
};
G.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function H() {}
H.prototype = G.prototype;
function I(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = F;
    this.updater = c || D;
}
var J = I.prototype = new H;
J.constructor = I;
E(J, G.prototype);
J.isPureReactComponent = !0;
var K = Array.isArray, L = Object.prototype.hasOwnProperty, M = {
    current: null
}, N = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function O(a, b, c) {
    var d, e = {}, f = null, g = null;
    if (null != b) for(d in void 0 !== b.ref && (g = b.ref), void 0 !== b.key && (f = "" + b.key), b)L.call(b, d) && !N.hasOwnProperty(d) && (e[d] = b[d]);
    var h = arguments.length - 2;
    if (1 === h) e.children = c;
    else if (1 < h) {
        for(var k = Array(h), m = 0; m < h; m++)k[m] = arguments[m + 2];
        e.children = k;
    }
    if (a && a.defaultProps) for(d in h = a.defaultProps, h)void 0 === e[d] && (e[d] = h[d]);
    return {
        $$typeof: l,
        type: a,
        key: f,
        ref: g,
        props: e,
        _owner: M.current
    };
}
function aa(a, b) {
    return {
        $$typeof: l,
        type: a.type,
        key: b,
        ref: a.ref,
        props: a.props,
        _owner: a._owner
    };
}
function P(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
}
function escape(a) {
    var b = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function(c) {
        return b[c];
    });
}
var Q = /\/+/g;
function R(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function S(a, b, c, d, e) {
    var f = typeof a;
    if ("undefined" === f || "boolean" === f) a = null;
    var g = !1;
    if (null === a) g = !0;
    else switch(f){
        case "string":
        case "number":
            g = !0;
            break;
        case "object":
            switch(a.$$typeof){
                case l:
                case n:
                    g = !0;
            }
    }
    if (g) return g = a, e = e(g), a = "" === d ? "." + R(g, 0) : d, K(e) ? (c = "", null != a && (c = a.replace(Q, "$&/") + "/"), S(e, b, c, "", function(m) {
        return m;
    })) : null != e && (P(e) && (e = aa(e, c + (!e.key || g && g.key === e.key ? "" : ("" + e.key).replace(Q, "$&/") + "/") + a)), b.push(e)), 1;
    g = 0;
    d = "" === d ? "." : d + ":";
    if (K(a)) for(var h = 0; h < a.length; h++){
        f = a[h];
        var k = d + R(f, h);
        g += S(f, b, c, k, e);
    }
    else if (k = C(a), "function" === typeof k) for(a = k.call(a), h = 0; !(f = a.next()).done;)f = f.value, k = d + R(f, h++), g += S(f, b, c, k, e);
    else if ("object" === f) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return g;
}
function T(a, b, c) {
    if (null == a) return a;
    var d = [], e = 0;
    S(a, d, "", "", function(f) {
        return b.call(c, f, e++);
    });
    return d;
}
function ba(a) {
    if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(c) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = c;
        }, function(c) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = c;
        });
        -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
}
var U = {
    current: null
};
function ca() {
    return new WeakMap;
}
function V() {
    return {
        s: 0,
        v: void 0,
        o: null,
        p: null
    };
}
var W = {
    current: null
}, X = {
    transition: null
}, Y = {
    ReactCurrentDispatcher: W,
    ReactCurrentCache: U,
    ReactCurrentBatchConfig: X,
    ReactCurrentOwner: M,
    ContextRegistry: {}
}, Z = Y.ContextRegistry;
exports.Children = {
    map: T,
    forEach: function(a, b, c) {
        T(a, function() {
            b.apply(this, arguments);
        }, c);
    },
    count: function(a) {
        var b = 0;
        T(a, function() {
            b++;
        });
        return b;
    },
    toArray: function(a) {
        return T(a, function(b) {
            return b;
        }) || [];
    },
    only: function(a) {
        if (!P(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
    }
};
exports.Component = G;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = I;
exports.StrictMode = q;
exports.Suspense = x;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y;
exports.cache = function(a) {
    return function() {
        var b = U.current;
        if (!b) return a.apply(null, arguments);
        var c = b.getCacheForType(ca);
        b = c.get(a);
        void 0 === b && (b = V(), c.set(a, b));
        c = 0;
        for(var d = arguments.length; c < d; c++){
            var e = arguments[c];
            if ("function" === typeof e || "object" === typeof e && null !== e) {
                var f = b.o;
                null === f && (b.o = f = new WeakMap);
                b = f.get(e);
                void 0 === b && (b = V(), f.set(e, b));
            } else f = b.p, null === f && (b.p = f = new Map), b = f.get(e), void 0 === b && (b = V(), f.set(e, b));
        }
        if (1 === b.s) return b.v;
        if (2 === b.s) throw b.v;
        try {
            var g = a.apply(null, arguments);
            c = b;
            c.s = 1;
            return c.v = g;
        } catch (h) {
            throw g = b, g.s = 2, g.v = h, h;
        }
    };
};
exports.cloneElement = function(a, b, c) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = E({}, a.props), e = a.key, f = a.ref, g = a._owner;
    if (null != b) {
        void 0 !== b.ref && (f = b.ref, g = M.current);
        void 0 !== b.key && (e = "" + b.key);
        if (a.type && a.type.defaultProps) var h = a.type.defaultProps;
        for(k in b)L.call(b, k) && !N.hasOwnProperty(k) && (d[k] = void 0 === b[k] && void 0 !== h ? h[k] : b[k]);
    }
    var k = arguments.length - 2;
    if (1 === k) d.children = c;
    else if (1 < k) {
        h = Array(k);
        for(var m = 0; m < k; m++)h[m] = arguments[m + 2];
        d.children = h;
    }
    return {
        $$typeof: l,
        type: a.type,
        key: e,
        ref: f,
        props: d,
        _owner: g
    };
};
exports.createContext = function(a) {
    a = {
        $$typeof: u,
        _currentValue: a,
        _currentValue2: a,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    };
    a.Provider = {
        $$typeof: t,
        _context: a
    };
    return a.Consumer = a;
};
exports.createElement = O;
exports.createFactory = function(a) {
    var b = O.bind(null, a);
    b.type = a;
    return b;
};
exports.createRef = function() {
    return {
        current: null
    };
};
exports.createServerContext = function(a, b) {
    var c = !0;
    if (!Z[a]) {
        c = !1;
        var d = {
            $$typeof: v,
            _currentValue: b,
            _currentValue2: b,
            _defaultValue: b,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _globalName: a
        };
        d.Provider = {
            $$typeof: t,
            _context: d
        };
        Z[a] = d;
    }
    d = Z[a];
    if (d._defaultValue === A) d._defaultValue = b, d._currentValue === A && (d._currentValue = b), d._currentValue2 === A && (d._currentValue2 = b);
    else if (c) throw Error("ServerContext: " + a + " already defined");
    return d;
};
exports.forwardRef = function(a) {
    return {
        $$typeof: w,
        render: a
    };
};
exports.isValidElement = P;
exports.lazy = function(a) {
    return {
        $$typeof: z,
        _payload: {
            _status: -1,
            _result: a
        },
        _init: ba
    };
};
exports.memo = function(a, b) {
    return {
        $$typeof: y,
        type: a,
        compare: void 0 === b ? null : b
    };
};
exports.startTransition = function(a) {
    var b = X.transition;
    X.transition = {};
    try {
        a();
    } finally{
        X.transition = b;
    }
};
exports.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
};
exports.unstable_useCacheRefresh = function() {
    return W.current.useCacheRefresh();
};
exports.use = function(a) {
    return W.current.use(a);
};
exports.useCallback = function(a, b) {
    return W.current.useCallback(a, b);
};
exports.useContext = function(a) {
    return W.current.useContext(a);
};
exports.useDebugValue = function() {};
exports.useDeferredValue = function(a) {
    return W.current.useDeferredValue(a);
};
exports.useEffect = function(a, b) {
    return W.current.useEffect(a, b);
};
exports.useId = function() {
    return W.current.useId();
};
exports.useImperativeHandle = function(a, b, c) {
    return W.current.useImperativeHandle(a, b, c);
};
exports.useInsertionEffect = function(a, b) {
    return W.current.useInsertionEffect(a, b);
};
exports.useLayoutEffect = function(a, b) {
    return W.current.useLayoutEffect(a, b);
};
exports.useMemo = function(a, b) {
    return W.current.useMemo(a, b);
};
exports.useReducer = function(a, b, c) {
    return W.current.useReducer(a, b, c);
};
exports.useRef = function(a) {
    return W.current.useRef(a);
};
exports.useState = function(a) {
    return W.current.useState(a);
};
exports.useSyncExternalStore = function(a, b, c) {
    return W.current.useSyncExternalStore(a, b, c);
};
exports.useTransition = function() {
    return W.current.useTransition();
};
exports.version = "18.3.0-canary-9377e1010-20230712";


/***/ }),

/***/ 32308:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(59984);
} else {}


/***/ }),

/***/ 23212:
/***/ ((module) => {

"use strict";

/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @return {Object} Address object
 */ function _handleAddress(tokens) {
    let token;
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: []
    };
    let i;
    let len;
    // Filter out <addresses>, (comments) and regular text
    for(i = 0, len = tokens.length; i < len; i++){
        token = tokens[i];
        if (token.type === "operator") {
            switch(token.value){
                case "<":
                    state = "address";
                    break;
                case "(":
                    state = "comment";
                    break;
                case ":":
                    state = "group";
                    isGroup = true;
                    break;
                default:
                    state = "text";
            }
        } else if (token.value) {
            if (state === "address") {
                // handle use case where unquoted name includes a "<"
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, "");
            }
            data[state].push(token.value);
        }
    }
    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }
    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(" ");
        addresses.push({
            name: data.text || address && address.name,
            group: data.group.length ? addressparser(data.group.join(",")) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for(i = data.text.length - 1; i >= 0; i--){
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    break;
                }
            }
            let _regexHandler = function(address) {
                if (!data.address.length) {
                    data.address = [
                        address.trim()
                    ];
                    return " ";
                } else {
                    return address;
                }
            };
            // still no address
            if (!data.address.length) {
                for(i = data.text.length - 1; i >= 0; i--){
                    // fixed the regex to parse email address correctly when email address has more than one @
                    data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                    if (data.address.length) {
                        break;
                    }
                }
            }
        }
        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }
        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }
        // Join values with spaces
        data.text = data.text.join(" ");
        data.address = data.address.join(" ");
        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || "",
                name: data.text || data.address || ""
            };
            if (address.address === address.name) {
                if ((address.address || "").match(/@/)) {
                    address.name = "";
                } else {
                    address.address = "";
                }
            }
            addresses.push(address);
        }
    }
    return addresses;
}
/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */ class Tokenizer {
    constructor(str){
        this.str = (str || "").toString();
        this.operatorCurrent = "";
        this.operatorExpecting = "";
        this.node = null;
        this.escaped = false;
        this.list = [];
        /**
         * Operator tokens and which tokens are expected to end the sequence
         */ this.operators = {
            '"': '"',
            "(": ")",
            "<": ">",
            ",": "",
            ":": ";",
            // Semicolons are not a legal delimiter per the RFC2822 grammar other
            // than for terminating a group, but they are also not valid for any
            // other use in this context.  Given that some mail clients have
            // historically allowed the semicolon as a delimiter equivalent to the
            // comma in their UI, it makes sense to treat them the same as a comma
            // when used outside of a group.
            ";": ""
        };
    }
    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */ tokenize() {
        let chr, list = [];
        for(let i = 0, len = this.str.length; i < len; i++){
            chr = this.str.charAt(i);
            this.checkChar(chr);
        }
        this.list.forEach((node)=>{
            node.value = (node.value || "").toString().trim();
            if (node.value) {
                list.push(node);
            }
        });
        return list;
    }
    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */ checkChar(chr) {
        if (this.escaped) {
        // ignore next condition blocks
        } else if (chr === this.operatorExpecting) {
            this.node = {
                type: "operator",
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = "";
            this.escaped = false;
            return;
        } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
                type: "operator",
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
        } else if ([
            '"',
            "'"
        ].includes(this.operatorExpecting) && chr === "\\") {
            this.escaped = true;
            return;
        }
        if (!this.node) {
            this.node = {
                type: "text",
                value: ""
            };
            this.list.push(this.node);
        }
        if (chr === "\n") {
            // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
            // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
            chr = " ";
        }
        if (chr.charCodeAt(0) >= 0x21 || [
            " ",
            "	"
        ].includes(chr)) {
            // skip command bytes
            this.node.value += chr;
        }
        this.escaped = false;
    }
}
/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @return {Array} An array of address objects
 */ function addressparser(str, options) {
    options = options || {};
    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token)=>{
        if (token.type === "operator" && (token.value === "," || token.value === ";")) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });
    if (address.length) {
        addresses.push(address);
    }
    addresses.forEach((address)=>{
        address = _handleAddress(address);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });
    if (options.flatten) {
        let addresses = [];
        let walkAddressList = (list)=>{
            list.forEach((address)=>{
                if (address.group) {
                    return walkAddressList(address.group);
                } else {
                    addresses.push(address);
                }
            });
        };
        walkAddressList(parsedAddresses);
        return addresses;
    }
    return parsedAddresses;
}
// expose to the world
module.exports = addressparser;


/***/ }),

/***/ 2553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * Encodes a Buffer into a base64 encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} base64 encoded string
 */ function encode(buffer) {
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
    }
    return buffer.toString("base64");
}
/**
 * Adds soft line breaks to a base64 string
 *
 * @param {String} str base64 encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped base64 encoded string
 */ function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
        return str;
    }
    let result = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while(pos < str.length){
        let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
        result.push(wrappedLines);
        pos += chunkLength;
    }
    return result.join("\r\n").trim();
}
/**
 * Creates a transform stream for encoding data to base64 encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */ class Encoder extends Transform {
    constructor(options){
        super();
        // init Transform
        this.options = options || {};
        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this._remainingBytes = false;
        this.inputBytes = 0;
        this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
        if (encoding !== "buffer") {
            chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
            return setImmediate(done);
        }
        this.inputBytes += chunk.length;
        if (this._remainingBytes && this._remainingBytes.length) {
            chunk = Buffer.concat([
                this._remainingBytes,
                chunk
            ], this._remainingBytes.length + chunk.length);
            this._remainingBytes = false;
        }
        if (chunk.length % 3) {
            this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
            chunk = chunk.slice(0, chunk.length - chunk.length % 3);
        } else {
            this._remainingBytes = false;
        }
        let b64 = this._curLine + encode(chunk);
        if (this.options.lineLength) {
            b64 = wrap(b64, this.options.lineLength);
            // remove last line as it is still most probably incomplete
            let lastLF = b64.lastIndexOf("\n");
            if (lastLF < 0) {
                this._curLine = b64;
                b64 = "";
            } else if (lastLF === b64.length - 1) {
                this._curLine = "";
            } else {
                this._curLine = b64.substr(lastLF + 1);
                b64 = b64.substr(0, lastLF + 1);
            }
        }
        if (b64) {
            this.outputBytes += b64.length;
            this.push(Buffer.from(b64, "ascii"));
        }
        setImmediate(done);
    }
    _flush(done) {
        if (this._remainingBytes && this._remainingBytes.length) {
            this._curLine += encode(this._remainingBytes);
        }
        if (this._curLine) {
            this._curLine = wrap(this._curLine, this.options.lineLength);
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, "ascii");
            this._curLine = "";
        }
        done();
    }
}
// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 35767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// FIXME:
// replace this Transform mess with a method that pipes input argument to output argument
const MessageParser = __webpack_require__(86948);
const RelaxedBody = __webpack_require__(69154);
const sign = __webpack_require__(27899);
const PassThrough = (__webpack_require__(12781).PassThrough);
const fs = __webpack_require__(57147);
const path = __webpack_require__(71017);
const crypto = __webpack_require__(6113);
const DKIM_ALGO = "sha256";
const MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk
/*
// Usage:

let dkim = new DKIM({
    domainName: 'example.com',
    keySelector: 'key-selector',
    privateKey,
    cacheDir: '/tmp'
});
dkim.sign(input).pipe(process.stdout);

// Where inputStream is a rfc822 message (either a stream, string or Buffer)
// and outputStream is a DKIM signed rfc822 message
*/ class DKIMSigner {
    constructor(options, keys, input, output){
        this.options = options || {};
        this.keys = keys;
        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
        this.cacheDir = this.options.cacheDir || false;
        this.chunks = [];
        this.chunklen = 0;
        this.readPos = 0;
        this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto.randomBytes(14).toString("hex")) : false;
        this.cache = false;
        this.headers = false;
        this.bodyHash = false;
        this.parser = false;
        this.relaxedBody = false;
        this.input = input;
        this.output = output;
        this.output.usingCache = false;
        this.hasErrored = false;
        this.input.on("error", (err)=>{
            this.hasErrored = true;
            this.cleanup();
            output.emit("error", err);
        });
    }
    cleanup() {
        if (!this.cache || !this.cachePath) {
            return;
        }
        fs.unlink(this.cachePath, ()=>false);
    }
    createReadCache() {
        // pipe remainings to cache file
        this.cache = fs.createReadStream(this.cachePath);
        this.cache.once("error", (err)=>{
            this.cleanup();
            this.output.emit("error", err);
        });
        this.cache.once("close", ()=>{
            this.cleanup();
        });
        this.cache.pipe(this.output);
    }
    sendNextChunk() {
        if (this.hasErrored) {
            return;
        }
        if (this.readPos >= this.chunks.length) {
            if (!this.cache) {
                return this.output.end();
            }
            return this.createReadCache();
        }
        let chunk = this.chunks[this.readPos++];
        if (this.output.write(chunk) === false) {
            return this.output.once("drain", ()=>{
                this.sendNextChunk();
            });
        }
        setImmediate(()=>this.sendNextChunk());
    }
    sendSignedOutput() {
        let keyPos = 0;
        let signNextKey = ()=>{
            if (keyPos >= this.keys.length) {
                this.output.write(this.parser.rawHeaders);
                return setImmediate(()=>this.sendNextChunk());
            }
            let key = this.keys[keyPos++];
            let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
                domainName: key.domainName,
                keySelector: key.keySelector,
                privateKey: key.privateKey,
                headerFieldNames: this.options.headerFieldNames,
                skipFields: this.options.skipFields
            });
            if (dkimField) {
                this.output.write(Buffer.from(dkimField + "\r\n"));
            }
            return setImmediate(signNextKey);
        };
        if (this.bodyHash && this.headers) {
            return signNextKey();
        }
        this.output.write(this.parser.rawHeaders);
        this.sendNextChunk();
    }
    createWriteCache() {
        this.output.usingCache = true;
        // pipe remainings to cache file
        this.cache = fs.createWriteStream(this.cachePath);
        this.cache.once("error", (err)=>{
            this.cleanup();
            // drain input
            this.relaxedBody.unpipe(this.cache);
            this.relaxedBody.on("readable", ()=>{
                while(this.relaxedBody.read() !== null){
                // do nothing
                }
            });
            this.hasErrored = true;
            // emit error
            this.output.emit("error", err);
        });
        this.cache.once("close", ()=>{
            this.sendSignedOutput();
        });
        this.relaxedBody.removeAllListeners("readable");
        this.relaxedBody.pipe(this.cache);
    }
    signStream() {
        this.parser = new MessageParser();
        this.relaxedBody = new RelaxedBody({
            hashAlgo: this.hashAlgo
        });
        this.parser.on("headers", (value)=>{
            this.headers = value;
        });
        this.relaxedBody.on("hash", (value)=>{
            this.bodyHash = value;
        });
        this.relaxedBody.on("readable", ()=>{
            let chunk;
            if (this.cache) {
                return;
            }
            while((chunk = this.relaxedBody.read()) !== null){
                this.chunks.push(chunk);
                this.chunklen += chunk.length;
                if (this.chunklen >= this.cacheTreshold && this.cachePath) {
                    return this.createWriteCache();
                }
            }
        });
        this.relaxedBody.on("end", ()=>{
            if (this.cache) {
                return;
            }
            this.sendSignedOutput();
        });
        this.parser.pipe(this.relaxedBody);
        setImmediate(()=>this.input.pipe(this.parser));
    }
}
class DKIM {
    constructor(options){
        this.options = options || {};
        this.keys = [].concat(this.options.keys || {
            domainName: options.domainName,
            keySelector: options.keySelector,
            privateKey: options.privateKey
        });
    }
    sign(input, extraOptions) {
        let output = new PassThrough();
        let inputStream = input;
        let writeValue = false;
        if (Buffer.isBuffer(input)) {
            writeValue = input;
            inputStream = new PassThrough();
        } else if (typeof input === "string") {
            writeValue = Buffer.from(input);
            inputStream = new PassThrough();
        }
        let options = this.options;
        if (extraOptions && Object.keys(extraOptions).length) {
            options = {};
            Object.keys(this.options || {}).forEach((key)=>{
                options[key] = this.options[key];
            });
            Object.keys(extraOptions || {}).forEach((key)=>{
                if (!(key in options)) {
                    options[key] = extraOptions[key];
                }
            });
        }
        let signer = new DKIMSigner(options, this.keys, inputStream, output);
        setImmediate(()=>{
            signer.signStream();
            if (writeValue) {
                setImmediate(()=>{
                    inputStream.end(writeValue);
                });
            }
        });
        return output;
    }
}
module.exports = DKIM;


/***/ }),

/***/ 86948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * MessageParser instance is a transform stream that separates message headers
 * from the rest of the body. Headers are emitted with the 'headers' event. Message
 * body is passed on as the resulting stream.
 */ class MessageParser extends Transform {
    constructor(options){
        super(options);
        this.lastBytes = Buffer.alloc(4);
        this.headersParsed = false;
        this.headerBytes = 0;
        this.headerChunks = [];
        this.rawHeaders = false;
        this.bodySize = 0;
    }
    /**
     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
     *
     * @param {Buffer} data Next data chunk from the stream
     */ updateLastBytes(data) {
        let lblen = this.lastBytes.length;
        let nblen = Math.min(data.length, lblen);
        // shift existing bytes
        for(let i = 0, len = lblen - nblen; i < len; i++){
            this.lastBytes[i] = this.lastBytes[i + nblen];
        }
        // add new bytes
        for(let i = 1; i <= nblen; i++){
            this.lastBytes[lblen - i] = data[data.length - i];
        }
    }
    /**
     * Finds and removes message headers from the remaining body. We want to keep
     * headers separated until final delivery to be able to modify these
     *
     * @param {Buffer} data Next chunk of data
     * @return {Boolean} Returns true if headers are already found or false otherwise
     */ checkHeaders(data) {
        if (this.headersParsed) {
            return true;
        }
        let lblen = this.lastBytes.length;
        let headerPos = 0;
        this.curLinePos = 0;
        for(let i = 0, len = this.lastBytes.length + data.length; i < len; i++){
            let chr;
            if (i < lblen) {
                chr = this.lastBytes[i];
            } else {
                chr = data[i - lblen];
            }
            if (chr === 0x0a && i) {
                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
                let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
                if (pr1 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                } else if (pr1 === 0x0d && pr2 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                }
            }
        }
        if (this.headersParsed) {
            this.headerChunks.push(data.slice(0, headerPos));
            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
            this.headerChunks = null;
            this.emit("headers", this.parseHeaders());
            if (data.length - 1 > headerPos) {
                let chunk = data.slice(headerPos);
                this.bodySize += chunk.length;
                // this would be the first chunk of data sent downstream
                setImmediate(()=>this.push(chunk));
            }
            return false;
        } else {
            this.headerBytes += data.length;
            this.headerChunks.push(data);
        }
        // store last 4 bytes to catch header break
        this.updateLastBytes(data);
        return false;
    }
    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
        }
        let headersFound;
        try {
            headersFound = this.checkHeaders(chunk);
        } catch (E) {
            return callback(E);
        }
        if (headersFound) {
            this.bodySize += chunk.length;
            this.push(chunk);
        }
        setImmediate(callback);
    }
    _flush(callback) {
        if (this.headerChunks) {
            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
            this.bodySize += chunk.length;
            this.push(chunk);
            this.headerChunks = null;
        }
        callback();
    }
    parseHeaders() {
        let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
        for(let i = lines.length - 1; i > 0; i--){
            if (/^\s/.test(lines[i])) {
                lines[i - 1] += "\n" + lines[i];
                lines.splice(i, 1);
            }
        }
        return lines.filter((line)=>line.trim()).map((line)=>({
                key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
                line
            }));
    }
}
module.exports = MessageParser;


/***/ }),

/***/ 69154:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// streams through a message body and calculates relaxed body hash
const Transform = (__webpack_require__(12781).Transform);
const crypto = __webpack_require__(6113);
class RelaxedBody extends Transform {
    constructor(options){
        super();
        options = options || {};
        this.chunkBuffer = [];
        this.chunkBufferLen = 0;
        this.bodyHash = crypto.createHash(options.hashAlgo || "sha1");
        this.remainder = "";
        this.byteLength = 0;
        this.debug = options.debug;
        this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
        let bodyStr;
        // find next remainder
        let nextRemainder = "";
        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line
        // If we get another chunk that does not match this description then we can restore the previously processed data
        let state = "file";
        for(let i = chunk.length - 1; i >= 0; i--){
            let c = chunk[i];
            if (state === "file" && (c === 0x0a || c === 0x0d)) {
            // do nothing, found \n or \r at the end of chunk, stil end of file
            } else if (state === "file" && (c === 0x09 || c === 0x20)) {
                // switch to line ending mode, this is the last non-empty line
                state = "line";
            } else if (state === "line" && (c === 0x09 || c === 0x20)) {
            // do nothing, found ' ' or \t at the end of line, keep processing the last non-empty line
            } else if (state === "file" || state === "line") {
                // non line/file ending character found, switch to body mode
                state = "body";
                if (i === chunk.length - 1) {
                    break;
                }
            }
            if (i === 0) {
                // reached to the beginning of the chunk, check if it is still about the ending
                // and if the remainder also matches
                if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
                    // keep everything
                    this.remainder += chunk.toString("binary");
                    return;
                } else if (state === "line" || state === "file") {
                    // process existing remainder as normal line but store the current chunk
                    nextRemainder = chunk.toString("binary");
                    chunk = false;
                    break;
                }
            }
            if (state !== "body") {
                continue;
            }
            // reached first non ending byte
            nextRemainder = chunk.slice(i + 1).toString("binary");
            chunk = chunk.slice(0, i + 1);
            break;
        }
        let needsFixing = !!this.remainder;
        if (chunk && !needsFixing) {
            // check if we even need to change anything
            for(let i = 0, len = chunk.length; i < len; i++){
                if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {
                    // missing \r before \n
                    needsFixing = true;
                    break;
                } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {
                    // trailing WSP found
                    needsFixing = true;
                    break;
                } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {
                    // multiple spaces found, needs to be replaced with just one
                    needsFixing = true;
                    break;
                } else if (chunk[i] === 0x09) {
                    // TAB found, needs to be replaced with a space
                    needsFixing = true;
                    break;
                }
            }
        }
        if (needsFixing) {
            bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
            this.remainder = nextRemainder;
            bodyStr = bodyStr.replace(/\r?\n/g, "\n") // use js line endings
            .replace(/[ \t]*$/gm, "") // remove line endings, rtrim
            .replace(/[ \t]+/gm, " ") // single spaces
            .replace(/\n/g, "\r\n"); // restore rfc822 line endings
            chunk = Buffer.from(bodyStr, "binary");
        } else if (nextRemainder) {
            this.remainder = nextRemainder;
        }
        if (this.debug) {
            this._debugBody.push(chunk);
        }
        this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
        }
        this.updateHash(chunk);
        this.byteLength += chunk.length;
        this.push(chunk);
        callback();
    }
    _flush(callback) {
        // generate final hash and emit it
        if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
            // add terminating line end
            this.bodyHash.update(Buffer.from("\r\n"));
        }
        if (!this.byteLength) {
            // emit empty line buffer to keep the stream flowing
            this.push(Buffer.from("\r\n"));
        // this.bodyHash.update(Buffer.from('\r\n'));
        }
        this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
        callback();
    }
}
module.exports = RelaxedBody;


/***/ }),

/***/ 27899:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const punycode = __webpack_require__(71415);
const mimeFuncs = __webpack_require__(41552);
const crypto = __webpack_require__(6113);
/**
 * Returns DKIM signature header line
 *
 * @param {Object} headers Parsed headers object from MessageParser
 * @param {String} bodyHash Base64 encoded hash of the message
 * @param {Object} options DKIM options
 * @param {String} options.domainName Domain name to be signed for
 * @param {String} options.keySelector DKIM key selector to use
 * @param {String} options.privateKey DKIM private key to use
 * @return {String} Complete header line
 */ module.exports = (headers, hashAlgo, bodyHash, options)=>{
    options = options || {};
    // all listed fields from RFC4871 #5.5
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:" + "Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:" + "Content-Description:Resent-Date:Resent-From:Resent-Sender:" + "Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:" + "List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:" + "List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
        signature = signer.sign(options.privateKey, "base64");
    } catch (E) {
        return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
};
module.exports.relaxedHeaders = relaxedHeaders;
function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
        "v=1",
        "a=rsa-" + hashAlgo,
        "c=relaxed/relaxed",
        "d=" + punycode.toASCII(domainName),
        "q=dns/txt",
        "s=" + keySelector,
        "bh=" + bodyHash,
        "h=" + fieldNames
    ].join("; ");
    return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
}
function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = new Set();
    let skip = new Set();
    let headerFields = new Map();
    (skipFields || "").toLowerCase().split(":").forEach((field)=>{
        skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field)=>!skip.has(field.trim())).forEach((field)=>{
        includedFields.add(field.trim());
    });
    for(let i = headers.length - 1; i >= 0; i--){
        let line = headers[i];
        // only include the first value from bottom to top
        if (includedFields.has(line.key) && !headerFields.has(line.key)) {
            headerFields.set(line.key, relaxedHeaderLine(line.line));
        }
    }
    let headersList = [];
    let fields = [];
    includedFields.forEach((field)=>{
        if (headerFields.has(field)) {
            fields.push(field);
            headersList.push(field + ":" + headerFields.get(field));
        }
    });
    return {
        headers: headersList.join("\r\n") + "\r\n",
        fieldNames: fields.join(":")
    };
}
function relaxedHeaderLine(line) {
    return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
}


/***/ }),

/***/ 56709:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// module to handle cookies
const urllib = __webpack_require__(57310);
const SESSION_TIMEOUT = 1800; // 30 min
/**
 * Creates a biskviit cookie jar for managing cookie values in memory
 *
 * @constructor
 * @param {Object} [options] Optional options object
 */ class Cookies {
    constructor(options){
        this.options = options || {};
        this.cookies = [];
    }
    /**
     * Stores a cookie string to the cookie storage
     *
     * @param {String} cookieStr Value from the 'Set-Cookie:' header
     * @param {String} url Current URL
     */ set(cookieStr, url) {
        let urlparts = urllib.parse(url || "");
        let cookie = this.parse(cookieStr);
        let domain;
        if (cookie.domain) {
            domain = cookie.domain.replace(/^\./, "");
            // do not allow cross origin cookies
            if (// can't be valid if the requested domain is shorter than current hostname
            urlparts.hostname.length < domain.length || // prefix domains with dot to be sure that partial matches are not used
            ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain) {
                cookie.domain = urlparts.hostname;
            }
        } else {
            cookie.domain = urlparts.hostname;
        }
        if (!cookie.path) {
            cookie.path = this.getPath(urlparts.pathname);
        }
        // if no expire date, then use sessionTimeout value
        if (!cookie.expires) {
            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
        }
        return this.add(cookie);
    }
    /**
     * Returns cookie string for the 'Cookie:' header.
     *
     * @param {String} url URL to check for
     * @returns {String} Cookie header or empty string if no matches were found
     */ get(url) {
        return this.list(url).map((cookie)=>cookie.name + "=" + cookie.value).join("; ");
    }
    /**
     * Lists all valied cookie objects for the specified URL
     *
     * @param {String} url URL to check for
     * @returns {Array} An array of cookie objects
     */ list(url) {
        let result = [];
        let i;
        let cookie;
        for(i = this.cookies.length - 1; i >= 0; i--){
            cookie = this.cookies[i];
            if (this.isExpired(cookie)) {
                this.cookies.splice(i, i);
                continue;
            }
            if (this.match(cookie, url)) {
                result.unshift(cookie);
            }
        }
        return result;
    }
    /**
     * Parses cookie string from the 'Set-Cookie:' header
     *
     * @param {String} cookieStr String from the 'Set-Cookie:' header
     * @returns {Object} Cookie object
     */ parse(cookieStr) {
        let cookie = {};
        (cookieStr || "").toString().split(";").forEach((cookiePart)=>{
            let valueParts = cookiePart.split("=");
            let key = valueParts.shift().trim().toLowerCase();
            let value = valueParts.join("=").trim();
            let domain;
            if (!key) {
                // skip empty parts
                return;
            }
            switch(key){
                case "expires":
                    value = new Date(value);
                    // ignore date if can not parse it
                    if (value.toString() !== "Invalid Date") {
                        cookie.expires = value;
                    }
                    break;
                case "path":
                    cookie.path = value;
                    break;
                case "domain":
                    domain = value.toLowerCase();
                    if (domain.length && domain.charAt(0) !== ".") {
                        domain = "." + domain; // ensure preceeding dot for user set domains
                    }
                    cookie.domain = domain;
                    break;
                case "max-age":
                    cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                    break;
                case "secure":
                    cookie.secure = true;
                    break;
                case "httponly":
                    cookie.httponly = true;
                    break;
                default:
                    if (!cookie.name) {
                        cookie.name = key;
                        cookie.value = value;
                    }
            }
        });
        return cookie;
    }
    /**
     * Checks if a cookie object is valid for a specified URL
     *
     * @param {Object} cookie Cookie object
     * @param {String} url URL to check for
     * @returns {Boolean} true if cookie is valid for specifiec URL
     */ match(cookie, url) {
        let urlparts = urllib.parse(url || "");
        // check if hostname matches
        // .foo.com also matches subdomains, foo.com does not
        if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
            return false;
        }
        // check if path matches
        let path = this.getPath(urlparts.pathname);
        if (path.substr(0, cookie.path.length) !== cookie.path) {
            return false;
        }
        // check secure argument
        if (cookie.secure && urlparts.protocol !== "https:") {
            return false;
        }
        return true;
    }
    /**
     * Adds (or updates/removes if needed) a cookie object to the cookie storage
     *
     * @param {Object} cookie Cookie value to be stored
     */ add(cookie) {
        let i;
        let len;
        // nothing to do here
        if (!cookie || !cookie.name) {
            return false;
        }
        // overwrite if has same params
        for(i = 0, len = this.cookies.length; i < len; i++){
            if (this.compare(this.cookies[i], cookie)) {
                // check if the cookie needs to be removed instead
                if (this.isExpired(cookie)) {
                    this.cookies.splice(i, 1); // remove expired/unset cookie
                    return false;
                }
                this.cookies[i] = cookie;
                return true;
            }
        }
        // add as new if not already expired
        if (!this.isExpired(cookie)) {
            this.cookies.push(cookie);
        }
        return true;
    }
    /**
     * Checks if two cookie objects are the same
     *
     * @param {Object} a Cookie to check against
     * @param {Object} b Cookie to check against
     * @returns {Boolean} True, if the cookies are the same
     */ compare(a, b) {
        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
    }
    /**
     * Checks if a cookie is expired
     *
     * @param {Object} cookie Cookie object to check against
     * @returns {Boolean} True, if the cookie is expired
     */ isExpired(cookie) {
        return cookie.expires && cookie.expires < new Date() || !cookie.value;
    }
    /**
     * Returns normalized cookie path for an URL path argument
     *
     * @param {String} pathname
     * @returns {String} Normalized path
     */ getPath(pathname) {
        let path = (pathname || "/").split("/");
        path.pop(); // remove filename part
        path = path.join("/").trim();
        // ensure path prefix /
        if (path.charAt(0) !== "/") {
            path = "/" + path;
        }
        // ensure path suffix /
        if (path.substr(-1) !== "/") {
            path += "/";
        }
        return path;
    }
}
module.exports = Cookies;


/***/ }),

/***/ 99075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http = __webpack_require__(13685);
const https = __webpack_require__(95687);
const urllib = __webpack_require__(57310);
const zlib = __webpack_require__(59796);
const PassThrough = (__webpack_require__(12781).PassThrough);
const Cookies = __webpack_require__(56709);
const packageData = __webpack_require__(60983);
const net = __webpack_require__(41808);
const MAX_REDIRECTS = 5;
module.exports = function(url, options) {
    return nmfetch(url, options);
};
module.exports.Cookies = Cookies;
function nmfetch(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
        [].concat(options.cookie || []).forEach((cookie)=>{
            options.cookies.set(cookie, url);
        });
        options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies;
    let body;
    let handler = parsed.protocol === "https:" ? https : http;
    let headers = {
        "accept-encoding": "gzip,deflate",
        "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key)=>{
        headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
        headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
        headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies = options.cookies.get(url)) {
        headers.cookie = cookies;
    }
    if (options.body) {
        if (options.contentType !== false) {
            headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        }
        if (typeof options.body.pipe === "function") {
            // it's a stream
            headers["Transfer-Encoding"] = "chunked";
            body = options.body;
            body.on("error", (err)=>{
                if (finished) {
                    return;
                }
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
            });
        } else {
            if (options.body instanceof Buffer) {
                body = options.body;
            } else if (typeof options.body === "object") {
                try {
                    // encodeURIComponent can fail on invalid input (partial emoji etc.)
                    body = Buffer.from(Object.keys(options.body).map((key)=>{
                        let value = options.body[key].toString().trim();
                        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
                    }).join("&"));
                } catch (E) {
                    if (finished) {
                        return;
                    }
                    finished = true;
                    E.type = "FETCH";
                    E.sourceUrl = url;
                    fetchRes.emit("error", E);
                    return;
                }
            } else {
                body = Buffer.from(options.body.toString().trim());
            }
            headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
            headers["Content-Length"] = body.length;
        }
        // if method is not provided, use POST instead of GET
        method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req;
    let reqOptions = {
        method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
        headers,
        rejectUnauthorized: false,
        agent: false
    };
    if (options.tls) {
        Object.keys(options.tls).forEach((key)=>{
            reqOptions[key] = options.tls[key];
        });
    }
    if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {
        reqOptions.servername = parsed.hostname;
    }
    try {
        req = handler.request(reqOptions);
    } catch (E) {
        finished = true;
        setImmediate(()=>{
            E.type = "FETCH";
            E.sourceUrl = url;
            fetchRes.emit("error", E);
        });
        return fetchRes;
    }
    if (options.timeout) {
        req.setTimeout(options.timeout, ()=>{
            if (finished) {
                return;
            }
            finished = true;
            req.abort();
            let err = new Error("Request Timeout");
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
        });
    }
    req.on("error", (err)=>{
        if (finished) {
            return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
    });
    req.on("response", (res)=>{
        let inflate;
        if (finished) {
            return;
        }
        switch(res.headers["content-encoding"]){
            case "gzip":
            case "deflate":
                inflate = zlib.createUnzip();
                break;
        }
        if (res.headers["set-cookie"]) {
            [].concat(res.headers["set-cookie"] || []).forEach((cookie)=>{
                options.cookies.set(cookie, url);
            });
        }
        if ([
            301,
            302,
            303,
            307,
            308
        ].includes(res.statusCode) && res.headers.location) {
            // redirect
            options.redirects++;
            if (options.redirects > options.maxRedirects) {
                finished = true;
                let err = new Error("Maximum redirect count exceeded");
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                req.abort();
                return;
            }
            // redirect does not include POST body
            options.method = "GET";
            options.body = false;
            return nmfetch(urllib.resolve(url, res.headers.location), options);
        }
        fetchRes.statusCode = res.statusCode;
        fetchRes.headers = res.headers;
        if (res.statusCode >= 300 && !options.allowErrorResponse) {
            finished = true;
            let err = new Error("Invalid status code " + res.statusCode);
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            req.abort();
            return;
        }
        res.on("error", (err)=>{
            if (finished) {
                return;
            }
            finished = true;
            err.type = "FETCH";
            err.sourceUrl = url;
            fetchRes.emit("error", err);
            req.abort();
        });
        if (inflate) {
            res.pipe(inflate).pipe(fetchRes);
            inflate.on("error", (err)=>{
                if (finished) {
                    return;
                }
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                req.abort();
            });
        } else {
            res.pipe(fetchRes);
        }
    });
    setImmediate(()=>{
        if (body) {
            try {
                if (typeof body.pipe === "function") {
                    return body.pipe(req);
                } else {
                    req.write(body);
                }
            } catch (err) {
                finished = true;
                err.type = "FETCH";
                err.sourceUrl = url;
                fetchRes.emit("error", err);
                return;
            }
        }
        req.end();
    });
    return fetchRes;
}


/***/ }),

/***/ 9413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageData = __webpack_require__(60983);
const shared = __webpack_require__(33050);
/**
 * Generates a Transport object to generate JSON output
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class JSONTransport {
    constructor(options){
        options = options || {};
        this.options = options || {};
        this.name = "JSONTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "json-transport"
        });
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Composing JSON structure of %s to <%s>", messageId, recipients.join(", "));
        setImmediate(()=>{
            mail.normalize((err, data)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed building JSON structure for %s. %s", messageId, err.message);
                    return done(err);
                }
                delete data.envelope;
                delete data.normalizedHeaders;
                return done(null, {
                    envelope,
                    messageId,
                    message: this.options.skipEncoding ? data : JSON.stringify(data)
                });
            });
        });
    }
}
module.exports = JSONTransport;


/***/ }),

/***/ 79804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */ 
const MimeNode = __webpack_require__(47419);
const mimeFuncs = __webpack_require__(41552);
const parseDataURI = (__webpack_require__(33050).parseDataURI);
/**
 * Creates the object for composing a MimeNode instance out from the mail options
 *
 * @constructor
 * @param {Object} mail Mail options
 */ class MailComposer {
    constructor(mail){
        this.mail = mail || {};
        this.message = false;
    }
    /**
     * Builds MimeNode instance
     */ compile() {
        this._alternatives = this.getAlternatives();
        this._htmlNode = this._alternatives.filter((alternative)=>/^text\/html\b/i.test(alternative.contentType)).pop();
        this._attachments = this.getAttachments(!!this._htmlNode);
        this._useRelated = !!(this._htmlNode && this._attachments.related.length);
        this._useAlternative = this._alternatives.length > 1;
        this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
        // Compose MIME tree
        if (this.mail.raw) {
            this.message = new MimeNode("message/rfc822", {
                newline: this.mail.newline
            }).setRaw(this.mail.raw);
        } else if (this._useMixed) {
            this.message = this._createMixed();
        } else if (this._useAlternative) {
            this.message = this._createAlternative();
        } else if (this._useRelated) {
            this.message = this._createRelated();
        } else {
            this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
                contentType: "text/plain",
                content: ""
            });
        }
        // Add custom headers
        if (this.mail.headers) {
            this.message.addHeader(this.mail.headers);
        }
        // Add headers to the root node, always overrides custom headers
        [
            "from",
            "sender",
            "to",
            "cc",
            "bcc",
            "reply-to",
            "in-reply-to",
            "references",
            "subject",
            "message-id",
            "date"
        ].forEach((header)=>{
            let key = header.replace(/-(\w)/g, (o, c)=>c.toUpperCase());
            if (this.mail[key]) {
                this.message.setHeader(header, this.mail[key]);
            }
        });
        // Sets custom envelope
        if (this.mail.envelope) {
            this.message.setEnvelope(this.mail.envelope);
        }
        // ensure Message-Id value
        this.message.messageId();
        return this.message;
    }
    /**
     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
     *
     * @param {Boolean} findRelated If true separate related attachments from attached ones
     * @returns {Object} An object of arrays (`related` and `attached`)
     */ getAttachments(findRelated) {
        let icalEvent, eventObject;
        let attachments = [].concat(this.mail.attachments || []).map((attachment, i)=>{
            let data;
            let isMessageNode = /^message\//i.test(attachment.contentType);
            if (/^data:/i.test(attachment.path || attachment.href)) {
                attachment = this._processDataUrl(attachment);
            }
            let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
            let isImage = /^image\//i.test(contentType);
            let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
            data = {
                contentType,
                contentDisposition,
                contentTransferEncoding: "contentTransferEncoding" in attachment ? attachment.contentTransferEncoding : "base64"
            };
            if (attachment.filename) {
                data.filename = attachment.filename;
            } else if (!isMessageNode && attachment.filename !== false) {
                data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
                if (data.filename.indexOf(".") < 0) {
                    data.filename += "." + mimeFuncs.detectExtension(data.contentType);
                }
            }
            if (/^https?:\/\//i.test(attachment.path)) {
                attachment.href = attachment.path;
                attachment.path = undefined;
            }
            if (attachment.cid) {
                data.cid = attachment.cid;
            }
            if (attachment.raw) {
                data.raw = attachment.raw;
            } else if (attachment.path) {
                data.content = {
                    path: attachment.path
                };
            } else if (attachment.href) {
                data.content = {
                    href: attachment.href,
                    httpHeaders: attachment.httpHeaders
                };
            } else {
                data.content = attachment.content || "";
            }
            if (attachment.encoding) {
                data.encoding = attachment.encoding;
            }
            if (attachment.headers) {
                data.headers = attachment.headers;
            }
            return data;
        });
        if (this.mail.icalEvent) {
            if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }
            eventObject = {};
            Object.keys(icalEvent).forEach((key)=>{
                eventObject[key] = icalEvent[key];
            });
            eventObject.contentType = "application/ics";
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
            eventObject.filename = eventObject.filename || "invite.ics";
            eventObject.headers["Content-Disposition"] = "attachment";
            eventObject.headers["Content-Transfer-Encoding"] = "base64";
        }
        if (!findRelated) {
            return {
                attached: attachments.concat(eventObject || []),
                related: []
            };
        } else {
            return {
                attached: attachments.filter((attachment)=>!attachment.cid).concat(eventObject || []),
                related: attachments.filter((attachment)=>!!attachment.cid)
            };
        }
    }
    /**
     * List alternatives. Resulting objects can be used as input for MimeNode nodes
     *
     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
     */ getAlternatives() {
        let alternatives = [], text, html, watchHtml, amp, icalEvent, eventObject;
        if (this.mail.text) {
            if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
                text = this.mail.text;
            } else {
                text = {
                    content: this.mail.text
                };
            }
            text.contentType = "text/plain; charset=utf-8";
        }
        if (this.mail.watchHtml) {
            if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
                watchHtml = this.mail.watchHtml;
            } else {
                watchHtml = {
                    content: this.mail.watchHtml
                };
            }
            watchHtml.contentType = "text/watch-html; charset=utf-8";
        }
        if (this.mail.amp) {
            if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
                amp = this.mail.amp;
            } else {
                amp = {
                    content: this.mail.amp
                };
            }
            amp.contentType = "text/x-amp-html; charset=utf-8";
        }
        // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients
        if (this.mail.icalEvent) {
            if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }
            eventObject = {};
            Object.keys(icalEvent).forEach((key)=>{
                eventObject[key] = icalEvent[key];
            });
            if (eventObject.content && typeof eventObject.content === "object") {
                // we are going to have the same attachment twice, so mark this to be
                // resolved just once
                eventObject.content._resolve = true;
            }
            eventObject.filename = false;
            eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
        }
        if (this.mail.html) {
            if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
                html = this.mail.html;
            } else {
                html = {
                    content: this.mail.html
                };
            }
            html.contentType = "text/html; charset=utf-8";
        }
        [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative)=>{
            let data;
            if (/^data:/i.test(alternative.path || alternative.href)) {
                alternative = this._processDataUrl(alternative);
            }
            data = {
                contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
                contentTransferEncoding: alternative.contentTransferEncoding
            };
            if (alternative.filename) {
                data.filename = alternative.filename;
            }
            if (/^https?:\/\//i.test(alternative.path)) {
                alternative.href = alternative.path;
                alternative.path = undefined;
            }
            if (alternative.raw) {
                data.raw = alternative.raw;
            } else if (alternative.path) {
                data.content = {
                    path: alternative.path
                };
            } else if (alternative.href) {
                data.content = {
                    href: alternative.href
                };
            } else {
                data.content = alternative.content || "";
            }
            if (alternative.encoding) {
                data.encoding = alternative.encoding;
            }
            if (alternative.headers) {
                data.headers = alternative.headers;
            }
            alternatives.push(data);
        });
        return alternatives;
    }
    /**
     * Builds multipart/mixed node. It should always contain different type of elements on the same level
     * eg. text + attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createMixed(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode("multipart/mixed", {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild("multipart/mixed", {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        if (this._useAlternative) {
            this._createAlternative(node);
        } else if (this._useRelated) {
            this._createRelated(node);
        }
        [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element)=>{
            // if the element is a html node from related subpart then ignore it
            if (!this._useRelated || element !== this._htmlNode) {
                this._createContentNode(node, element);
            }
        });
        return node;
    }
    /**
     * Builds multipart/alternative node. It should always contain same type of elements on the same level
     * eg. text + html view of the same data
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createAlternative(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode("multipart/alternative", {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild("multipart/alternative", {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        this._alternatives.forEach((alternative)=>{
            if (this._useRelated && this._htmlNode === alternative) {
                this._createRelated(node);
            } else {
                this._createContentNode(node, alternative);
            }
        });
        return node;
    }
    /**
     * Builds multipart/related node. It should always contain html node with related attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */ _createRelated(parentNode) {
        let node;
        if (!parentNode) {
            node = new MimeNode('multipart/related; type="text/html"', {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild('multipart/related; type="text/html"', {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        this._createContentNode(node, this._htmlNode);
        this._attachments.related.forEach((alternative)=>this._createContentNode(node, alternative));
        return node;
    }
    /**
     * Creates a regular node with contents
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @param {Object} element Node data
     * @returns {Object} MimeNode node element
     */ _createContentNode(parentNode, element) {
        element = element || {};
        element.content = element.content || "";
        let node;
        let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
        if (!parentNode) {
            node = new MimeNode(element.contentType, {
                filename: element.filename,
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild(element.contentType, {
                filename: element.filename,
                textEncoding: this.mail.textEncoding,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }
        // add custom headers
        if (element.headers) {
            node.addHeader(element.headers);
        }
        if (element.cid) {
            node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
        }
        if (element.contentTransferEncoding) {
            node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
        } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
            node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
        }
        if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
            node.setHeader("Content-Disposition", element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment"));
        }
        if (typeof element.content === "string" && ![
            "utf8",
            "usascii",
            "ascii"
        ].includes(encoding)) {
            element.content = Buffer.from(element.content, encoding);
        }
        // prefer pregenerated raw content
        if (element.raw) {
            node.setRaw(element.raw);
        } else {
            node.setContent(element.content);
        }
        return node;
    }
    /**
     * Parses data uri and converts it to a Buffer
     *
     * @param {Object} element Content element
     * @return {Object} Parsed element
     */ _processDataUrl(element) {
        let parsedDataUri;
        if ((element.path || element.href).match(/^data:/)) {
            parsedDataUri = parseDataURI(element.path || element.href);
        }
        if (!parsedDataUri) {
            return element;
        }
        element.content = parsedDataUri.data;
        element.contentType = element.contentType || parsedDataUri.contentType;
        if ("path" in element) {
            element.path = false;
        }
        if ("href" in element) {
            element.href = false;
        }
        return element;
    }
}
module.exports = MailComposer;


/***/ }),

/***/ 73378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const shared = __webpack_require__(33050);
const mimeTypes = __webpack_require__(48702);
const MailComposer = __webpack_require__(79804);
const DKIM = __webpack_require__(35767);
const httpProxyClient = __webpack_require__(62989);
const util = __webpack_require__(73837);
const urllib = __webpack_require__(57310);
const packageData = __webpack_require__(60983);
const MailMessage = __webpack_require__(81520);
const net = __webpack_require__(41808);
const dns = __webpack_require__(17578);
const crypto = __webpack_require__(6113);
/**
 * Creates an object for exposing the Mail API
 *
 * @constructor
 * @param {Object} transporter Transport object instance to pass the mails to
 */ class Mail extends EventEmitter {
    constructor(transporter, options, defaults){
        super();
        this.options = options || {};
        this._defaults = defaults || {};
        this._defaultPlugins = {
            compile: [
                (...args)=>this._convertDataImages(...args)
            ],
            stream: []
        };
        this._userPlugins = {
            compile: [],
            stream: []
        };
        this.meta = new Map();
        this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
        this.transporter = transporter;
        this.transporter.mailer = this;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "mail"
        });
        this.logger.debug({
            tnx: "create"
        }, "Creating transport: %s", this.getVersionString());
        // setup emit handlers for the transporter
        if (typeof this.transporter.on === "function") {
            // deprecated log interface
            this.transporter.on("log", (log)=>{
                this.logger.debug({
                    tnx: "transport"
                }, "%s: %s", log.type, log.message);
            });
            // transporter errors
            this.transporter.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "transport"
                }, "Transport Error: %s", err.message);
                this.emit("error", err);
            });
            // indicates if the sender has became idle
            this.transporter.on("idle", (...args)=>{
                this.emit("idle", ...args);
            });
        }
        /**
         * Optional methods passed to the underlying transport object
         */ [
            "close",
            "isIdle",
            "verify"
        ].forEach((method)=>{
            this[method] = (...args)=>{
                if (typeof this.transporter[method] === "function") {
                    if (method === "verify" && typeof this.getSocket === "function") {
                        this.transporter.getSocket = this.getSocket;
                        this.getSocket = false;
                    }
                    return this.transporter[method](...args);
                } else {
                    this.logger.warn({
                        tnx: "transport",
                        methodName: method
                    }, "Non existing method %s called for transport", method);
                    return false;
                }
            };
        });
        // setup proxy handling
        if (this.options.proxy && typeof this.options.proxy === "string") {
            this.setupProxy(this.options.proxy);
        }
    }
    use(step, plugin) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
            this._userPlugins[step] = [
                plugin
            ];
        } else {
            this._userPlugins[step].push(plugin);
        }
        return this;
    }
    /**
     * Sends an email using the preselected transport object
     *
     * @param {Object} data E-data description
     * @param {Function?} callback Callback to run once the sending succeeded or failed
     */ sendMail(data, callback = null) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        if (typeof this.getSocket === "function") {
            this.transporter.getSocket = this.getSocket;
            this.getSocket = false;
        }
        let mail = new MailMessage(this, data);
        this.logger.debug({
            tnx: "transport",
            name: this.transporter.name,
            version: this.transporter.version,
            action: "send"
        }, "Sending mail using %s/%s", this.transporter.name, this.transporter.version);
        this._processPlugins("compile", mail, (err)=>{
            if (err) {
                this.logger.error({
                    err,
                    tnx: "plugin",
                    action: "compile"
                }, "PluginCompile Error: %s", err.message);
                return callback(err);
            }
            mail.message = new MailComposer(mail.data).compile();
            mail.setMailerHeader();
            mail.setPriorityHeaders();
            mail.setListHeaders();
            this._processPlugins("stream", mail, (err)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "plugin",
                        action: "stream"
                    }, "PluginStream Error: %s", err.message);
                    return callback(err);
                }
                if (mail.data.dkim || this.dkim) {
                    mail.message.processFunc((input)=>{
                        let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
                        this.logger.debug({
                            tnx: "DKIM",
                            messageId: mail.message.messageId(),
                            dkimDomains: dkim.keys.map((key)=>key.keySelector + "." + key.domainName).join(", ")
                        }, "Signing outgoing message with %s keys", dkim.keys.length);
                        return dkim.sign(input, mail.data._dkim);
                    });
                }
                this.transporter.send(mail, (...args)=>{
                    if (args[0]) {
                        this.logger.error({
                            err: args[0],
                            tnx: "transport",
                            action: "send"
                        }, "Send Error: %s", args[0].message);
                    }
                    callback(...args);
                });
            });
        });
        return promise;
    }
    getVersionString() {
        return util.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
    _processPlugins(step, mail, callback) {
        step = (step || "").toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
            return callback();
        }
        let userPlugins = this._userPlugins[step] || [];
        let defaultPlugins = this._defaultPlugins[step] || [];
        if (userPlugins.length) {
            this.logger.debug({
                tnx: "transaction",
                pluginCount: userPlugins.length,
                step
            }, "Using %s plugins for %s", userPlugins.length, step);
        }
        if (userPlugins.length + defaultPlugins.length === 0) {
            return callback();
        }
        let pos = 0;
        let block = "default";
        let processPlugins = ()=>{
            let curplugins = block === "default" ? defaultPlugins : userPlugins;
            if (pos >= curplugins.length) {
                if (block === "default" && userPlugins.length) {
                    block = "user";
                    pos = 0;
                    curplugins = userPlugins;
                } else {
                    return callback();
                }
            }
            let plugin = curplugins[pos++];
            plugin(mail, (err)=>{
                if (err) {
                    return callback(err);
                }
                processPlugins();
            });
        };
        processPlugins();
    }
    /**
     * Sets up proxy handler for a Nodemailer object
     *
     * @param {String} proxyUrl Proxy configuration url
     */ setupProxy(proxyUrl) {
        let proxy = urllib.parse(proxyUrl);
        // setup socket handler for the mailer object
        this.getSocket = (options, callback)=>{
            let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
            if (this.meta.has("proxy_handler_" + protocol)) {
                return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback);
            }
            switch(protocol){
                // Connect using a HTTP CONNECT method
                case "http":
                case "https":
                    httpProxyClient(proxy.href, options.port, options.host, (err, socket)=>{
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, {
                            connection: socket
                        });
                    });
                    return;
                case "socks":
                case "socks5":
                case "socks4":
                case "socks4a":
                    {
                        if (!this.meta.has("proxy_socks_module")) {
                            return callback(new Error("Socks module not loaded"));
                        }
                        let connect = (ipaddress)=>{
                            let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
                            let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
                            let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
                            let connectionOpts = {
                                proxy: {
                                    ipaddress,
                                    port: Number(proxy.port),
                                    type: proxyType
                                },
                                [proxyV2 ? "destination" : "target"]: {
                                    host: options.host,
                                    port: options.port
                                },
                                command: "connect"
                            };
                            if (proxy.auth) {
                                let username = decodeURIComponent(proxy.auth.split(":").shift());
                                let password = decodeURIComponent(proxy.auth.split(":").pop());
                                if (proxyV2) {
                                    connectionOpts.proxy.userId = username;
                                    connectionOpts.proxy.password = password;
                                } else if (proxyType === 4) {
                                    connectionOpts.userid = username;
                                } else {
                                    connectionOpts.authentication = {
                                        username,
                                        password
                                    };
                                }
                            }
                            socksClient.createConnection(connectionOpts, (err, info)=>{
                                if (err) {
                                    return callback(err);
                                }
                                return callback(null, {
                                    connection: info.socket || info
                                });
                            });
                        };
                        if (net.isIP(proxy.hostname)) {
                            return connect(proxy.hostname);
                        }
                        return dns.resolve(proxy.hostname, (err, address)=>{
                            if (err) {
                                return callback(err);
                            }
                            connect(Array.isArray(address) ? address[0] : address);
                        });
                    }
            }
            callback(new Error("Unknown proxy configuration"));
        };
    }
    _convertDataImages(mail, callback) {
        if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
            return callback();
        }
        mail.resolveContent(mail.data, "html", (err, html)=>{
            if (err) {
                return callback(err);
            }
            let cidCounter = 0;
            html = (html || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType)=>{
                let cid = crypto.randomBytes(10).toString("hex") + "@localhost";
                if (!mail.data.attachments) {
                    mail.data.attachments = [];
                }
                if (!Array.isArray(mail.data.attachments)) {
                    mail.data.attachments = [].concat(mail.data.attachments || []);
                }
                mail.data.attachments.push({
                    path: dataUri,
                    cid,
                    filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
                });
                return prefix + "cid:" + cid;
            });
            mail.data.html = html;
            callback();
        });
    }
    set(key, value) {
        return this.meta.set(key, value);
    }
    get(key) {
        return this.meta.get(key);
    }
}
module.exports = Mail;


/***/ }),

/***/ 81520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const shared = __webpack_require__(33050);
const MimeNode = __webpack_require__(47419);
const mimeFuncs = __webpack_require__(41552);
class MailMessage {
    constructor(mailer, data){
        this.mailer = mailer;
        this.data = {};
        this.message = null;
        data = data || {};
        let options = mailer.options || {};
        let defaults = mailer._defaults || {};
        Object.keys(data).forEach((key)=>{
            this.data[key] = data[key];
        });
        this.data.headers = this.data.headers || {};
        // apply defaults
        Object.keys(defaults).forEach((key)=>{
            if (!(key in this.data)) {
                this.data[key] = defaults[key];
            } else if (key === "headers") {
                // headers is a special case. Allow setting individual default headers
                Object.keys(defaults.headers).forEach((key)=>{
                    if (!(key in this.data.headers)) {
                        this.data.headers[key] = defaults.headers[key];
                    }
                });
            }
        });
        // force specific keys from transporter options
        [
            "disableFileAccess",
            "disableUrlAccess",
            "normalizeHeaderKey"
        ].forEach((key)=>{
            if (key in options) {
                this.data[key] = options[key];
            }
        });
    }
    resolveContent(...args) {
        return shared.resolveContent(...args);
    }
    resolveAll(callback) {
        let keys = [
            [
                this.data,
                "html"
            ],
            [
                this.data,
                "text"
            ],
            [
                this.data,
                "watchHtml"
            ],
            [
                this.data,
                "amp"
            ],
            [
                this.data,
                "icalEvent"
            ]
        ];
        if (this.data.alternatives && this.data.alternatives.length) {
            this.data.alternatives.forEach((alternative, i)=>{
                keys.push([
                    this.data.alternatives,
                    i
                ]);
            });
        }
        if (this.data.attachments && this.data.attachments.length) {
            this.data.attachments.forEach((attachment, i)=>{
                if (!attachment.filename) {
                    attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
                    if (attachment.filename.indexOf(".") < 0) {
                        attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
                    }
                }
                if (!attachment.contentType) {
                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
                }
                keys.push([
                    this.data.attachments,
                    i
                ]);
            });
        }
        let mimeNode = new MimeNode();
        let addressKeys = [
            "from",
            "to",
            "cc",
            "bcc",
            "sender",
            "replyTo"
        ];
        addressKeys.forEach((address)=>{
            let value;
            if (this.message) {
                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
            } else if (this.data[address]) {
                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
            }
            if (value && value.length) {
                this.data[address] = value;
            } else if (address in this.data) {
                this.data[address] = null;
            }
        });
        let singleKeys = [
            "from",
            "sender"
        ];
        singleKeys.forEach((address)=>{
            if (this.data[address]) {
                this.data[address] = this.data[address].shift();
            }
        });
        let pos = 0;
        let resolveNext = ()=>{
            if (pos >= keys.length) {
                return callback(null, this.data);
            }
            let args = keys[pos++];
            if (!args[0] || !args[0][args[1]]) {
                return resolveNext();
            }
            shared.resolveContent(...args, (err, value)=>{
                if (err) {
                    return callback(err);
                }
                let node = {
                    content: value
                };
                if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
                    Object.keys(args[0][args[1]]).forEach((key)=>{
                        if (!(key in node) && ![
                            "content",
                            "path",
                            "href",
                            "raw"
                        ].includes(key)) {
                            node[key] = args[0][args[1]][key];
                        }
                    });
                }
                args[0][args[1]] = node;
                resolveNext();
            });
        };
        setImmediate(()=>resolveNext());
    }
    normalize(callback) {
        let envelope = this.data.envelope || this.message.getEnvelope();
        let messageId = this.message.messageId();
        this.resolveAll((err, data)=>{
            if (err) {
                return callback(err);
            }
            data.envelope = envelope;
            data.messageId = messageId;
            [
                "html",
                "text",
                "watchHtml",
                "amp"
            ].forEach((key)=>{
                if (data[key] && data[key].content) {
                    if (typeof data[key].content === "string") {
                        data[key] = data[key].content;
                    } else if (Buffer.isBuffer(data[key].content)) {
                        data[key] = data[key].content.toString();
                    }
                }
            });
            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
                data.icalEvent.content = data.icalEvent.content.toString("base64");
                data.icalEvent.encoding = "base64";
            }
            if (data.alternatives && data.alternatives.length) {
                data.alternatives.forEach((alternative)=>{
                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
                        alternative.content = alternative.content.toString("base64");
                        alternative.encoding = "base64";
                    }
                });
            }
            if (data.attachments && data.attachments.length) {
                data.attachments.forEach((attachment)=>{
                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
                        attachment.content = attachment.content.toString("base64");
                        attachment.encoding = "base64";
                    }
                });
            }
            data.normalizedHeaders = {};
            Object.keys(data.headers || {}).forEach((key)=>{
                let value = [].concat(data.headers[key] || []).shift();
                value = value && value.value || value;
                if (value) {
                    if ([
                        "references",
                        "in-reply-to",
                        "message-id",
                        "content-id"
                    ].includes(key)) {
                        value = this.message._encodeHeaderValue(key, value);
                    }
                    data.normalizedHeaders[key] = value;
                }
            });
            if (data.list && typeof data.list === "object") {
                let listHeaders = this._getListHeaders(data.list);
                listHeaders.forEach((entry)=>{
                    data.normalizedHeaders[entry.key] = entry.value.map((val)=>val && val.value || val).join(", ");
                });
            }
            if (data.references) {
                data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
            }
            if (data.inReplyTo) {
                data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
            }
            return callback(null, data);
        });
    }
    setMailerHeader() {
        if (!this.message || !this.data.xMailer) {
            return;
        }
        this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
        if (!this.message || !this.data.priority) {
            return;
        }
        switch((this.data.priority || "").toString().toLowerCase()){
            case "high":
                this.message.setHeader("X-Priority", "1 (Highest)");
                this.message.setHeader("X-MSMail-Priority", "High");
                this.message.setHeader("Importance", "High");
                break;
            case "low":
                this.message.setHeader("X-Priority", "5 (Lowest)");
                this.message.setHeader("X-MSMail-Priority", "Low");
                this.message.setHeader("Importance", "Low");
                break;
            default:
        }
    }
    setListHeaders() {
        if (!this.message || !this.data.list || typeof this.data.list !== "object") {
            return;
        }
        // add optional List-* headers
        if (this.data.list && typeof this.data.list === "object") {
            this._getListHeaders(this.data.list).forEach((listHeader)=>{
                listHeader.value.forEach((value)=>{
                    this.message.addHeader(listHeader.key, value);
                });
            });
        }
    }
    _getListHeaders(listData) {
        // make sure an url looks like <protocol:url>
        return Object.keys(listData).map((key)=>({
                key: "list-" + key.toLowerCase().trim(),
                value: [].concat(listData[key] || []).map((value)=>({
                        prepared: true,
                        foldLines: true,
                        value: [].concat(value || []).map((value)=>{
                            if (typeof value === "string") {
                                value = {
                                    url: value
                                };
                            }
                            if (value && value.url) {
                                if (key.toLowerCase().trim() === "id") {
                                    // List-ID: "comment" <domain>
                                    let comment = value.comment || "";
                                    if (mimeFuncs.isPlainText(comment)) {
                                        comment = '"' + comment + '"';
                                    } else {
                                        comment = mimeFuncs.encodeWord(comment);
                                    }
                                    return (value.comment ? comment + " " : "") + this._formatListUrl(value.url).replace(/^<[^:]+\/{,2}/, "");
                                }
                                // List-*: <http://domain> (comment)
                                let comment = value.comment || "";
                                if (!mimeFuncs.isPlainText(comment)) {
                                    comment = mimeFuncs.encodeWord(comment);
                                }
                                return this._formatListUrl(value.url) + (value.comment ? " (" + comment + ")" : "");
                            }
                            return "";
                        }).filter((value)=>value).join(", ")
                    }))
            }));
    }
    _formatListUrl(url) {
        url = url.replace(/[\s<]+|[\s>]+/g, "");
        if (/^(https?|mailto|ftp):/.test(url)) {
            return "<" + url + ">";
        }
        if (/^[^@]+@[^@]+$/.test(url)) {
            return "<mailto:" + url + ">";
        }
        return "<http://" + url + ">";
    }
}
module.exports = MailMessage;


/***/ }),

/***/ 41552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-control-regex:0 */ 
const base64 = __webpack_require__(2553);
const qp = __webpack_require__(46661);
const mimeTypes = __webpack_require__(48702);
module.exports = {
    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */ isPlainText (value, isParam) {
        const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
        if (typeof value !== "string" || re.test(value)) {
            return false;
        } else {
            return true;
        }
    },
    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all –
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */ hasLongerLines (str, lineLength) {
        if (str.length > 128 * 1024) {
            // do not test strings longer than 128kB
            return true;
        }
        return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */ encodeWord (data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;
        let encodedStr;
        let toCharset = "UTF-8";
        if (maxLength && maxLength > 7 + toCharset.length) {
            maxLength -= 7 + toCharset.length;
        }
        if (mimeWordEncoding === "Q") {
            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr)=>{
                let ord = chr.charCodeAt(0).toString(16).toUpperCase();
                if (chr === " ") {
                    return "_";
                } else {
                    return "=" + (ord.length === 1 ? "0" + ord : ord);
                }
            });
        } else if (mimeWordEncoding === "B") {
            encodedStr = typeof data === "string" ? data : base64.encode(data);
            maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
        }
        if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
            if (mimeWordEncoding === "Q") {
                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
            } else {
                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                let parts = [];
                let lpart = "";
                for(let i = 0, len = encodedStr.length; i < len; i++){
                    let chr = encodedStr.charAt(i);
                    if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
                        // composite emoji byte, so add the next byte as well
                        chr += encodedStr.charAt(++i);
                    }
                    // check if we can add this character to the existing string
                    // without breaking byte length limit
                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                        lpart += chr;
                    } else {
                        // we hit the length limit, so push the existing string and start over
                        parts.push(base64.encode(lpart));
                        lpart = chr;
                    }
                }
                if (lpart) {
                    parts.push(base64.encode(lpart));
                }
                if (parts.length > 1) {
                    encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
                } else {
                    encodedStr = parts.join("");
                }
            }
        } else if (mimeWordEncoding === "B") {
            encodedStr = base64.encode(data);
        }
        return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String} value String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
     * @return {String} String with possible mime words
     */ encodeWords (value, mimeWordEncoding, maxLength, encodeAll) {
        maxLength = maxLength || 0;
        let encodedValue;
        // find first word with a non-printable ascii or special symbol in it
        let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
        if (!firstMatch) {
            return value;
        }
        if (encodeAll) {
            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything
            return this.encodeWord(value, mimeWordEncoding, maxLength);
        }
        // find the last word with a non-printable ascii in it
        let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
        if (!lastMatch) {
            // should not happen
            return value;
        }
        let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
            index: 0
        }).index;
        let endIndex = lastMatch.index + (lastMatch[1] || "").length;
        encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
        return encodedValue;
    },
    /**
     * Joins parsed header value together as 'value; param1=value1; param2=value2'
     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */ buildHeaderValue (structured) {
        let paramsArray = [];
        Object.keys(structured.params || {}).forEach((param)=>{
            // filename might include unicode characters so it is a special case
            // other values probably do not
            let value = structured.params[param];
            if (!this.isPlainText(value, true) || value.length >= 75) {
                this.buildHeaderParam(param, value, 50).forEach((encodedParam)=>{
                    if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
                        paramsArray.push(encodedParam.key + "=" + encodedParam.value);
                    } else {
                        paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
                    }
                });
            } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
                paramsArray.push(param + "=" + JSON.stringify(value));
            } else {
                paramsArray.push(param + "=" + value);
            }
        });
        return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title="unicode string"
     * becomes
     *     title*0*=utf-8''unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */ buildHeaderParam (key, data, maxLength) {
        let list = [];
        let encodedStr = typeof data === "string" ? data : (data || "").toString();
        let encodedStrArr;
        let chr, ord;
        let line;
        let startPos = 0;
        let i, len;
        maxLength = maxLength || 50;
        // process ascii only text
        if (this.isPlainText(data, true)) {
            // check if conversion is even needed
            if (encodedStr.length <= maxLength) {
                return [
                    {
                        key,
                        value: encodedStr
                    }
                ];
            }
            encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str)=>{
                list.push({
                    line: str
                });
                return "";
            });
            if (encodedStr) {
                list.push({
                    line: encodedStr
                });
            }
        } else {
            if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                // string containts surrogate pairs, so normalize it to an array of bytes
                encodedStrArr = [];
                for(i = 0, len = encodedStr.length; i < len; i++){
                    chr = encodedStr.charAt(i);
                    ord = chr.charCodeAt(0);
                    if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {
                        chr += encodedStr.charAt(i + 1);
                        encodedStrArr.push(chr);
                        i++;
                    } else {
                        encodedStrArr.push(chr);
                    }
                }
                encodedStr = encodedStrArr;
            }
            // first line includes the charset and language info and needs to be encoded
            // even if it does not contain any unicode characters
            line = "utf-8''";
            let encoded = true;
            startPos = 0;
            // process text with unicode or special chars
            for(i = 0, len = encodedStr.length; i < len; i++){
                chr = encodedStr[i];
                if (encoded) {
                    chr = this.safeEncodeURIComponent(chr);
                } else {
                    // try to urlencode current char
                    chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
                    // By default it is not required to encode a line, the need
                    // only appears when the string contains unicode or special chars
                    // in this case we start processing the line over and encode all chars
                    if (chr !== encodedStr[i]) {
                        // Check if it is even possible to add the encoded char to the line
                        // If not, there is no reason to use this line, just push it to the list
                        // and start a new line with the char that needs encoding
                        if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                            list.push({
                                line,
                                encoded
                            });
                            line = "";
                            startPos = i - 1;
                        } else {
                            encoded = true;
                            i = startPos;
                            line = "";
                            continue;
                        }
                    }
                }
                // if the line is already too long, push it to the list and start a new one
                if ((line + chr).length >= maxLength) {
                    list.push({
                        line,
                        encoded
                    });
                    line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
                    if (chr === encodedStr[i]) {
                        encoded = false;
                        startPos = i - 1;
                    } else {
                        encoded = true;
                    }
                } else {
                    line += chr;
                }
            }
            if (line) {
                list.push({
                    line,
                    encoded
                });
            }
        }
        return list.map((item, i)=>({
                // encoded lines: {name}*{part}*
                // unencoded lines: {name}*{part}
                // if any line needs to be encoded then the first line (part==0) is always encoded
                key: key + "*" + i + (item.encoded ? "*" : ""),
                value: item.line
            }));
    },
    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
     *   {
     *     'value': 'text/plain',
     *     'params': {
     *       'charset': 'UTF-8'
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */ parseHeaderValue (str) {
        let response = {
            value: false,
            params: {}
        };
        let key = false;
        let value = "";
        let type = "value";
        let quote = false;
        let escaped = false;
        let chr;
        for(let i = 0, len = str.length; i < len; i++){
            chr = str.charAt(i);
            if (type === "key") {
                if (chr === "=") {
                    key = value.trim().toLowerCase();
                    type = "value";
                    value = "";
                    continue;
                }
                value += chr;
            } else {
                if (escaped) {
                    value += chr;
                } else if (chr === "\\") {
                    escaped = true;
                    continue;
                } else if (quote && chr === quote) {
                    quote = false;
                } else if (!quote && chr === '"') {
                    quote = chr;
                } else if (!quote && chr === ";") {
                    if (key === false) {
                        response.value = value.trim();
                    } else {
                        response.params[key] = value.trim();
                    }
                    type = "key";
                    value = "";
                } else {
                    value += chr;
                }
                escaped = false;
            }
        }
        if (type === "value") {
            if (key === false) {
                response.value = value.trim();
            } else {
                response.params[key] = value.trim();
            }
        } else if (value.trim()) {
            response.params[value.trim().toLowerCase()] = "";
        }
        // handle parameter value continuations
        // https://tools.ietf.org/html/rfc2231#section-3
        // preprocess values
        Object.keys(response.params).forEach((key)=>{
            let actualKey, nr, match, value;
            if (match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
                actualKey = key.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;
                if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
                    response.params[actualKey] = {
                        charset: false,
                        values: []
                    };
                }
                value = response.params[key];
                if (nr === 0 && match[0].substr(-1) === "*" && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
                    response.params[actualKey].charset = match[1] || "iso-8859-1";
                    value = match[2];
                }
                response.params[actualKey].values[nr] = value;
                // remove the old reference
                delete response.params[key];
            }
        });
        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
        Object.keys(response.params).forEach((key)=>{
            let value;
            if (response.params[key] && Array.isArray(response.params[key].values)) {
                value = response.params[key].values.map((val)=>val || "").join("");
                if (response.params[key].charset) {
                    // convert "%AB" to "=?charset?Q?=AB?="
                    response.params[key] = "=?" + response.params[key].charset + "?Q?" + value// fix invalidly encoded chars
                    .replace(/[=?_\s]/g, (s)=>{
                        let c = s.charCodeAt(0).toString(16);
                        if (s === " ") {
                            return "_";
                        } else {
                            return "%" + (c.length < 2 ? "0" : "") + c;
                        }
                    })// change from urlencoding to percent encoding
                    .replace(/%/g, "=") + "?=";
                } else {
                    response.params[key] = value;
                }
            }
        });
        return response;
    },
    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, 'bin' is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */ detectExtension: (mimeType)=>mimeTypes.detectExtension(mimeType),
    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, 'application/octet-stream' is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */ detectMimeType: (extension)=>mimeTypes.detectMimeType(extension),
    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */ foldLines (str, lineLength, afterSpace) {
        str = (str || "").toString();
        lineLength = lineLength || 76;
        let pos = 0, len = str.length, result = "", line, match;
        while(pos < len){
            line = str.substr(pos, lineLength);
            if (line.length < lineLength) {
                result += line;
                break;
            }
            if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
            } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
            } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
            }
            result += line;
            pos += line.length;
            if (pos < len) {
                result += "\r\n";
            }
        }
        return result;
    },
    /**
     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
     *
     * @param {String} str Mime encoded string to be split up
     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
     * @return {Array} Split string
     */ splitMimeEncodedString: (str, maxlen)=>{
        let curLine, match, chr, done, lines = [];
        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
        maxlen = Math.max(maxlen || 0, 12);
        while(str.length){
            curLine = str.substr(0, maxlen);
            // move incomplete escaped char back to main
            if (match = curLine.match(/[=][0-9A-F]?$/i)) {
                curLine = curLine.substr(0, match.index);
            }
            done = false;
            while(!done){
                done = true;
                // check if not middle of a unicode char sequence
                if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
                    chr = parseInt(match[1], 16);
                    // invalid sequence, move one char back anc recheck
                    if (chr < 0xc2 && chr > 0x7f) {
                        curLine = curLine.substr(0, curLine.length - 3);
                        done = false;
                    }
                }
            }
            if (curLine.length) {
                lines.push(curLine);
            }
            str = str.substr(curLine.length);
        }
        return lines;
    },
    encodeURICharComponent: (chr)=>{
        let res = "";
        let ord = chr.charCodeAt(0).toString(16).toUpperCase();
        if (ord.length % 2) {
            ord = "0" + ord;
        }
        if (ord.length > 2) {
            for(let i = 0, len = ord.length / 2; i < len; i++){
                res += "%" + ord.substr(i, 2);
            }
        } else {
            res += "%" + ord;
        }
        return res;
    },
    safeEncodeURIComponent (str) {
        str = (str || "").toString();
        try {
            // might throw if we try to encode invalid sequences, eg. partial emoji
            str = encodeURIComponent(str);
        } catch (E) {
            // should never run
            return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
        }
        // ensure chars that are not handled by encodeURICompent are converted as well
        return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr)=>this.encodeURICharComponent(chr));
    }
};


/***/ }),

/***/ 48702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint quote-props: 0 */ 
const path = __webpack_require__(71017);
const defaultMimeType = "application/octet-stream";
const defaultExtension = "bin";
const mimeTypes = new Map([
    [
        "application/acad",
        "dwg"
    ],
    [
        "application/applixware",
        "aw"
    ],
    [
        "application/arj",
        "arj"
    ],
    [
        "application/atom+xml",
        "xml"
    ],
    [
        "application/atomcat+xml",
        "atomcat"
    ],
    [
        "application/atomsvc+xml",
        "atomsvc"
    ],
    [
        "application/base64",
        [
            "mm",
            "mme"
        ]
    ],
    [
        "application/binhex",
        "hqx"
    ],
    [
        "application/binhex4",
        "hqx"
    ],
    [
        "application/book",
        [
            "book",
            "boo"
        ]
    ],
    [
        "application/ccxml+xml,",
        "ccxml"
    ],
    [
        "application/cdf",
        "cdf"
    ],
    [
        "application/cdmi-capability",
        "cdmia"
    ],
    [
        "application/cdmi-container",
        "cdmic"
    ],
    [
        "application/cdmi-domain",
        "cdmid"
    ],
    [
        "application/cdmi-object",
        "cdmio"
    ],
    [
        "application/cdmi-queue",
        "cdmiq"
    ],
    [
        "application/clariscad",
        "ccad"
    ],
    [
        "application/commonground",
        "dp"
    ],
    [
        "application/cu-seeme",
        "cu"
    ],
    [
        "application/davmount+xml",
        "davmount"
    ],
    [
        "application/drafting",
        "drw"
    ],
    [
        "application/dsptype",
        "tsp"
    ],
    [
        "application/dssc+der",
        "dssc"
    ],
    [
        "application/dssc+xml",
        "xdssc"
    ],
    [
        "application/dxf",
        "dxf"
    ],
    [
        "application/ecmascript",
        [
            "js",
            "es"
        ]
    ],
    [
        "application/emma+xml",
        "emma"
    ],
    [
        "application/envoy",
        "evy"
    ],
    [
        "application/epub+zip",
        "epub"
    ],
    [
        "application/excel",
        [
            "xls",
            "xl",
            "xla",
            "xlb",
            "xlc",
            "xld",
            "xlk",
            "xll",
            "xlm",
            "xlt",
            "xlv",
            "xlw"
        ]
    ],
    [
        "application/exi",
        "exi"
    ],
    [
        "application/font-tdpfr",
        "pfr"
    ],
    [
        "application/fractals",
        "fif"
    ],
    [
        "application/freeloader",
        "frl"
    ],
    [
        "application/futuresplash",
        "spl"
    ],
    [
        "application/gnutar",
        "tgz"
    ],
    [
        "application/groupwise",
        "vew"
    ],
    [
        "application/hlp",
        "hlp"
    ],
    [
        "application/hta",
        "hta"
    ],
    [
        "application/hyperstudio",
        "stk"
    ],
    [
        "application/i-deas",
        "unv"
    ],
    [
        "application/iges",
        [
            "iges",
            "igs"
        ]
    ],
    [
        "application/inf",
        "inf"
    ],
    [
        "application/internet-property-stream",
        "acx"
    ],
    [
        "application/ipfix",
        "ipfix"
    ],
    [
        "application/java",
        "class"
    ],
    [
        "application/java-archive",
        "jar"
    ],
    [
        "application/java-byte-code",
        "class"
    ],
    [
        "application/java-serialized-object",
        "ser"
    ],
    [
        "application/java-vm",
        "class"
    ],
    [
        "application/javascript",
        "js"
    ],
    [
        "application/json",
        "json"
    ],
    [
        "application/lha",
        "lha"
    ],
    [
        "application/lzx",
        "lzx"
    ],
    [
        "application/mac-binary",
        "bin"
    ],
    [
        "application/mac-binhex",
        "hqx"
    ],
    [
        "application/mac-binhex40",
        "hqx"
    ],
    [
        "application/mac-compactpro",
        "cpt"
    ],
    [
        "application/macbinary",
        "bin"
    ],
    [
        "application/mads+xml",
        "mads"
    ],
    [
        "application/marc",
        "mrc"
    ],
    [
        "application/marcxml+xml",
        "mrcx"
    ],
    [
        "application/mathematica",
        "ma"
    ],
    [
        "application/mathml+xml",
        "mathml"
    ],
    [
        "application/mbedlet",
        "mbd"
    ],
    [
        "application/mbox",
        "mbox"
    ],
    [
        "application/mcad",
        "mcd"
    ],
    [
        "application/mediaservercontrol+xml",
        "mscml"
    ],
    [
        "application/metalink4+xml",
        "meta4"
    ],
    [
        "application/mets+xml",
        "mets"
    ],
    [
        "application/mime",
        "aps"
    ],
    [
        "application/mods+xml",
        "mods"
    ],
    [
        "application/mp21",
        "m21"
    ],
    [
        "application/mp4",
        "mp4"
    ],
    [
        "application/mspowerpoint",
        [
            "ppt",
            "pot",
            "pps",
            "ppz"
        ]
    ],
    [
        "application/msword",
        [
            "doc",
            "dot",
            "w6w",
            "wiz",
            "word"
        ]
    ],
    [
        "application/mswrite",
        "wri"
    ],
    [
        "application/mxf",
        "mxf"
    ],
    [
        "application/netmc",
        "mcp"
    ],
    [
        "application/octet-stream",
        [
            "*"
        ]
    ],
    [
        "application/oda",
        "oda"
    ],
    [
        "application/oebps-package+xml",
        "opf"
    ],
    [
        "application/ogg",
        "ogx"
    ],
    [
        "application/olescript",
        "axs"
    ],
    [
        "application/onenote",
        "onetoc"
    ],
    [
        "application/patch-ops-error+xml",
        "xer"
    ],
    [
        "application/pdf",
        "pdf"
    ],
    [
        "application/pgp-encrypted",
        "asc"
    ],
    [
        "application/pgp-signature",
        "pgp"
    ],
    [
        "application/pics-rules",
        "prf"
    ],
    [
        "application/pkcs-12",
        "p12"
    ],
    [
        "application/pkcs-crl",
        "crl"
    ],
    [
        "application/pkcs10",
        "p10"
    ],
    [
        "application/pkcs7-mime",
        [
            "p7c",
            "p7m"
        ]
    ],
    [
        "application/pkcs7-signature",
        "p7s"
    ],
    [
        "application/pkcs8",
        "p8"
    ],
    [
        "application/pkix-attr-cert",
        "ac"
    ],
    [
        "application/pkix-cert",
        [
            "cer",
            "crt"
        ]
    ],
    [
        "application/pkix-crl",
        "crl"
    ],
    [
        "application/pkix-pkipath",
        "pkipath"
    ],
    [
        "application/pkixcmp",
        "pki"
    ],
    [
        "application/plain",
        "text"
    ],
    [
        "application/pls+xml",
        "pls"
    ],
    [
        "application/postscript",
        [
            "ps",
            "ai",
            "eps"
        ]
    ],
    [
        "application/powerpoint",
        "ppt"
    ],
    [
        "application/pro_eng",
        [
            "part",
            "prt"
        ]
    ],
    [
        "application/prs.cww",
        "cww"
    ],
    [
        "application/pskc+xml",
        "pskcxml"
    ],
    [
        "application/rdf+xml",
        "rdf"
    ],
    [
        "application/reginfo+xml",
        "rif"
    ],
    [
        "application/relax-ng-compact-syntax",
        "rnc"
    ],
    [
        "application/resource-lists+xml",
        "rl"
    ],
    [
        "application/resource-lists-diff+xml",
        "rld"
    ],
    [
        "application/ringing-tones",
        "rng"
    ],
    [
        "application/rls-services+xml",
        "rs"
    ],
    [
        "application/rsd+xml",
        "rsd"
    ],
    [
        "application/rss+xml",
        "xml"
    ],
    [
        "application/rtf",
        [
            "rtf",
            "rtx"
        ]
    ],
    [
        "application/sbml+xml",
        "sbml"
    ],
    [
        "application/scvp-cv-request",
        "scq"
    ],
    [
        "application/scvp-cv-response",
        "scs"
    ],
    [
        "application/scvp-vp-request",
        "spq"
    ],
    [
        "application/scvp-vp-response",
        "spp"
    ],
    [
        "application/sdp",
        "sdp"
    ],
    [
        "application/sea",
        "sea"
    ],
    [
        "application/set",
        "set"
    ],
    [
        "application/set-payment-initiation",
        "setpay"
    ],
    [
        "application/set-registration-initiation",
        "setreg"
    ],
    [
        "application/shf+xml",
        "shf"
    ],
    [
        "application/sla",
        "stl"
    ],
    [
        "application/smil",
        [
            "smi",
            "smil"
        ]
    ],
    [
        "application/smil+xml",
        "smi"
    ],
    [
        "application/solids",
        "sol"
    ],
    [
        "application/sounder",
        "sdr"
    ],
    [
        "application/sparql-query",
        "rq"
    ],
    [
        "application/sparql-results+xml",
        "srx"
    ],
    [
        "application/srgs",
        "gram"
    ],
    [
        "application/srgs+xml",
        "grxml"
    ],
    [
        "application/sru+xml",
        "sru"
    ],
    [
        "application/ssml+xml",
        "ssml"
    ],
    [
        "application/step",
        [
            "step",
            "stp"
        ]
    ],
    [
        "application/streamingmedia",
        "ssm"
    ],
    [
        "application/tei+xml",
        "tei"
    ],
    [
        "application/thraud+xml",
        "tfi"
    ],
    [
        "application/timestamped-data",
        "tsd"
    ],
    [
        "application/toolbook",
        "tbk"
    ],
    [
        "application/vda",
        "vda"
    ],
    [
        "application/vnd.3gpp.pic-bw-large",
        "plb"
    ],
    [
        "application/vnd.3gpp.pic-bw-small",
        "psb"
    ],
    [
        "application/vnd.3gpp.pic-bw-var",
        "pvb"
    ],
    [
        "application/vnd.3gpp2.tcap",
        "tcap"
    ],
    [
        "application/vnd.3m.post-it-notes",
        "pwn"
    ],
    [
        "application/vnd.accpac.simply.aso",
        "aso"
    ],
    [
        "application/vnd.accpac.simply.imp",
        "imp"
    ],
    [
        "application/vnd.acucobol",
        "acu"
    ],
    [
        "application/vnd.acucorp",
        "atc"
    ],
    [
        "application/vnd.adobe.air-application-installer-package+zip",
        "air"
    ],
    [
        "application/vnd.adobe.fxp",
        "fxp"
    ],
    [
        "application/vnd.adobe.xdp+xml",
        "xdp"
    ],
    [
        "application/vnd.adobe.xfdf",
        "xfdf"
    ],
    [
        "application/vnd.ahead.space",
        "ahead"
    ],
    [
        "application/vnd.airzip.filesecure.azf",
        "azf"
    ],
    [
        "application/vnd.airzip.filesecure.azs",
        "azs"
    ],
    [
        "application/vnd.amazon.ebook",
        "azw"
    ],
    [
        "application/vnd.americandynamics.acc",
        "acc"
    ],
    [
        "application/vnd.amiga.ami",
        "ami"
    ],
    [
        "application/vnd.android.package-archive",
        "apk"
    ],
    [
        "application/vnd.anser-web-certificate-issue-initiation",
        "cii"
    ],
    [
        "application/vnd.anser-web-funds-transfer-initiation",
        "fti"
    ],
    [
        "application/vnd.antix.game-component",
        "atx"
    ],
    [
        "application/vnd.apple.installer+xml",
        "mpkg"
    ],
    [
        "application/vnd.apple.mpegurl",
        "m3u8"
    ],
    [
        "application/vnd.aristanetworks.swi",
        "swi"
    ],
    [
        "application/vnd.audiograph",
        "aep"
    ],
    [
        "application/vnd.blueice.multipass",
        "mpm"
    ],
    [
        "application/vnd.bmi",
        "bmi"
    ],
    [
        "application/vnd.businessobjects",
        "rep"
    ],
    [
        "application/vnd.chemdraw+xml",
        "cdxml"
    ],
    [
        "application/vnd.chipnuts.karaoke-mmd",
        "mmd"
    ],
    [
        "application/vnd.cinderella",
        "cdy"
    ],
    [
        "application/vnd.claymore",
        "cla"
    ],
    [
        "application/vnd.cloanto.rp9",
        "rp9"
    ],
    [
        "application/vnd.clonk.c4group",
        "c4g"
    ],
    [
        "application/vnd.cluetrust.cartomobile-config",
        "c11amc"
    ],
    [
        "application/vnd.cluetrust.cartomobile-config-pkg",
        "c11amz"
    ],
    [
        "application/vnd.commonspace",
        "csp"
    ],
    [
        "application/vnd.contact.cmsg",
        "cdbcmsg"
    ],
    [
        "application/vnd.cosmocaller",
        "cmc"
    ],
    [
        "application/vnd.crick.clicker",
        "clkx"
    ],
    [
        "application/vnd.crick.clicker.keyboard",
        "clkk"
    ],
    [
        "application/vnd.crick.clicker.palette",
        "clkp"
    ],
    [
        "application/vnd.crick.clicker.template",
        "clkt"
    ],
    [
        "application/vnd.crick.clicker.wordbank",
        "clkw"
    ],
    [
        "application/vnd.criticaltools.wbs+xml",
        "wbs"
    ],
    [
        "application/vnd.ctc-posml",
        "pml"
    ],
    [
        "application/vnd.cups-ppd",
        "ppd"
    ],
    [
        "application/vnd.curl.car",
        "car"
    ],
    [
        "application/vnd.curl.pcurl",
        "pcurl"
    ],
    [
        "application/vnd.data-vision.rdz",
        "rdz"
    ],
    [
        "application/vnd.denovo.fcselayout-link",
        "fe_launch"
    ],
    [
        "application/vnd.dna",
        "dna"
    ],
    [
        "application/vnd.dolby.mlp",
        "mlp"
    ],
    [
        "application/vnd.dpgraph",
        "dpg"
    ],
    [
        "application/vnd.dreamfactory",
        "dfac"
    ],
    [
        "application/vnd.dvb.ait",
        "ait"
    ],
    [
        "application/vnd.dvb.service",
        "svc"
    ],
    [
        "application/vnd.dynageo",
        "geo"
    ],
    [
        "application/vnd.ecowin.chart",
        "mag"
    ],
    [
        "application/vnd.enliven",
        "nml"
    ],
    [
        "application/vnd.epson.esf",
        "esf"
    ],
    [
        "application/vnd.epson.msf",
        "msf"
    ],
    [
        "application/vnd.epson.quickanime",
        "qam"
    ],
    [
        "application/vnd.epson.salt",
        "slt"
    ],
    [
        "application/vnd.epson.ssf",
        "ssf"
    ],
    [
        "application/vnd.eszigno3+xml",
        "es3"
    ],
    [
        "application/vnd.ezpix-album",
        "ez2"
    ],
    [
        "application/vnd.ezpix-package",
        "ez3"
    ],
    [
        "application/vnd.fdf",
        "fdf"
    ],
    [
        "application/vnd.fdsn.seed",
        "seed"
    ],
    [
        "application/vnd.flographit",
        "gph"
    ],
    [
        "application/vnd.fluxtime.clip",
        "ftc"
    ],
    [
        "application/vnd.framemaker",
        "fm"
    ],
    [
        "application/vnd.frogans.fnc",
        "fnc"
    ],
    [
        "application/vnd.frogans.ltf",
        "ltf"
    ],
    [
        "application/vnd.fsc.weblaunch",
        "fsc"
    ],
    [
        "application/vnd.fujitsu.oasys",
        "oas"
    ],
    [
        "application/vnd.fujitsu.oasys2",
        "oa2"
    ],
    [
        "application/vnd.fujitsu.oasys3",
        "oa3"
    ],
    [
        "application/vnd.fujitsu.oasysgp",
        "fg5"
    ],
    [
        "application/vnd.fujitsu.oasysprs",
        "bh2"
    ],
    [
        "application/vnd.fujixerox.ddd",
        "ddd"
    ],
    [
        "application/vnd.fujixerox.docuworks",
        "xdw"
    ],
    [
        "application/vnd.fujixerox.docuworks.binder",
        "xbd"
    ],
    [
        "application/vnd.fuzzysheet",
        "fzs"
    ],
    [
        "application/vnd.genomatix.tuxedo",
        "txd"
    ],
    [
        "application/vnd.geogebra.file",
        "ggb"
    ],
    [
        "application/vnd.geogebra.tool",
        "ggt"
    ],
    [
        "application/vnd.geometry-explorer",
        "gex"
    ],
    [
        "application/vnd.geonext",
        "gxt"
    ],
    [
        "application/vnd.geoplan",
        "g2w"
    ],
    [
        "application/vnd.geospace",
        "g3w"
    ],
    [
        "application/vnd.gmx",
        "gmx"
    ],
    [
        "application/vnd.google-earth.kml+xml",
        "kml"
    ],
    [
        "application/vnd.google-earth.kmz",
        "kmz"
    ],
    [
        "application/vnd.grafeq",
        "gqf"
    ],
    [
        "application/vnd.groove-account",
        "gac"
    ],
    [
        "application/vnd.groove-help",
        "ghf"
    ],
    [
        "application/vnd.groove-identity-message",
        "gim"
    ],
    [
        "application/vnd.groove-injector",
        "grv"
    ],
    [
        "application/vnd.groove-tool-message",
        "gtm"
    ],
    [
        "application/vnd.groove-tool-template",
        "tpl"
    ],
    [
        "application/vnd.groove-vcard",
        "vcg"
    ],
    [
        "application/vnd.hal+xml",
        "hal"
    ],
    [
        "application/vnd.handheld-entertainment+xml",
        "zmm"
    ],
    [
        "application/vnd.hbci",
        "hbci"
    ],
    [
        "application/vnd.hhe.lesson-player",
        "les"
    ],
    [
        "application/vnd.hp-hpgl",
        [
            "hgl",
            "hpg",
            "hpgl"
        ]
    ],
    [
        "application/vnd.hp-hpid",
        "hpid"
    ],
    [
        "application/vnd.hp-hps",
        "hps"
    ],
    [
        "application/vnd.hp-jlyt",
        "jlt"
    ],
    [
        "application/vnd.hp-pcl",
        "pcl"
    ],
    [
        "application/vnd.hp-pclxl",
        "pclxl"
    ],
    [
        "application/vnd.hydrostatix.sof-data",
        "sfd-hdstx"
    ],
    [
        "application/vnd.hzn-3d-crossword",
        "x3d"
    ],
    [
        "application/vnd.ibm.minipay",
        "mpy"
    ],
    [
        "application/vnd.ibm.modcap",
        "afp"
    ],
    [
        "application/vnd.ibm.rights-management",
        "irm"
    ],
    [
        "application/vnd.ibm.secure-container",
        "sc"
    ],
    [
        "application/vnd.iccprofile",
        "icc"
    ],
    [
        "application/vnd.igloader",
        "igl"
    ],
    [
        "application/vnd.immervision-ivp",
        "ivp"
    ],
    [
        "application/vnd.immervision-ivu",
        "ivu"
    ],
    [
        "application/vnd.insors.igm",
        "igm"
    ],
    [
        "application/vnd.intercon.formnet",
        "xpw"
    ],
    [
        "application/vnd.intergeo",
        "i2g"
    ],
    [
        "application/vnd.intu.qbo",
        "qbo"
    ],
    [
        "application/vnd.intu.qfx",
        "qfx"
    ],
    [
        "application/vnd.ipunplugged.rcprofile",
        "rcprofile"
    ],
    [
        "application/vnd.irepository.package+xml",
        "irp"
    ],
    [
        "application/vnd.is-xpr",
        "xpr"
    ],
    [
        "application/vnd.isac.fcs",
        "fcs"
    ],
    [
        "application/vnd.jam",
        "jam"
    ],
    [
        "application/vnd.jcp.javame.midlet-rms",
        "rms"
    ],
    [
        "application/vnd.jisp",
        "jisp"
    ],
    [
        "application/vnd.joost.joda-archive",
        "joda"
    ],
    [
        "application/vnd.kahootz",
        "ktz"
    ],
    [
        "application/vnd.kde.karbon",
        "karbon"
    ],
    [
        "application/vnd.kde.kchart",
        "chrt"
    ],
    [
        "application/vnd.kde.kformula",
        "kfo"
    ],
    [
        "application/vnd.kde.kivio",
        "flw"
    ],
    [
        "application/vnd.kde.kontour",
        "kon"
    ],
    [
        "application/vnd.kde.kpresenter",
        "kpr"
    ],
    [
        "application/vnd.kde.kspread",
        "ksp"
    ],
    [
        "application/vnd.kde.kword",
        "kwd"
    ],
    [
        "application/vnd.kenameaapp",
        "htke"
    ],
    [
        "application/vnd.kidspiration",
        "kia"
    ],
    [
        "application/vnd.kinar",
        "kne"
    ],
    [
        "application/vnd.koan",
        "skp"
    ],
    [
        "application/vnd.kodak-descriptor",
        "sse"
    ],
    [
        "application/vnd.las.las+xml",
        "lasxml"
    ],
    [
        "application/vnd.llamagraphics.life-balance.desktop",
        "lbd"
    ],
    [
        "application/vnd.llamagraphics.life-balance.exchange+xml",
        "lbe"
    ],
    [
        "application/vnd.lotus-1-2-3",
        "123"
    ],
    [
        "application/vnd.lotus-approach",
        "apr"
    ],
    [
        "application/vnd.lotus-freelance",
        "pre"
    ],
    [
        "application/vnd.lotus-notes",
        "nsf"
    ],
    [
        "application/vnd.lotus-organizer",
        "org"
    ],
    [
        "application/vnd.lotus-screencam",
        "scm"
    ],
    [
        "application/vnd.lotus-wordpro",
        "lwp"
    ],
    [
        "application/vnd.macports.portpkg",
        "portpkg"
    ],
    [
        "application/vnd.mcd",
        "mcd"
    ],
    [
        "application/vnd.medcalcdata",
        "mc1"
    ],
    [
        "application/vnd.mediastation.cdkey",
        "cdkey"
    ],
    [
        "application/vnd.mfer",
        "mwf"
    ],
    [
        "application/vnd.mfmp",
        "mfm"
    ],
    [
        "application/vnd.micrografx.flo",
        "flo"
    ],
    [
        "application/vnd.micrografx.igx",
        "igx"
    ],
    [
        "application/vnd.mif",
        "mif"
    ],
    [
        "application/vnd.mobius.daf",
        "daf"
    ],
    [
        "application/vnd.mobius.dis",
        "dis"
    ],
    [
        "application/vnd.mobius.mbk",
        "mbk"
    ],
    [
        "application/vnd.mobius.mqy",
        "mqy"
    ],
    [
        "application/vnd.mobius.msl",
        "msl"
    ],
    [
        "application/vnd.mobius.plc",
        "plc"
    ],
    [
        "application/vnd.mobius.txf",
        "txf"
    ],
    [
        "application/vnd.mophun.application",
        "mpn"
    ],
    [
        "application/vnd.mophun.certificate",
        "mpc"
    ],
    [
        "application/vnd.mozilla.xul+xml",
        "xul"
    ],
    [
        "application/vnd.ms-artgalry",
        "cil"
    ],
    [
        "application/vnd.ms-cab-compressed",
        "cab"
    ],
    [
        "application/vnd.ms-excel",
        [
            "xls",
            "xla",
            "xlc",
            "xlm",
            "xlt",
            "xlw",
            "xlb",
            "xll"
        ]
    ],
    [
        "application/vnd.ms-excel.addin.macroenabled.12",
        "xlam"
    ],
    [
        "application/vnd.ms-excel.sheet.binary.macroenabled.12",
        "xlsb"
    ],
    [
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "xlsm"
    ],
    [
        "application/vnd.ms-excel.template.macroenabled.12",
        "xltm"
    ],
    [
        "application/vnd.ms-fontobject",
        "eot"
    ],
    [
        "application/vnd.ms-htmlhelp",
        "chm"
    ],
    [
        "application/vnd.ms-ims",
        "ims"
    ],
    [
        "application/vnd.ms-lrm",
        "lrm"
    ],
    [
        "application/vnd.ms-officetheme",
        "thmx"
    ],
    [
        "application/vnd.ms-outlook",
        "msg"
    ],
    [
        "application/vnd.ms-pki.certstore",
        "sst"
    ],
    [
        "application/vnd.ms-pki.pko",
        "pko"
    ],
    [
        "application/vnd.ms-pki.seccat",
        "cat"
    ],
    [
        "application/vnd.ms-pki.stl",
        "stl"
    ],
    [
        "application/vnd.ms-pkicertstore",
        "sst"
    ],
    [
        "application/vnd.ms-pkiseccat",
        "cat"
    ],
    [
        "application/vnd.ms-pkistl",
        "stl"
    ],
    [
        "application/vnd.ms-powerpoint",
        [
            "ppt",
            "pot",
            "pps",
            "ppa",
            "pwz"
        ]
    ],
    [
        "application/vnd.ms-powerpoint.addin.macroenabled.12",
        "ppam"
    ],
    [
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "pptm"
    ],
    [
        "application/vnd.ms-powerpoint.slide.macroenabled.12",
        "sldm"
    ],
    [
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "ppsm"
    ],
    [
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "potm"
    ],
    [
        "application/vnd.ms-project",
        "mpp"
    ],
    [
        "application/vnd.ms-word.document.macroenabled.12",
        "docm"
    ],
    [
        "application/vnd.ms-word.template.macroenabled.12",
        "dotm"
    ],
    [
        "application/vnd.ms-works",
        [
            "wks",
            "wcm",
            "wdb",
            "wps"
        ]
    ],
    [
        "application/vnd.ms-wpl",
        "wpl"
    ],
    [
        "application/vnd.ms-xpsdocument",
        "xps"
    ],
    [
        "application/vnd.mseq",
        "mseq"
    ],
    [
        "application/vnd.musician",
        "mus"
    ],
    [
        "application/vnd.muvee.style",
        "msty"
    ],
    [
        "application/vnd.neurolanguage.nlu",
        "nlu"
    ],
    [
        "application/vnd.noblenet-directory",
        "nnd"
    ],
    [
        "application/vnd.noblenet-sealer",
        "nns"
    ],
    [
        "application/vnd.noblenet-web",
        "nnw"
    ],
    [
        "application/vnd.nokia.configuration-message",
        "ncm"
    ],
    [
        "application/vnd.nokia.n-gage.data",
        "ngdat"
    ],
    [
        "application/vnd.nokia.n-gage.symbian.install",
        "n-gage"
    ],
    [
        "application/vnd.nokia.radio-preset",
        "rpst"
    ],
    [
        "application/vnd.nokia.radio-presets",
        "rpss"
    ],
    [
        "application/vnd.nokia.ringing-tone",
        "rng"
    ],
    [
        "application/vnd.novadigm.edm",
        "edm"
    ],
    [
        "application/vnd.novadigm.edx",
        "edx"
    ],
    [
        "application/vnd.novadigm.ext",
        "ext"
    ],
    [
        "application/vnd.oasis.opendocument.chart",
        "odc"
    ],
    [
        "application/vnd.oasis.opendocument.chart-template",
        "otc"
    ],
    [
        "application/vnd.oasis.opendocument.database",
        "odb"
    ],
    [
        "application/vnd.oasis.opendocument.formula",
        "odf"
    ],
    [
        "application/vnd.oasis.opendocument.formula-template",
        "odft"
    ],
    [
        "application/vnd.oasis.opendocument.graphics",
        "odg"
    ],
    [
        "application/vnd.oasis.opendocument.graphics-template",
        "otg"
    ],
    [
        "application/vnd.oasis.opendocument.image",
        "odi"
    ],
    [
        "application/vnd.oasis.opendocument.image-template",
        "oti"
    ],
    [
        "application/vnd.oasis.opendocument.presentation",
        "odp"
    ],
    [
        "application/vnd.oasis.opendocument.presentation-template",
        "otp"
    ],
    [
        "application/vnd.oasis.opendocument.spreadsheet",
        "ods"
    ],
    [
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "ots"
    ],
    [
        "application/vnd.oasis.opendocument.text",
        "odt"
    ],
    [
        "application/vnd.oasis.opendocument.text-master",
        "odm"
    ],
    [
        "application/vnd.oasis.opendocument.text-template",
        "ott"
    ],
    [
        "application/vnd.oasis.opendocument.text-web",
        "oth"
    ],
    [
        "application/vnd.olpc-sugar",
        "xo"
    ],
    [
        "application/vnd.oma.dd2+xml",
        "dd2"
    ],
    [
        "application/vnd.openofficeorg.extension",
        "oxt"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "pptx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.slide",
        "sldx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "ppsx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.presentationml.template",
        "potx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "xlsx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "xltx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "docx"
    ],
    [
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "dotx"
    ],
    [
        "application/vnd.osgeo.mapguide.package",
        "mgp"
    ],
    [
        "application/vnd.osgi.dp",
        "dp"
    ],
    [
        "application/vnd.palm",
        "pdb"
    ],
    [
        "application/vnd.pawaafile",
        "paw"
    ],
    [
        "application/vnd.pg.format",
        "str"
    ],
    [
        "application/vnd.pg.osasli",
        "ei6"
    ],
    [
        "application/vnd.picsel",
        "efif"
    ],
    [
        "application/vnd.pmi.widget",
        "wg"
    ],
    [
        "application/vnd.pocketlearn",
        "plf"
    ],
    [
        "application/vnd.powerbuilder6",
        "pbd"
    ],
    [
        "application/vnd.previewsystems.box",
        "box"
    ],
    [
        "application/vnd.proteus.magazine",
        "mgz"
    ],
    [
        "application/vnd.publishare-delta-tree",
        "qps"
    ],
    [
        "application/vnd.pvi.ptid1",
        "ptid"
    ],
    [
        "application/vnd.quark.quarkxpress",
        "qxd"
    ],
    [
        "application/vnd.realvnc.bed",
        "bed"
    ],
    [
        "application/vnd.recordare.musicxml",
        "mxl"
    ],
    [
        "application/vnd.recordare.musicxml+xml",
        "musicxml"
    ],
    [
        "application/vnd.rig.cryptonote",
        "cryptonote"
    ],
    [
        "application/vnd.rim.cod",
        "cod"
    ],
    [
        "application/vnd.rn-realmedia",
        "rm"
    ],
    [
        "application/vnd.rn-realplayer",
        "rnx"
    ],
    [
        "application/vnd.route66.link66+xml",
        "link66"
    ],
    [
        "application/vnd.sailingtracker.track",
        "st"
    ],
    [
        "application/vnd.seemail",
        "see"
    ],
    [
        "application/vnd.sema",
        "sema"
    ],
    [
        "application/vnd.semd",
        "semd"
    ],
    [
        "application/vnd.semf",
        "semf"
    ],
    [
        "application/vnd.shana.informed.formdata",
        "ifm"
    ],
    [
        "application/vnd.shana.informed.formtemplate",
        "itp"
    ],
    [
        "application/vnd.shana.informed.interchange",
        "iif"
    ],
    [
        "application/vnd.shana.informed.package",
        "ipk"
    ],
    [
        "application/vnd.simtech-mindmapper",
        "twd"
    ],
    [
        "application/vnd.smaf",
        "mmf"
    ],
    [
        "application/vnd.smart.teacher",
        "teacher"
    ],
    [
        "application/vnd.solent.sdkm+xml",
        "sdkm"
    ],
    [
        "application/vnd.spotfire.dxp",
        "dxp"
    ],
    [
        "application/vnd.spotfire.sfs",
        "sfs"
    ],
    [
        "application/vnd.stardivision.calc",
        "sdc"
    ],
    [
        "application/vnd.stardivision.draw",
        "sda"
    ],
    [
        "application/vnd.stardivision.impress",
        "sdd"
    ],
    [
        "application/vnd.stardivision.math",
        "smf"
    ],
    [
        "application/vnd.stardivision.writer",
        "sdw"
    ],
    [
        "application/vnd.stardivision.writer-global",
        "sgl"
    ],
    [
        "application/vnd.stepmania.stepchart",
        "sm"
    ],
    [
        "application/vnd.sun.xml.calc",
        "sxc"
    ],
    [
        "application/vnd.sun.xml.calc.template",
        "stc"
    ],
    [
        "application/vnd.sun.xml.draw",
        "sxd"
    ],
    [
        "application/vnd.sun.xml.draw.template",
        "std"
    ],
    [
        "application/vnd.sun.xml.impress",
        "sxi"
    ],
    [
        "application/vnd.sun.xml.impress.template",
        "sti"
    ],
    [
        "application/vnd.sun.xml.math",
        "sxm"
    ],
    [
        "application/vnd.sun.xml.writer",
        "sxw"
    ],
    [
        "application/vnd.sun.xml.writer.global",
        "sxg"
    ],
    [
        "application/vnd.sun.xml.writer.template",
        "stw"
    ],
    [
        "application/vnd.sus-calendar",
        "sus"
    ],
    [
        "application/vnd.svd",
        "svd"
    ],
    [
        "application/vnd.symbian.install",
        "sis"
    ],
    [
        "application/vnd.syncml+xml",
        "xsm"
    ],
    [
        "application/vnd.syncml.dm+wbxml",
        "bdm"
    ],
    [
        "application/vnd.syncml.dm+xml",
        "xdm"
    ],
    [
        "application/vnd.tao.intent-module-archive",
        "tao"
    ],
    [
        "application/vnd.tmobile-livetv",
        "tmo"
    ],
    [
        "application/vnd.trid.tpt",
        "tpt"
    ],
    [
        "application/vnd.triscape.mxs",
        "mxs"
    ],
    [
        "application/vnd.trueapp",
        "tra"
    ],
    [
        "application/vnd.ufdl",
        "ufd"
    ],
    [
        "application/vnd.uiq.theme",
        "utz"
    ],
    [
        "application/vnd.umajin",
        "umj"
    ],
    [
        "application/vnd.unity",
        "unityweb"
    ],
    [
        "application/vnd.uoml+xml",
        "uoml"
    ],
    [
        "application/vnd.vcx",
        "vcx"
    ],
    [
        "application/vnd.visio",
        "vsd"
    ],
    [
        "application/vnd.visionary",
        "vis"
    ],
    [
        "application/vnd.vsf",
        "vsf"
    ],
    [
        "application/vnd.wap.wbxml",
        "wbxml"
    ],
    [
        "application/vnd.wap.wmlc",
        "wmlc"
    ],
    [
        "application/vnd.wap.wmlscriptc",
        "wmlsc"
    ],
    [
        "application/vnd.webturbo",
        "wtb"
    ],
    [
        "application/vnd.wolfram.player",
        "nbp"
    ],
    [
        "application/vnd.wordperfect",
        "wpd"
    ],
    [
        "application/vnd.wqd",
        "wqd"
    ],
    [
        "application/vnd.wt.stf",
        "stf"
    ],
    [
        "application/vnd.xara",
        [
            "web",
            "xar"
        ]
    ],
    [
        "application/vnd.xfdl",
        "xfdl"
    ],
    [
        "application/vnd.yamaha.hv-dic",
        "hvd"
    ],
    [
        "application/vnd.yamaha.hv-script",
        "hvs"
    ],
    [
        "application/vnd.yamaha.hv-voice",
        "hvp"
    ],
    [
        "application/vnd.yamaha.openscoreformat",
        "osf"
    ],
    [
        "application/vnd.yamaha.openscoreformat.osfpvg+xml",
        "osfpvg"
    ],
    [
        "application/vnd.yamaha.smaf-audio",
        "saf"
    ],
    [
        "application/vnd.yamaha.smaf-phrase",
        "spf"
    ],
    [
        "application/vnd.yellowriver-custom-menu",
        "cmp"
    ],
    [
        "application/vnd.zul",
        "zir"
    ],
    [
        "application/vnd.zzazz.deck+xml",
        "zaz"
    ],
    [
        "application/vocaltec-media-desc",
        "vmd"
    ],
    [
        "application/vocaltec-media-file",
        "vmf"
    ],
    [
        "application/voicexml+xml",
        "vxml"
    ],
    [
        "application/widget",
        "wgt"
    ],
    [
        "application/winhlp",
        "hlp"
    ],
    [
        "application/wordperfect",
        [
            "wp",
            "wp5",
            "wp6",
            "wpd"
        ]
    ],
    [
        "application/wordperfect6.0",
        [
            "w60",
            "wp5"
        ]
    ],
    [
        "application/wordperfect6.1",
        "w61"
    ],
    [
        "application/wsdl+xml",
        "wsdl"
    ],
    [
        "application/wspolicy+xml",
        "wspolicy"
    ],
    [
        "application/x-123",
        "wk1"
    ],
    [
        "application/x-7z-compressed",
        "7z"
    ],
    [
        "application/x-abiword",
        "abw"
    ],
    [
        "application/x-ace-compressed",
        "ace"
    ],
    [
        "application/x-aim",
        "aim"
    ],
    [
        "application/x-authorware-bin",
        "aab"
    ],
    [
        "application/x-authorware-map",
        "aam"
    ],
    [
        "application/x-authorware-seg",
        "aas"
    ],
    [
        "application/x-bcpio",
        "bcpio"
    ],
    [
        "application/x-binary",
        "bin"
    ],
    [
        "application/x-binhex40",
        "hqx"
    ],
    [
        "application/x-bittorrent",
        "torrent"
    ],
    [
        "application/x-bsh",
        [
            "bsh",
            "sh",
            "shar"
        ]
    ],
    [
        "application/x-bytecode.elisp",
        "elc"
    ],
    [
        "application/x-bytecode.python",
        "pyc"
    ],
    [
        "application/x-bzip",
        "bz"
    ],
    [
        "application/x-bzip2",
        [
            "boz",
            "bz2"
        ]
    ],
    [
        "application/x-cdf",
        "cdf"
    ],
    [
        "application/x-cdlink",
        "vcd"
    ],
    [
        "application/x-chat",
        [
            "cha",
            "chat"
        ]
    ],
    [
        "application/x-chess-pgn",
        "pgn"
    ],
    [
        "application/x-cmu-raster",
        "ras"
    ],
    [
        "application/x-cocoa",
        "cco"
    ],
    [
        "application/x-compactpro",
        "cpt"
    ],
    [
        "application/x-compress",
        "z"
    ],
    [
        "application/x-compressed",
        [
            "tgz",
            "gz",
            "z",
            "zip"
        ]
    ],
    [
        "application/x-conference",
        "nsc"
    ],
    [
        "application/x-cpio",
        "cpio"
    ],
    [
        "application/x-cpt",
        "cpt"
    ],
    [
        "application/x-csh",
        "csh"
    ],
    [
        "application/x-debian-package",
        "deb"
    ],
    [
        "application/x-deepv",
        "deepv"
    ],
    [
        "application/x-director",
        [
            "dir",
            "dcr",
            "dxr"
        ]
    ],
    [
        "application/x-doom",
        "wad"
    ],
    [
        "application/x-dtbncx+xml",
        "ncx"
    ],
    [
        "application/x-dtbook+xml",
        "dtb"
    ],
    [
        "application/x-dtbresource+xml",
        "res"
    ],
    [
        "application/x-dvi",
        "dvi"
    ],
    [
        "application/x-elc",
        "elc"
    ],
    [
        "application/x-envoy",
        [
            "env",
            "evy"
        ]
    ],
    [
        "application/x-esrehber",
        "es"
    ],
    [
        "application/x-excel",
        [
            "xls",
            "xla",
            "xlb",
            "xlc",
            "xld",
            "xlk",
            "xll",
            "xlm",
            "xlt",
            "xlv",
            "xlw"
        ]
    ],
    [
        "application/x-font-bdf",
        "bdf"
    ],
    [
        "application/x-font-ghostscript",
        "gsf"
    ],
    [
        "application/x-font-linux-psf",
        "psf"
    ],
    [
        "application/x-font-otf",
        "otf"
    ],
    [
        "application/x-font-pcf",
        "pcf"
    ],
    [
        "application/x-font-snf",
        "snf"
    ],
    [
        "application/x-font-ttf",
        "ttf"
    ],
    [
        "application/x-font-type1",
        "pfa"
    ],
    [
        "application/x-font-woff",
        "woff"
    ],
    [
        "application/x-frame",
        "mif"
    ],
    [
        "application/x-freelance",
        "pre"
    ],
    [
        "application/x-futuresplash",
        "spl"
    ],
    [
        "application/x-gnumeric",
        "gnumeric"
    ],
    [
        "application/x-gsp",
        "gsp"
    ],
    [
        "application/x-gss",
        "gss"
    ],
    [
        "application/x-gtar",
        "gtar"
    ],
    [
        "application/x-gzip",
        [
            "gz",
            "gzip"
        ]
    ],
    [
        "application/x-hdf",
        "hdf"
    ],
    [
        "application/x-helpfile",
        [
            "help",
            "hlp"
        ]
    ],
    [
        "application/x-httpd-imap",
        "imap"
    ],
    [
        "application/x-ima",
        "ima"
    ],
    [
        "application/x-internet-signup",
        [
            "ins",
            "isp"
        ]
    ],
    [
        "application/x-internett-signup",
        "ins"
    ],
    [
        "application/x-inventor",
        "iv"
    ],
    [
        "application/x-ip2",
        "ip"
    ],
    [
        "application/x-iphone",
        "iii"
    ],
    [
        "application/x-java-class",
        "class"
    ],
    [
        "application/x-java-commerce",
        "jcm"
    ],
    [
        "application/x-java-jnlp-file",
        "jnlp"
    ],
    [
        "application/x-javascript",
        "js"
    ],
    [
        "application/x-koan",
        [
            "skd",
            "skm",
            "skp",
            "skt"
        ]
    ],
    [
        "application/x-ksh",
        "ksh"
    ],
    [
        "application/x-latex",
        [
            "latex",
            "ltx"
        ]
    ],
    [
        "application/x-lha",
        "lha"
    ],
    [
        "application/x-lisp",
        "lsp"
    ],
    [
        "application/x-livescreen",
        "ivy"
    ],
    [
        "application/x-lotus",
        "wq1"
    ],
    [
        "application/x-lotusscreencam",
        "scm"
    ],
    [
        "application/x-lzh",
        "lzh"
    ],
    [
        "application/x-lzx",
        "lzx"
    ],
    [
        "application/x-mac-binhex40",
        "hqx"
    ],
    [
        "application/x-macbinary",
        "bin"
    ],
    [
        "application/x-magic-cap-package-1.0",
        "mc$"
    ],
    [
        "application/x-mathcad",
        "mcd"
    ],
    [
        "application/x-meme",
        "mm"
    ],
    [
        "application/x-midi",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "application/x-mif",
        "mif"
    ],
    [
        "application/x-mix-transfer",
        "nix"
    ],
    [
        "application/x-mobipocket-ebook",
        "prc"
    ],
    [
        "application/x-mplayer2",
        "asx"
    ],
    [
        "application/x-ms-application",
        "application"
    ],
    [
        "application/x-ms-wmd",
        "wmd"
    ],
    [
        "application/x-ms-wmz",
        "wmz"
    ],
    [
        "application/x-ms-xbap",
        "xbap"
    ],
    [
        "application/x-msaccess",
        "mdb"
    ],
    [
        "application/x-msbinder",
        "obd"
    ],
    [
        "application/x-mscardfile",
        "crd"
    ],
    [
        "application/x-msclip",
        "clp"
    ],
    [
        "application/x-msdownload",
        [
            "exe",
            "dll"
        ]
    ],
    [
        "application/x-msexcel",
        [
            "xls",
            "xla",
            "xlw"
        ]
    ],
    [
        "application/x-msmediaview",
        [
            "mvb",
            "m13",
            "m14"
        ]
    ],
    [
        "application/x-msmetafile",
        "wmf"
    ],
    [
        "application/x-msmoney",
        "mny"
    ],
    [
        "application/x-mspowerpoint",
        "ppt"
    ],
    [
        "application/x-mspublisher",
        "pub"
    ],
    [
        "application/x-msschedule",
        "scd"
    ],
    [
        "application/x-msterminal",
        "trm"
    ],
    [
        "application/x-mswrite",
        "wri"
    ],
    [
        "application/x-navi-animation",
        "ani"
    ],
    [
        "application/x-navidoc",
        "nvd"
    ],
    [
        "application/x-navimap",
        "map"
    ],
    [
        "application/x-navistyle",
        "stl"
    ],
    [
        "application/x-netcdf",
        [
            "cdf",
            "nc"
        ]
    ],
    [
        "application/x-newton-compatible-pkg",
        "pkg"
    ],
    [
        "application/x-nokia-9000-communicator-add-on-software",
        "aos"
    ],
    [
        "application/x-omc",
        "omc"
    ],
    [
        "application/x-omcdatamaker",
        "omcd"
    ],
    [
        "application/x-omcregerator",
        "omcr"
    ],
    [
        "application/x-pagemaker",
        [
            "pm4",
            "pm5"
        ]
    ],
    [
        "application/x-pcl",
        "pcl"
    ],
    [
        "application/x-perfmon",
        [
            "pma",
            "pmc",
            "pml",
            "pmr",
            "pmw"
        ]
    ],
    [
        "application/x-pixclscript",
        "plx"
    ],
    [
        "application/x-pkcs10",
        "p10"
    ],
    [
        "application/x-pkcs12",
        [
            "p12",
            "pfx"
        ]
    ],
    [
        "application/x-pkcs7-certificates",
        [
            "p7b",
            "spc"
        ]
    ],
    [
        "application/x-pkcs7-certreqresp",
        "p7r"
    ],
    [
        "application/x-pkcs7-mime",
        [
            "p7m",
            "p7c"
        ]
    ],
    [
        "application/x-pkcs7-signature",
        [
            "p7s",
            "p7a"
        ]
    ],
    [
        "application/x-pointplus",
        "css"
    ],
    [
        "application/x-portable-anymap",
        "pnm"
    ],
    [
        "application/x-project",
        [
            "mpc",
            "mpt",
            "mpv",
            "mpx"
        ]
    ],
    [
        "application/x-qpro",
        "wb1"
    ],
    [
        "application/x-rar-compressed",
        "rar"
    ],
    [
        "application/x-rtf",
        "rtf"
    ],
    [
        "application/x-sdp",
        "sdp"
    ],
    [
        "application/x-sea",
        "sea"
    ],
    [
        "application/x-seelogo",
        "sl"
    ],
    [
        "application/x-sh",
        "sh"
    ],
    [
        "application/x-shar",
        [
            "shar",
            "sh"
        ]
    ],
    [
        "application/x-shockwave-flash",
        "swf"
    ],
    [
        "application/x-silverlight-app",
        "xap"
    ],
    [
        "application/x-sit",
        "sit"
    ],
    [
        "application/x-sprite",
        [
            "spr",
            "sprite"
        ]
    ],
    [
        "application/x-stuffit",
        "sit"
    ],
    [
        "application/x-stuffitx",
        "sitx"
    ],
    [
        "application/x-sv4cpio",
        "sv4cpio"
    ],
    [
        "application/x-sv4crc",
        "sv4crc"
    ],
    [
        "application/x-tar",
        "tar"
    ],
    [
        "application/x-tbook",
        [
            "sbk",
            "tbk"
        ]
    ],
    [
        "application/x-tcl",
        "tcl"
    ],
    [
        "application/x-tex",
        "tex"
    ],
    [
        "application/x-tex-tfm",
        "tfm"
    ],
    [
        "application/x-texinfo",
        [
            "texi",
            "texinfo"
        ]
    ],
    [
        "application/x-troff",
        [
            "roff",
            "t",
            "tr"
        ]
    ],
    [
        "application/x-troff-man",
        "man"
    ],
    [
        "application/x-troff-me",
        "me"
    ],
    [
        "application/x-troff-ms",
        "ms"
    ],
    [
        "application/x-troff-msvideo",
        "avi"
    ],
    [
        "application/x-ustar",
        "ustar"
    ],
    [
        "application/x-visio",
        [
            "vsd",
            "vst",
            "vsw"
        ]
    ],
    [
        "application/x-vnd.audioexplosion.mzz",
        "mzz"
    ],
    [
        "application/x-vnd.ls-xpix",
        "xpix"
    ],
    [
        "application/x-vrml",
        "vrml"
    ],
    [
        "application/x-wais-source",
        [
            "src",
            "wsrc"
        ]
    ],
    [
        "application/x-winhelp",
        "hlp"
    ],
    [
        "application/x-wintalk",
        "wtk"
    ],
    [
        "application/x-world",
        [
            "wrl",
            "svr"
        ]
    ],
    [
        "application/x-wpwin",
        "wpd"
    ],
    [
        "application/x-wri",
        "wri"
    ],
    [
        "application/x-x509-ca-cert",
        [
            "cer",
            "crt",
            "der"
        ]
    ],
    [
        "application/x-x509-user-cert",
        "crt"
    ],
    [
        "application/x-xfig",
        "fig"
    ],
    [
        "application/x-xpinstall",
        "xpi"
    ],
    [
        "application/x-zip-compressed",
        "zip"
    ],
    [
        "application/xcap-diff+xml",
        "xdf"
    ],
    [
        "application/xenc+xml",
        "xenc"
    ],
    [
        "application/xhtml+xml",
        "xhtml"
    ],
    [
        "application/xml",
        "xml"
    ],
    [
        "application/xml-dtd",
        "dtd"
    ],
    [
        "application/xop+xml",
        "xop"
    ],
    [
        "application/xslt+xml",
        "xslt"
    ],
    [
        "application/xspf+xml",
        "xspf"
    ],
    [
        "application/xv+xml",
        "mxml"
    ],
    [
        "application/yang",
        "yang"
    ],
    [
        "application/yin+xml",
        "yin"
    ],
    [
        "application/ynd.ms-pkipko",
        "pko"
    ],
    [
        "application/zip",
        "zip"
    ],
    [
        "audio/adpcm",
        "adp"
    ],
    [
        "audio/aiff",
        [
            "aiff",
            "aif",
            "aifc"
        ]
    ],
    [
        "audio/basic",
        [
            "snd",
            "au"
        ]
    ],
    [
        "audio/it",
        "it"
    ],
    [
        "audio/make",
        [
            "funk",
            "my",
            "pfunk"
        ]
    ],
    [
        "audio/make.my.funk",
        "pfunk"
    ],
    [
        "audio/mid",
        [
            "mid",
            "rmi"
        ]
    ],
    [
        "audio/midi",
        [
            "midi",
            "kar",
            "mid"
        ]
    ],
    [
        "audio/mod",
        "mod"
    ],
    [
        "audio/mp4",
        "mp4a"
    ],
    [
        "audio/mpeg",
        [
            "mpga",
            "mp3",
            "m2a",
            "mp2",
            "mpa",
            "mpg"
        ]
    ],
    [
        "audio/mpeg3",
        "mp3"
    ],
    [
        "audio/nspaudio",
        [
            "la",
            "lma"
        ]
    ],
    [
        "audio/ogg",
        "oga"
    ],
    [
        "audio/s3m",
        "s3m"
    ],
    [
        "audio/tsp-audio",
        "tsi"
    ],
    [
        "audio/tsplayer",
        "tsp"
    ],
    [
        "audio/vnd.dece.audio",
        "uva"
    ],
    [
        "audio/vnd.digital-winds",
        "eol"
    ],
    [
        "audio/vnd.dra",
        "dra"
    ],
    [
        "audio/vnd.dts",
        "dts"
    ],
    [
        "audio/vnd.dts.hd",
        "dtshd"
    ],
    [
        "audio/vnd.lucent.voice",
        "lvp"
    ],
    [
        "audio/vnd.ms-playready.media.pya",
        "pya"
    ],
    [
        "audio/vnd.nuera.ecelp4800",
        "ecelp4800"
    ],
    [
        "audio/vnd.nuera.ecelp7470",
        "ecelp7470"
    ],
    [
        "audio/vnd.nuera.ecelp9600",
        "ecelp9600"
    ],
    [
        "audio/vnd.qcelp",
        "qcp"
    ],
    [
        "audio/vnd.rip",
        "rip"
    ],
    [
        "audio/voc",
        "voc"
    ],
    [
        "audio/voxware",
        "vox"
    ],
    [
        "audio/wav",
        "wav"
    ],
    [
        "audio/webm",
        "weba"
    ],
    [
        "audio/x-aac",
        "aac"
    ],
    [
        "audio/x-adpcm",
        "snd"
    ],
    [
        "audio/x-aiff",
        [
            "aiff",
            "aif",
            "aifc"
        ]
    ],
    [
        "audio/x-au",
        "au"
    ],
    [
        "audio/x-gsm",
        [
            "gsd",
            "gsm"
        ]
    ],
    [
        "audio/x-jam",
        "jam"
    ],
    [
        "audio/x-liveaudio",
        "lam"
    ],
    [
        "audio/x-mid",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "audio/x-midi",
        [
            "midi",
            "mid"
        ]
    ],
    [
        "audio/x-mod",
        "mod"
    ],
    [
        "audio/x-mpeg",
        "mp2"
    ],
    [
        "audio/x-mpeg-3",
        "mp3"
    ],
    [
        "audio/x-mpegurl",
        "m3u"
    ],
    [
        "audio/x-mpequrl",
        "m3u"
    ],
    [
        "audio/x-ms-wax",
        "wax"
    ],
    [
        "audio/x-ms-wma",
        "wma"
    ],
    [
        "audio/x-nspaudio",
        [
            "la",
            "lma"
        ]
    ],
    [
        "audio/x-pn-realaudio",
        [
            "ra",
            "ram",
            "rm",
            "rmm",
            "rmp"
        ]
    ],
    [
        "audio/x-pn-realaudio-plugin",
        [
            "ra",
            "rmp",
            "rpm"
        ]
    ],
    [
        "audio/x-psid",
        "sid"
    ],
    [
        "audio/x-realaudio",
        "ra"
    ],
    [
        "audio/x-twinvq",
        "vqf"
    ],
    [
        "audio/x-twinvq-plugin",
        [
            "vqe",
            "vql"
        ]
    ],
    [
        "audio/x-vnd.audioexplosion.mjuicemediafile",
        "mjf"
    ],
    [
        "audio/x-voc",
        "voc"
    ],
    [
        "audio/x-wav",
        "wav"
    ],
    [
        "audio/xm",
        "xm"
    ],
    [
        "chemical/x-cdx",
        "cdx"
    ],
    [
        "chemical/x-cif",
        "cif"
    ],
    [
        "chemical/x-cmdf",
        "cmdf"
    ],
    [
        "chemical/x-cml",
        "cml"
    ],
    [
        "chemical/x-csml",
        "csml"
    ],
    [
        "chemical/x-pdb",
        [
            "pdb",
            "xyz"
        ]
    ],
    [
        "chemical/x-xyz",
        "xyz"
    ],
    [
        "drawing/x-dwf",
        "dwf"
    ],
    [
        "i-world/i-vrml",
        "ivr"
    ],
    [
        "image/bmp",
        [
            "bmp",
            "bm"
        ]
    ],
    [
        "image/cgm",
        "cgm"
    ],
    [
        "image/cis-cod",
        "cod"
    ],
    [
        "image/cmu-raster",
        [
            "ras",
            "rast"
        ]
    ],
    [
        "image/fif",
        "fif"
    ],
    [
        "image/florian",
        [
            "flo",
            "turbot"
        ]
    ],
    [
        "image/g3fax",
        "g3"
    ],
    [
        "image/gif",
        "gif"
    ],
    [
        "image/ief",
        [
            "ief",
            "iefs"
        ]
    ],
    [
        "image/jpeg",
        [
            "jpeg",
            "jpe",
            "jpg",
            "jfif",
            "jfif-tbnl"
        ]
    ],
    [
        "image/jutvision",
        "jut"
    ],
    [
        "image/ktx",
        "ktx"
    ],
    [
        "image/naplps",
        [
            "nap",
            "naplps"
        ]
    ],
    [
        "image/pict",
        [
            "pic",
            "pict"
        ]
    ],
    [
        "image/pipeg",
        "jfif"
    ],
    [
        "image/pjpeg",
        [
            "jfif",
            "jpe",
            "jpeg",
            "jpg"
        ]
    ],
    [
        "image/png",
        [
            "png",
            "x-png"
        ]
    ],
    [
        "image/prs.btif",
        "btif"
    ],
    [
        "image/svg+xml",
        "svg"
    ],
    [
        "image/tiff",
        [
            "tif",
            "tiff"
        ]
    ],
    [
        "image/vasa",
        "mcf"
    ],
    [
        "image/vnd.adobe.photoshop",
        "psd"
    ],
    [
        "image/vnd.dece.graphic",
        "uvi"
    ],
    [
        "image/vnd.djvu",
        "djvu"
    ],
    [
        "image/vnd.dvb.subtitle",
        "sub"
    ],
    [
        "image/vnd.dwg",
        [
            "dwg",
            "dxf",
            "svf"
        ]
    ],
    [
        "image/vnd.dxf",
        "dxf"
    ],
    [
        "image/vnd.fastbidsheet",
        "fbs"
    ],
    [
        "image/vnd.fpx",
        "fpx"
    ],
    [
        "image/vnd.fst",
        "fst"
    ],
    [
        "image/vnd.fujixerox.edmics-mmr",
        "mmr"
    ],
    [
        "image/vnd.fujixerox.edmics-rlc",
        "rlc"
    ],
    [
        "image/vnd.ms-modi",
        "mdi"
    ],
    [
        "image/vnd.net-fpx",
        [
            "fpx",
            "npx"
        ]
    ],
    [
        "image/vnd.rn-realflash",
        "rf"
    ],
    [
        "image/vnd.rn-realpix",
        "rp"
    ],
    [
        "image/vnd.wap.wbmp",
        "wbmp"
    ],
    [
        "image/vnd.xiff",
        "xif"
    ],
    [
        "image/webp",
        "webp"
    ],
    [
        "image/x-cmu-raster",
        "ras"
    ],
    [
        "image/x-cmx",
        "cmx"
    ],
    [
        "image/x-dwg",
        [
            "dwg",
            "dxf",
            "svf"
        ]
    ],
    [
        "image/x-freehand",
        "fh"
    ],
    [
        "image/x-icon",
        "ico"
    ],
    [
        "image/x-jg",
        "art"
    ],
    [
        "image/x-jps",
        "jps"
    ],
    [
        "image/x-niff",
        [
            "niff",
            "nif"
        ]
    ],
    [
        "image/x-pcx",
        "pcx"
    ],
    [
        "image/x-pict",
        [
            "pct",
            "pic"
        ]
    ],
    [
        "image/x-portable-anymap",
        "pnm"
    ],
    [
        "image/x-portable-bitmap",
        "pbm"
    ],
    [
        "image/x-portable-graymap",
        "pgm"
    ],
    [
        "image/x-portable-greymap",
        "pgm"
    ],
    [
        "image/x-portable-pixmap",
        "ppm"
    ],
    [
        "image/x-quicktime",
        [
            "qif",
            "qti",
            "qtif"
        ]
    ],
    [
        "image/x-rgb",
        "rgb"
    ],
    [
        "image/x-tiff",
        [
            "tif",
            "tiff"
        ]
    ],
    [
        "image/x-windows-bmp",
        "bmp"
    ],
    [
        "image/x-xbitmap",
        "xbm"
    ],
    [
        "image/x-xbm",
        "xbm"
    ],
    [
        "image/x-xpixmap",
        [
            "xpm",
            "pm"
        ]
    ],
    [
        "image/x-xwd",
        "xwd"
    ],
    [
        "image/x-xwindowdump",
        "xwd"
    ],
    [
        "image/xbm",
        "xbm"
    ],
    [
        "image/xpm",
        "xpm"
    ],
    [
        "message/rfc822",
        [
            "eml",
            "mht",
            "mhtml",
            "nws",
            "mime"
        ]
    ],
    [
        "model/iges",
        [
            "iges",
            "igs"
        ]
    ],
    [
        "model/mesh",
        "msh"
    ],
    [
        "model/vnd.collada+xml",
        "dae"
    ],
    [
        "model/vnd.dwf",
        "dwf"
    ],
    [
        "model/vnd.gdl",
        "gdl"
    ],
    [
        "model/vnd.gtw",
        "gtw"
    ],
    [
        "model/vnd.mts",
        "mts"
    ],
    [
        "model/vnd.vtu",
        "vtu"
    ],
    [
        "model/vrml",
        [
            "vrml",
            "wrl",
            "wrz"
        ]
    ],
    [
        "model/x-pov",
        "pov"
    ],
    [
        "multipart/x-gzip",
        "gzip"
    ],
    [
        "multipart/x-ustar",
        "ustar"
    ],
    [
        "multipart/x-zip",
        "zip"
    ],
    [
        "music/crescendo",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "music/x-karaoke",
        "kar"
    ],
    [
        "paleovu/x-pv",
        "pvu"
    ],
    [
        "text/asp",
        "asp"
    ],
    [
        "text/calendar",
        "ics"
    ],
    [
        "text/css",
        "css"
    ],
    [
        "text/csv",
        "csv"
    ],
    [
        "text/ecmascript",
        "js"
    ],
    [
        "text/h323",
        "323"
    ],
    [
        "text/html",
        [
            "html",
            "htm",
            "stm",
            "acgi",
            "htmls",
            "htx",
            "shtml"
        ]
    ],
    [
        "text/iuls",
        "uls"
    ],
    [
        "text/javascript",
        "js"
    ],
    [
        "text/mcf",
        "mcf"
    ],
    [
        "text/n3",
        "n3"
    ],
    [
        "text/pascal",
        "pas"
    ],
    [
        "text/plain",
        [
            "txt",
            "bas",
            "c",
            "h",
            "c++",
            "cc",
            "com",
            "conf",
            "cxx",
            "def",
            "f",
            "f90",
            "for",
            "g",
            "hh",
            "idc",
            "jav",
            "java",
            "list",
            "log",
            "lst",
            "m",
            "mar",
            "pl",
            "sdml",
            "text"
        ]
    ],
    [
        "text/plain-bas",
        "par"
    ],
    [
        "text/prs.lines.tag",
        "dsc"
    ],
    [
        "text/richtext",
        [
            "rtx",
            "rt",
            "rtf"
        ]
    ],
    [
        "text/scriplet",
        "wsc"
    ],
    [
        "text/scriptlet",
        "sct"
    ],
    [
        "text/sgml",
        [
            "sgm",
            "sgml"
        ]
    ],
    [
        "text/tab-separated-values",
        "tsv"
    ],
    [
        "text/troff",
        "t"
    ],
    [
        "text/turtle",
        "ttl"
    ],
    [
        "text/uri-list",
        [
            "uni",
            "unis",
            "uri",
            "uris"
        ]
    ],
    [
        "text/vnd.abc",
        "abc"
    ],
    [
        "text/vnd.curl",
        "curl"
    ],
    [
        "text/vnd.curl.dcurl",
        "dcurl"
    ],
    [
        "text/vnd.curl.mcurl",
        "mcurl"
    ],
    [
        "text/vnd.curl.scurl",
        "scurl"
    ],
    [
        "text/vnd.fly",
        "fly"
    ],
    [
        "text/vnd.fmi.flexstor",
        "flx"
    ],
    [
        "text/vnd.graphviz",
        "gv"
    ],
    [
        "text/vnd.in3d.3dml",
        "3dml"
    ],
    [
        "text/vnd.in3d.spot",
        "spot"
    ],
    [
        "text/vnd.rn-realtext",
        "rt"
    ],
    [
        "text/vnd.sun.j2me.app-descriptor",
        "jad"
    ],
    [
        "text/vnd.wap.wml",
        "wml"
    ],
    [
        "text/vnd.wap.wmlscript",
        "wmls"
    ],
    [
        "text/webviewhtml",
        "htt"
    ],
    [
        "text/x-asm",
        [
            "asm",
            "s"
        ]
    ],
    [
        "text/x-audiosoft-intra",
        "aip"
    ],
    [
        "text/x-c",
        [
            "c",
            "cc",
            "cpp"
        ]
    ],
    [
        "text/x-component",
        "htc"
    ],
    [
        "text/x-fortran",
        [
            "for",
            "f",
            "f77",
            "f90"
        ]
    ],
    [
        "text/x-h",
        [
            "h",
            "hh"
        ]
    ],
    [
        "text/x-java-source",
        [
            "java",
            "jav"
        ]
    ],
    [
        "text/x-java-source,java",
        "java"
    ],
    [
        "text/x-la-asf",
        "lsx"
    ],
    [
        "text/x-m",
        "m"
    ],
    [
        "text/x-pascal",
        "p"
    ],
    [
        "text/x-script",
        "hlb"
    ],
    [
        "text/x-script.csh",
        "csh"
    ],
    [
        "text/x-script.elisp",
        "el"
    ],
    [
        "text/x-script.guile",
        "scm"
    ],
    [
        "text/x-script.ksh",
        "ksh"
    ],
    [
        "text/x-script.lisp",
        "lsp"
    ],
    [
        "text/x-script.perl",
        "pl"
    ],
    [
        "text/x-script.perl-module",
        "pm"
    ],
    [
        "text/x-script.phyton",
        "py"
    ],
    [
        "text/x-script.rexx",
        "rexx"
    ],
    [
        "text/x-script.scheme",
        "scm"
    ],
    [
        "text/x-script.sh",
        "sh"
    ],
    [
        "text/x-script.tcl",
        "tcl"
    ],
    [
        "text/x-script.tcsh",
        "tcsh"
    ],
    [
        "text/x-script.zsh",
        "zsh"
    ],
    [
        "text/x-server-parsed-html",
        [
            "shtml",
            "ssi"
        ]
    ],
    [
        "text/x-setext",
        "etx"
    ],
    [
        "text/x-sgml",
        [
            "sgm",
            "sgml"
        ]
    ],
    [
        "text/x-speech",
        [
            "spc",
            "talk"
        ]
    ],
    [
        "text/x-uil",
        "uil"
    ],
    [
        "text/x-uuencode",
        [
            "uu",
            "uue"
        ]
    ],
    [
        "text/x-vcalendar",
        "vcs"
    ],
    [
        "text/x-vcard",
        "vcf"
    ],
    [
        "text/xml",
        "xml"
    ],
    [
        "video/3gpp",
        "3gp"
    ],
    [
        "video/3gpp2",
        "3g2"
    ],
    [
        "video/animaflex",
        "afl"
    ],
    [
        "video/avi",
        "avi"
    ],
    [
        "video/avs-video",
        "avs"
    ],
    [
        "video/dl",
        "dl"
    ],
    [
        "video/fli",
        "fli"
    ],
    [
        "video/gl",
        "gl"
    ],
    [
        "video/h261",
        "h261"
    ],
    [
        "video/h263",
        "h263"
    ],
    [
        "video/h264",
        "h264"
    ],
    [
        "video/jpeg",
        "jpgv"
    ],
    [
        "video/jpm",
        "jpm"
    ],
    [
        "video/mj2",
        "mj2"
    ],
    [
        "video/mp4",
        "mp4"
    ],
    [
        "video/mpeg",
        [
            "mpeg",
            "mp2",
            "mpa",
            "mpe",
            "mpg",
            "mpv2",
            "m1v",
            "m2v",
            "mp3"
        ]
    ],
    [
        "video/msvideo",
        "avi"
    ],
    [
        "video/ogg",
        "ogv"
    ],
    [
        "video/quicktime",
        [
            "mov",
            "qt",
            "moov"
        ]
    ],
    [
        "video/vdo",
        "vdo"
    ],
    [
        "video/vivo",
        [
            "viv",
            "vivo"
        ]
    ],
    [
        "video/vnd.dece.hd",
        "uvh"
    ],
    [
        "video/vnd.dece.mobile",
        "uvm"
    ],
    [
        "video/vnd.dece.pd",
        "uvp"
    ],
    [
        "video/vnd.dece.sd",
        "uvs"
    ],
    [
        "video/vnd.dece.video",
        "uvv"
    ],
    [
        "video/vnd.fvt",
        "fvt"
    ],
    [
        "video/vnd.mpegurl",
        "mxu"
    ],
    [
        "video/vnd.ms-playready.media.pyv",
        "pyv"
    ],
    [
        "video/vnd.rn-realvideo",
        "rv"
    ],
    [
        "video/vnd.uvvu.mp4",
        "uvu"
    ],
    [
        "video/vnd.vivo",
        [
            "viv",
            "vivo"
        ]
    ],
    [
        "video/vosaic",
        "vos"
    ],
    [
        "video/webm",
        "webm"
    ],
    [
        "video/x-amt-demorun",
        "xdr"
    ],
    [
        "video/x-amt-showrun",
        "xsr"
    ],
    [
        "video/x-atomic3d-feature",
        "fmf"
    ],
    [
        "video/x-dl",
        "dl"
    ],
    [
        "video/x-dv",
        [
            "dif",
            "dv"
        ]
    ],
    [
        "video/x-f4v",
        "f4v"
    ],
    [
        "video/x-fli",
        "fli"
    ],
    [
        "video/x-flv",
        "flv"
    ],
    [
        "video/x-gl",
        "gl"
    ],
    [
        "video/x-isvideo",
        "isu"
    ],
    [
        "video/x-la-asf",
        [
            "lsf",
            "lsx"
        ]
    ],
    [
        "video/x-m4v",
        "m4v"
    ],
    [
        "video/x-motion-jpeg",
        "mjpg"
    ],
    [
        "video/x-mpeg",
        [
            "mp3",
            "mp2"
        ]
    ],
    [
        "video/x-mpeq2a",
        "mp2"
    ],
    [
        "video/x-ms-asf",
        [
            "asf",
            "asr",
            "asx"
        ]
    ],
    [
        "video/x-ms-asf-plugin",
        "asx"
    ],
    [
        "video/x-ms-wm",
        "wm"
    ],
    [
        "video/x-ms-wmv",
        "wmv"
    ],
    [
        "video/x-ms-wmx",
        "wmx"
    ],
    [
        "video/x-ms-wvx",
        "wvx"
    ],
    [
        "video/x-msvideo",
        "avi"
    ],
    [
        "video/x-qtc",
        "qtc"
    ],
    [
        "video/x-scm",
        "scm"
    ],
    [
        "video/x-sgi-movie",
        [
            "movie",
            "mv"
        ]
    ],
    [
        "windows/metafile",
        "wmf"
    ],
    [
        "www/mime",
        "mime"
    ],
    [
        "x-conference/x-cooltalk",
        "ice"
    ],
    [
        "x-music/x-midi",
        [
            "mid",
            "midi"
        ]
    ],
    [
        "x-world/x-3dmf",
        [
            "3dm",
            "3dmf",
            "qd3",
            "qd3d"
        ]
    ],
    [
        "x-world/x-svr",
        "svr"
    ],
    [
        "x-world/x-vrml",
        [
            "flr",
            "vrml",
            "wrl",
            "wrz",
            "xaf",
            "xof"
        ]
    ],
    [
        "x-world/x-vrt",
        "vrt"
    ],
    [
        "xgl/drawing",
        "xgz"
    ],
    [
        "xgl/movie",
        "xmz"
    ]
]);
const extensions = new Map([
    [
        "123",
        "application/vnd.lotus-1-2-3"
    ],
    [
        "323",
        "text/h323"
    ],
    [
        "*",
        "application/octet-stream"
    ],
    [
        "3dm",
        "x-world/x-3dmf"
    ],
    [
        "3dmf",
        "x-world/x-3dmf"
    ],
    [
        "3dml",
        "text/vnd.in3d.3dml"
    ],
    [
        "3g2",
        "video/3gpp2"
    ],
    [
        "3gp",
        "video/3gpp"
    ],
    [
        "7z",
        "application/x-7z-compressed"
    ],
    [
        "a",
        "application/octet-stream"
    ],
    [
        "aab",
        "application/x-authorware-bin"
    ],
    [
        "aac",
        "audio/x-aac"
    ],
    [
        "aam",
        "application/x-authorware-map"
    ],
    [
        "aas",
        "application/x-authorware-seg"
    ],
    [
        "abc",
        "text/vnd.abc"
    ],
    [
        "abw",
        "application/x-abiword"
    ],
    [
        "ac",
        "application/pkix-attr-cert"
    ],
    [
        "acc",
        "application/vnd.americandynamics.acc"
    ],
    [
        "ace",
        "application/x-ace-compressed"
    ],
    [
        "acgi",
        "text/html"
    ],
    [
        "acu",
        "application/vnd.acucobol"
    ],
    [
        "acx",
        "application/internet-property-stream"
    ],
    [
        "adp",
        "audio/adpcm"
    ],
    [
        "aep",
        "application/vnd.audiograph"
    ],
    [
        "afl",
        "video/animaflex"
    ],
    [
        "afp",
        "application/vnd.ibm.modcap"
    ],
    [
        "ahead",
        "application/vnd.ahead.space"
    ],
    [
        "ai",
        "application/postscript"
    ],
    [
        "aif",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aifc",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aiff",
        [
            "audio/aiff",
            "audio/x-aiff"
        ]
    ],
    [
        "aim",
        "application/x-aim"
    ],
    [
        "aip",
        "text/x-audiosoft-intra"
    ],
    [
        "air",
        "application/vnd.adobe.air-application-installer-package+zip"
    ],
    [
        "ait",
        "application/vnd.dvb.ait"
    ],
    [
        "ami",
        "application/vnd.amiga.ami"
    ],
    [
        "ani",
        "application/x-navi-animation"
    ],
    [
        "aos",
        "application/x-nokia-9000-communicator-add-on-software"
    ],
    [
        "apk",
        "application/vnd.android.package-archive"
    ],
    [
        "application",
        "application/x-ms-application"
    ],
    [
        "apr",
        "application/vnd.lotus-approach"
    ],
    [
        "aps",
        "application/mime"
    ],
    [
        "arc",
        "application/octet-stream"
    ],
    [
        "arj",
        [
            "application/arj",
            "application/octet-stream"
        ]
    ],
    [
        "art",
        "image/x-jg"
    ],
    [
        "asf",
        "video/x-ms-asf"
    ],
    [
        "asm",
        "text/x-asm"
    ],
    [
        "aso",
        "application/vnd.accpac.simply.aso"
    ],
    [
        "asp",
        "text/asp"
    ],
    [
        "asr",
        "video/x-ms-asf"
    ],
    [
        "asx",
        [
            "video/x-ms-asf",
            "application/x-mplayer2",
            "video/x-ms-asf-plugin"
        ]
    ],
    [
        "atc",
        "application/vnd.acucorp"
    ],
    [
        "atomcat",
        "application/atomcat+xml"
    ],
    [
        "atomsvc",
        "application/atomsvc+xml"
    ],
    [
        "atx",
        "application/vnd.antix.game-component"
    ],
    [
        "au",
        [
            "audio/basic",
            "audio/x-au"
        ]
    ],
    [
        "avi",
        [
            "video/avi",
            "video/msvideo",
            "application/x-troff-msvideo",
            "video/x-msvideo"
        ]
    ],
    [
        "avs",
        "video/avs-video"
    ],
    [
        "aw",
        "application/applixware"
    ],
    [
        "axs",
        "application/olescript"
    ],
    [
        "azf",
        "application/vnd.airzip.filesecure.azf"
    ],
    [
        "azs",
        "application/vnd.airzip.filesecure.azs"
    ],
    [
        "azw",
        "application/vnd.amazon.ebook"
    ],
    [
        "bas",
        "text/plain"
    ],
    [
        "bcpio",
        "application/x-bcpio"
    ],
    [
        "bdf",
        "application/x-font-bdf"
    ],
    [
        "bdm",
        "application/vnd.syncml.dm+wbxml"
    ],
    [
        "bed",
        "application/vnd.realvnc.bed"
    ],
    [
        "bh2",
        "application/vnd.fujitsu.oasysprs"
    ],
    [
        "bin",
        [
            "application/octet-stream",
            "application/mac-binary",
            "application/macbinary",
            "application/x-macbinary",
            "application/x-binary"
        ]
    ],
    [
        "bm",
        "image/bmp"
    ],
    [
        "bmi",
        "application/vnd.bmi"
    ],
    [
        "bmp",
        [
            "image/bmp",
            "image/x-windows-bmp"
        ]
    ],
    [
        "boo",
        "application/book"
    ],
    [
        "book",
        "application/book"
    ],
    [
        "box",
        "application/vnd.previewsystems.box"
    ],
    [
        "boz",
        "application/x-bzip2"
    ],
    [
        "bsh",
        "application/x-bsh"
    ],
    [
        "btif",
        "image/prs.btif"
    ],
    [
        "bz",
        "application/x-bzip"
    ],
    [
        "bz2",
        "application/x-bzip2"
    ],
    [
        "c",
        [
            "text/plain",
            "text/x-c"
        ]
    ],
    [
        "c++",
        "text/plain"
    ],
    [
        "c11amc",
        "application/vnd.cluetrust.cartomobile-config"
    ],
    [
        "c11amz",
        "application/vnd.cluetrust.cartomobile-config-pkg"
    ],
    [
        "c4g",
        "application/vnd.clonk.c4group"
    ],
    [
        "cab",
        "application/vnd.ms-cab-compressed"
    ],
    [
        "car",
        "application/vnd.curl.car"
    ],
    [
        "cat",
        [
            "application/vnd.ms-pkiseccat",
            "application/vnd.ms-pki.seccat"
        ]
    ],
    [
        "cc",
        [
            "text/plain",
            "text/x-c"
        ]
    ],
    [
        "ccad",
        "application/clariscad"
    ],
    [
        "cco",
        "application/x-cocoa"
    ],
    [
        "ccxml",
        "application/ccxml+xml,"
    ],
    [
        "cdbcmsg",
        "application/vnd.contact.cmsg"
    ],
    [
        "cdf",
        [
            "application/cdf",
            "application/x-cdf",
            "application/x-netcdf"
        ]
    ],
    [
        "cdkey",
        "application/vnd.mediastation.cdkey"
    ],
    [
        "cdmia",
        "application/cdmi-capability"
    ],
    [
        "cdmic",
        "application/cdmi-container"
    ],
    [
        "cdmid",
        "application/cdmi-domain"
    ],
    [
        "cdmio",
        "application/cdmi-object"
    ],
    [
        "cdmiq",
        "application/cdmi-queue"
    ],
    [
        "cdx",
        "chemical/x-cdx"
    ],
    [
        "cdxml",
        "application/vnd.chemdraw+xml"
    ],
    [
        "cdy",
        "application/vnd.cinderella"
    ],
    [
        "cer",
        [
            "application/pkix-cert",
            "application/x-x509-ca-cert"
        ]
    ],
    [
        "cgm",
        "image/cgm"
    ],
    [
        "cha",
        "application/x-chat"
    ],
    [
        "chat",
        "application/x-chat"
    ],
    [
        "chm",
        "application/vnd.ms-htmlhelp"
    ],
    [
        "chrt",
        "application/vnd.kde.kchart"
    ],
    [
        "cif",
        "chemical/x-cif"
    ],
    [
        "cii",
        "application/vnd.anser-web-certificate-issue-initiation"
    ],
    [
        "cil",
        "application/vnd.ms-artgalry"
    ],
    [
        "cla",
        "application/vnd.claymore"
    ],
    [
        "class",
        [
            "application/octet-stream",
            "application/java",
            "application/java-byte-code",
            "application/java-vm",
            "application/x-java-class"
        ]
    ],
    [
        "clkk",
        "application/vnd.crick.clicker.keyboard"
    ],
    [
        "clkp",
        "application/vnd.crick.clicker.palette"
    ],
    [
        "clkt",
        "application/vnd.crick.clicker.template"
    ],
    [
        "clkw",
        "application/vnd.crick.clicker.wordbank"
    ],
    [
        "clkx",
        "application/vnd.crick.clicker"
    ],
    [
        "clp",
        "application/x-msclip"
    ],
    [
        "cmc",
        "application/vnd.cosmocaller"
    ],
    [
        "cmdf",
        "chemical/x-cmdf"
    ],
    [
        "cml",
        "chemical/x-cml"
    ],
    [
        "cmp",
        "application/vnd.yellowriver-custom-menu"
    ],
    [
        "cmx",
        "image/x-cmx"
    ],
    [
        "cod",
        [
            "image/cis-cod",
            "application/vnd.rim.cod"
        ]
    ],
    [
        "com",
        [
            "application/octet-stream",
            "text/plain"
        ]
    ],
    [
        "conf",
        "text/plain"
    ],
    [
        "cpio",
        "application/x-cpio"
    ],
    [
        "cpp",
        "text/x-c"
    ],
    [
        "cpt",
        [
            "application/mac-compactpro",
            "application/x-compactpro",
            "application/x-cpt"
        ]
    ],
    [
        "crd",
        "application/x-mscardfile"
    ],
    [
        "crl",
        [
            "application/pkix-crl",
            "application/pkcs-crl"
        ]
    ],
    [
        "crt",
        [
            "application/pkix-cert",
            "application/x-x509-user-cert",
            "application/x-x509-ca-cert"
        ]
    ],
    [
        "cryptonote",
        "application/vnd.rig.cryptonote"
    ],
    [
        "csh",
        [
            "text/x-script.csh",
            "application/x-csh"
        ]
    ],
    [
        "csml",
        "chemical/x-csml"
    ],
    [
        "csp",
        "application/vnd.commonspace"
    ],
    [
        "css",
        [
            "text/css",
            "application/x-pointplus"
        ]
    ],
    [
        "csv",
        "text/csv"
    ],
    [
        "cu",
        "application/cu-seeme"
    ],
    [
        "curl",
        "text/vnd.curl"
    ],
    [
        "cww",
        "application/prs.cww"
    ],
    [
        "cxx",
        "text/plain"
    ],
    [
        "dae",
        "model/vnd.collada+xml"
    ],
    [
        "daf",
        "application/vnd.mobius.daf"
    ],
    [
        "davmount",
        "application/davmount+xml"
    ],
    [
        "dcr",
        "application/x-director"
    ],
    [
        "dcurl",
        "text/vnd.curl.dcurl"
    ],
    [
        "dd2",
        "application/vnd.oma.dd2+xml"
    ],
    [
        "ddd",
        "application/vnd.fujixerox.ddd"
    ],
    [
        "deb",
        "application/x-debian-package"
    ],
    [
        "deepv",
        "application/x-deepv"
    ],
    [
        "def",
        "text/plain"
    ],
    [
        "der",
        "application/x-x509-ca-cert"
    ],
    [
        "dfac",
        "application/vnd.dreamfactory"
    ],
    [
        "dif",
        "video/x-dv"
    ],
    [
        "dir",
        "application/x-director"
    ],
    [
        "dis",
        "application/vnd.mobius.dis"
    ],
    [
        "djvu",
        "image/vnd.djvu"
    ],
    [
        "dl",
        [
            "video/dl",
            "video/x-dl"
        ]
    ],
    [
        "dll",
        "application/x-msdownload"
    ],
    [
        "dms",
        "application/octet-stream"
    ],
    [
        "dna",
        "application/vnd.dna"
    ],
    [
        "doc",
        "application/msword"
    ],
    [
        "docm",
        "application/vnd.ms-word.document.macroenabled.12"
    ],
    [
        "docx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    ],
    [
        "dot",
        "application/msword"
    ],
    [
        "dotm",
        "application/vnd.ms-word.template.macroenabled.12"
    ],
    [
        "dotx",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template"
    ],
    [
        "dp",
        [
            "application/commonground",
            "application/vnd.osgi.dp"
        ]
    ],
    [
        "dpg",
        "application/vnd.dpgraph"
    ],
    [
        "dra",
        "audio/vnd.dra"
    ],
    [
        "drw",
        "application/drafting"
    ],
    [
        "dsc",
        "text/prs.lines.tag"
    ],
    [
        "dssc",
        "application/dssc+der"
    ],
    [
        "dtb",
        "application/x-dtbook+xml"
    ],
    [
        "dtd",
        "application/xml-dtd"
    ],
    [
        "dts",
        "audio/vnd.dts"
    ],
    [
        "dtshd",
        "audio/vnd.dts.hd"
    ],
    [
        "dump",
        "application/octet-stream"
    ],
    [
        "dv",
        "video/x-dv"
    ],
    [
        "dvi",
        "application/x-dvi"
    ],
    [
        "dwf",
        [
            "model/vnd.dwf",
            "drawing/x-dwf"
        ]
    ],
    [
        "dwg",
        [
            "application/acad",
            "image/vnd.dwg",
            "image/x-dwg"
        ]
    ],
    [
        "dxf",
        [
            "application/dxf",
            "image/vnd.dwg",
            "image/vnd.dxf",
            "image/x-dwg"
        ]
    ],
    [
        "dxp",
        "application/vnd.spotfire.dxp"
    ],
    [
        "dxr",
        "application/x-director"
    ],
    [
        "ecelp4800",
        "audio/vnd.nuera.ecelp4800"
    ],
    [
        "ecelp7470",
        "audio/vnd.nuera.ecelp7470"
    ],
    [
        "ecelp9600",
        "audio/vnd.nuera.ecelp9600"
    ],
    [
        "edm",
        "application/vnd.novadigm.edm"
    ],
    [
        "edx",
        "application/vnd.novadigm.edx"
    ],
    [
        "efif",
        "application/vnd.picsel"
    ],
    [
        "ei6",
        "application/vnd.pg.osasli"
    ],
    [
        "el",
        "text/x-script.elisp"
    ],
    [
        "elc",
        [
            "application/x-elc",
            "application/x-bytecode.elisp"
        ]
    ],
    [
        "eml",
        "message/rfc822"
    ],
    [
        "emma",
        "application/emma+xml"
    ],
    [
        "env",
        "application/x-envoy"
    ],
    [
        "eol",
        "audio/vnd.digital-winds"
    ],
    [
        "eot",
        "application/vnd.ms-fontobject"
    ],
    [
        "eps",
        "application/postscript"
    ],
    [
        "epub",
        "application/epub+zip"
    ],
    [
        "es",
        [
            "application/ecmascript",
            "application/x-esrehber"
        ]
    ],
    [
        "es3",
        "application/vnd.eszigno3+xml"
    ],
    [
        "esf",
        "application/vnd.epson.esf"
    ],
    [
        "etx",
        "text/x-setext"
    ],
    [
        "evy",
        [
            "application/envoy",
            "application/x-envoy"
        ]
    ],
    [
        "exe",
        [
            "application/octet-stream",
            "application/x-msdownload"
        ]
    ],
    [
        "exi",
        "application/exi"
    ],
    [
        "ext",
        "application/vnd.novadigm.ext"
    ],
    [
        "ez2",
        "application/vnd.ezpix-album"
    ],
    [
        "ez3",
        "application/vnd.ezpix-package"
    ],
    [
        "f",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "f4v",
        "video/x-f4v"
    ],
    [
        "f77",
        "text/x-fortran"
    ],
    [
        "f90",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "fbs",
        "image/vnd.fastbidsheet"
    ],
    [
        "fcs",
        "application/vnd.isac.fcs"
    ],
    [
        "fdf",
        "application/vnd.fdf"
    ],
    [
        "fe_launch",
        "application/vnd.denovo.fcselayout-link"
    ],
    [
        "fg5",
        "application/vnd.fujitsu.oasysgp"
    ],
    [
        "fh",
        "image/x-freehand"
    ],
    [
        "fif",
        [
            "application/fractals",
            "image/fif"
        ]
    ],
    [
        "fig",
        "application/x-xfig"
    ],
    [
        "fli",
        [
            "video/fli",
            "video/x-fli"
        ]
    ],
    [
        "flo",
        [
            "image/florian",
            "application/vnd.micrografx.flo"
        ]
    ],
    [
        "flr",
        "x-world/x-vrml"
    ],
    [
        "flv",
        "video/x-flv"
    ],
    [
        "flw",
        "application/vnd.kde.kivio"
    ],
    [
        "flx",
        "text/vnd.fmi.flexstor"
    ],
    [
        "fly",
        "text/vnd.fly"
    ],
    [
        "fm",
        "application/vnd.framemaker"
    ],
    [
        "fmf",
        "video/x-atomic3d-feature"
    ],
    [
        "fnc",
        "application/vnd.frogans.fnc"
    ],
    [
        "for",
        [
            "text/plain",
            "text/x-fortran"
        ]
    ],
    [
        "fpx",
        [
            "image/vnd.fpx",
            "image/vnd.net-fpx"
        ]
    ],
    [
        "frl",
        "application/freeloader"
    ],
    [
        "fsc",
        "application/vnd.fsc.weblaunch"
    ],
    [
        "fst",
        "image/vnd.fst"
    ],
    [
        "ftc",
        "application/vnd.fluxtime.clip"
    ],
    [
        "fti",
        "application/vnd.anser-web-funds-transfer-initiation"
    ],
    [
        "funk",
        "audio/make"
    ],
    [
        "fvt",
        "video/vnd.fvt"
    ],
    [
        "fxp",
        "application/vnd.adobe.fxp"
    ],
    [
        "fzs",
        "application/vnd.fuzzysheet"
    ],
    [
        "g",
        "text/plain"
    ],
    [
        "g2w",
        "application/vnd.geoplan"
    ],
    [
        "g3",
        "image/g3fax"
    ],
    [
        "g3w",
        "application/vnd.geospace"
    ],
    [
        "gac",
        "application/vnd.groove-account"
    ],
    [
        "gdl",
        "model/vnd.gdl"
    ],
    [
        "geo",
        "application/vnd.dynageo"
    ],
    [
        "gex",
        "application/vnd.geometry-explorer"
    ],
    [
        "ggb",
        "application/vnd.geogebra.file"
    ],
    [
        "ggt",
        "application/vnd.geogebra.tool"
    ],
    [
        "ghf",
        "application/vnd.groove-help"
    ],
    [
        "gif",
        "image/gif"
    ],
    [
        "gim",
        "application/vnd.groove-identity-message"
    ],
    [
        "gl",
        [
            "video/gl",
            "video/x-gl"
        ]
    ],
    [
        "gmx",
        "application/vnd.gmx"
    ],
    [
        "gnumeric",
        "application/x-gnumeric"
    ],
    [
        "gph",
        "application/vnd.flographit"
    ],
    [
        "gqf",
        "application/vnd.grafeq"
    ],
    [
        "gram",
        "application/srgs"
    ],
    [
        "grv",
        "application/vnd.groove-injector"
    ],
    [
        "grxml",
        "application/srgs+xml"
    ],
    [
        "gsd",
        "audio/x-gsm"
    ],
    [
        "gsf",
        "application/x-font-ghostscript"
    ],
    [
        "gsm",
        "audio/x-gsm"
    ],
    [
        "gsp",
        "application/x-gsp"
    ],
    [
        "gss",
        "application/x-gss"
    ],
    [
        "gtar",
        "application/x-gtar"
    ],
    [
        "gtm",
        "application/vnd.groove-tool-message"
    ],
    [
        "gtw",
        "model/vnd.gtw"
    ],
    [
        "gv",
        "text/vnd.graphviz"
    ],
    [
        "gxt",
        "application/vnd.geonext"
    ],
    [
        "gz",
        [
            "application/x-gzip",
            "application/x-compressed"
        ]
    ],
    [
        "gzip",
        [
            "multipart/x-gzip",
            "application/x-gzip"
        ]
    ],
    [
        "h",
        [
            "text/plain",
            "text/x-h"
        ]
    ],
    [
        "h261",
        "video/h261"
    ],
    [
        "h263",
        "video/h263"
    ],
    [
        "h264",
        "video/h264"
    ],
    [
        "hal",
        "application/vnd.hal+xml"
    ],
    [
        "hbci",
        "application/vnd.hbci"
    ],
    [
        "hdf",
        "application/x-hdf"
    ],
    [
        "help",
        "application/x-helpfile"
    ],
    [
        "hgl",
        "application/vnd.hp-hpgl"
    ],
    [
        "hh",
        [
            "text/plain",
            "text/x-h"
        ]
    ],
    [
        "hlb",
        "text/x-script"
    ],
    [
        "hlp",
        [
            "application/winhlp",
            "application/hlp",
            "application/x-helpfile",
            "application/x-winhelp"
        ]
    ],
    [
        "hpg",
        "application/vnd.hp-hpgl"
    ],
    [
        "hpgl",
        "application/vnd.hp-hpgl"
    ],
    [
        "hpid",
        "application/vnd.hp-hpid"
    ],
    [
        "hps",
        "application/vnd.hp-hps"
    ],
    [
        "hqx",
        [
            "application/mac-binhex40",
            "application/binhex",
            "application/binhex4",
            "application/mac-binhex",
            "application/x-binhex40",
            "application/x-mac-binhex40"
        ]
    ],
    [
        "hta",
        "application/hta"
    ],
    [
        "htc",
        "text/x-component"
    ],
    [
        "htke",
        "application/vnd.kenameaapp"
    ],
    [
        "htm",
        "text/html"
    ],
    [
        "html",
        "text/html"
    ],
    [
        "htmls",
        "text/html"
    ],
    [
        "htt",
        "text/webviewhtml"
    ],
    [
        "htx",
        "text/html"
    ],
    [
        "hvd",
        "application/vnd.yamaha.hv-dic"
    ],
    [
        "hvp",
        "application/vnd.yamaha.hv-voice"
    ],
    [
        "hvs",
        "application/vnd.yamaha.hv-script"
    ],
    [
        "i2g",
        "application/vnd.intergeo"
    ],
    [
        "icc",
        "application/vnd.iccprofile"
    ],
    [
        "ice",
        "x-conference/x-cooltalk"
    ],
    [
        "ico",
        "image/x-icon"
    ],
    [
        "ics",
        "text/calendar"
    ],
    [
        "idc",
        "text/plain"
    ],
    [
        "ief",
        "image/ief"
    ],
    [
        "iefs",
        "image/ief"
    ],
    [
        "ifm",
        "application/vnd.shana.informed.formdata"
    ],
    [
        "iges",
        [
            "application/iges",
            "model/iges"
        ]
    ],
    [
        "igl",
        "application/vnd.igloader"
    ],
    [
        "igm",
        "application/vnd.insors.igm"
    ],
    [
        "igs",
        [
            "application/iges",
            "model/iges"
        ]
    ],
    [
        "igx",
        "application/vnd.micrografx.igx"
    ],
    [
        "iif",
        "application/vnd.shana.informed.interchange"
    ],
    [
        "iii",
        "application/x-iphone"
    ],
    [
        "ima",
        "application/x-ima"
    ],
    [
        "imap",
        "application/x-httpd-imap"
    ],
    [
        "imp",
        "application/vnd.accpac.simply.imp"
    ],
    [
        "ims",
        "application/vnd.ms-ims"
    ],
    [
        "inf",
        "application/inf"
    ],
    [
        "ins",
        [
            "application/x-internet-signup",
            "application/x-internett-signup"
        ]
    ],
    [
        "ip",
        "application/x-ip2"
    ],
    [
        "ipfix",
        "application/ipfix"
    ],
    [
        "ipk",
        "application/vnd.shana.informed.package"
    ],
    [
        "irm",
        "application/vnd.ibm.rights-management"
    ],
    [
        "irp",
        "application/vnd.irepository.package+xml"
    ],
    [
        "isp",
        "application/x-internet-signup"
    ],
    [
        "isu",
        "video/x-isvideo"
    ],
    [
        "it",
        "audio/it"
    ],
    [
        "itp",
        "application/vnd.shana.informed.formtemplate"
    ],
    [
        "iv",
        "application/x-inventor"
    ],
    [
        "ivp",
        "application/vnd.immervision-ivp"
    ],
    [
        "ivr",
        "i-world/i-vrml"
    ],
    [
        "ivu",
        "application/vnd.immervision-ivu"
    ],
    [
        "ivy",
        "application/x-livescreen"
    ],
    [
        "jad",
        "text/vnd.sun.j2me.app-descriptor"
    ],
    [
        "jam",
        [
            "application/vnd.jam",
            "audio/x-jam"
        ]
    ],
    [
        "jar",
        "application/java-archive"
    ],
    [
        "jav",
        [
            "text/plain",
            "text/x-java-source"
        ]
    ],
    [
        "java",
        [
            "text/plain",
            "text/x-java-source,java",
            "text/x-java-source"
        ]
    ],
    [
        "jcm",
        "application/x-java-commerce"
    ],
    [
        "jfif",
        [
            "image/pipeg",
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jfif-tbnl",
        "image/jpeg"
    ],
    [
        "jisp",
        "application/vnd.jisp"
    ],
    [
        "jlt",
        "application/vnd.hp-jlyt"
    ],
    [
        "jnlp",
        "application/x-java-jnlp-file"
    ],
    [
        "joda",
        "application/vnd.joost.joda-archive"
    ],
    [
        "jpe",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpeg",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpg",
        [
            "image/jpeg",
            "image/pjpeg"
        ]
    ],
    [
        "jpgv",
        "video/jpeg"
    ],
    [
        "jpm",
        "video/jpm"
    ],
    [
        "jps",
        "image/x-jps"
    ],
    [
        "js",
        [
            "application/javascript",
            "application/ecmascript",
            "text/javascript",
            "text/ecmascript",
            "application/x-javascript"
        ]
    ],
    [
        "json",
        "application/json"
    ],
    [
        "jut",
        "image/jutvision"
    ],
    [
        "kar",
        [
            "audio/midi",
            "music/x-karaoke"
        ]
    ],
    [
        "karbon",
        "application/vnd.kde.karbon"
    ],
    [
        "kfo",
        "application/vnd.kde.kformula"
    ],
    [
        "kia",
        "application/vnd.kidspiration"
    ],
    [
        "kml",
        "application/vnd.google-earth.kml+xml"
    ],
    [
        "kmz",
        "application/vnd.google-earth.kmz"
    ],
    [
        "kne",
        "application/vnd.kinar"
    ],
    [
        "kon",
        "application/vnd.kde.kontour"
    ],
    [
        "kpr",
        "application/vnd.kde.kpresenter"
    ],
    [
        "ksh",
        [
            "application/x-ksh",
            "text/x-script.ksh"
        ]
    ],
    [
        "ksp",
        "application/vnd.kde.kspread"
    ],
    [
        "ktx",
        "image/ktx"
    ],
    [
        "ktz",
        "application/vnd.kahootz"
    ],
    [
        "kwd",
        "application/vnd.kde.kword"
    ],
    [
        "la",
        [
            "audio/nspaudio",
            "audio/x-nspaudio"
        ]
    ],
    [
        "lam",
        "audio/x-liveaudio"
    ],
    [
        "lasxml",
        "application/vnd.las.las+xml"
    ],
    [
        "latex",
        "application/x-latex"
    ],
    [
        "lbd",
        "application/vnd.llamagraphics.life-balance.desktop"
    ],
    [
        "lbe",
        "application/vnd.llamagraphics.life-balance.exchange+xml"
    ],
    [
        "les",
        "application/vnd.hhe.lesson-player"
    ],
    [
        "lha",
        [
            "application/octet-stream",
            "application/lha",
            "application/x-lha"
        ]
    ],
    [
        "lhx",
        "application/octet-stream"
    ],
    [
        "link66",
        "application/vnd.route66.link66+xml"
    ],
    [
        "list",
        "text/plain"
    ],
    [
        "lma",
        [
            "audio/nspaudio",
            "audio/x-nspaudio"
        ]
    ],
    [
        "log",
        "text/plain"
    ],
    [
        "lrm",
        "application/vnd.ms-lrm"
    ],
    [
        "lsf",
        "video/x-la-asf"
    ],
    [
        "lsp",
        [
            "application/x-lisp",
            "text/x-script.lisp"
        ]
    ],
    [
        "lst",
        "text/plain"
    ],
    [
        "lsx",
        [
            "video/x-la-asf",
            "text/x-la-asf"
        ]
    ],
    [
        "ltf",
        "application/vnd.frogans.ltf"
    ],
    [
        "ltx",
        "application/x-latex"
    ],
    [
        "lvp",
        "audio/vnd.lucent.voice"
    ],
    [
        "lwp",
        "application/vnd.lotus-wordpro"
    ],
    [
        "lzh",
        [
            "application/octet-stream",
            "application/x-lzh"
        ]
    ],
    [
        "lzx",
        [
            "application/lzx",
            "application/octet-stream",
            "application/x-lzx"
        ]
    ],
    [
        "m",
        [
            "text/plain",
            "text/x-m"
        ]
    ],
    [
        "m13",
        "application/x-msmediaview"
    ],
    [
        "m14",
        "application/x-msmediaview"
    ],
    [
        "m1v",
        "video/mpeg"
    ],
    [
        "m21",
        "application/mp21"
    ],
    [
        "m2a",
        "audio/mpeg"
    ],
    [
        "m2v",
        "video/mpeg"
    ],
    [
        "m3u",
        [
            "audio/x-mpegurl",
            "audio/x-mpequrl"
        ]
    ],
    [
        "m3u8",
        "application/vnd.apple.mpegurl"
    ],
    [
        "m4v",
        "video/x-m4v"
    ],
    [
        "ma",
        "application/mathematica"
    ],
    [
        "mads",
        "application/mads+xml"
    ],
    [
        "mag",
        "application/vnd.ecowin.chart"
    ],
    [
        "man",
        "application/x-troff-man"
    ],
    [
        "map",
        "application/x-navimap"
    ],
    [
        "mar",
        "text/plain"
    ],
    [
        "mathml",
        "application/mathml+xml"
    ],
    [
        "mbd",
        "application/mbedlet"
    ],
    [
        "mbk",
        "application/vnd.mobius.mbk"
    ],
    [
        "mbox",
        "application/mbox"
    ],
    [
        "mc$",
        "application/x-magic-cap-package-1.0"
    ],
    [
        "mc1",
        "application/vnd.medcalcdata"
    ],
    [
        "mcd",
        [
            "application/mcad",
            "application/vnd.mcd",
            "application/x-mathcad"
        ]
    ],
    [
        "mcf",
        [
            "image/vasa",
            "text/mcf"
        ]
    ],
    [
        "mcp",
        "application/netmc"
    ],
    [
        "mcurl",
        "text/vnd.curl.mcurl"
    ],
    [
        "mdb",
        "application/x-msaccess"
    ],
    [
        "mdi",
        "image/vnd.ms-modi"
    ],
    [
        "me",
        "application/x-troff-me"
    ],
    [
        "meta4",
        "application/metalink4+xml"
    ],
    [
        "mets",
        "application/mets+xml"
    ],
    [
        "mfm",
        "application/vnd.mfmp"
    ],
    [
        "mgp",
        "application/vnd.osgeo.mapguide.package"
    ],
    [
        "mgz",
        "application/vnd.proteus.magazine"
    ],
    [
        "mht",
        "message/rfc822"
    ],
    [
        "mhtml",
        "message/rfc822"
    ],
    [
        "mid",
        [
            "audio/mid",
            "audio/midi",
            "music/crescendo",
            "x-music/x-midi",
            "audio/x-midi",
            "application/x-midi",
            "audio/x-mid"
        ]
    ],
    [
        "midi",
        [
            "audio/midi",
            "music/crescendo",
            "x-music/x-midi",
            "audio/x-midi",
            "application/x-midi",
            "audio/x-mid"
        ]
    ],
    [
        "mif",
        [
            "application/vnd.mif",
            "application/x-mif",
            "application/x-frame"
        ]
    ],
    [
        "mime",
        [
            "message/rfc822",
            "www/mime"
        ]
    ],
    [
        "mj2",
        "video/mj2"
    ],
    [
        "mjf",
        "audio/x-vnd.audioexplosion.mjuicemediafile"
    ],
    [
        "mjpg",
        "video/x-motion-jpeg"
    ],
    [
        "mlp",
        "application/vnd.dolby.mlp"
    ],
    [
        "mm",
        [
            "application/base64",
            "application/x-meme"
        ]
    ],
    [
        "mmd",
        "application/vnd.chipnuts.karaoke-mmd"
    ],
    [
        "mme",
        "application/base64"
    ],
    [
        "mmf",
        "application/vnd.smaf"
    ],
    [
        "mmr",
        "image/vnd.fujixerox.edmics-mmr"
    ],
    [
        "mny",
        "application/x-msmoney"
    ],
    [
        "mod",
        [
            "audio/mod",
            "audio/x-mod"
        ]
    ],
    [
        "mods",
        "application/mods+xml"
    ],
    [
        "moov",
        "video/quicktime"
    ],
    [
        "mov",
        "video/quicktime"
    ],
    [
        "movie",
        "video/x-sgi-movie"
    ],
    [
        "mp2",
        [
            "video/mpeg",
            "audio/mpeg",
            "video/x-mpeg",
            "audio/x-mpeg",
            "video/x-mpeq2a"
        ]
    ],
    [
        "mp3",
        [
            "audio/mpeg",
            "audio/mpeg3",
            "video/mpeg",
            "audio/x-mpeg-3",
            "video/x-mpeg"
        ]
    ],
    [
        "mp4",
        [
            "video/mp4",
            "application/mp4"
        ]
    ],
    [
        "mp4a",
        "audio/mp4"
    ],
    [
        "mpa",
        [
            "video/mpeg",
            "audio/mpeg"
        ]
    ],
    [
        "mpc",
        [
            "application/vnd.mophun.certificate",
            "application/x-project"
        ]
    ],
    [
        "mpe",
        "video/mpeg"
    ],
    [
        "mpeg",
        "video/mpeg"
    ],
    [
        "mpg",
        [
            "video/mpeg",
            "audio/mpeg"
        ]
    ],
    [
        "mpga",
        "audio/mpeg"
    ],
    [
        "mpkg",
        "application/vnd.apple.installer+xml"
    ],
    [
        "mpm",
        "application/vnd.blueice.multipass"
    ],
    [
        "mpn",
        "application/vnd.mophun.application"
    ],
    [
        "mpp",
        "application/vnd.ms-project"
    ],
    [
        "mpt",
        "application/x-project"
    ],
    [
        "mpv",
        "application/x-project"
    ],
    [
        "mpv2",
        "video/mpeg"
    ],
    [
        "mpx",
        "application/x-project"
    ],
    [
        "mpy",
        "application/vnd.ibm.minipay"
    ],
    [
        "mqy",
        "application/vnd.mobius.mqy"
    ],
    [
        "mrc",
        "application/marc"
    ],
    [
        "mrcx",
        "application/marcxml+xml"
    ],
    [
        "ms",
        "application/x-troff-ms"
    ],
    [
        "mscml",
        "application/mediaservercontrol+xml"
    ],
    [
        "mseq",
        "application/vnd.mseq"
    ],
    [
        "msf",
        "application/vnd.epson.msf"
    ],
    [
        "msg",
        "application/vnd.ms-outlook"
    ],
    [
        "msh",
        "model/mesh"
    ],
    [
        "msl",
        "application/vnd.mobius.msl"
    ],
    [
        "msty",
        "application/vnd.muvee.style"
    ],
    [
        "mts",
        "model/vnd.mts"
    ],
    [
        "mus",
        "application/vnd.musician"
    ],
    [
        "musicxml",
        "application/vnd.recordare.musicxml+xml"
    ],
    [
        "mv",
        "video/x-sgi-movie"
    ],
    [
        "mvb",
        "application/x-msmediaview"
    ],
    [
        "mwf",
        "application/vnd.mfer"
    ],
    [
        "mxf",
        "application/mxf"
    ],
    [
        "mxl",
        "application/vnd.recordare.musicxml"
    ],
    [
        "mxml",
        "application/xv+xml"
    ],
    [
        "mxs",
        "application/vnd.triscape.mxs"
    ],
    [
        "mxu",
        "video/vnd.mpegurl"
    ],
    [
        "my",
        "audio/make"
    ],
    [
        "mzz",
        "application/x-vnd.audioexplosion.mzz"
    ],
    [
        "n-gage",
        "application/vnd.nokia.n-gage.symbian.install"
    ],
    [
        "n3",
        "text/n3"
    ],
    [
        "nap",
        "image/naplps"
    ],
    [
        "naplps",
        "image/naplps"
    ],
    [
        "nbp",
        "application/vnd.wolfram.player"
    ],
    [
        "nc",
        "application/x-netcdf"
    ],
    [
        "ncm",
        "application/vnd.nokia.configuration-message"
    ],
    [
        "ncx",
        "application/x-dtbncx+xml"
    ],
    [
        "ngdat",
        "application/vnd.nokia.n-gage.data"
    ],
    [
        "nif",
        "image/x-niff"
    ],
    [
        "niff",
        "image/x-niff"
    ],
    [
        "nix",
        "application/x-mix-transfer"
    ],
    [
        "nlu",
        "application/vnd.neurolanguage.nlu"
    ],
    [
        "nml",
        "application/vnd.enliven"
    ],
    [
        "nnd",
        "application/vnd.noblenet-directory"
    ],
    [
        "nns",
        "application/vnd.noblenet-sealer"
    ],
    [
        "nnw",
        "application/vnd.noblenet-web"
    ],
    [
        "npx",
        "image/vnd.net-fpx"
    ],
    [
        "nsc",
        "application/x-conference"
    ],
    [
        "nsf",
        "application/vnd.lotus-notes"
    ],
    [
        "nvd",
        "application/x-navidoc"
    ],
    [
        "nws",
        "message/rfc822"
    ],
    [
        "o",
        "application/octet-stream"
    ],
    [
        "oa2",
        "application/vnd.fujitsu.oasys2"
    ],
    [
        "oa3",
        "application/vnd.fujitsu.oasys3"
    ],
    [
        "oas",
        "application/vnd.fujitsu.oasys"
    ],
    [
        "obd",
        "application/x-msbinder"
    ],
    [
        "oda",
        "application/oda"
    ],
    [
        "odb",
        "application/vnd.oasis.opendocument.database"
    ],
    [
        "odc",
        "application/vnd.oasis.opendocument.chart"
    ],
    [
        "odf",
        "application/vnd.oasis.opendocument.formula"
    ],
    [
        "odft",
        "application/vnd.oasis.opendocument.formula-template"
    ],
    [
        "odg",
        "application/vnd.oasis.opendocument.graphics"
    ],
    [
        "odi",
        "application/vnd.oasis.opendocument.image"
    ],
    [
        "odm",
        "application/vnd.oasis.opendocument.text-master"
    ],
    [
        "odp",
        "application/vnd.oasis.opendocument.presentation"
    ],
    [
        "ods",
        "application/vnd.oasis.opendocument.spreadsheet"
    ],
    [
        "odt",
        "application/vnd.oasis.opendocument.text"
    ],
    [
        "oga",
        "audio/ogg"
    ],
    [
        "ogv",
        "video/ogg"
    ],
    [
        "ogx",
        "application/ogg"
    ],
    [
        "omc",
        "application/x-omc"
    ],
    [
        "omcd",
        "application/x-omcdatamaker"
    ],
    [
        "omcr",
        "application/x-omcregerator"
    ],
    [
        "onetoc",
        "application/onenote"
    ],
    [
        "opf",
        "application/oebps-package+xml"
    ],
    [
        "org",
        "application/vnd.lotus-organizer"
    ],
    [
        "osf",
        "application/vnd.yamaha.openscoreformat"
    ],
    [
        "osfpvg",
        "application/vnd.yamaha.openscoreformat.osfpvg+xml"
    ],
    [
        "otc",
        "application/vnd.oasis.opendocument.chart-template"
    ],
    [
        "otf",
        "application/x-font-otf"
    ],
    [
        "otg",
        "application/vnd.oasis.opendocument.graphics-template"
    ],
    [
        "oth",
        "application/vnd.oasis.opendocument.text-web"
    ],
    [
        "oti",
        "application/vnd.oasis.opendocument.image-template"
    ],
    [
        "otp",
        "application/vnd.oasis.opendocument.presentation-template"
    ],
    [
        "ots",
        "application/vnd.oasis.opendocument.spreadsheet-template"
    ],
    [
        "ott",
        "application/vnd.oasis.opendocument.text-template"
    ],
    [
        "oxt",
        "application/vnd.openofficeorg.extension"
    ],
    [
        "p",
        "text/x-pascal"
    ],
    [
        "p10",
        [
            "application/pkcs10",
            "application/x-pkcs10"
        ]
    ],
    [
        "p12",
        [
            "application/pkcs-12",
            "application/x-pkcs12"
        ]
    ],
    [
        "p7a",
        "application/x-pkcs7-signature"
    ],
    [
        "p7b",
        "application/x-pkcs7-certificates"
    ],
    [
        "p7c",
        [
            "application/pkcs7-mime",
            "application/x-pkcs7-mime"
        ]
    ],
    [
        "p7m",
        [
            "application/pkcs7-mime",
            "application/x-pkcs7-mime"
        ]
    ],
    [
        "p7r",
        "application/x-pkcs7-certreqresp"
    ],
    [
        "p7s",
        [
            "application/pkcs7-signature",
            "application/x-pkcs7-signature"
        ]
    ],
    [
        "p8",
        "application/pkcs8"
    ],
    [
        "par",
        "text/plain-bas"
    ],
    [
        "part",
        "application/pro_eng"
    ],
    [
        "pas",
        "text/pascal"
    ],
    [
        "paw",
        "application/vnd.pawaafile"
    ],
    [
        "pbd",
        "application/vnd.powerbuilder6"
    ],
    [
        "pbm",
        "image/x-portable-bitmap"
    ],
    [
        "pcf",
        "application/x-font-pcf"
    ],
    [
        "pcl",
        [
            "application/vnd.hp-pcl",
            "application/x-pcl"
        ]
    ],
    [
        "pclxl",
        "application/vnd.hp-pclxl"
    ],
    [
        "pct",
        "image/x-pict"
    ],
    [
        "pcurl",
        "application/vnd.curl.pcurl"
    ],
    [
        "pcx",
        "image/x-pcx"
    ],
    [
        "pdb",
        [
            "application/vnd.palm",
            "chemical/x-pdb"
        ]
    ],
    [
        "pdf",
        "application/pdf"
    ],
    [
        "pfa",
        "application/x-font-type1"
    ],
    [
        "pfr",
        "application/font-tdpfr"
    ],
    [
        "pfunk",
        [
            "audio/make",
            "audio/make.my.funk"
        ]
    ],
    [
        "pfx",
        "application/x-pkcs12"
    ],
    [
        "pgm",
        [
            "image/x-portable-graymap",
            "image/x-portable-greymap"
        ]
    ],
    [
        "pgn",
        "application/x-chess-pgn"
    ],
    [
        "pgp",
        "application/pgp-signature"
    ],
    [
        "pic",
        [
            "image/pict",
            "image/x-pict"
        ]
    ],
    [
        "pict",
        "image/pict"
    ],
    [
        "pkg",
        "application/x-newton-compatible-pkg"
    ],
    [
        "pki",
        "application/pkixcmp"
    ],
    [
        "pkipath",
        "application/pkix-pkipath"
    ],
    [
        "pko",
        [
            "application/ynd.ms-pkipko",
            "application/vnd.ms-pki.pko"
        ]
    ],
    [
        "pl",
        [
            "text/plain",
            "text/x-script.perl"
        ]
    ],
    [
        "plb",
        "application/vnd.3gpp.pic-bw-large"
    ],
    [
        "plc",
        "application/vnd.mobius.plc"
    ],
    [
        "plf",
        "application/vnd.pocketlearn"
    ],
    [
        "pls",
        "application/pls+xml"
    ],
    [
        "plx",
        "application/x-pixclscript"
    ],
    [
        "pm",
        [
            "text/x-script.perl-module",
            "image/x-xpixmap"
        ]
    ],
    [
        "pm4",
        "application/x-pagemaker"
    ],
    [
        "pm5",
        "application/x-pagemaker"
    ],
    [
        "pma",
        "application/x-perfmon"
    ],
    [
        "pmc",
        "application/x-perfmon"
    ],
    [
        "pml",
        [
            "application/vnd.ctc-posml",
            "application/x-perfmon"
        ]
    ],
    [
        "pmr",
        "application/x-perfmon"
    ],
    [
        "pmw",
        "application/x-perfmon"
    ],
    [
        "png",
        "image/png"
    ],
    [
        "pnm",
        [
            "application/x-portable-anymap",
            "image/x-portable-anymap"
        ]
    ],
    [
        "portpkg",
        "application/vnd.macports.portpkg"
    ],
    [
        "pot",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint"
        ]
    ],
    [
        "potm",
        "application/vnd.ms-powerpoint.template.macroenabled.12"
    ],
    [
        "potx",
        "application/vnd.openxmlformats-officedocument.presentationml.template"
    ],
    [
        "pov",
        "model/x-pov"
    ],
    [
        "ppa",
        "application/vnd.ms-powerpoint"
    ],
    [
        "ppam",
        "application/vnd.ms-powerpoint.addin.macroenabled.12"
    ],
    [
        "ppd",
        "application/vnd.cups-ppd"
    ],
    [
        "ppm",
        "image/x-portable-pixmap"
    ],
    [
        "pps",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint"
        ]
    ],
    [
        "ppsm",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
    ],
    [
        "ppsx",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow"
    ],
    [
        "ppt",
        [
            "application/vnd.ms-powerpoint",
            "application/mspowerpoint",
            "application/powerpoint",
            "application/x-mspowerpoint"
        ]
    ],
    [
        "pptm",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12"
    ],
    [
        "pptx",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    ],
    [
        "ppz",
        "application/mspowerpoint"
    ],
    [
        "prc",
        "application/x-mobipocket-ebook"
    ],
    [
        "pre",
        [
            "application/vnd.lotus-freelance",
            "application/x-freelance"
        ]
    ],
    [
        "prf",
        "application/pics-rules"
    ],
    [
        "prt",
        "application/pro_eng"
    ],
    [
        "ps",
        "application/postscript"
    ],
    [
        "psb",
        "application/vnd.3gpp.pic-bw-small"
    ],
    [
        "psd",
        [
            "application/octet-stream",
            "image/vnd.adobe.photoshop"
        ]
    ],
    [
        "psf",
        "application/x-font-linux-psf"
    ],
    [
        "pskcxml",
        "application/pskc+xml"
    ],
    [
        "ptid",
        "application/vnd.pvi.ptid1"
    ],
    [
        "pub",
        "application/x-mspublisher"
    ],
    [
        "pvb",
        "application/vnd.3gpp.pic-bw-var"
    ],
    [
        "pvu",
        "paleovu/x-pv"
    ],
    [
        "pwn",
        "application/vnd.3m.post-it-notes"
    ],
    [
        "pwz",
        "application/vnd.ms-powerpoint"
    ],
    [
        "py",
        "text/x-script.phyton"
    ],
    [
        "pya",
        "audio/vnd.ms-playready.media.pya"
    ],
    [
        "pyc",
        "application/x-bytecode.python"
    ],
    [
        "pyv",
        "video/vnd.ms-playready.media.pyv"
    ],
    [
        "qam",
        "application/vnd.epson.quickanime"
    ],
    [
        "qbo",
        "application/vnd.intu.qbo"
    ],
    [
        "qcp",
        "audio/vnd.qcelp"
    ],
    [
        "qd3",
        "x-world/x-3dmf"
    ],
    [
        "qd3d",
        "x-world/x-3dmf"
    ],
    [
        "qfx",
        "application/vnd.intu.qfx"
    ],
    [
        "qif",
        "image/x-quicktime"
    ],
    [
        "qps",
        "application/vnd.publishare-delta-tree"
    ],
    [
        "qt",
        "video/quicktime"
    ],
    [
        "qtc",
        "video/x-qtc"
    ],
    [
        "qti",
        "image/x-quicktime"
    ],
    [
        "qtif",
        "image/x-quicktime"
    ],
    [
        "qxd",
        "application/vnd.quark.quarkxpress"
    ],
    [
        "ra",
        [
            "audio/x-realaudio",
            "audio/x-pn-realaudio",
            "audio/x-pn-realaudio-plugin"
        ]
    ],
    [
        "ram",
        "audio/x-pn-realaudio"
    ],
    [
        "rar",
        "application/x-rar-compressed"
    ],
    [
        "ras",
        [
            "image/cmu-raster",
            "application/x-cmu-raster",
            "image/x-cmu-raster"
        ]
    ],
    [
        "rast",
        "image/cmu-raster"
    ],
    [
        "rcprofile",
        "application/vnd.ipunplugged.rcprofile"
    ],
    [
        "rdf",
        "application/rdf+xml"
    ],
    [
        "rdz",
        "application/vnd.data-vision.rdz"
    ],
    [
        "rep",
        "application/vnd.businessobjects"
    ],
    [
        "res",
        "application/x-dtbresource+xml"
    ],
    [
        "rexx",
        "text/x-script.rexx"
    ],
    [
        "rf",
        "image/vnd.rn-realflash"
    ],
    [
        "rgb",
        "image/x-rgb"
    ],
    [
        "rif",
        "application/reginfo+xml"
    ],
    [
        "rip",
        "audio/vnd.rip"
    ],
    [
        "rl",
        "application/resource-lists+xml"
    ],
    [
        "rlc",
        "image/vnd.fujixerox.edmics-rlc"
    ],
    [
        "rld",
        "application/resource-lists-diff+xml"
    ],
    [
        "rm",
        [
            "application/vnd.rn-realmedia",
            "audio/x-pn-realaudio"
        ]
    ],
    [
        "rmi",
        "audio/mid"
    ],
    [
        "rmm",
        "audio/x-pn-realaudio"
    ],
    [
        "rmp",
        [
            "audio/x-pn-realaudio-plugin",
            "audio/x-pn-realaudio"
        ]
    ],
    [
        "rms",
        "application/vnd.jcp.javame.midlet-rms"
    ],
    [
        "rnc",
        "application/relax-ng-compact-syntax"
    ],
    [
        "rng",
        [
            "application/ringing-tones",
            "application/vnd.nokia.ringing-tone"
        ]
    ],
    [
        "rnx",
        "application/vnd.rn-realplayer"
    ],
    [
        "roff",
        "application/x-troff"
    ],
    [
        "rp",
        "image/vnd.rn-realpix"
    ],
    [
        "rp9",
        "application/vnd.cloanto.rp9"
    ],
    [
        "rpm",
        "audio/x-pn-realaudio-plugin"
    ],
    [
        "rpss",
        "application/vnd.nokia.radio-presets"
    ],
    [
        "rpst",
        "application/vnd.nokia.radio-preset"
    ],
    [
        "rq",
        "application/sparql-query"
    ],
    [
        "rs",
        "application/rls-services+xml"
    ],
    [
        "rsd",
        "application/rsd+xml"
    ],
    [
        "rt",
        [
            "text/richtext",
            "text/vnd.rn-realtext"
        ]
    ],
    [
        "rtf",
        [
            "application/rtf",
            "text/richtext",
            "application/x-rtf"
        ]
    ],
    [
        "rtx",
        [
            "text/richtext",
            "application/rtf"
        ]
    ],
    [
        "rv",
        "video/vnd.rn-realvideo"
    ],
    [
        "s",
        "text/x-asm"
    ],
    [
        "s3m",
        "audio/s3m"
    ],
    [
        "saf",
        "application/vnd.yamaha.smaf-audio"
    ],
    [
        "saveme",
        "application/octet-stream"
    ],
    [
        "sbk",
        "application/x-tbook"
    ],
    [
        "sbml",
        "application/sbml+xml"
    ],
    [
        "sc",
        "application/vnd.ibm.secure-container"
    ],
    [
        "scd",
        "application/x-msschedule"
    ],
    [
        "scm",
        [
            "application/vnd.lotus-screencam",
            "video/x-scm",
            "text/x-script.guile",
            "application/x-lotusscreencam",
            "text/x-script.scheme"
        ]
    ],
    [
        "scq",
        "application/scvp-cv-request"
    ],
    [
        "scs",
        "application/scvp-cv-response"
    ],
    [
        "sct",
        "text/scriptlet"
    ],
    [
        "scurl",
        "text/vnd.curl.scurl"
    ],
    [
        "sda",
        "application/vnd.stardivision.draw"
    ],
    [
        "sdc",
        "application/vnd.stardivision.calc"
    ],
    [
        "sdd",
        "application/vnd.stardivision.impress"
    ],
    [
        "sdkm",
        "application/vnd.solent.sdkm+xml"
    ],
    [
        "sdml",
        "text/plain"
    ],
    [
        "sdp",
        [
            "application/sdp",
            "application/x-sdp"
        ]
    ],
    [
        "sdr",
        "application/sounder"
    ],
    [
        "sdw",
        "application/vnd.stardivision.writer"
    ],
    [
        "sea",
        [
            "application/sea",
            "application/x-sea"
        ]
    ],
    [
        "see",
        "application/vnd.seemail"
    ],
    [
        "seed",
        "application/vnd.fdsn.seed"
    ],
    [
        "sema",
        "application/vnd.sema"
    ],
    [
        "semd",
        "application/vnd.semd"
    ],
    [
        "semf",
        "application/vnd.semf"
    ],
    [
        "ser",
        "application/java-serialized-object"
    ],
    [
        "set",
        "application/set"
    ],
    [
        "setpay",
        "application/set-payment-initiation"
    ],
    [
        "setreg",
        "application/set-registration-initiation"
    ],
    [
        "sfd-hdstx",
        "application/vnd.hydrostatix.sof-data"
    ],
    [
        "sfs",
        "application/vnd.spotfire.sfs"
    ],
    [
        "sgl",
        "application/vnd.stardivision.writer-global"
    ],
    [
        "sgm",
        [
            "text/sgml",
            "text/x-sgml"
        ]
    ],
    [
        "sgml",
        [
            "text/sgml",
            "text/x-sgml"
        ]
    ],
    [
        "sh",
        [
            "application/x-shar",
            "application/x-bsh",
            "application/x-sh",
            "text/x-script.sh"
        ]
    ],
    [
        "shar",
        [
            "application/x-bsh",
            "application/x-shar"
        ]
    ],
    [
        "shf",
        "application/shf+xml"
    ],
    [
        "shtml",
        [
            "text/html",
            "text/x-server-parsed-html"
        ]
    ],
    [
        "sid",
        "audio/x-psid"
    ],
    [
        "sis",
        "application/vnd.symbian.install"
    ],
    [
        "sit",
        [
            "application/x-stuffit",
            "application/x-sit"
        ]
    ],
    [
        "sitx",
        "application/x-stuffitx"
    ],
    [
        "skd",
        "application/x-koan"
    ],
    [
        "skm",
        "application/x-koan"
    ],
    [
        "skp",
        [
            "application/vnd.koan",
            "application/x-koan"
        ]
    ],
    [
        "skt",
        "application/x-koan"
    ],
    [
        "sl",
        "application/x-seelogo"
    ],
    [
        "sldm",
        "application/vnd.ms-powerpoint.slide.macroenabled.12"
    ],
    [
        "sldx",
        "application/vnd.openxmlformats-officedocument.presentationml.slide"
    ],
    [
        "slt",
        "application/vnd.epson.salt"
    ],
    [
        "sm",
        "application/vnd.stepmania.stepchart"
    ],
    [
        "smf",
        "application/vnd.stardivision.math"
    ],
    [
        "smi",
        [
            "application/smil",
            "application/smil+xml"
        ]
    ],
    [
        "smil",
        "application/smil"
    ],
    [
        "snd",
        [
            "audio/basic",
            "audio/x-adpcm"
        ]
    ],
    [
        "snf",
        "application/x-font-snf"
    ],
    [
        "sol",
        "application/solids"
    ],
    [
        "spc",
        [
            "text/x-speech",
            "application/x-pkcs7-certificates"
        ]
    ],
    [
        "spf",
        "application/vnd.yamaha.smaf-phrase"
    ],
    [
        "spl",
        [
            "application/futuresplash",
            "application/x-futuresplash"
        ]
    ],
    [
        "spot",
        "text/vnd.in3d.spot"
    ],
    [
        "spp",
        "application/scvp-vp-response"
    ],
    [
        "spq",
        "application/scvp-vp-request"
    ],
    [
        "spr",
        "application/x-sprite"
    ],
    [
        "sprite",
        "application/x-sprite"
    ],
    [
        "src",
        "application/x-wais-source"
    ],
    [
        "sru",
        "application/sru+xml"
    ],
    [
        "srx",
        "application/sparql-results+xml"
    ],
    [
        "sse",
        "application/vnd.kodak-descriptor"
    ],
    [
        "ssf",
        "application/vnd.epson.ssf"
    ],
    [
        "ssi",
        "text/x-server-parsed-html"
    ],
    [
        "ssm",
        "application/streamingmedia"
    ],
    [
        "ssml",
        "application/ssml+xml"
    ],
    [
        "sst",
        [
            "application/vnd.ms-pkicertstore",
            "application/vnd.ms-pki.certstore"
        ]
    ],
    [
        "st",
        "application/vnd.sailingtracker.track"
    ],
    [
        "stc",
        "application/vnd.sun.xml.calc.template"
    ],
    [
        "std",
        "application/vnd.sun.xml.draw.template"
    ],
    [
        "step",
        "application/step"
    ],
    [
        "stf",
        "application/vnd.wt.stf"
    ],
    [
        "sti",
        "application/vnd.sun.xml.impress.template"
    ],
    [
        "stk",
        "application/hyperstudio"
    ],
    [
        "stl",
        [
            "application/vnd.ms-pkistl",
            "application/sla",
            "application/vnd.ms-pki.stl",
            "application/x-navistyle"
        ]
    ],
    [
        "stm",
        "text/html"
    ],
    [
        "stp",
        "application/step"
    ],
    [
        "str",
        "application/vnd.pg.format"
    ],
    [
        "stw",
        "application/vnd.sun.xml.writer.template"
    ],
    [
        "sub",
        "image/vnd.dvb.subtitle"
    ],
    [
        "sus",
        "application/vnd.sus-calendar"
    ],
    [
        "sv4cpio",
        "application/x-sv4cpio"
    ],
    [
        "sv4crc",
        "application/x-sv4crc"
    ],
    [
        "svc",
        "application/vnd.dvb.service"
    ],
    [
        "svd",
        "application/vnd.svd"
    ],
    [
        "svf",
        [
            "image/vnd.dwg",
            "image/x-dwg"
        ]
    ],
    [
        "svg",
        "image/svg+xml"
    ],
    [
        "svr",
        [
            "x-world/x-svr",
            "application/x-world"
        ]
    ],
    [
        "swf",
        "application/x-shockwave-flash"
    ],
    [
        "swi",
        "application/vnd.aristanetworks.swi"
    ],
    [
        "sxc",
        "application/vnd.sun.xml.calc"
    ],
    [
        "sxd",
        "application/vnd.sun.xml.draw"
    ],
    [
        "sxg",
        "application/vnd.sun.xml.writer.global"
    ],
    [
        "sxi",
        "application/vnd.sun.xml.impress"
    ],
    [
        "sxm",
        "application/vnd.sun.xml.math"
    ],
    [
        "sxw",
        "application/vnd.sun.xml.writer"
    ],
    [
        "t",
        [
            "text/troff",
            "application/x-troff"
        ]
    ],
    [
        "talk",
        "text/x-speech"
    ],
    [
        "tao",
        "application/vnd.tao.intent-module-archive"
    ],
    [
        "tar",
        "application/x-tar"
    ],
    [
        "tbk",
        [
            "application/toolbook",
            "application/x-tbook"
        ]
    ],
    [
        "tcap",
        "application/vnd.3gpp2.tcap"
    ],
    [
        "tcl",
        [
            "text/x-script.tcl",
            "application/x-tcl"
        ]
    ],
    [
        "tcsh",
        "text/x-script.tcsh"
    ],
    [
        "teacher",
        "application/vnd.smart.teacher"
    ],
    [
        "tei",
        "application/tei+xml"
    ],
    [
        "tex",
        "application/x-tex"
    ],
    [
        "texi",
        "application/x-texinfo"
    ],
    [
        "texinfo",
        "application/x-texinfo"
    ],
    [
        "text",
        [
            "application/plain",
            "text/plain"
        ]
    ],
    [
        "tfi",
        "application/thraud+xml"
    ],
    [
        "tfm",
        "application/x-tex-tfm"
    ],
    [
        "tgz",
        [
            "application/gnutar",
            "application/x-compressed"
        ]
    ],
    [
        "thmx",
        "application/vnd.ms-officetheme"
    ],
    [
        "tif",
        [
            "image/tiff",
            "image/x-tiff"
        ]
    ],
    [
        "tiff",
        [
            "image/tiff",
            "image/x-tiff"
        ]
    ],
    [
        "tmo",
        "application/vnd.tmobile-livetv"
    ],
    [
        "torrent",
        "application/x-bittorrent"
    ],
    [
        "tpl",
        "application/vnd.groove-tool-template"
    ],
    [
        "tpt",
        "application/vnd.trid.tpt"
    ],
    [
        "tr",
        "application/x-troff"
    ],
    [
        "tra",
        "application/vnd.trueapp"
    ],
    [
        "trm",
        "application/x-msterminal"
    ],
    [
        "tsd",
        "application/timestamped-data"
    ],
    [
        "tsi",
        "audio/tsp-audio"
    ],
    [
        "tsp",
        [
            "application/dsptype",
            "audio/tsplayer"
        ]
    ],
    [
        "tsv",
        "text/tab-separated-values"
    ],
    [
        "ttf",
        "application/x-font-ttf"
    ],
    [
        "ttl",
        "text/turtle"
    ],
    [
        "turbot",
        "image/florian"
    ],
    [
        "twd",
        "application/vnd.simtech-mindmapper"
    ],
    [
        "txd",
        "application/vnd.genomatix.tuxedo"
    ],
    [
        "txf",
        "application/vnd.mobius.txf"
    ],
    [
        "txt",
        "text/plain"
    ],
    [
        "ufd",
        "application/vnd.ufdl"
    ],
    [
        "uil",
        "text/x-uil"
    ],
    [
        "uls",
        "text/iuls"
    ],
    [
        "umj",
        "application/vnd.umajin"
    ],
    [
        "uni",
        "text/uri-list"
    ],
    [
        "unis",
        "text/uri-list"
    ],
    [
        "unityweb",
        "application/vnd.unity"
    ],
    [
        "unv",
        "application/i-deas"
    ],
    [
        "uoml",
        "application/vnd.uoml+xml"
    ],
    [
        "uri",
        "text/uri-list"
    ],
    [
        "uris",
        "text/uri-list"
    ],
    [
        "ustar",
        [
            "application/x-ustar",
            "multipart/x-ustar"
        ]
    ],
    [
        "utz",
        "application/vnd.uiq.theme"
    ],
    [
        "uu",
        [
            "application/octet-stream",
            "text/x-uuencode"
        ]
    ],
    [
        "uue",
        "text/x-uuencode"
    ],
    [
        "uva",
        "audio/vnd.dece.audio"
    ],
    [
        "uvh",
        "video/vnd.dece.hd"
    ],
    [
        "uvi",
        "image/vnd.dece.graphic"
    ],
    [
        "uvm",
        "video/vnd.dece.mobile"
    ],
    [
        "uvp",
        "video/vnd.dece.pd"
    ],
    [
        "uvs",
        "video/vnd.dece.sd"
    ],
    [
        "uvu",
        "video/vnd.uvvu.mp4"
    ],
    [
        "uvv",
        "video/vnd.dece.video"
    ],
    [
        "vcd",
        "application/x-cdlink"
    ],
    [
        "vcf",
        "text/x-vcard"
    ],
    [
        "vcg",
        "application/vnd.groove-vcard"
    ],
    [
        "vcs",
        "text/x-vcalendar"
    ],
    [
        "vcx",
        "application/vnd.vcx"
    ],
    [
        "vda",
        "application/vda"
    ],
    [
        "vdo",
        "video/vdo"
    ],
    [
        "vew",
        "application/groupwise"
    ],
    [
        "vis",
        "application/vnd.visionary"
    ],
    [
        "viv",
        [
            "video/vivo",
            "video/vnd.vivo"
        ]
    ],
    [
        "vivo",
        [
            "video/vivo",
            "video/vnd.vivo"
        ]
    ],
    [
        "vmd",
        "application/vocaltec-media-desc"
    ],
    [
        "vmf",
        "application/vocaltec-media-file"
    ],
    [
        "voc",
        [
            "audio/voc",
            "audio/x-voc"
        ]
    ],
    [
        "vos",
        "video/vosaic"
    ],
    [
        "vox",
        "audio/voxware"
    ],
    [
        "vqe",
        "audio/x-twinvq-plugin"
    ],
    [
        "vqf",
        "audio/x-twinvq"
    ],
    [
        "vql",
        "audio/x-twinvq-plugin"
    ],
    [
        "vrml",
        [
            "model/vrml",
            "x-world/x-vrml",
            "application/x-vrml"
        ]
    ],
    [
        "vrt",
        "x-world/x-vrt"
    ],
    [
        "vsd",
        [
            "application/vnd.visio",
            "application/x-visio"
        ]
    ],
    [
        "vsf",
        "application/vnd.vsf"
    ],
    [
        "vst",
        "application/x-visio"
    ],
    [
        "vsw",
        "application/x-visio"
    ],
    [
        "vtu",
        "model/vnd.vtu"
    ],
    [
        "vxml",
        "application/voicexml+xml"
    ],
    [
        "w60",
        "application/wordperfect6.0"
    ],
    [
        "w61",
        "application/wordperfect6.1"
    ],
    [
        "w6w",
        "application/msword"
    ],
    [
        "wad",
        "application/x-doom"
    ],
    [
        "wav",
        [
            "audio/wav",
            "audio/x-wav"
        ]
    ],
    [
        "wax",
        "audio/x-ms-wax"
    ],
    [
        "wb1",
        "application/x-qpro"
    ],
    [
        "wbmp",
        "image/vnd.wap.wbmp"
    ],
    [
        "wbs",
        "application/vnd.criticaltools.wbs+xml"
    ],
    [
        "wbxml",
        "application/vnd.wap.wbxml"
    ],
    [
        "wcm",
        "application/vnd.ms-works"
    ],
    [
        "wdb",
        "application/vnd.ms-works"
    ],
    [
        "web",
        "application/vnd.xara"
    ],
    [
        "weba",
        "audio/webm"
    ],
    [
        "webm",
        "video/webm"
    ],
    [
        "webp",
        "image/webp"
    ],
    [
        "wg",
        "application/vnd.pmi.widget"
    ],
    [
        "wgt",
        "application/widget"
    ],
    [
        "wiz",
        "application/msword"
    ],
    [
        "wk1",
        "application/x-123"
    ],
    [
        "wks",
        "application/vnd.ms-works"
    ],
    [
        "wm",
        "video/x-ms-wm"
    ],
    [
        "wma",
        "audio/x-ms-wma"
    ],
    [
        "wmd",
        "application/x-ms-wmd"
    ],
    [
        "wmf",
        [
            "windows/metafile",
            "application/x-msmetafile"
        ]
    ],
    [
        "wml",
        "text/vnd.wap.wml"
    ],
    [
        "wmlc",
        "application/vnd.wap.wmlc"
    ],
    [
        "wmls",
        "text/vnd.wap.wmlscript"
    ],
    [
        "wmlsc",
        "application/vnd.wap.wmlscriptc"
    ],
    [
        "wmv",
        "video/x-ms-wmv"
    ],
    [
        "wmx",
        "video/x-ms-wmx"
    ],
    [
        "wmz",
        "application/x-ms-wmz"
    ],
    [
        "woff",
        "application/x-font-woff"
    ],
    [
        "word",
        "application/msword"
    ],
    [
        "wp",
        "application/wordperfect"
    ],
    [
        "wp5",
        [
            "application/wordperfect",
            "application/wordperfect6.0"
        ]
    ],
    [
        "wp6",
        "application/wordperfect"
    ],
    [
        "wpd",
        [
            "application/wordperfect",
            "application/vnd.wordperfect",
            "application/x-wpwin"
        ]
    ],
    [
        "wpl",
        "application/vnd.ms-wpl"
    ],
    [
        "wps",
        "application/vnd.ms-works"
    ],
    [
        "wq1",
        "application/x-lotus"
    ],
    [
        "wqd",
        "application/vnd.wqd"
    ],
    [
        "wri",
        [
            "application/mswrite",
            "application/x-wri",
            "application/x-mswrite"
        ]
    ],
    [
        "wrl",
        [
            "model/vrml",
            "x-world/x-vrml",
            "application/x-world"
        ]
    ],
    [
        "wrz",
        [
            "model/vrml",
            "x-world/x-vrml"
        ]
    ],
    [
        "wsc",
        "text/scriplet"
    ],
    [
        "wsdl",
        "application/wsdl+xml"
    ],
    [
        "wspolicy",
        "application/wspolicy+xml"
    ],
    [
        "wsrc",
        "application/x-wais-source"
    ],
    [
        "wtb",
        "application/vnd.webturbo"
    ],
    [
        "wtk",
        "application/x-wintalk"
    ],
    [
        "wvx",
        "video/x-ms-wvx"
    ],
    [
        "x-png",
        "image/png"
    ],
    [
        "x3d",
        "application/vnd.hzn-3d-crossword"
    ],
    [
        "xaf",
        "x-world/x-vrml"
    ],
    [
        "xap",
        "application/x-silverlight-app"
    ],
    [
        "xar",
        "application/vnd.xara"
    ],
    [
        "xbap",
        "application/x-ms-xbap"
    ],
    [
        "xbd",
        "application/vnd.fujixerox.docuworks.binder"
    ],
    [
        "xbm",
        [
            "image/xbm",
            "image/x-xbm",
            "image/x-xbitmap"
        ]
    ],
    [
        "xdf",
        "application/xcap-diff+xml"
    ],
    [
        "xdm",
        "application/vnd.syncml.dm+xml"
    ],
    [
        "xdp",
        "application/vnd.adobe.xdp+xml"
    ],
    [
        "xdr",
        "video/x-amt-demorun"
    ],
    [
        "xdssc",
        "application/dssc+xml"
    ],
    [
        "xdw",
        "application/vnd.fujixerox.docuworks"
    ],
    [
        "xenc",
        "application/xenc+xml"
    ],
    [
        "xer",
        "application/patch-ops-error+xml"
    ],
    [
        "xfdf",
        "application/vnd.adobe.xfdf"
    ],
    [
        "xfdl",
        "application/vnd.xfdl"
    ],
    [
        "xgz",
        "xgl/drawing"
    ],
    [
        "xhtml",
        "application/xhtml+xml"
    ],
    [
        "xif",
        "image/vnd.xiff"
    ],
    [
        "xl",
        "application/excel"
    ],
    [
        "xla",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xlam",
        "application/vnd.ms-excel.addin.macroenabled.12"
    ],
    [
        "xlb",
        [
            "application/excel",
            "application/vnd.ms-excel",
            "application/x-excel"
        ]
    ],
    [
        "xlc",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xld",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xlk",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xll",
        [
            "application/excel",
            "application/vnd.ms-excel",
            "application/x-excel"
        ]
    ],
    [
        "xlm",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xls",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xlsb",
        "application/vnd.ms-excel.sheet.binary.macroenabled.12"
    ],
    [
        "xlsm",
        "application/vnd.ms-excel.sheet.macroenabled.12"
    ],
    [
        "xlsx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    ],
    [
        "xlt",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xltm",
        "application/vnd.ms-excel.template.macroenabled.12"
    ],
    [
        "xltx",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template"
    ],
    [
        "xlv",
        [
            "application/excel",
            "application/x-excel"
        ]
    ],
    [
        "xlw",
        [
            "application/vnd.ms-excel",
            "application/excel",
            "application/x-msexcel",
            "application/x-excel"
        ]
    ],
    [
        "xm",
        "audio/xm"
    ],
    [
        "xml",
        [
            "application/xml",
            "text/xml",
            "application/atom+xml",
            "application/rss+xml"
        ]
    ],
    [
        "xmz",
        "xgl/movie"
    ],
    [
        "xo",
        "application/vnd.olpc-sugar"
    ],
    [
        "xof",
        "x-world/x-vrml"
    ],
    [
        "xop",
        "application/xop+xml"
    ],
    [
        "xpi",
        "application/x-xpinstall"
    ],
    [
        "xpix",
        "application/x-vnd.ls-xpix"
    ],
    [
        "xpm",
        [
            "image/xpm",
            "image/x-xpixmap"
        ]
    ],
    [
        "xpr",
        "application/vnd.is-xpr"
    ],
    [
        "xps",
        "application/vnd.ms-xpsdocument"
    ],
    [
        "xpw",
        "application/vnd.intercon.formnet"
    ],
    [
        "xslt",
        "application/xslt+xml"
    ],
    [
        "xsm",
        "application/vnd.syncml+xml"
    ],
    [
        "xspf",
        "application/xspf+xml"
    ],
    [
        "xsr",
        "video/x-amt-showrun"
    ],
    [
        "xul",
        "application/vnd.mozilla.xul+xml"
    ],
    [
        "xwd",
        [
            "image/x-xwd",
            "image/x-xwindowdump"
        ]
    ],
    [
        "xyz",
        [
            "chemical/x-xyz",
            "chemical/x-pdb"
        ]
    ],
    [
        "yang",
        "application/yang"
    ],
    [
        "yin",
        "application/yin+xml"
    ],
    [
        "z",
        [
            "application/x-compressed",
            "application/x-compress"
        ]
    ],
    [
        "zaz",
        "application/vnd.zzazz.deck+xml"
    ],
    [
        "zip",
        [
            "application/zip",
            "multipart/x-zip",
            "application/x-zip-compressed",
            "application/x-compressed"
        ]
    ],
    [
        "zir",
        "application/vnd.zul"
    ],
    [
        "zmm",
        "application/vnd.handheld-entertainment+xml"
    ],
    [
        "zoo",
        "application/octet-stream"
    ],
    [
        "zsh",
        "text/x-script.zsh"
    ]
]);
module.exports = {
    detectMimeType (filename) {
        if (!filename) {
            return defaultMimeType;
        }
        let parsed = path.parse(filename);
        let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
        let value = defaultMimeType;
        if (extensions.has(extension)) {
            value = extensions.get(extension);
        }
        if (Array.isArray(value)) {
            return value[0];
        }
        return value;
    },
    detectExtension (mimeType) {
        if (!mimeType) {
            return defaultExtension;
        }
        let parts = (mimeType || "").toLowerCase().trim().split("/");
        let rootType = parts.shift().trim();
        let subType = parts.join("/").trim();
        if (mimeTypes.has(rootType + "/" + subType)) {
            let value = mimeTypes.get(rootType + "/" + subType);
            if (Array.isArray(value)) {
                return value[0];
            }
            return value;
        }
        switch(rootType){
            case "text":
                return "txt";
            default:
                return "bin";
        }
    }
};


/***/ }),

/***/ 47419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */ 
const crypto = __webpack_require__(6113);
const fs = __webpack_require__(57147);
const punycode = __webpack_require__(71415);
const PassThrough = (__webpack_require__(12781).PassThrough);
const shared = __webpack_require__(33050);
const mimeFuncs = __webpack_require__(41552);
const qp = __webpack_require__(46661);
const base64 = __webpack_require__(2553);
const addressparser = __webpack_require__(23212);
const nmfetch = __webpack_require__(99075);
const LastNewline = __webpack_require__(19374);
const LeWindows = __webpack_require__(52045);
const LeUnix = __webpack_require__(8812);
/**
 * Creates a new mime tree node. Assumes 'multipart/*' as the content type
 * if it is a branch, anything else counts as leaf. If rootNode is missing from
 * the options, assumes this is the root.
 *
 * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
 * @param {Object} [options] optional options
 * @param {Object} [options.rootNode] root node for this tree
 * @param {Object} [options.parentNode] immediate parent for this node
 * @param {Object} [options.filename] filename for an attachment node
 * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
 * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
 * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing
 * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'
 */ class MimeNode {
    constructor(contentType, options){
        this.nodeCounter = 0;
        options = options || {};
        /**
         * shared part of the unique multipart boundary
         */ this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString("hex");
        this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
        this.disableFileAccess = !!options.disableFileAccess;
        this.disableUrlAccess = !!options.disableUrlAccess;
        this.normalizeHeaderKey = options.normalizeHeaderKey;
        /**
         * If date headers is missing and current node is the root, this value is used instead
         */ this.date = new Date();
        /**
         * Root node for current mime tree
         */ this.rootNode = options.rootNode || this;
        /**
         * If true include Bcc in generated headers (if available)
         */ this.keepBcc = !!options.keepBcc;
        /**
         * If filename is specified but contentType is not (probably an attachment)
         * detect the content type from filename extension
         */ if (options.filename) {
            /**
             * Filename for this node. Useful with attachments
             */ this.filename = options.filename;
            if (!contentType) {
                contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
            }
        }
        /**
         * Indicates which encoding should be used for header strings: "Q" or "B"
         */ this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
        /**
         * Immediate parent for this node (or undefined if not set)
         */ this.parentNode = options.parentNode;
        /**
         * Hostname for default message-id values
         */ this.hostname = options.hostname;
        /**
         * If set to 'win' then uses \r\n, if 'linux' then \n. If not set (or `raw` is used) then newlines are kept as is.
         */ this.newline = options.newline;
        /**
         * An array for possible child nodes
         */ this.childNodes = [];
        /**
         * Used for generating unique boundaries (prepended to the shared base)
         */ this._nodeId = ++this.rootNode.nodeCounter;
        /**
         * A list of header values for this node in the form of [{key:'', value:''}]
         */ this._headers = [];
        /**
         * True if the content only uses ASCII printable characters
         * @type {Boolean}
         */ this._isPlainText = false;
        /**
         * True if the content is plain text but has longer lines than allowed
         * @type {Boolean}
         */ this._hasLongLines = false;
        /**
         * If set, use instead this value for envelopes instead of generating one
         * @type {Boolean}
         */ this._envelope = false;
        /**
         * If set then use this value as the stream content instead of building it
         * @type {String|Buffer|Stream}
         */ this._raw = false;
        /**
         * Additional transform streams that the message will be piped before
         * exposing by createReadStream
         * @type {Array}
         */ this._transforms = [];
        /**
         * Additional process functions that the message will be piped through before
         * exposing by createReadStream. These functions are run after transforms
         * @type {Array}
         */ this._processFuncs = [];
        /**
         * If content type is set (or derived from the filename) add it to headers
         */ if (contentType) {
            this.setHeader("Content-Type", contentType);
        }
    }
    /////// PUBLIC METHODS
    /**
     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
     *
     * @param {String} [contentType] Optional content type
     * @param {Object} [options] Optional options object
     * @return {Object} Created node object
     */ createChild(contentType, options) {
        if (!options && typeof contentType === "object") {
            options = contentType;
            contentType = undefined;
        }
        let node = new MimeNode(contentType, options);
        this.appendChild(node);
        return node;
    }
    /**
     * Appends an existing node to the mime tree. Removes the node from an existing
     * tree if needed
     *
     * @param {Object} childNode node to be appended
     * @return {Object} Appended node object
     */ appendChild(childNode) {
        if (childNode.rootNode !== this.rootNode) {
            childNode.rootNode = this.rootNode;
            childNode._nodeId = ++this.rootNode.nodeCounter;
        }
        childNode.parentNode = this;
        this.childNodes.push(childNode);
        return childNode;
    }
    /**
     * Replaces current node with another node
     *
     * @param {Object} node Replacement node
     * @return {Object} Replacement node
     */ replace(node) {
        if (node === this) {
            return this;
        }
        this.parentNode.childNodes.forEach((childNode, i)=>{
            if (childNode === this) {
                node.rootNode = this.rootNode;
                node.parentNode = this.parentNode;
                node._nodeId = this._nodeId;
                this.rootNode = this;
                this.parentNode = undefined;
                node.parentNode.childNodes[i] = node;
            }
        });
        return node;
    }
    /**
     * Removes current node from the mime tree
     *
     * @return {Object} removed node
     */ remove() {
        if (!this.parentNode) {
            return this;
        }
        for(let i = this.parentNode.childNodes.length - 1; i >= 0; i--){
            if (this.parentNode.childNodes[i] === this) {
                this.parentNode.childNodes.splice(i, 1);
                this.parentNode = undefined;
                this.rootNode = this;
                return this;
            }
        }
    }
    /**
     * Sets a header value. If the value for selected key exists, it is overwritten.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */ setHeader(key, value) {
        let added = false, headerValue;
        // Allow setting multiple headers at once
        if (!value && key && typeof key === "object") {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && "value" in key) {
                this.setHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach((i)=>{
                    this.setHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach((i)=>{
                    this.setHeader(i, key[i]);
                });
            }
            return this;
        }
        key = this._normalizeHeaderKey(key);
        headerValue = {
            key,
            value
        };
        // Check if the value exists and overwrite
        for(let i = 0, len = this._headers.length; i < len; i++){
            if (this._headers[i].key === key) {
                if (!added) {
                    // replace the first match
                    this._headers[i] = headerValue;
                    added = true;
                } else {
                    // remove following matches
                    this._headers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        // match not found, append the value
        if (!added) {
            this._headers.push(headerValue);
        }
        return this;
    }
    /**
     * Adds a header value. If the value for selected key exists, the value is appended
     * as a new field and old one is not touched.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */ addHeader(key, value) {
        // Allow setting multiple headers at once
        if (!value && key && typeof key === "object") {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && key.value) {
                this.addHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach((i)=>{
                    this.addHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach((i)=>{
                    this.addHeader(i, key[i]);
                });
            }
            return this;
        } else if (Array.isArray(value)) {
            value.forEach((val)=>{
                this.addHeader(key, val);
            });
            return this;
        }
        this._headers.push({
            key: this._normalizeHeaderKey(key),
            value
        });
        return this;
    }
    /**
     * Retrieves the first mathcing value of a selected key
     *
     * @param {String} key Key to search for
     * @retun {String} Value for the key
     */ getHeader(key) {
        key = this._normalizeHeaderKey(key);
        for(let i = 0, len = this._headers.length; i < len; i++){
            if (this._headers[i].key === key) {
                return this._headers[i].value;
            }
        }
    }
    /**
     * Sets body content for current node. If the value is a string, charset is added automatically
     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
     * the charset yourself
     *
     * @param (String|Buffer) content Body content
     * @return {Object} current node
     */ setContent(content) {
        this.content = content;
        if (typeof this.content.pipe === "function") {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = (err)=>{
                this.content.removeListener("error", this._contentErrorHandler);
                this.content = err;
            };
            this.content.once("error", this._contentErrorHandler);
        } else if (typeof this.content === "string") {
            this._isPlainText = mimeFuncs.isPlainText(this.content);
            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
                // If there are lines longer than 76 symbols/bytes do not use 7bit
                this._hasLongLines = true;
            }
        }
        return this;
    }
    build(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        let stream = this.createReadStream();
        let buf = [];
        let buflen = 0;
        let returned = false;
        stream.on("readable", ()=>{
            let chunk;
            while((chunk = stream.read()) !== null){
                buf.push(chunk);
                buflen += chunk.length;
            }
        });
        stream.once("error", (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });
        stream.once("end", (chunk)=>{
            if (returned) {
                return;
            }
            returned = true;
            if (chunk && chunk.length) {
                buf.push(chunk);
                buflen += chunk.length;
            }
            return callback(null, Buffer.concat(buf, buflen));
        });
        return promise;
    }
    getTransferEncoding() {
        let transferEncoding = false;
        let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
        if (this.content) {
            transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
            if (!transferEncoding || ![
                "base64",
                "quoted-printable"
            ].includes(transferEncoding)) {
                if (/^text\//i.test(contentType)) {
                    // If there are no special symbols, no need to modify the text
                    if (this._isPlainText && !this._hasLongLines) {
                        transferEncoding = "7bit";
                    } else if (typeof this.content === "string" || this.content instanceof Buffer) {
                        // detect preferred encoding for string value
                        transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
                    } else {
                        // we can not check content for a stream, so either use preferred encoding or fallback to QP
                        transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
                    }
                } else if (!/^(multipart|message)\//i.test(contentType)) {
                    transferEncoding = transferEncoding || "base64";
                }
            }
        }
        return transferEncoding;
    }
    /**
     * Builds the header block for the mime node. Append \r\n\r\n before writing the content
     *
     * @returns {String} Headers
     */ buildHeaders() {
        let transferEncoding = this.getTransferEncoding();
        let headers = [];
        if (transferEncoding) {
            this.setHeader("Content-Transfer-Encoding", transferEncoding);
        }
        if (this.filename && !this.getHeader("Content-Disposition")) {
            this.setHeader("Content-Disposition", "attachment");
        }
        // Ensure mandatory header fields
        if (this.rootNode === this) {
            if (!this.getHeader("Date")) {
                this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
            }
            // ensure that Message-Id is present
            this.messageId();
            if (!this.getHeader("MIME-Version")) {
                this.setHeader("MIME-Version", "1.0");
            }
            // Ensure that Content-Type is the last header for the root node
            for(let i = this._headers.length - 2; i >= 0; i--){
                let header = this._headers[i];
                if (header.key === "Content-Type") {
                    this._headers.splice(i, 1);
                    this._headers.push(header);
                }
            }
        }
        this._headers.forEach((header)=>{
            let key = header.key;
            let value = header.value;
            let structured;
            let param;
            let options = {};
            let formattedHeaders = [
                "From",
                "Sender",
                "To",
                "Cc",
                "Bcc",
                "Reply-To",
                "Date",
                "References"
            ];
            if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
                Object.keys(value).forEach((key)=>{
                    if (key !== "value") {
                        options[key] = value[key];
                    }
                });
                value = (value.value || "").toString();
                if (!value.trim()) {
                    return;
                }
            }
            if (options.prepared) {
                // header value is
                if (options.foldLines) {
                    headers.push(mimeFuncs.foldLines(key + ": " + value));
                } else {
                    headers.push(key + ": " + value);
                }
                return;
            }
            switch(header.key){
                case "Content-Disposition":
                    structured = mimeFuncs.parseHeaderValue(value);
                    if (this.filename) {
                        structured.params.filename = this.filename;
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    break;
                case "Content-Type":
                    structured = mimeFuncs.parseHeaderValue(value);
                    this._handleContentType(structured);
                    if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
                        structured.params.charset = "utf-8";
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    if (this.filename) {
                        // add support for non-compliant clients like QQ webmail
                        // we can't build the value with buildHeaderValue as the value is non standard and
                        // would be converted to parameter continuation encoding that we do not want
                        param = this._encodeWords(this.filename);
                        if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                            // include value in quotes if needed
                            param = '"' + param + '"';
                        }
                        value += "; name=" + param;
                    }
                    break;
                case "Bcc":
                    if (!this.keepBcc) {
                        // skip BCC values
                        return;
                    }
                    break;
            }
            value = this._encodeHeaderValue(key, value);
            // skip empty lines
            if (!(value || "").toString().trim()) {
                return;
            }
            if (typeof this.normalizeHeaderKey === "function") {
                let normalized = this.normalizeHeaderKey(key, value);
                if (normalized && typeof normalized === "string" && normalized.length) {
                    key = normalized;
                }
            }
            headers.push(mimeFuncs.foldLines(key + ": " + value, 76));
        });
        return headers.join("\r\n");
    }
    /**
     * Streams the rfc2822 message from the current node. If this is a root node,
     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
     *
     * @return {String} Compiled message
     */ createReadStream(options) {
        options = options || {};
        let stream = new PassThrough(options);
        let outputStream = stream;
        let transform;
        this.stream(stream, options, (err)=>{
            if (err) {
                outputStream.emit("error", err);
                return;
            }
            stream.end();
        });
        for(let i = 0, len = this._transforms.length; i < len; i++){
            transform = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
            outputStream.once("error", (err)=>{
                transform.emit("error", err);
            });
            outputStream = outputStream.pipe(transform);
        }
        // ensure terminating newline after possible user transforms
        transform = new LastNewline();
        outputStream.once("error", (err)=>{
            transform.emit("error", err);
        });
        outputStream = outputStream.pipe(transform);
        // dkim and stuff
        for(let i = 0, len = this._processFuncs.length; i < len; i++){
            transform = this._processFuncs[i];
            outputStream = transform(outputStream);
        }
        if (this.newline) {
            const winbreak = [
                "win",
                "windows",
                "dos",
                "\r\n"
            ].includes(this.newline.toString().toLowerCase());
            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();
            const stream = outputStream.pipe(newlineTransform);
            outputStream.on("error", (err)=>stream.emit("error", err));
            return stream;
        }
        return outputStream;
    }
    /**
     * Appends a transform stream object to the transforms list. Final output
     * is passed through this stream before exposing
     *
     * @param {Object} transform Read-Write stream
     */ transform(transform) {
        this._transforms.push(transform);
    }
    /**
     * Appends a post process function. The functon is run after transforms and
     * uses the following syntax
     *
     *   processFunc(input) -> outputStream
     *
     * @param {Object} processFunc Read-Write stream
     */ processFunc(processFunc) {
        this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
        let transferEncoding = this.getTransferEncoding();
        let contentStream;
        let localStream;
        // protect actual callback against multiple triggering
        let returned = false;
        let callback = (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            done(err);
        };
        // for multipart nodes, push child nodes
        // for content nodes end the stream
        let finalize = ()=>{
            let childId = 0;
            let processChildNode = ()=>{
                if (childId >= this.childNodes.length) {
                    outputStream.write("\r\n--" + this.boundary + "--\r\n");
                    return callback();
                }
                let child = this.childNodes[childId++];
                outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
                child.stream(outputStream, options, (err)=>{
                    if (err) {
                        return callback(err);
                    }
                    setImmediate(processChildNode);
                });
            };
            if (this.multipart) {
                setImmediate(processChildNode);
            } else {
                return callback();
            }
        };
        // pushes node content
        let sendContent = ()=>{
            if (this.content) {
                if (Object.prototype.toString.call(this.content) === "[object Error]") {
                    // content is already errored
                    return callback(this.content);
                }
                if (typeof this.content.pipe === "function") {
                    this.content.removeListener("error", this._contentErrorHandler);
                    this._contentErrorHandler = (err)=>callback(err);
                    this.content.once("error", this._contentErrorHandler);
                }
                let createStream = ()=>{
                    if ([
                        "quoted-printable",
                        "base64"
                    ].includes(transferEncoding)) {
                        contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
                        contentStream.pipe(outputStream, {
                            end: false
                        });
                        contentStream.once("end", finalize);
                        contentStream.once("error", (err)=>callback(err));
                        localStream = this._getStream(this.content);
                        localStream.pipe(contentStream);
                    } else {
                        // anything that is not QP or Base54 passes as-is
                        localStream = this._getStream(this.content);
                        localStream.pipe(outputStream, {
                            end: false
                        });
                        localStream.once("end", finalize);
                    }
                    localStream.once("error", (err)=>callback(err));
                };
                if (this.content._resolve) {
                    let chunks = [];
                    let chunklen = 0;
                    let returned = false;
                    let sourceStream = this._getStream(this.content);
                    sourceStream.on("error", (err)=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        callback(err);
                    });
                    sourceStream.on("readable", ()=>{
                        let chunk;
                        while((chunk = sourceStream.read()) !== null){
                            chunks.push(chunk);
                            chunklen += chunk.length;
                        }
                    });
                    sourceStream.on("end", ()=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        this.content._resolve = false;
                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                        setImmediate(createStream);
                    });
                } else {
                    setImmediate(createStream);
                }
                return;
            } else {
                return setImmediate(finalize);
            }
        };
        if (this._raw) {
            setImmediate(()=>{
                if (Object.prototype.toString.call(this._raw) === "[object Error]") {
                    // content is already errored
                    return callback(this._raw);
                }
                // remove default error handler (if set)
                if (typeof this._raw.pipe === "function") {
                    this._raw.removeListener("error", this._contentErrorHandler);
                }
                let raw = this._getStream(this._raw);
                raw.pipe(outputStream, {
                    end: false
                });
                raw.on("error", (err)=>outputStream.emit("error", err));
                raw.on("end", finalize);
            });
        } else {
            outputStream.write(this.buildHeaders() + "\r\n\r\n");
            setImmediate(sendContent);
        }
    }
    /**
     * Sets envelope to be used instead of the generated one
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */ setEnvelope(envelope) {
        let list;
        this._envelope = {
            from: false,
            to: []
        };
        if (envelope.from) {
            list = [];
            this._convertAddresses(this._parseAddresses(envelope.from), list);
            list = list.filter((address)=>address && address.address);
            if (list.length && list[0]) {
                this._envelope.from = list[0].address;
            }
        }
        [
            "to",
            "cc",
            "bcc"
        ].forEach((key)=>{
            if (envelope[key]) {
                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
            }
        });
        this._envelope.to = this._envelope.to.map((to)=>to.address).filter((address)=>address);
        let standardFields = [
            "to",
            "cc",
            "bcc",
            "from"
        ];
        Object.keys(envelope).forEach((key)=>{
            if (!standardFields.includes(key)) {
                this._envelope[key] = envelope[key];
            }
        });
        return this;
    }
    /**
     * Generates and returns an object with parsed address fields
     *
     * @return {Object} Address object
     */ getAddresses() {
        let addresses = {};
        this._headers.forEach((header)=>{
            let key = header.key.toLowerCase();
            if ([
                "from",
                "sender",
                "reply-to",
                "to",
                "cc",
                "bcc"
            ].includes(key)) {
                if (!Array.isArray(addresses[key])) {
                    addresses[key] = [];
                }
                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
            }
        });
        return addresses;
    }
    /**
     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */ getEnvelope() {
        if (this._envelope) {
            return this._envelope;
        }
        let envelope = {
            from: false,
            to: []
        };
        this._headers.forEach((header)=>{
            let list = [];
            if (header.key === "From" || !envelope.from && [
                "Reply-To",
                "Sender"
            ].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), list);
                if (list.length && list[0]) {
                    envelope.from = list[0].address;
                }
            } else if ([
                "To",
                "Cc",
                "Bcc"
            ].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), envelope.to);
            }
        });
        envelope.to = envelope.to.map((to)=>to.address);
        return envelope;
    }
    /**
     * Returns Message-Id value. If it does not exist, then creates one
     *
     * @return {String} Message-Id value
     */ messageId() {
        let messageId = this.getHeader("Message-ID");
        // You really should define your own Message-Id field!
        if (!messageId) {
            messageId = this._generateMessageId();
            this.setHeader("Message-ID", messageId);
        }
        return messageId;
    }
    /**
     * Sets pregenerated content that will be used as the output of this node
     *
     * @param {String|Buffer|Stream} Raw MIME contents
     */ setRaw(raw) {
        this._raw = raw;
        if (this._raw && typeof this._raw.pipe === "function") {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = (err)=>{
                this._raw.removeListener("error", this._contentErrorHandler);
                this._raw = err;
            };
            this._raw.once("error", this._contentErrorHandler);
        }
        return this;
    }
    /////// PRIVATE METHODS
    /**
     * Detects and returns handle to a stream related with the content.
     *
     * @param {Mixed} content Node content
     * @returns {Object} Stream object
     */ _getStream(content) {
        let contentStream;
        if (content._resolvedValue) {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();
            setImmediate(()=>{
                try {
                    contentStream.end(content._resolvedValue);
                } catch (err) {
                    contentStream.emit("error", err);
                }
            });
            return contentStream;
        } else if (typeof content.pipe === "function") {
            // assume as stream
            return content;
        } else if (content && typeof content.path === "string" && !content.href) {
            if (this.disableFileAccess) {
                contentStream = new PassThrough();
                setImmediate(()=>contentStream.emit("error", new Error("File access rejected for " + content.path)));
                return contentStream;
            }
            // read file
            return fs.createReadStream(content.path);
        } else if (content && typeof content.href === "string") {
            if (this.disableUrlAccess) {
                contentStream = new PassThrough();
                setImmediate(()=>contentStream.emit("error", new Error("Url access rejected for " + content.href)));
                return contentStream;
            }
            // fetch URL
            return nmfetch(content.href, {
                headers: content.httpHeaders
            });
        } else {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();
            setImmediate(()=>{
                try {
                    contentStream.end(content || "");
                } catch (err) {
                    contentStream.emit("error", err);
                }
            });
            return contentStream;
        }
    }
    /**
     * Parses addresses. Takes in a single address or an array or an
     * array of address arrays (eg. To: [[first group], [second group],...])
     *
     * @param {Mixed} addresses Addresses to be parsed
     * @return {Array} An array of address objects
     */ _parseAddresses(addresses) {
        return [].concat.apply([], [].concat(addresses).map((address)=>{
            // eslint-disable-line prefer-spread
            if (address && address.address) {
                address.address = this._normalizeAddress(address.address);
                address.name = address.name || "";
                return [
                    address
                ];
            }
            return addressparser(address);
        }));
    }
    /**
     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
     *
     * @param {String} key Key to be normalized
     * @return {String} key in Camel-Case form
     */ _normalizeHeaderKey(key) {
        key = (key || "").toString()// no newlines in keys
        .replace(/\r?\n|\r/g, " ").trim().toLowerCase()// use uppercase words, except MIME
        .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c)=>c.toUpperCase())// special case
        .replace(/^Content-Features$/i, "Content-features");
        return key;
    }
    /**
     * Checks if the content type is multipart and defines boundary if needed.
     * Doesn't return anything, modifies object argument instead.
     *
     * @param {Object} structured Parsed header value for 'Content-Type' key
     */ _handleContentType(structured) {
        this.contentType = structured.value.trim().toLowerCase();
        this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
        if (this.multipart) {
            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
        } else {
            this.boundary = false;
        }
    }
    /**
     * Generates a multipart boundary value
     *
     * @return {String} boundary value
     */ _generateBoundary() {
        return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    /**
     * Encodes a header value for use in the generated rfc2822 email.
     *
     * @param {String} key Header key
     * @param {String} value Header value
     */ _encodeHeaderValue(key, value) {
        key = this._normalizeHeaderKey(key);
        switch(key){
            // Structured headers
            case "From":
            case "Sender":
            case "To":
            case "Cc":
            case "Bcc":
            case "Reply-To":
                return this._convertAddresses(this._parseAddresses(value));
            // values enclosed in <>
            case "Message-ID":
            case "In-Reply-To":
            case "Content-Id":
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                if (value.charAt(0) !== "<") {
                    value = "<" + value;
                }
                if (value.charAt(value.length - 1) !== ">") {
                    value = value + ">";
                }
                return value;
            // space separated list of values enclosed in <>
            case "References":
                value = [].concat.apply([], [].concat(value || "").map((elm)=>{
                    // eslint-disable-line prefer-spread
                    elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
                    return elm.replace(/<[^>]*>/g, (str)=>str.replace(/\s/g, "")).split(/\s+/);
                })).map((elm)=>{
                    if (elm.charAt(0) !== "<") {
                        elm = "<" + elm;
                    }
                    if (elm.charAt(elm.length - 1) !== ">") {
                        elm = elm + ">";
                    }
                    return elm;
                });
                return value.join(" ").trim();
            case "Date":
                if (Object.prototype.toString.call(value) === "[object Date]") {
                    return value.toUTCString().replace(/GMT/, "+0000");
                }
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                return this._encodeWords(value);
            case "Content-Type":
            case "Content-Disposition":
                // if it includes a filename then it is already encoded
                return (value || "").toString().replace(/\r?\n|\r/g, " ");
            default:
                value = (value || "").toString().replace(/\r?\n|\r/g, " ");
                // encodeWords only encodes if needed, otherwise the original string is returned
                return this._encodeWords(value);
        }
    }
    /**
     * Rebuilds address object using punycode and other adjustments
     *
     * @param {Array} addresses An array of address objects
     * @param {Array} [uniqueList] An array to be populated with addresses
     * @return {String} address string
     */ _convertAddresses(addresses, uniqueList) {
        let values = [];
        uniqueList = uniqueList || [];
        [].concat(addresses || []).forEach((address)=>{
            if (address.address) {
                address.address = this._normalizeAddress(address.address);
                if (!address.name) {
                    values.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
                } else if (address.name) {
                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
                }
                if (address.address) {
                    if (!uniqueList.filter((a)=>a.address === address.address).length) {
                        uniqueList.push(address);
                    }
                }
            } else if (address.group) {
                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
            }
        });
        return values.join(", ");
    }
    /**
     * Normalizes an email address
     *
     * @param {Array} address An array of address objects
     * @return {String} address string
     */ _normalizeAddress(address) {
        address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ") // remove unallowed characters
        .trim();
        let lastAt = address.lastIndexOf("@");
        if (lastAt < 0) {
            // Bare username
            return address;
        }
        let user = address.substr(0, lastAt);
        let domain = address.substr(lastAt + 1);
        // Usernames are not touched and are kept as is even if these include unicode
        // Domains are punycoded by default
        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'
        // non-unicode domains are left as is
        let encodedDomain;
        try {
            encodedDomain = punycode.toASCII(domain.toLowerCase());
        } catch (err) {
        // keep as is?
        }
        if (user.indexOf(" ") >= 0) {
            if (user.charAt(0) !== '"') {
                user = '"' + user;
            }
            if (user.substr(-1) !== '"') {
                user = user + '"';
            }
        }
        return `${user}@${encodedDomain}`;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */ _encodeAddressName(name) {
        if (!/^[\w ]*$/.test(name)) {
            if (/^[\x20-\x7e]*$/.test(name)) {
                return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
            } else {
                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
            }
        }
        return name;
    }
    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */ _encodeWords(value) {
        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,
        // by default only words that include non-ascii should be converted into encoded words
        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace
        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }
    /**
     * Detects best mime encoding for a text value
     *
     * @param {String} value Value to check for
     * @return {String} either 'Q' or 'B'
     */ _getTextEncoding(value) {
        value = (value || "").toString();
        let encoding = this.textEncoding;
        let latinLen;
        let nonLatinLen;
        if (!encoding) {
            // count latin alphabet symbols and 8-bit range symbols + control symbols
            // if there are more latin characters, then use quoted-printable
            // encoding, otherwise use base64
            nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex
            latinLen = (value.match(/[a-z]/gi) || []).length;
            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
            encoding = nonLatinLen < latinLen ? "Q" : "B";
        }
        return encoding;
    }
    /**
     * Generates a message id
     *
     * @return {String} Random Message-ID value
     */ _generateMessageId() {
        return "<" + [
            2,
            2,
            2,
            6
        ].reduce(// crux to generate UUID-like random strings
        (prev, len)=>prev + "-" + crypto.randomBytes(len).toString("hex"), crypto.randomBytes(4).toString("hex")) + "@" + // try to use the domain of the FROM address or fallback to server hostname
        (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
}
module.exports = MimeNode;


/***/ }),

/***/ 19374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
class LastNewline extends Transform {
    constructor(){
        super();
        this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
        if (chunk.length) {
            this.lastByte = chunk[chunk.length - 1];
        }
        this.push(chunk);
        done();
    }
    _flush(done) {
        if (this.lastByte === 0x0a) {
            return done();
        }
        if (this.lastByte === 0x0d) {
            this.push(Buffer.from("\n"));
            return done();
        }
        this.push(Buffer.from("\r\n"));
        return done();
    }
}
module.exports = LastNewline;


/***/ }),

/***/ 8812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Ensures that only <LF> is used for linebreaks
 *
 * @param {Object} options Stream options
 */ class LeWindows extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for(let i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x0d) {
                // \n
                buf = chunk.slice(lastPos, i);
                lastPos = i + 1;
                this.push(buf);
            }
        }
        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }
        done();
    }
}
module.exports = LeWindows;


/***/ }),

/***/ 52045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Ensures that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */ class LeWindows extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
        this.lastByte = false;
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;
        for(let i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x0a) {
                // \n
                if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        this.push(buf);
                    }
                    this.push(Buffer.from("\r\n"));
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
    }
}
module.exports = LeWindows;


/***/ }),

/***/ 4032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Mailer = __webpack_require__(73378);
const shared = __webpack_require__(33050);
const SMTPPool = __webpack_require__(48242);
const SMTPTransport = __webpack_require__(96911);
const SendmailTransport = __webpack_require__(10387);
const StreamTransport = __webpack_require__(76203);
const JSONTransport = __webpack_require__(9413);
const SESTransport = __webpack_require__(19728);
const nmfetch = __webpack_require__(99075);
const packageData = __webpack_require__(60983);
const ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
const ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
const ETHEREAL_API_KEY = (process.env.ETHEREAL_API_KEY || "").replace(/\s*/g, "") || null;
const ETHEREAL_CACHE = [
    "true",
    "yes",
    "y",
    "1"
].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
let testAccount = false;
module.exports.createTransport = function(transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;
    if (// provided transporter is a configuration object, not transporter plugin
    typeof transporter === "object" && typeof transporter.send !== "function" || // provided transporter looks like a connection url
    typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)) {
        if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }
        if (options.pool) {
            transporter = new SMTPPool(options);
        } else if (options.sendmail) {
            transporter = new SendmailTransport(options);
        } else if (options.streamTransport) {
            transporter = new StreamTransport(options);
        } else if (options.jsonTransport) {
            transporter = new JSONTransport(options);
        } else if (options.SES) {
            transporter = new SESTransport(options);
        } else {
            transporter = new SMTPTransport(options);
        }
    }
    mailer = new Mailer(transporter, options, defaults);
    return mailer;
};
module.exports.createTestAccount = function(apiUrl, callback) {
    let promise;
    if (!callback && typeof apiUrl === "function") {
        callback = apiUrl;
        apiUrl = false;
    }
    if (!callback) {
        promise = new Promise((resolve, reject)=>{
            callback = shared.callbackPromise(resolve, reject);
        });
    }
    if (ETHEREAL_CACHE && testAccount) {
        setImmediate(()=>callback(null, testAccount));
        return promise;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let requestHeaders = {};
    let requestBody = {
        requestor: packageData.name,
        version: packageData.version
    };
    if (ETHEREAL_API_KEY) {
        requestHeaders.Authorization = "Bearer " + ETHEREAL_API_KEY;
    }
    let req = nmfetch(apiUrl + "/user", {
        contentType: "application/json",
        method: "POST",
        headers: requestHeaders,
        body: Buffer.from(JSON.stringify(requestBody))
    });
    req.on("readable", ()=>{
        let chunk;
        while((chunk = req.read()) !== null){
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });
    req.once("error", (err)=>callback(err));
    req.once("end", ()=>{
        let res = Buffer.concat(chunks, chunklen);
        let data;
        let err;
        try {
            data = JSON.parse(res.toString());
        } catch (E) {
            err = E;
        }
        if (err) {
            return callback(err);
        }
        if (data.status !== "success" || data.error) {
            return callback(new Error(data.error || "Request failed"));
        }
        delete data.status;
        testAccount = data;
        callback(null, testAccount);
    });
    return promise;
};
module.exports.getTestMessageUrl = function(info) {
    if (!info || !info.response) {
        return false;
    }
    let infoProps = new Map();
    info.response.replace(/\[([^\]]+)\]$/, (m, props)=>{
        props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m, key, value)=>{
            infoProps.set(key, value);
        });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
        return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
};


/***/ }),

/***/ 71415:
/***/ ((module) => {

"use strict";
/*

Copied from https://github.com/mathiasbynens/punycode.js/blob/ef3505c8abb5143a00d53ce59077c9f7f4b2ac47/punycode.js

Copyright Mathias Bynens <https://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/ /* eslint callback-return: 0, no-bitwise: 0, eqeqeq: 0, prefer-arrow-callback: 0, object-shorthand: 0 */ 
/** Highest positive signed 32-bit float value */ const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */ const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = "-"; // '\x2D'
/** Regular expressions */ const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
/** Error messages */ const errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
/** Convenience shortcuts */ const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
/*--------------------------------------------------------------------------*/ /**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */ function error(type) {
    throw new RangeError(errors[type]);
}
/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */ function map(array, callback) {
    const result = [];
    let length = array.length;
    while(length--){
        result[length] = callback(array[length]);
    }
    return result;
}
/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {String} A new string of characters returned by the callback
 * function.
 */ function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + "@";
        domain = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
}
/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */ function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while(counter < length){
        const value = string.charCodeAt(counter++);
        if (value >= 0xd800 && value <= 0xdbff && counter < length) {
            // It's a high surrogate, and there is a next character.
            const extra = string.charCodeAt(counter++);
            if ((extra & 0xfc00) == 0xdc00) {
                // Low surrogate.
                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
            } else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */ const ucs2encode = (codePoints)=>String.fromCodePoint(...codePoints);
/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */ const basicToDigit = function(codePoint) {
    if (codePoint >= 0x30 && codePoint < 0x3a) {
        return 26 + (codePoint - 0x30);
    }
    if (codePoint >= 0x41 && codePoint < 0x5b) {
        return codePoint - 0x41;
    }
    if (codePoint >= 0x61 && codePoint < 0x7b) {
        return codePoint - 0x61;
    }
    return base;
};
/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */ const digitToBasic = function(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */ const adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for(; delta > baseMinusTMin * tMax >> 1; k += base){
        delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */ const decode = function(input) {
    // Don't use UCS-2.
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
        basic = 0;
    }
    for(let j = 0; j < basic; ++j){
        // if it's not a basic code point
        if (input.charCodeAt(j) >= 0x80) {
            error("not-basic");
        }
        output.push(input.charCodeAt(j));
    }
    // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.
    for(let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */ ;){
        // `index` is the index of the next character to be consumed.
        // Decode a generalized variable-length integer into `delta`,
        // which gets added to `i`. The overflow checking is easier
        // if we increase `i` as we go, then subtract off its starting
        // value at the end to obtain `delta`.
        const oldi = i;
        for(let w = 1, k = base /* no condition */ ;; k += base){
            if (index >= inputLength) {
                error("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base) {
                error("invalid-input");
            }
            if (digit > floor((maxInt - i) / w)) {
                error("overflow");
            }
            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
                break;
            }
            const baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
            }
            w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        // `i` was supposed to wrap around from `out` to `0`,
        // incrementing `n` each time, so we'll fix that now:
        if (floor(i / out) > maxInt - n) {
            error("overflow");
        }
        n += floor(i / out);
        i %= out;
        // Insert `n` at position `i` of the output.
        output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
};
/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */ const encode = function(input) {
    const output = [];
    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);
    // Cache the length.
    const inputLength = input.length;
    // Initialize the state.
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    // Handle the basic code points.
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) {
        output.push(delimiter);
    }
    // Main encoding loop:
    while(handledCPCount < inputLength){
        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        let m = maxInt;
        for (const currentValue of input){
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }
        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input){
            if (currentValue < n && ++delta > maxInt) {
                error("overflow");
            }
            if (currentValue === n) {
                // Represent delta as a generalized variable-length integer.
                let q = delta;
                for(let k = base /* no condition */ ;; k += base){
                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
};
/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */ const toUnicode = function(input) {
    return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
};
/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */ const toASCII = function(input) {
    return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
};
/*--------------------------------------------------------------------------*/ /** Define the public API */ const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */ version: "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */ ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
    },
    decode: decode,
    encode: encode,
    toASCII: toASCII,
    toUnicode: toUnicode
};
module.exports = punycode;


/***/ }),

/***/ 46661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Transform = (__webpack_require__(12781).Transform);
/**
 * Encodes a Buffer into a Quoted-Printable encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} Quoted-Printable encoded string
 */ function encode(buffer) {
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer, "utf-8");
    }
    // usable characters that do not need encoding
    let ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [
            0x09
        ],
        [
            0x0a
        ],
        [
            0x0d
        ],
        [
            0x20,
            0x3c
        ],
        [
            0x3e,
            0x7e
        ] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    let result = "";
    let ord;
    for(let i = 0, len = buffer.length; i < len; i++){
        ord = buffer[i];
        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line
        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {
            result += String.fromCharCode(ord);
            continue;
        }
        result += "=" + (ord < 0x10 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result;
}
/**
 * Adds soft line breaks to a Quoted-Printable string
 *
 * @param {String} str Quoted-Printable encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped Quoted-Printable encoded string
 */ function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
        return str;
    }
    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result = "";
    // insert soft linebreaks where needed
    while(pos < len){
        line = str.substr(pos, lineLength);
        if (match = line.match(/\r\n/)) {
            line = line.substr(0, match.index + match[0].length);
            result += line;
            pos += line.length;
            continue;
        }
        if (line.substr(-1) === "\n") {
            // nothing to change here
            result += line;
            pos += line.length;
            continue;
        } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
            // truncate to nearest line break
            line = line.substr(0, line.length - (match[0].length - 1));
            result += line;
            pos += line.length;
            continue;
        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
            // truncate to nearest space
            line = line.substr(0, line.length - (match[0].length - 1));
        } else if (line.match(/[=][\da-f]{0,2}$/i)) {
            // push incomplete encoding sequences to the next line
            if (match = line.match(/[=][\da-f]{0,1}$/i)) {
                line = line.substr(0, line.length - match[0].length);
            }
            // ensure that utf-8 sequences are not split
            while(line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))){
                code = parseInt(match[0].substr(1, 2), 16);
                if (code < 128) {
                    break;
                }
                line = line.substr(0, line.length - 3);
                if (code >= 0xc0) {
                    break;
                }
            }
        }
        if (pos + line.length < len && line.substr(-1) !== "\n") {
            if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
                line = line.substr(0, line.length - 3);
            } else if (line.length === lineLength) {
                line = line.substr(0, line.length - 1);
            }
            pos += line.length;
            line += "=\r\n";
        } else {
            pos += line.length;
        }
        result += line;
    }
    return result;
}
/**
 * Helper function to check if a number is inside provided ranges
 *
 * @param {Number} nr Number to check for
 * @param {Array} ranges An Array of allowed values
 * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise
 */ function checkRanges(nr, ranges) {
    for(let i = ranges.length - 1; i >= 0; i--){
        if (!ranges[i].length) {
            continue;
        }
        if (ranges[i].length === 1 && nr === ranges[i][0]) {
            return true;
        }
        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
            return true;
        }
    }
    return false;
}
/**
 * Creates a transform stream for encoding data to Quoted-Printable encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */ class Encoder extends Transform {
    constructor(options){
        super();
        // init Transform
        this.options = options || {};
        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }
        this._curLine = "";
        this.inputBytes = 0;
        this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
        let qp;
        if (encoding !== "buffer") {
            chunk = Buffer.from(chunk, encoding);
        }
        if (!chunk || !chunk.length) {
            return done();
        }
        this.inputBytes += chunk.length;
        if (this.options.lineLength) {
            qp = this._curLine + encode(chunk);
            qp = wrap(qp, this.options.lineLength);
            qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine)=>{
                this._curLine = lastLine;
                return lineBreak;
            });
            if (qp) {
                this.outputBytes += qp.length;
                this.push(qp);
            }
        } else {
            qp = encode(chunk);
            this.outputBytes += qp.length;
            this.push(qp, "ascii");
        }
        done();
    }
    _flush(done) {
        if (this._curLine) {
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, "ascii");
        }
        done();
    }
}
// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 10387:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const spawn = (__webpack_require__(32081).spawn);
const packageData = __webpack_require__(60983);
const shared = __webpack_require__(33050);
/**
 * Generates a Transport object for Sendmail
 *
 * Possible options can be the following:
 *
 *  * **path** optional path to sendmail binary
 *  * **newline** either 'windows' or 'unix'
 *  * **args** an array of arguments for the sendmail binary
 *
 * @constructor
 * @param {Object} optional config parameter for Sendmail
 */ class SendmailTransport {
    constructor(options){
        options = options || {};
        // use a reference to spawn for mocking purposes
        this._spawn = spawn;
        this.options = options || {};
        this.name = "Sendmail";
        this.version = packageData.version;
        this.path = "sendmail";
        this.args = false;
        this.winbreak = false;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "sendmail"
        });
        if (options) {
            if (typeof options === "string") {
                this.path = options;
            } else if (typeof options === "object") {
                if (options.path) {
                    this.path = options.path;
                }
                if (Array.isArray(options.args)) {
                    this.args = options.args;
                }
                this.winbreak = [
                    "win",
                    "windows",
                    "dos",
                    "\r\n"
                ].includes((options.newline || "").toString().toLowerCase());
            }
        }
    }
    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let args;
        let sendmail;
        let returned;
        const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr)=>/^-/.test(addr));
        if (hasInvalidAddresses) {
            return done(new Error("Can not send mail. Invalid envelope addresses."));
        }
        if (this.args) {
            // force -i to keep single dots
            args = [
                "-i"
            ].concat(this.args).concat(envelope.to);
        } else {
            args = [
                "-i"
            ].concat(envelope.from ? [
                "-f",
                envelope.from
            ] : []).concat(envelope.to);
        }
        let callback = (err)=>{
            if (returned) {
                // ignore any additional responses, already done
                return;
            }
            returned = true;
            if (typeof done === "function") {
                if (err) {
                    return done(err);
                } else {
                    return done(null, {
                        envelope: mail.data.envelope || mail.message.getEnvelope(),
                        messageId,
                        response: "Messages queued for delivery"
                    });
                }
            }
        };
        try {
            sendmail = this._spawn(this.path, args);
        } catch (E) {
            this.logger.error({
                err: E,
                tnx: "spawn",
                messageId
            }, "Error occurred while spawning sendmail. %s", E.message);
            return callback(E);
        }
        if (sendmail) {
            sendmail.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "spawn",
                    messageId
                }, "Error occurred when sending message %s. %s", messageId, err.message);
                callback(err);
            });
            sendmail.once("exit", (code)=>{
                if (!code) {
                    return callback();
                }
                let err;
                if (code === 127) {
                    err = new Error("Sendmail command not found, process exited with code " + code);
                } else {
                    err = new Error("Sendmail exited with code " + code);
                }
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error sending message %s to sendmail. %s", messageId, err.message);
                callback(err);
            });
            sendmail.once("close", callback);
            sendmail.stdin.on("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error occurred when piping message %s to sendmail. %s", messageId, err.message);
                callback(err);
            });
            let recipients = [].concat(envelope.to || []);
            if (recipients.length > 3) {
                recipients.push("...and " + recipients.splice(2).length + " more");
            }
            this.logger.info({
                tnx: "send",
                messageId
            }, "Sending message %s to <%s>", messageId, recipients.join(", "));
            let sourceStream = mail.message.createReadStream();
            sourceStream.once("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "stdin",
                    messageId
                }, "Error occurred when generating message %s. %s", messageId, err.message);
                sendmail.kill("SIGINT"); // do not deliver the message
                callback(err);
            });
            sourceStream.pipe(sendmail.stdin);
        } else {
            return callback(new Error("sendmail was not found"));
        }
    }
}
module.exports = SendmailTransport;


/***/ }),

/***/ 19728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const packageData = __webpack_require__(60983);
const shared = __webpack_require__(33050);
const LeWindows = __webpack_require__(52045);
/**
 * Generates a Transport object for AWS SES
 *
 * Possible options can be the following:
 *
 *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES
 *  * **maxConnections** optional Number specifying max number of parallel connections to SES
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class SESTransport extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        this.options = options || {};
        this.ses = this.options.SES;
        this.name = "SESTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "ses-transport"
        });
        // parallel sending connections
        this.maxConnections = Number(this.options.maxConnections) || Infinity;
        this.connections = 0;
        // max messages per second
        this.sendingRate = Number(this.options.sendingRate) || Infinity;
        this.sendingRateTTL = null;
        this.rateInterval = 1000; // milliseconds
        this.rateMessages = [];
        this.pending = [];
        this.idling = true;
        setImmediate(()=>{
            if (this.idling) {
                this.emit("idle");
            }
        });
    }
    /**
     * Schedules a sending of a message
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, callback) {
        if (this.connections >= this.maxConnections) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }
        if (!this._checkSendingRate()) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }
        this._send(mail, (...args)=>{
            setImmediate(()=>callback(...args));
            this._sent();
        });
    }
    _checkRatedQueue() {
        if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
            return;
        }
        if (!this.pending.length) {
            if (!this.idling) {
                this.idling = true;
                this.emit("idle");
            }
            return;
        }
        let next = this.pending.shift();
        this._send(next.mail, (...args)=>{
            setImmediate(()=>next.callback(...args));
            this._sent();
        });
    }
    _checkSendingRate() {
        clearTimeout(this.sendingRateTTL);
        let now = Date.now();
        let oldest = false;
        // delete older messages
        for(let i = this.rateMessages.length - 1; i >= 0; i--){
            if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
                oldest = this.rateMessages[i].ts;
            }
            if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
                this.rateMessages.splice(i, 1);
            }
        }
        if (this.rateMessages.length < this.sendingRate) {
            return true;
        }
        let delay = Math.max(oldest + 1001, now + 20);
        this.sendingRateTTL = setTimeout(()=>this._checkRatedQueue(), now - delay);
        try {
            this.sendingRateTTL.unref();
        } catch (E) {
        // Ignore. Happens on envs with non-node timer implementation
        }
        return false;
    }
    _sent() {
        this.connections--;
        this._checkRatedQueue();
    }
    /**
     * Returns true if there are free slots in the queue
     */ isIdle() {
        return this.idling;
    }
    /**
     * Compiles a mailcomposer message and forwards it to SES
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ _send(mail, callback) {
        let statObject = {
            ts: Date.now(),
            pending: true
        };
        this.connections++;
        this.rateMessages.push(statObject);
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Sending message %s to <%s>", messageId, recipients.join(", "));
        let getRawMessage = (next)=>{
            // do not use Message-ID and Date in DKIM signature
            if (!mail.data._dkim) {
                mail.data._dkim = {};
            }
            if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
                mail.data._dkim.skipFields += ":date:message-id";
            } else {
                mail.data._dkim.skipFields = "date:message-id";
            }
            let sourceStream = mail.message.createReadStream();
            let stream = sourceStream.pipe(new LeWindows());
            let chunks = [];
            let chunklen = 0;
            stream.on("readable", ()=>{
                let chunk;
                while((chunk = stream.read()) !== null){
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });
            sourceStream.once("error", (err)=>stream.emit("error", err));
            stream.once("error", (err)=>{
                next(err);
            });
            stream.once("end", ()=>next(null, Buffer.concat(chunks, chunklen)));
        };
        setImmediate(()=>getRawMessage((err, raw)=>{
                if (err) {
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed creating message for %s. %s", messageId, err.message);
                    statObject.pending = false;
                    return callback(err);
                }
                let sesMessage = {
                    RawMessage: {
                        // required
                        Data: raw // required
                    },
                    Source: envelope.from,
                    Destinations: envelope.to
                };
                Object.keys(mail.data.ses || {}).forEach((key)=>{
                    sesMessage[key] = mail.data.ses[key];
                });
                let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
                let aws = this.ses.aws || {};
                let getRegion = (cb)=>{
                    if (ses.config && typeof ses.config.region === "function") {
                        // promise
                        return ses.config.region().then((region)=>cb(null, region)).catch((err)=>cb(err));
                    }
                    return cb(null, ses.config && ses.config.region || "us-east-1");
                };
                getRegion((err, region)=>{
                    if (err || !region) {
                        region = "us-east-1";
                    }
                    let sendPromise;
                    if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
                        // v3 API
                        sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
                    } else {
                        // v2 API
                        sendPromise = ses.sendRawEmail(sesMessage).promise();
                    }
                    sendPromise.then((data)=>{
                        if (region === "us-east-1") {
                            region = "email";
                        }
                        statObject.pending = false;
                        callback(null, {
                            envelope: {
                                from: envelope.from,
                                to: envelope.to
                            },
                            messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
                            response: data.MessageId,
                            raw
                        });
                    }).catch((err)=>{
                        this.logger.error({
                            err,
                            tnx: "send"
                        }, "Send error for %s: %s", messageId, err.message);
                        statObject.pending = false;
                        callback(err);
                    });
                });
            }));
    }
    /**
     * Verifies SES configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};
        const sesMessage = {
            RawMessage: {
                // required
                Data: "From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid"
            },
            Source: "invalid@invalid",
            Destinations: [
                "invalid@invalid"
            ]
        };
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        const cb = (err)=>{
            if (err && (err.code || err.Code) !== "InvalidParameterValue") {
                return callback(err);
            }
            return callback(null, true);
        };
        if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
            // v3 API
            sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
            ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
        } else {
            // v2 API
            ses.sendRawEmail(sesMessage, cb);
        }
        return promise;
    }
}
module.exports = SESTransport;


/***/ }),

/***/ 33050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-console: 0 */ 
const urllib = __webpack_require__(57310);
const util = __webpack_require__(73837);
const fs = __webpack_require__(57147);
const nmfetch = __webpack_require__(99075);
const dns = __webpack_require__(17578);
const net = __webpack_require__(41808);
const os = __webpack_require__(22037);
const DNS_TTL = 5 * 60 * 1000;
let networkInterfaces;
try {
    networkInterfaces = os.networkInterfaces();
} catch (err) {
// fails on some systems
}
module.exports.networkInterfaces = networkInterfaces;
const isFamilySupported = (family, allowInternal)=>{
    let networkInterfaces = module.exports.networkInterfaces;
    if (!networkInterfaces) {
        // hope for the best
        return true;
    }
    const familySupported = // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
    Object.keys(networkInterfaces).map((key)=>networkInterfaces[key])// crux that replaces .flat() as it is not supported in older Node versions (v10 and older)
    .reduce((acc, val)=>acc.concat(val), []).filter((i)=>!i.internal || allowInternal).filter((i)=>i.family === "IPv" + family || i.family === family).length > 0;
    return familySupported;
};
const resolver = (family, hostname, options, callback)=>{
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
    if (!familySupported) {
        return callback(null, []);
    }
    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver["resolve" + family](hostname, (err, addresses)=>{
        if (err) {
            switch(err.code){
                case dns.NODATA:
                case dns.NOTFOUND:
                case dns.NOTIMP:
                case dns.SERVFAIL:
                case dns.CONNREFUSED:
                case dns.REFUSED:
                case "EAI_AGAIN":
                    return callback(null, []);
            }
            return callback(err);
        }
        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
};
const dnsCache = module.exports.dnsCache = new Map();
const formatDNSValue = (value, extra)=>{
    if (!value) {
        return Object.assign({}, extra || {});
    }
    return Object.assign({
        servername: value.servername,
        host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
    }, extra || {});
};
module.exports.resolveHostname = (options, callback)=>{
    options = options || {};
    if (!options.host && options.servername) {
        options.host = options.servername;
    }
    if (!options.host || net.isIP(options.host)) {
        // nothing to do here
        let value = {
            addresses: [
                options.host
            ],
            servername: options.servername || false
        };
        return callback(null, formatDNSValue(value, {
            cached: false
        }));
    }
    let cached;
    if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);
        if (!cached.expires || cached.expires >= Date.now()) {
            return callback(null, formatDNSValue(cached.value, {
                cached: true
            }));
        }
    }
    resolver(4, options.host, options, (err, addresses)=>{
        if (err) {
            if (cached) {
                // ignore error, use expired value
                return callback(null, formatDNSValue(cached.value, {
                    cached: true,
                    error: err
                }));
            }
            return callback(err);
        }
        if (addresses && addresses.length) {
            let value = {
                addresses,
                servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(null, formatDNSValue(value, {
                cached: false
            }));
        }
        resolver(6, options.host, options, (err, addresses)=>{
            if (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(null, formatDNSValue(cached.value, {
                        cached: true,
                        error: err
                    }));
                }
                return callback(err);
            }
            if (addresses && addresses.length) {
                let value = {
                    addresses,
                    servername: options.servername || options.host
                };
                dnsCache.set(options.host, {
                    value,
                    expires: Date.now() + (options.dnsTtl || DNS_TTL)
                });
                return callback(null, formatDNSValue(value, {
                    cached: false
                }));
            }
            try {
                dns.lookup(options.host, {
                    all: true
                }, (err, addresses)=>{
                    if (err) {
                        if (cached) {
                            // ignore error, use expired value
                            return callback(null, formatDNSValue(cached.value, {
                                cached: true,
                                error: err
                            }));
                        }
                        return callback(err);
                    }
                    let address = addresses ? addresses.filter((addr)=>isFamilySupported(addr.family)).map((addr)=>addr.address).shift() : false;
                    if (addresses && addresses.length && !address) {
                        // there are addresses but none can be used
                        console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);
                    }
                    if (!address && cached) {
                        // nothing was found, fallback to cached value
                        return callback(null, formatDNSValue(cached.value, {
                            cached: true
                        }));
                    }
                    let value = {
                        addresses: address ? [
                            address
                        ] : [
                            options.host
                        ],
                        servername: options.servername || options.host
                    };
                    dnsCache.set(options.host, {
                        value,
                        expires: Date.now() + (options.dnsTtl || DNS_TTL)
                    });
                    return callback(null, formatDNSValue(value, {
                        cached: false
                    }));
                });
            } catch (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(null, formatDNSValue(cached.value, {
                        cached: true,
                        error: err
                    }));
                }
                return callback(err);
            }
        });
    });
};
/**
 * Parses connection url to a structured configuration object
 *
 * @param {String} str Connection url
 * @return {Object} Configuration object
 */ module.exports.parseConnectionUrl = (str)=>{
    str = str || "";
    let options = {};
    [
        urllib.parse(str, true)
    ].forEach((url)=>{
        let auth;
        switch(url.protocol){
            case "smtp:":
                options.secure = false;
                break;
            case "smtps:":
                options.secure = true;
                break;
            case "direct:":
                options.direct = true;
                break;
        }
        if (!isNaN(url.port) && Number(url.port)) {
            options.port = Number(url.port);
        }
        if (url.hostname) {
            options.host = url.hostname;
        }
        if (url.auth) {
            auth = url.auth.split(":");
            if (!options.auth) {
                options.auth = {};
            }
            options.auth.user = auth.shift();
            options.auth.pass = auth.join(":");
        }
        Object.keys(url.query || {}).forEach((key)=>{
            let obj = options;
            let lKey = key;
            let value = url.query[key];
            if (!isNaN(value)) {
                value = Number(value);
            }
            switch(value){
                case "true":
                    value = true;
                    break;
                case "false":
                    value = false;
                    break;
            }
            // tls is nested object
            if (key.indexOf("tls.") === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf(".") >= 0) {
                // ignore nested properties besides tls
                return;
            }
            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });
    return options;
};
module.exports._logFunc = (logger, level, defaults, data, message, ...args)=>{
    let entry = {};
    Object.keys(defaults || {}).forEach((key)=>{
        if (key !== "level") {
            entry[key] = defaults[key];
        }
    });
    Object.keys(data || {}).forEach((key)=>{
        if (key !== "level") {
            entry[key] = data[key];
        }
    });
    logger[level](entry, message, ...args);
};
/**
 * Returns a bunyan-compatible logger interface. Uses either provided logger or
 * creates a default console logger
 *
 * @param {Object} [options] Options object that might include 'logger' value
 * @return {Object} bunyan compatible logger
 */ module.exports.getLogger = (options, defaults)=>{
    options = options || {};
    let response = {};
    let levels = [
        "trace",
        "debug",
        "info",
        "warn",
        "error",
        "fatal"
    ];
    if (!options.logger) {
        // use vanity logger
        levels.forEach((level)=>{
            response[level] = ()=>false;
        });
        return response;
    }
    let logger = options.logger;
    if (options.logger === true) {
        // create console logger
        logger = createDefaultLogger(levels);
    }
    levels.forEach((level)=>{
        response[level] = (data, message, ...args)=>{
            module.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
    });
    return response;
};
/**
 * Wrapper for creating a callback that either resolves or rejects a promise
 * based on input
 *
 * @param {Function} resolve Function to run if callback is called
 * @param {Function} reject Function to run if callback ends with an error
 */ module.exports.callbackPromise = (resolve, reject)=>function() {
        let args = Array.from(arguments);
        let err = args.shift();
        if (err) {
            reject(err);
        } else {
            resolve(...args);
        }
    };
module.exports.parseDataURI = (uri)=>{
    let input = uri;
    let commaPos = input.indexOf(",");
    if (!commaPos) {
        return uri;
    }
    let data = input.substring(commaPos + 1);
    let metaStr = input.substring("data:".length, commaPos);
    let encoding;
    let metaEntries = metaStr.split(";");
    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry && lastMetaEntry.indexOf("=") < 0) {
        encoding = lastMetaEntry.toLowerCase();
        metaEntries.pop();
    }
    let contentType = metaEntries.shift() || "application/octet-stream";
    let params = {};
    for (let entry of metaEntries){
        let sep = entry.indexOf("=");
        if (sep >= 0) {
            let key = entry.substring(0, sep);
            let value = entry.substring(sep + 1);
            params[key] = value;
        }
    }
    switch(encoding){
        case "base64":
            data = Buffer.from(data, "base64");
            break;
        case "utf8":
            data = Buffer.from(data);
            break;
        default:
            try {
                data = Buffer.from(decodeURIComponent(data));
            } catch (err) {
                data = Buffer.from(data);
            }
            data = Buffer.from(data);
    }
    return {
        data,
        encoding,
        contentType,
        params
    };
};
/**
 * Resolves a String or a Buffer value for content value. Useful if the value
 * is a Stream or a file or an URL. If the value is a Stream, overwrites
 * the stream object with the resolved value (you can't stream a value twice).
 *
 * This is useful when you want to create a plugin that needs a content value,
 * for example the `html` or `text` value as a String or a Buffer but not as
 * a file path or an URL.
 *
 * @param {Object} data An object or an Array you want to resolve an element for
 * @param {String|Number} key Property name or an Array index
 * @param {Function} callback Callback function with (err, value)
 */ module.exports.resolveContent = (data, key, callback)=>{
    let promise;
    if (!callback) {
        promise = new Promise((resolve, reject)=>{
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }
    let content = data && data[key] && data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
    if (!content) {
        return callback(null, content);
    }
    if (typeof content === "object") {
        if (typeof content.pipe === "function") {
            return resolveStream(content, (err, value)=>{
                if (err) {
                    return callback(err);
                }
                // we can't stream twice the same content, so we need
                // to replace the stream object with the streaming result
                if (data[key].content) {
                    data[key].content = value;
                } else {
                    data[key] = value;
                }
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = nmfetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            let parsedDataUri = module.exports.parseDataURI(content.path || content.href);
            if (!parsedDataUri || !parsedDataUri.data) {
                return callback(null, Buffer.from(0));
            }
            return callback(null, parsedDataUri.data);
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }
    if (typeof data[key].content === "string" && ![
        "utf8",
        "usascii",
        "ascii"
    ].includes(encoding)) {
        content = Buffer.from(data[key].content, encoding);
    }
    // default action, return as is
    setImmediate(()=>callback(null, content));
    return promise;
};
/**
 * Copies properties from source objects to target objects
 */ module.exports.assign = function() {
    let args = Array.from(arguments);
    let target = args.shift() || {};
    args.forEach((source)=>{
        Object.keys(source || {}).forEach((key)=>{
            if ([
                "tls",
                "auth"
            ].includes(key) && source[key] && typeof source[key] === "object") {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // ensure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach((subKey)=>{
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
};
module.exports.encodeXText = (str)=>{
    // ! 0x21
    // + 0x2B
    // = 0x3D
    // ~ 0x7E
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
    }
    let buf = Buffer.from(str);
    let result = "";
    for(let i = 0, len = buf.length; i < len; i++){
        let c = buf[i];
        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {
            result += "+" + (c < 0x10 ? "0" : "") + c.toString(16).toUpperCase();
        } else {
            result += String.fromCharCode(c);
        }
    }
    return result;
};
/**
 * Streams a stream value into a Buffer
 *
 * @param {Object} stream Readable stream
 * @param {Function} callback Callback function with (err, value)
 */ function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;
    stream.on("error", (err)=>{
        if (responded) {
            return;
        }
        responded = true;
        callback(err);
    });
    stream.on("readable", ()=>{
        let chunk;
        while((chunk = stream.read()) !== null){
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });
    stream.on("end", ()=>{
        if (responded) {
            return;
        }
        responded = true;
        let value;
        try {
            value = Buffer.concat(chunks, chunklen);
        } catch (E) {
            return callback(E);
        }
        callback(null, value);
    });
}
/**
 * Generates a bunyan-like logger that prints to console
 *
 * @returns {Object} Bunyan logger instance
 */ function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map();
    levels.forEach((level)=>{
        if (level.length > levelMaxLen) {
            levelMaxLen = level.length;
        }
    });
    levels.forEach((level)=>{
        let levelName = level.toUpperCase();
        if (levelName.length < levelMaxLen) {
            levelName += " ".repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
    });
    let print = (level, entry, message, ...args)=>{
        let prefix = "";
        if (entry) {
            if (entry.tnx === "server") {
                prefix = "S: ";
            } else if (entry.tnx === "client") {
                prefix = "C: ";
            }
            if (entry.sid) {
                prefix = "[" + entry.sid + "] " + prefix;
            }
            if (entry.cid) {
                prefix = "[#" + entry.cid + "] " + prefix;
            }
        }
        message = util.format(message, ...args);
        message.split(/\r?\n/).forEach((line)=>{
            console.log("[%s] %s %s", new Date().toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
        });
    };
    let logger = {};
    levels.forEach((level)=>{
        logger[level] = print.bind(null, level);
    });
    return logger;
}


/***/ }),

/***/ 58102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const stream = __webpack_require__(12781);
const Transform = stream.Transform;
/**
 * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>
 * Also makes sure that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */ class DataStream extends Transform {
    constructor(options){
        super(options);
        // init Transform
        this.options = options || {};
        this._curLine = "";
        this.inByteCount = 0;
        this.outByteCount = 0;
        this.lastByte = false;
    }
    /**
     * Escapes dots
     */ _transform(chunk, encoding, done) {
        let chunks = [];
        let chunklen = 0;
        let i, len, lastPos = 0;
        let buf;
        if (!chunk || !chunk.length) {
            return done();
        }
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk);
        }
        this.inByteCount += chunk.length;
        for(i = 0, len = chunk.length; i < len; i++){
            if (chunk[i] === 0x2e) {
                // .
                if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {
                    buf = chunk.slice(lastPos, i + 1);
                    chunks.push(buf);
                    chunks.push(Buffer.from("."));
                    chunklen += buf.length + 1;
                    lastPos = i + 1;
                }
            } else if (chunk[i] === 0x0a) {
                // .
                if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        chunks.push(buf);
                        chunklen += buf.length + 2;
                    } else {
                        chunklen += 2;
                    }
                    chunks.push(Buffer.from("\r\n"));
                    lastPos = i + 1;
                }
            }
        }
        if (chunklen) {
            // add last piece
            if (lastPos < chunk.length) {
                buf = chunk.slice(lastPos);
                chunks.push(buf);
                chunklen += buf.length;
            }
            this.outByteCount += chunklen;
            this.push(Buffer.concat(chunks, chunklen));
        } else {
            this.outByteCount += chunk.length;
            this.push(chunk);
        }
        this.lastByte = chunk[chunk.length - 1];
        done();
    }
    /**
     * Finalizes the stream with a dot on a single line
     */ _flush(done) {
        let buf;
        if (this.lastByte === 0x0a) {
            buf = Buffer.from(".\r\n");
        } else if (this.lastByte === 0x0d) {
            buf = Buffer.from("\n.\r\n");
        } else {
            buf = Buffer.from("\r\n.\r\n");
        }
        this.outByteCount += buf.length;
        this.push(buf);
        done();
    }
}
module.exports = DataStream;


/***/ }),

/***/ 62989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/**
 * Minimal HTTP/S proxy client
 */ const net = __webpack_require__(41808);
const tls = __webpack_require__(24404);
const urllib = __webpack_require__(57310);
/**
 * Establishes proxied connection to destinationPort
 *
 * httpProxyClient("http://localhost:3128/", 80, "google.com", function(err, socket){
 *     socket.write("GET / HTTP/1.0\r\n\r\n");
 * });
 *
 * @param {String} proxyUrl proxy configuration, etg "http://proxy.host:3128/"
 * @param {Number} destinationPort Port to open in destination host
 * @param {String} destinationHost Destination hostname
 * @param {Function} callback Callback to run with the rocket object once connection is established
 */ function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    // create a socket connection to the proxy server
    let options;
    let connect;
    let socket;
    options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
        // we can use untrusted proxies as long as we verify actual SMTP certificates
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
    } else {
        connect = net.connect.bind(net);
    }
    // Error harness for initial connection. Once connection is established, the responsibility
    // to handle errors is passed to whoever uses this socket
    let finished = false;
    let tempSocketErr = (err)=>{
        if (finished) {
            return;
        }
        finished = true;
        try {
            socket.destroy();
        } catch (E) {
        // ignore
        }
        callback(err);
    };
    let timeoutErr = ()=>{
        let err = new Error("Proxy socket timed out");
        err.code = "ETIMEDOUT";
        tempSocketErr(err);
    };
    socket = connect(options, ()=>{
        if (finished) {
            return;
        }
        let reqHeaders = {
            Host: destinationHost + ":" + destinationPort,
            Connection: "close"
        };
        if (proxy.auth) {
            reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
        }
        socket.write(// HTTP method
        "CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + // HTTP request headers
        Object.keys(reqHeaders).map((key)=>key + ": " + reqHeaders[key]).join("\r\n") + // End request
        "\r\n\r\n");
        let headers = "";
        let onSocketData = (chunk)=>{
            let match;
            let remainder;
            if (finished) {
                return;
            }
            headers += chunk.toString("binary");
            if (match = headers.match(/\r\n\r\n/)) {
                socket.removeListener("data", onSocketData);
                remainder = headers.substr(match.index + match[0].length);
                headers = headers.substr(0, match.index);
                if (remainder) {
                    socket.unshift(Buffer.from(remainder, "binary"));
                }
                // proxy connection is now established
                finished = true;
                // check response code
                match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
                if (!match || (match[1] || "").charAt(0) !== "2") {
                    try {
                        socket.destroy();
                    } catch (E) {
                    // ignore
                    }
                    return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
                }
                socket.removeListener("error", tempSocketErr);
                socket.removeListener("timeout", timeoutErr);
                socket.setTimeout(0);
                return callback(null, socket);
            }
        };
        socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
}
module.exports = httpProxyClient;


/***/ }),

/***/ 29003:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageInfo = __webpack_require__(60983);
const EventEmitter = (__webpack_require__(82361).EventEmitter);
const net = __webpack_require__(41808);
const tls = __webpack_require__(24404);
const os = __webpack_require__(22037);
const crypto = __webpack_require__(6113);
const DataStream = __webpack_require__(58102);
const PassThrough = (__webpack_require__(12781).PassThrough);
const shared = __webpack_require__(33050);
// default timeout values in ms
const CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established
const SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client
const GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved
const DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname
/**
 * Generates a SMTP connection object
 *
 * Optional options object takes the following possible properties:
 *
 *  * **port** - is the port to connect to (defaults to 587 or 465)
 *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')
 *  * **secure** - use SSL
 *  * **ignoreTLS** - ignore server support for STARTTLS
 *  * **requireTLS** - forces the client to use STARTTLS
 *  * **name** - the name of the client server
 *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
 *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
 *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
 *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
 *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)
 *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
 *  * **logger** - bunyan compatible logger interface
 *  * **debug** - if true pass SMTP traffic to the logger
 *  * **tls** - options for createCredentials
 *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
 *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
 *
 * @constructor
 * @namespace SMTP Client module
 * @param {Object} [options] Option properties
 */ class SMTPConnection extends EventEmitter {
    constructor(options){
        super(options);
        this.id = crypto.randomBytes(8).toString("base64").replace(/\W/g, "");
        this.stage = "init";
        this.options = options || {};
        this.secureConnection = !!this.options.secure;
        this.alreadySecured = !!this.options.secured;
        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
        this.host = this.options.host || "localhost";
        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;
        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
        if (typeof this.options.secure === "undefined" && this.port === 465) {
            // if secure option is not set but port is 465, then default to secure
            this.secureConnection = true;
        }
        this.name = this.options.name || this._getHostname();
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-connection",
            sid: this.id
        });
        this.customAuth = new Map();
        Object.keys(this.options.customAuth || {}).forEach((key)=>{
            let mapKey = (key || "").toString().trim().toUpperCase();
            if (!mapKey) {
                return;
            }
            this.customAuth.set(mapKey, this.options.customAuth[key]);
        });
        /**
         * Expose version nr, just for the reference
         * @type {String}
         */ this.version = packageInfo.version;
        /**
         * If true, then the user is authenticated
         * @type {Boolean}
         */ this.authenticated = false;
        /**
         * If set to true, this instance is no longer active
         * @private
         */ this.destroyed = false;
        /**
         * Defines if the current connection is secure or not. If not,
         * STARTTLS can be used if available
         * @private
         */ this.secure = !!this.secureConnection;
        /**
         * Store incomplete messages coming from the server
         * @private
         */ this._remainder = "";
        /**
         * Unprocessed responses from the server
         * @type {Array}
         */ this._responseQueue = [];
        this.lastServerResponse = false;
        /**
         * The socket connecting to the server
         * @publick
         */ this._socket = false;
        /**
         * Lists supported auth mechanisms
         * @private
         */ this._supportedAuth = [];
        /**
         * Set to true, if EHLO response includes "AUTH".
         * If false then authentication is not tried
         */ this.allowsAuth = false;
        /**
         * Includes current envelope (from, to)
         * @private
         */ this._envelope = false;
        /**
         * Lists supported extensions
         * @private
         */ this._supportedExtensions = [];
        /**
         * Defines the maximum allowed size for a single message
         * @private
         */ this._maxAllowedSize = 0;
        /**
         * Function queue to run if a data chunk comes from the server
         * @private
         */ this._responseActions = [];
        this._recipientQueue = [];
        /**
         * Timeout variable for waiting the greeting
         * @private
         */ this._greetingTimeout = false;
        /**
         * Timeout variable for waiting the connection to start
         * @private
         */ this._connectionTimeout = false;
        /**
         * If the socket is deemed already closed
         * @private
         */ this._destroyed = false;
        /**
         * If the socket is already being closed
         * @private
         */ this._closing = false;
        /**
         * Callbacks for socket's listeners
         */ this._onSocketData = (chunk)=>this._onData(chunk);
        this._onSocketError = (error)=>this._onError(error, "ESOCKET", false, "CONN");
        this._onSocketClose = ()=>this._onClose();
        this._onSocketEnd = ()=>this._onEnd();
        this._onSocketTimeout = ()=>this._onTimeout();
    }
    /**
     * Creates a connection to a SMTP server and sets up connection
     * listener
     */ connect(connectCallback) {
        if (typeof connectCallback === "function") {
            this.once("connect", ()=>{
                this.logger.debug({
                    tnx: "smtp"
                }, "SMTP handshake finished");
                connectCallback();
            });
            const isDestroyedMessage = this._isDestroyedMessage("connect");
            if (isDestroyedMessage) {
                return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
            }
        }
        let opts = {
            port: this.port,
            host: this.host,
            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
            timeout: this.options.dnsTimeout || DNS_TIMEOUT
        };
        if (this.options.localAddress) {
            opts.localAddress = this.options.localAddress;
        }
        let setupConnectionHandlers = ()=>{
            this._connectionTimeout = setTimeout(()=>{
                this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
            this._socket.on("error", this._onSocketError);
        };
        if (this.options.connection) {
            // connection is already opened
            this._socket = this.options.connection;
            if (this.secureConnection && !this.alreadySecured) {
                setImmediate(()=>this._upgradeConnection((err)=>{
                        if (err) {
                            this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
                            return;
                        }
                        this._onConnect();
                    }));
            } else {
                setImmediate(()=>this._onConnect());
            }
            return;
        } else if (this.options.socket) {
            // socket object is set up but not yet connected
            this._socket = this.options.socket;
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket.connect(this.port, this.host, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        } else if (this.secureConnection) {
            // connect using tls
            if (this.options.tls) {
                Object.keys(this.options.tls).forEach((key)=>{
                    opts[key] = this.options.tls[key];
                });
            }
            // ensure servername for SNI
            if (this.servername && !opts.servername) {
                opts.servername = this.servername;
            }
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = tls.connect(opts, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        } else {
            // connect using plaintext
            return shared.resolveHostname(opts, (err, resolved)=>{
                if (err) {
                    return setImmediate(()=>this._onError(err, "EDNS", false, "CONN"));
                }
                this.logger.debug({
                    tnx: "dns",
                    source: opts.host,
                    resolved: resolved.host,
                    cached: !!resolved.cached
                }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
                Object.keys(resolved).forEach((key)=>{
                    if (key.charAt(0) !== "_" && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = net.connect(opts, ()=>{
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(()=>this._onError(E, "ECONNECTION", false, "CONN"));
                }
            });
        }
    }
    /**
     * Sends QUIT
     */ quit() {
        this._sendCommand("QUIT");
        this._responseActions.push(this.close);
    }
    /**
     * Closes the connection to the server
     */ close() {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        this._responseActions = [];
        // allow to run this function only once
        if (this._closing) {
            return;
        }
        this._closing = true;
        let closeMethod = "end";
        if (this.stage === "init") {
            // Close the socket immediately when connection timed out
            closeMethod = "destroy";
        }
        this.logger.debug({
            tnx: "smtp"
        }, 'Closing connection to the server using "%s"', closeMethod);
        let socket = this._socket && this._socket.socket || this._socket;
        if (socket && !socket.destroyed) {
            try {
                this._socket[closeMethod]();
            } catch (E) {
            // just ignore
            }
        }
        this._destroy();
    }
    /**
     * Authenticate user
     */ login(authData, callback) {
        const isDestroyedMessage = this._isDestroyedMessage("login");
        if (isDestroyedMessage) {
            return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        this._auth = authData || {};
        // Select SASL authentication method
        this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
            this._authMethod = "XOAUTH2";
        } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
            // use first supported
            this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
        }
        if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
            if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
                this._auth.credentials = {
                    user: this._auth.user,
                    pass: this._auth.pass,
                    options: this._auth.options
                };
            } else {
                return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
            }
        }
        if (this.customAuth.has(this._authMethod)) {
            let handler = this.customAuth.get(this._authMethod);
            let lastResponse;
            let returned = false;
            let resolve = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                this.logger.info({
                    tnx: "smtp",
                    username: this._auth.user,
                    action: "authenticated",
                    method: this._authMethod
                }, "User %s authenticated", JSON.stringify(this._auth.user));
                this.authenticated = true;
                callback(null, true);
            };
            let reject = (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                callback(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
            };
            let handlerResponse = handler({
                auth: this._auth,
                method: this._authMethod,
                extensions: [].concat(this._supportedExtensions),
                authMethods: [].concat(this._supportedAuth),
                maxAllowedSize: this._maxAllowedSize || false,
                sendCommand: (cmd, done)=>{
                    let promise;
                    if (!done) {
                        promise = new Promise((resolve, reject)=>{
                            done = shared.callbackPromise(resolve, reject);
                        });
                    }
                    this._responseActions.push((str)=>{
                        lastResponse = str;
                        let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                        let data = {
                            command: cmd,
                            response: str
                        };
                        if (codes) {
                            data.status = Number(codes[1]) || 0;
                            if (codes[2]) {
                                data.code = codes[2];
                            }
                            data.text = str.substr(codes[0].length);
                        } else {
                            data.text = str;
                            data.status = 0; // just in case we need to perform numeric comparisons
                        }
                        done(null, data);
                    });
                    setImmediate(()=>this._sendCommand(cmd));
                    return promise;
                },
                resolve,
                reject
            });
            if (handlerResponse && typeof handlerResponse.catch === "function") {
                // a promise was returned
                handlerResponse.then(resolve).catch(reject);
            }
            return;
        }
        switch(this._authMethod){
            case "XOAUTH2":
                this._handleXOauth2Token(false, callback);
                return;
            case "LOGIN":
                this._responseActions.push((str)=>{
                    this._actionAUTH_LOGIN_USER(str, callback);
                });
                this._sendCommand("AUTH LOGIN");
                return;
            case "PLAIN":
                this._responseActions.push((str)=>{
                    this._actionAUTHComplete(str, callback);
                });
                this._sendCommand("AUTH PLAIN " + Buffer.from(//this._auth.user+'\u0000'+
                "\x00" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\x00" + this._auth.credentials.pass, "utf-8").toString("base64"), // log entry without passwords
                "AUTH PLAIN " + Buffer.from(//this._auth.user+'\u0000'+
                "\x00" + // skip authorization identity as it causes problems with some servers
                this._auth.credentials.user + "\x00" + "/* secret */", "utf-8").toString("base64"));
                return;
            case "CRAM-MD5":
                this._responseActions.push((str)=>{
                    this._actionAUTH_CRAM_MD5(str, callback);
                });
                this._sendCommand("AUTH CRAM-MD5");
                return;
        }
        return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    /**
     * Sends a message
     *
     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
     * @param {Object} message String, Buffer or a Stream
     * @param {Function} callback Callback to return once sending is completed
     */ send(envelope, message, done) {
        if (!message) {
            return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
        }
        const isDestroyedMessage = this._isDestroyedMessage("send message");
        if (isDestroyedMessage) {
            return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
        }
        // reject larger messages than allowed
        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
            return setImmediate(()=>{
                done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
            });
        }
        // ensure that callback is only called once
        let returned = false;
        let callback = function() {
            if (returned) {
                return;
            }
            returned = true;
            done(...arguments);
        };
        if (typeof message.on === "function") {
            message.on("error", (err)=>callback(this._formatError(err, "ESTREAM", false, "API")));
        }
        let startTime = Date.now();
        this._setEnvelope(envelope, (err, info)=>{
            if (err) {
                return callback(err);
            }
            let envelopeTime = Date.now();
            let stream = this._createSendStream((err, str)=>{
                if (err) {
                    return callback(err);
                }
                info.envelopeTime = envelopeTime - startTime;
                info.messageTime = Date.now() - envelopeTime;
                info.messageSize = stream.outByteCount;
                info.response = str;
                return callback(null, info);
            });
            if (typeof message.pipe === "function") {
                message.pipe(stream);
            } else {
                stream.write(message);
                stream.end();
            }
        });
    }
    /**
     * Resets connection state
     *
     * @param {Function} callback Callback to return once connection is reset
     */ reset(callback) {
        this._sendCommand("RSET");
        this._responseActions.push((str)=>{
            if (str.charAt(0) !== "2") {
                return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
            }
            this._envelope = false;
            return callback(null, true);
        });
    }
    /**
     * Connection listener that is run when the connection to
     * the server is opened
     *
     * @event
     */ _onConnect() {
        clearTimeout(this._connectionTimeout);
        this.logger.info({
            tnx: "network",
            localAddress: this._socket.localAddress,
            localPort: this._socket.localPort,
            remoteAddress: this._socket.remoteAddress,
            remotePort: this._socket.remotePort
        }, "%s established to %s:%s", this.secure ? "Secure connection" : "Connection", this._socket.remoteAddress, this._socket.remotePort);
        if (this._destroyed) {
            // Connection was established after we already had canceled it
            this.close();
            return;
        }
        this.stage = "connected";
        // clear existing listeners for the socket
        this._socket.removeListener("data", this._onSocketData);
        this._socket.removeListener("timeout", this._onSocketTimeout);
        this._socket.removeListener("close", this._onSocketClose);
        this._socket.removeListener("end", this._onSocketEnd);
        this._socket.on("data", this._onSocketData);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on("timeout", this._onSocketTimeout);
        this._greetingTimeout = setTimeout(()=>{
            // if still waiting for greeting, give up
            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
                this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
            }
        }, this.options.greetingTimeout || GREETING_TIMEOUT);
        this._responseActions.push(this._actionGreeting);
        // we have a 'data' listener set up so resume socket if it was paused
        this._socket.resume();
    }
    /**
     * 'data' listener for data coming from the server
     *
     * @event
     * @param {Buffer} chunk Data chunk coming from the server
     */ _onData(chunk) {
        if (this._destroyed || !chunk || !chunk.length) {
            return;
        }
        let data = (chunk || "").toString("binary");
        let lines = (this._remainder + data).split(/\r?\n/);
        let lastline;
        this._remainder = lines.pop();
        for(let i = 0, len = lines.length; i < len; i++){
            if (this._responseQueue.length) {
                lastline = this._responseQueue[this._responseQueue.length - 1];
                if (/^\d+-/.test(lastline.split("\n").pop())) {
                    this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
                    continue;
                }
            }
            this._responseQueue.push(lines[i]);
        }
        if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+-/.test(lastline.split("\n").pop())) {
                return;
            }
        }
        this._processResponse();
    }
    /**
     * 'error' listener for the socket
     *
     * @event
     * @param {Error} err Error object
     * @param {String} type Error name
     */ _onError(err, type, data, command) {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        if (this._destroyed) {
            // just ignore, already closed
            // this might happen when a socket is canceled because of reached timeout
            // but the socket timeout error itself receives only after
            return;
        }
        err = this._formatError(err, type, data, command);
        this.logger.error(data, err.message);
        this.emit("error", err);
        this.close();
    }
    _formatError(message, type, response, command) {
        let err;
        if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
            err = message;
        } else {
            err = new Error(message);
        }
        if (type && type !== "Error") {
            err.code = type;
        }
        if (response) {
            err.response = response;
            err.message += ": " + response;
        }
        let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
        if (responseCode) {
            err.responseCode = responseCode;
        }
        if (command) {
            err.command = command;
        }
        return err;
    }
    /**
     * 'close' listener for the socket
     *
     * @event
     */ _onClose() {
        let serverResponse = false;
        if (this._remainder && this._remainder.trim()) {
            if (this.options.debug || this.options.transactionLog) {
                this.logger.debug({
                    tnx: "server"
                }, this._remainder.replace(/\r?\n$/, ""));
            }
            this.lastServerResponse = serverResponse = this._remainder.trim();
        }
        this.logger.info({
            tnx: "network"
        }, "Connection closed");
        if (this.upgrading && !this._destroyed) {
            return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
        } else if (![
            this._actionGreeting,
            this.close
        ].includes(this._responseActions[0]) && !this._destroyed) {
            return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
        } else if (/^[45]\d{2}\b/.test(serverResponse)) {
            return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
        }
        this._destroy();
    }
    /**
     * 'end' listener for the socket
     *
     * @event
     */ _onEnd() {
        if (this._socket && !this._socket.destroyed) {
            this._socket.destroy();
        }
    }
    /**
     * 'timeout' listener for the socket
     *
     * @event
     */ _onTimeout() {
        return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    /**
     * Destroys the client, emits 'end'
     */ _destroy() {
        if (this._destroyed) {
            return;
        }
        this._destroyed = true;
        this.emit("end");
    }
    /**
     * Upgrades the connection to TLS
     *
     * @param {Function} callback Callback function to run when the connection
     *        has been secured
     */ _upgradeConnection(callback) {
        // do not remove all listeners or it breaks node v0.10 as there's
        // apparently a 'finish' event set that would be cleared as well
        // we can safely keep 'error', 'end', 'close' etc. events
        this._socket.removeListener("data", this._onSocketData); // incoming data is going to be gibberish from this point onwards
        this._socket.removeListener("timeout", this._onSocketTimeout); // timeout will be re-set for the new socket object
        let socketPlain = this._socket;
        let opts = {
            socket: this._socket,
            host: this.host
        };
        Object.keys(this.options.tls || {}).forEach((key)=>{
            opts[key] = this.options.tls[key];
        });
        // ensure servername for SNI
        if (this.servername && !opts.servername) {
            opts.servername = this.servername;
        }
        this.upgrading = true;
        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch
        try {
            this._socket = tls.connect(opts, ()=>{
                this.secure = true;
                this.upgrading = false;
                this._socket.on("data", this._onSocketData);
                socketPlain.removeListener("close", this._onSocketClose);
                socketPlain.removeListener("end", this._onSocketEnd);
                return callback(null, true);
            });
        } catch (err) {
            return callback(err);
        }
        this._socket.on("error", this._onSocketError);
        this._socket.once("close", this._onSocketClose);
        this._socket.once("end", this._onSocketEnd);
        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.
        this._socket.on("timeout", this._onSocketTimeout);
        // resume in case the socket was paused
        socketPlain.resume();
    }
    /**
     * Processes queued responses from the server
     *
     * @param {Boolean} force If true, ignores _processing flag
     */ _processResponse() {
        if (!this._responseQueue.length) {
            return false;
        }
        let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
        if (/^\d+-/.test(str.split("\n").pop())) {
            // keep waiting for the final part of multiline response
            return;
        }
        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug({
                tnx: "server"
            }, str.replace(/\r?\n$/, ""));
        }
        if (!str.trim()) {
            // skip unexpected empty lines
            setImmediate(()=>this._processResponse());
        }
        let action = this._responseActions.shift();
        if (typeof action === "function") {
            action.call(this, str);
            setImmediate(()=>this._processResponse());
        } else {
            return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
        }
    }
    /**
     * Send a command to the server, append \r\n
     *
     * @param {String} str String to be sent to the server
     * @param {String} logStr Optional string to be used for logging instead of the actual string
     */ _sendCommand(str, logStr) {
        if (this._destroyed) {
            // Connection already closed, can't send any more data
            return;
        }
        if (this._socket.destroyed) {
            return this.close();
        }
        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug({
                tnx: "client"
            }, (logStr || str || "").toString().replace(/\r?\n$/, ""));
        }
        this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    /**
     * Initiates a new message by submitting envelope data, starting with
     * MAIL FROM: command
     *
     * @param {Object} envelope Envelope object in the form of
     *        {from:'...', to:['...']}
     *        or
     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
     */ _setEnvelope(envelope, callback) {
        let args = [];
        let useSmtpUtf8 = false;
        this._envelope = envelope || {};
        this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
        this._envelope.to = [].concat(this._envelope.to || []).map((to)=>(to && to.address || to || "").toString().trim());
        if (!this._envelope.to.length) {
            return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
        }
        if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
            return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
        }
        // check if the sender address uses only ASCII characters,
        // otherwise require usage of SMTPUTF8 extension
        if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
            useSmtpUtf8 = true;
        }
        for(let i = 0, len = this._envelope.to.length; i < len; i++){
            if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
                return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
            }
            // check if the recipients addresses use only ASCII characters,
            // otherwise require usage of SMTPUTF8 extension
            if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
                useSmtpUtf8 = true;
            }
        }
        // clone the recipients array for latter manipulation
        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
        this._envelope.rejected = [];
        this._envelope.rejectedErrors = [];
        this._envelope.accepted = [];
        if (this._envelope.dsn) {
            try {
                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
            } catch (err) {
                return callback(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
            }
        }
        this._responseActions.push((str)=>{
            this._actionMAIL(str, callback);
        });
        // If the server supports SMTPUTF8 and the envelope includes an internationalized
        // email address then append SMTPUTF8 keyword to the MAIL FROM command
        if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
            args.push("SMTPUTF8");
            this._usingSmtpUtf8 = true;
        }
        // If the server supports 8BITMIME and the message might contain non-ascii bytes
        // then append the 8BITMIME keyword to the MAIL FROM command
        if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
            args.push("BODY=8BITMIME");
            this._using8BitMime = true;
        }
        if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
            args.push("SIZE=" + this._envelope.size);
        }
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the MAIL FROM command
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
            if (this._envelope.dsn.ret) {
                args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
            }
            if (this._envelope.dsn.envid) {
                args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
            }
        }
        this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
        let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
        if (ret) {
            switch(ret){
                case "HDRS":
                case "HEADERS":
                    ret = "HDRS";
                    break;
                case "FULL":
                case "BODY":
                    ret = "FULL";
                    break;
            }
        }
        if (ret && ![
            "FULL",
            "HDRS"
        ].includes(ret)) {
            throw new Error("ret: " + JSON.stringify(ret));
        }
        let envid = (params.envid || params.id || "").toString() || null;
        let notify = params.notify || null;
        if (notify) {
            if (typeof notify === "string") {
                notify = notify.split(",");
            }
            notify = notify.map((n)=>n.trim().toUpperCase());
            let validNotify = [
                "NEVER",
                "SUCCESS",
                "FAILURE",
                "DELAY"
            ];
            let invaliNotify = notify.filter((n)=>!validNotify.includes(n));
            if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
                throw new Error("notify: " + JSON.stringify(notify.join(",")));
            }
            notify = notify.join(",");
        }
        let orcpt = (params.recipient || params.orcpt || "").toString() || null;
        if (orcpt && orcpt.indexOf(";") < 0) {
            orcpt = "rfc822;" + orcpt;
        }
        return {
            ret,
            envid,
            notify,
            orcpt
        };
    }
    _getDsnRcptToArgs() {
        let args = [];
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the RCPT TO command
        if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
            if (this._envelope.dsn.notify) {
                args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
            }
            if (this._envelope.dsn.orcpt) {
                args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
            }
        }
        return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
        let dataStream = new DataStream();
        let logStream;
        if (this.options.lmtp) {
            this._envelope.accepted.forEach((recipient, i)=>{
                let final = i === this._envelope.accepted.length - 1;
                this._responseActions.push((str)=>{
                    this._actionLMTPStream(recipient, final, str, callback);
                });
            });
        } else {
            this._responseActions.push((str)=>{
                this._actionSMTPStream(str, callback);
            });
        }
        dataStream.pipe(this._socket, {
            end: false
        });
        if (this.options.debug) {
            logStream = new PassThrough();
            logStream.on("readable", ()=>{
                let chunk;
                while(chunk = logStream.read()){
                    this.logger.debug({
                        tnx: "message"
                    }, chunk.toString("binary").replace(/\r?\n$/, ""));
                }
            });
            dataStream.pipe(logStream);
        }
        dataStream.once("end", ()=>{
            this.logger.info({
                tnx: "message",
                inByteCount: dataStream.inByteCount,
                outByteCount: dataStream.outByteCount
            }, "<%s bytes encoded mime message (source size %s bytes)>", dataStream.outByteCount, dataStream.inByteCount);
        });
        return dataStream;
    }
    /** ACTIONS **/ /**
     * Will be run after the connection is created and the server sends
     * a greeting. If the incoming message starts with 220 initiate
     * SMTP session by sending EHLO command
     *
     * @param {String} str Message from the server
     */ _actionGreeting(str) {
        clearTimeout(this._greetingTimeout);
        if (str.substr(0, 3) !== "220") {
            this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
            return;
        }
        if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
        } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
        }
    }
    /**
     * Handles server response for LHLO command. If it yielded in
     * error, emit 'error', otherwise treat this as an EHLO response
     *
     * @param {String} str Message from the server
     */ _actionLHLO(str) {
        if (str.charAt(0) !== "2") {
            this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
            return;
        }
        this._actionEHLO(str);
    }
    /**
     * Handles server response for EHLO command. If it yielded in
     * error, try HELO instead, otherwise initiate TLS negotiation
     * if STARTTLS is supported by the server or move into the
     * authentication phase.
     *
     * @param {String} str Message from the server
     */ _actionEHLO(str) {
        let match;
        if (str.substr(0, 3) === "421") {
            this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
            return;
        }
        if (str.charAt(0) !== "2") {
            if (this.options.requireTLS) {
                this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
                return;
            }
            // Try HELO instead
            this._responseActions.push(this._actionHELO);
            this._sendCommand("HELO " + this.name);
            return;
        }
        this._ehloLines = str.split(/\r?\n/).map((line)=>line.replace(/^\d+[ -]/, "").trim()).filter((line)=>line).slice(1);
        // Detect if the server supports STARTTLS
        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
            this._sendCommand("STARTTLS");
            this._responseActions.push(this._actionSTARTTLS);
            return;
        }
        // Detect if the server supports SMTPUTF8
        if (/[ -]SMTPUTF8\b/im.test(str)) {
            this._supportedExtensions.push("SMTPUTF8");
        }
        // Detect if the server supports DSN
        if (/[ -]DSN\b/im.test(str)) {
            this._supportedExtensions.push("DSN");
        }
        // Detect if the server supports 8BITMIME
        if (/[ -]8BITMIME\b/im.test(str)) {
            this._supportedExtensions.push("8BITMIME");
        }
        // Detect if the server supports PIPELINING
        if (/[ -]PIPELINING\b/im.test(str)) {
            this._supportedExtensions.push("PIPELINING");
        }
        // Detect if the server supports AUTH
        if (/[ -]AUTH\b/i.test(str)) {
            this.allowsAuth = true;
        }
        // Detect if the server supports PLAIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
            this._supportedAuth.push("PLAIN");
        }
        // Detect if the server supports LOGIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
            this._supportedAuth.push("LOGIN");
        }
        // Detect if the server supports CRAM-MD5 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
            this._supportedAuth.push("CRAM-MD5");
        }
        // Detect if the server supports XOAUTH2 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
            this._supportedAuth.push("XOAUTH2");
        }
        // Detect if the server supports SIZE extensions (and the max allowed size)
        if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
            this._supportedExtensions.push("SIZE");
            this._maxAllowedSize = Number(match[1]) || 0;
        }
        this.emit("connect");
    }
    /**
     * Handles server response for HELO command. If it yielded in
     * error, emit 'error', otherwise move into the authentication phase.
     *
     * @param {String} str Message from the server
     */ _actionHELO(str) {
        if (str.charAt(0) !== "2") {
            this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
            return;
        }
        // assume that authentication is enabled (most probably is not though)
        this.allowsAuth = true;
        this.emit("connect");
    }
    /**
     * Handles server response for STARTTLS command. If there's an error
     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
     * succeedes restart the EHLO
     *
     * @param {String} str Message from the server
     */ _actionSTARTTLS(str) {
        if (str.charAt(0) !== "2") {
            if (this.options.opportunisticTLS) {
                this.logger.info({
                    tnx: "smtp"
                }, "Failed STARTTLS upgrade, continuing unencrypted");
                return this.emit("connect");
            }
            this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
            return;
        }
        this._upgradeConnection((err, secured)=>{
            if (err) {
                this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
                return;
            }
            this.logger.info({
                tnx: "smtp"
            }, "Connection upgraded with STARTTLS");
            if (secured) {
                // restart session
                if (this.options.lmtp) {
                    this._responseActions.push(this._actionLHLO);
                    this._sendCommand("LHLO " + this.name);
                } else {
                    this._responseActions.push(this._actionEHLO);
                    this._sendCommand("EHLO " + this.name);
                }
            } else {
                this.emit("connect");
            }
        });
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
     * response needs to be base64 encoded username. We do not need
     * exact match but settle with 334 response in general as some
     * hosts invalidly use a longer message than VXNlcm5hbWU6
     *
     * @param {String} str Message from the server
     */ _actionAUTH_LOGIN_USER(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 VXNlcm5hbWU6'
            callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
            return;
        }
        this._responseActions.push((str)=>{
            this._actionAUTH_LOGIN_PASS(str, callback);
        });
        this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    /**
     * Handle the response for AUTH CRAM-MD5 command. We are expecting
     * '334 <challenge string>'. Data to be sent as response needs to be
     * base64 decoded challenge string, MD5 hashed using the password as
     * a HMAC key, prefixed by the username and a space, and finally all
     * base64 encoded again.
     *
     * @param {String} str Message from the server
     */ _actionAUTH_CRAM_MD5(str, callback) {
        let challengeMatch = str.match(/^334\s+(.+)$/);
        let challengeString = "";
        if (!challengeMatch) {
            return callback(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
        } else {
            challengeString = challengeMatch[1];
        }
        // Decode from base64
        let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto.createHmac("md5", this._auth.credentials.pass);
        hmacMD5.update(base64decoded);
        let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
        this._responseActions.push((str)=>{
            this._actionAUTH_CRAM_MD5_PASS(str, callback);
        });
        this._sendCommand(Buffer.from(prepended).toString("base64"), // hidden hash for logs
        Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64"));
    }
    /**
     * Handles the response to CRAM-MD5 authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */ _actionAUTH_CRAM_MD5_PASS(str, callback) {
        if (!str.match(/^235\s+/)) {
            return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
        }
        this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
        }, "User %s authenticated", JSON.stringify(this._auth.user));
        this.authenticated = true;
        callback(null, true);
    }
    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
     * response needs to be base64 encoded password.
     *
     * @param {String} str Message from the server
     */ _actionAUTH_LOGIN_PASS(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 UGFzc3dvcmQ6'
            return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
        }
        this._responseActions.push((str)=>{
            this._actionAUTHComplete(str, callback);
        });
        this._sendCommand(Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"), // Hidden pass for logs
        Buffer.from("/* secret */", "utf-8").toString("base64"));
    }
    /**
     * Handles the response for authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */ _actionAUTHComplete(str, isRetry, callback) {
        if (!callback && typeof isRetry === "function") {
            callback = isRetry;
            isRetry = false;
        }
        if (str.substr(0, 3) === "334") {
            this._responseActions.push((str)=>{
                if (isRetry || this._authMethod !== "XOAUTH2") {
                    this._actionAUTHComplete(str, true, callback);
                } else {
                    // fetch a new OAuth2 access token
                    setImmediate(()=>this._handleXOauth2Token(true, callback));
                }
            });
            this._sendCommand("");
            return;
        }
        if (str.charAt(0) !== "2") {
            this.logger.info({
                tnx: "smtp",
                username: this._auth.user,
                action: "authfail",
                method: this._authMethod
            }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
            return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
        }
        this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
        }, "User %s authenticated", JSON.stringify(this._auth.user));
        this.authenticated = true;
        callback(null, true);
    }
    /**
     * Handle response for a MAIL FROM: command
     *
     * @param {String} str Message from the server
     */ _actionMAIL(str, callback) {
        let message, curRecipient;
        if (Number(str.charAt(0)) !== 2) {
            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
                message = "Internationalized mailbox name not allowed";
            } else {
                message = "Mail command failed";
            }
            return callback(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
        }
        if (!this._envelope.rcptQueue.length) {
            return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
        } else {
            this._recipientQueue = [];
            if (this._supportedExtensions.includes("PIPELINING")) {
                while(this._envelope.rcptQueue.length){
                    curRecipient = this._envelope.rcptQueue.shift();
                    this._recipientQueue.push(curRecipient);
                    this._responseActions.push((str)=>{
                        this._actionRCPT(str, callback);
                    });
                    this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
                }
            } else {
                curRecipient = this._envelope.rcptQueue.shift();
                this._recipientQueue.push(curRecipient);
                this._responseActions.push((str)=>{
                    this._actionRCPT(str, callback);
                });
                this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
            }
        }
    }
    /**
     * Handle response for a RCPT TO: command
     *
     * @param {String} str Message from the server
     */ _actionRCPT(str, callback) {
        let message, err, curRecipient = this._recipientQueue.shift();
        if (Number(str.charAt(0)) !== 2) {
            // this is a soft error
            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
                message = "Internationalized mailbox name not allowed";
            } else {
                message = "Recipient command failed";
            }
            this._envelope.rejected.push(curRecipient);
            // store error for the failed recipient
            err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
            err.recipient = curRecipient;
            this._envelope.rejectedErrors.push(err);
        } else {
            this._envelope.accepted.push(curRecipient);
        }
        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
            if (this._envelope.rejected.length < this._envelope.to.length) {
                this._responseActions.push((str)=>{
                    this._actionDATA(str, callback);
                });
                this._sendCommand("DATA");
            } else {
                err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
                err.rejected = this._envelope.rejected;
                err.rejectedErrors = this._envelope.rejectedErrors;
                return callback(err);
            }
        } else if (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str)=>{
                this._actionRCPT(str, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
    }
    /**
     * Handle response for a DATA command
     *
     * @param {String} str Message from the server
     */ _actionDATA(str, callback) {
        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
        if (!/^[23]/.test(str)) {
            return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
        }
        let response = {
            accepted: this._envelope.accepted,
            rejected: this._envelope.rejected
        };
        if (this._ehloLines && this._ehloLines.length) {
            response.ehlo = this._ehloLines;
        }
        if (this._envelope.rejectedErrors.length) {
            response.rejectedErrors = this._envelope.rejectedErrors;
        }
        callback(null, response);
    }
    /**
     * Handle response for a DATA stream when using SMTP
     * We expect a single response that defines if the sending succeeded or failed
     *
     * @param {String} str Message from the server
     */ _actionSMTPStream(str, callback) {
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
        } else {
            // Message sent succesfully
            return callback(null, str);
        }
    }
    /**
     * Handle response for a DATA stream
     * We expect a separate response for every recipient. All recipients can either
     * succeed or fail separately
     *
     * @param {String} recipient The recipient this response applies to
     * @param {Boolean} final Is this the final recipient?
     * @param {String} str Message from the server
     */ _actionLMTPStream(recipient, final, str, callback) {
        let err;
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
            err.recipient = recipient;
            this._envelope.rejected.push(recipient);
            this._envelope.rejectedErrors.push(err);
            for(let i = 0, len = this._envelope.accepted.length; i < len; i++){
                if (this._envelope.accepted[i] === recipient) {
                    this._envelope.accepted.splice(i, 1);
                }
            }
        }
        if (final) {
            return callback(null, str);
        }
    }
    _handleXOauth2Token(isRetry, callback) {
        this._auth.oauth2.getToken(isRetry, (err, accessToken)=>{
            if (err) {
                this.logger.info({
                    tnx: "smtp",
                    username: this._auth.user,
                    action: "authfail",
                    method: this._authMethod
                }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
                return callback(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
            }
            this._responseActions.push((str)=>{
                this._actionAUTHComplete(str, isRetry, callback);
            });
            this._sendCommand("AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken), //  Hidden for logs
            "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */"));
        });
    }
    /**
     *
     * @param {string} command
     * @private
     */ _isDestroyedMessage(command) {
        if (this._destroyed) {
            return "Cannot " + command + " - smtp connection is already destroyed.";
        }
        if (this._socket) {
            if (this._socket.destroyed) {
                return "Cannot " + command + " - smtp connection socket is already destroyed.";
            }
            if (!this._socket.writable) {
                return "Cannot " + command + " - smtp connection socket is already half-closed.";
            }
        }
    }
    _getHostname() {
        // defaul hostname is machine hostname or [IP]
        let defaultHostname;
        try {
            defaultHostname = os.hostname() || "";
        } catch (err) {
            // fails on windows 7
            defaultHostname = "localhost";
        }
        // ignore if not FQDN
        if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
            defaultHostname = "[127.0.0.1]";
        }
        // IP should be enclosed in []
        if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
            defaultHostname = "[" + defaultHostname + "]";
        }
        return defaultHostname;
    }
}
module.exports = SMTPConnection;


/***/ }),

/***/ 48242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const PoolResource = __webpack_require__(48106);
const SMTPConnection = __webpack_require__(29003);
const wellKnown = __webpack_require__(18205);
const shared = __webpack_require__(33050);
const packageData = __webpack_require__(60983);
/**
 * Creates a SMTP pool transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options SMTP Connection options
 */ class SMTPPool extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        if (typeof options === "string") {
            options = {
                url: options
            };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
            this.getSocket = options.getSocket;
        }
        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }
        this.options = shared.assign(false, options, urlData, service && wellKnown(service) // wellknown options
        );
        this.options.maxConnections = this.options.maxConnections || 5;
        this.options.maxMessages = this.options.maxMessages || 100;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-pool"
        });
        // temporary object
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP (pool)";
        this.version = packageData.version + "[client:" + connection.version + "]";
        this._rateLimit = {
            counter: 0,
            timeout: null,
            waiting: [],
            checkpoint: false,
            delta: Number(this.options.rateDelta) || 1000,
            limit: Number(this.options.rateLimit) || 0
        };
        this._closed = false;
        this._queue = [];
        this._connections = [];
        this._connectionCounter = 0;
        this.idling = true;
        setImmediate(()=>{
            if (this.idling) {
                this.emit("idle");
            }
        });
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */ getSocket(options, callback) {
        // return immediatelly
        return setImmediate(()=>callback(null, false));
    }
    /**
     * Queues an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        if (this._closed) {
            return false;
        }
        this._queue.push({
            mail,
            requeueAttempts: 0,
            callback
        });
        if (this.idling && this._queue.length >= this.options.maxConnections) {
            this.idling = false;
        }
        setImmediate(()=>this._processMessages());
        return true;
    }
    /**
     * Closes all connections in the pool. If there is a message being sent, the connection
     * is closed later
     */ close() {
        let connection;
        let len = this._connections.length;
        this._closed = true;
        // clear rate limit timer if it exists
        clearTimeout(this._rateLimit.timeout);
        if (!len && !this._queue.length) {
            return;
        }
        // remove all available connections
        for(let i = len - 1; i >= 0; i--){
            if (this._connections[i] && this._connections[i].available) {
                connection = this._connections[i];
                connection.close();
                this.logger.info({
                    tnx: "connection",
                    cid: connection.id,
                    action: "removed"
                }, "Connection #%s removed", connection.id);
            }
        }
        if (len && !this._connections.length) {
            this.logger.debug({
                tnx: "connection"
            }, "All connections removed");
        }
        if (!this._queue.length) {
            return;
        }
        // make sure that entire queue would be cleaned
        let invokeCallbacks = ()=>{
            if (!this._queue.length) {
                this.logger.debug({
                    tnx: "connection"
                }, "Pending queue entries cleared");
                return;
            }
            let entry = this._queue.shift();
            if (entry && typeof entry.callback === "function") {
                try {
                    entry.callback(new Error("Connection pool was closed"));
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
            }
            setImmediate(invokeCallbacks);
        };
        setImmediate(invokeCallbacks);
    }
    /**
     * Check the queue and available connections. If there is a message to be sent and there is
     * an available connection, then use this connection to send the mail
     */ _processMessages() {
        let connection;
        let i, len;
        // do nothing if already closed
        if (this._closed) {
            return;
        }
        // do nothing if queue is empty
        if (!this._queue.length) {
            if (!this.idling) {
                // no pending jobs
                this.idling = true;
                this.emit("idle");
            }
            return;
        }
        // find first available connection
        for(i = 0, len = this._connections.length; i < len; i++){
            if (this._connections[i].available) {
                connection = this._connections[i];
                break;
            }
        }
        if (!connection && this._connections.length < this.options.maxConnections) {
            connection = this._createConnection();
        }
        if (!connection) {
            // no more free connection slots available
            this.idling = false;
            return;
        }
        // check if there is free space in the processing queue
        if (!this.idling && this._queue.length < this.options.maxConnections) {
            this.idling = true;
            this.emit("idle");
        }
        let entry = connection.queueEntry = this._queue.shift();
        entry.messageId = (connection.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
        connection.available = false;
        this.logger.debug({
            tnx: "pool",
            cid: connection.id,
            messageId: entry.messageId,
            action: "assign"
        }, "Assigned message <%s> to #%s (%s)", entry.messageId, connection.id, connection.messages + 1);
        if (this._rateLimit.limit) {
            this._rateLimit.counter++;
            if (!this._rateLimit.checkpoint) {
                this._rateLimit.checkpoint = Date.now();
            }
        }
        connection.send(entry.mail, (err, info)=>{
            // only process callback if current handler is not changed
            if (entry === connection.queueEntry) {
                try {
                    entry.callback(err, info);
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
                connection.queueEntry = false;
            }
        });
    }
    /**
     * Creates a new pool resource
     */ _createConnection() {
        let connection = new PoolResource(this);
        connection.id = ++this._connectionCounter;
        this.logger.info({
            tnx: "pool",
            cid: connection.id,
            action: "conection"
        }, "Created new pool resource #%s", connection.id);
        // resource comes available
        connection.on("available", ()=>{
            this.logger.debug({
                tnx: "connection",
                cid: connection.id,
                action: "available"
            }, "Connection #%s became available", connection.id);
            if (this._closed) {
                // if already closed run close() that will remove this connections from connections list
                this.close();
            } else {
                // check if there's anything else to send
                this._processMessages();
            }
        });
        // resource is terminated with an error
        connection.once("error", (err)=>{
            if (err.code !== "EMAXLIMIT") {
                this.logger.error({
                    err,
                    tnx: "pool",
                    cid: connection.id
                }, "Pool Error for #%s: %s", connection.id, err.message);
            } else {
                this.logger.debug({
                    tnx: "pool",
                    cid: connection.id,
                    action: "maxlimit"
                }, "Max messages limit exchausted for #%s", connection.id);
            }
            if (connection.queueEntry) {
                try {
                    connection.queueEntry.callback(err);
                } catch (E) {
                    this.logger.error({
                        err: E,
                        tnx: "callback",
                        cid: connection.id
                    }, "Callback error for #%s: %s", connection.id, E.message);
                }
                connection.queueEntry = false;
            }
            // remove the erroneus connection from connections list
            this._removeConnection(connection);
            this._continueProcessing();
        });
        connection.once("close", ()=>{
            this.logger.info({
                tnx: "connection",
                cid: connection.id,
                action: "closed"
            }, "Connection #%s was closed", connection.id);
            this._removeConnection(connection);
            if (connection.queueEntry) {
                // If the connection closed when sending, add the message to the queue again
                // if max number of requeues is not reached yet
                // Note that we must wait a bit.. because the callback of the 'error' handler might be called
                // in the next event loop
                setTimeout(()=>{
                    if (connection.queueEntry) {
                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                            this._requeueEntryOnConnectionClose(connection);
                        } else {
                            this._failDeliveryOnConnectionClose(connection);
                        }
                    }
                    this._continueProcessing();
                }, 50);
            } else {
                this._continueProcessing();
            }
        });
        this._connections.push(connection);
        return connection;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
            return true;
        }
        return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection) {
        if (connection.queueEntry && connection.queueEntry.callback) {
            try {
                connection.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
            } catch (E) {
                this.logger.error({
                    err: E,
                    tnx: "callback",
                    messageId: connection.queueEntry.messageId,
                    cid: connection.id
                }, "Callback error for #%s: %s", connection.id, E.message);
            }
            connection.queueEntry = false;
        }
    }
    _requeueEntryOnConnectionClose(connection) {
        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
        this.logger.debug({
            tnx: "pool",
            cid: connection.id,
            messageId: connection.queueEntry.messageId,
            action: "requeue"
        }, "Re-queued message <%s> for #%s. Attempt: #%s", connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);
        this._queue.unshift(connection.queueEntry);
        connection.queueEntry = false;
    }
    /**
     * Continue to process message if the pool hasn't closed
     */ _continueProcessing() {
        if (this._closed) {
            this.close();
        } else {
            setTimeout(()=>this._processMessages(), 100);
        }
    }
    /**
     * Remove resource from pool
     *
     * @param {Object} connection The PoolResource to remove
     */ _removeConnection(connection) {
        let index = this._connections.indexOf(connection);
        if (index !== -1) {
            this._connections.splice(index, 1);
        }
    }
    /**
     * Checks if connections have hit current rate limit and if so, queues the availability callback
     *
     * @param {Function} callback Callback function to run once rate limiter has been cleared
     */ _checkRateLimit(callback) {
        if (!this._rateLimit.limit) {
            return callback();
        }
        let now = Date.now();
        if (this._rateLimit.counter < this._rateLimit.limit) {
            return callback();
        }
        this._rateLimit.waiting.push(callback);
        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
            return this._clearRateLimit();
        } else if (!this._rateLimit.timeout) {
            this._rateLimit.timeout = setTimeout(()=>this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
            this._rateLimit.checkpoint = now;
        }
    }
    /**
     * Clears current rate limit limitation and runs paused callback
     */ _clearRateLimit() {
        clearTimeout(this._rateLimit.timeout);
        this._rateLimit.timeout = null;
        this._rateLimit.counter = 0;
        this._rateLimit.checkpoint = false;
        // resume all paused connections
        while(this._rateLimit.waiting.length){
            let cb = this._rateLimit.waiting.shift();
            setImmediate(cb);
        }
    }
    /**
     * Returns true if there are free slots in the queue
     */ isIdle() {
        return this.idling;
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        let auth = new PoolResource(this).auth;
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            let returned = false;
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error("Connection closed"));
            });
            let finalize = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, (err)=>{
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        finalize();
                    });
                } else if (!auth && connection.allowsAuth && options.forceAuth) {
                    let err = new Error("Authentication info was not provided");
                    err.code = "NoAuth";
                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });
        return promise;
    }
}
// expose to the world
module.exports = SMTPPool;


/***/ }),

/***/ 48106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SMTPConnection = __webpack_require__(29003);
const assign = (__webpack_require__(33050).assign);
const XOAuth2 = __webpack_require__(19011);
const EventEmitter = __webpack_require__(82361);
/**
 * Creates an element for the pool
 *
 * @constructor
 * @param {Object} options SMTPPool instance
 */ class PoolResource extends EventEmitter {
    constructor(pool){
        super();
        this.pool = pool;
        this.options = pool.options;
        this.logger = this.pool.logger;
        if (this.options.auth) {
            switch((this.options.auth.type || "").toString().toUpperCase()){
                case "OAUTH2":
                    {
                        let oauth2 = new XOAuth2(this.options.auth, this.logger);
                        oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
                        this.auth = {
                            type: "OAUTH2",
                            user: this.options.auth.user,
                            oauth2,
                            method: "XOAUTH2"
                        };
                        oauth2.on("token", (token)=>this.pool.mailer.emit("token", token));
                        oauth2.on("error", (err)=>this.emit("error", err));
                        break;
                    }
                default:
                    if (!this.options.auth.user && !this.options.auth.pass) {
                        break;
                    }
                    this.auth = {
                        type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
                        user: this.options.auth.user,
                        credentials: {
                            user: this.options.auth.user || "",
                            pass: this.options.auth.pass,
                            options: this.options.auth.options
                        },
                        method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
                    };
            }
        }
        this._connection = false;
        this._connected = false;
        this.messages = 0;
        this.available = true;
    }
    /**
     * Initiates a connection to the SMTP server
     *
     * @param {Function} callback Callback function to run once the connection is established or failed
     */ connect(callback) {
        this.pool.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            this.connection = new SMTPConnection(options);
            this.connection.once("error", (err)=>{
                this.emit("error", err);
                if (returned) {
                    return;
                }
                returned = true;
                return callback(err);
            });
            this.connection.once("end", ()=>{
                this.close();
                if (returned) {
                    return;
                }
                returned = true;
                let timer = setTimeout(()=>{
                    if (returned) {
                        return;
                    }
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error("Unexpected socket close");
                    if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = "ETLS";
                    }
                    callback(err);
                }, 1000);
                try {
                    timer.unref();
                } catch (E) {
                // Ignore. Happens on envs with non-node timer implementation
                }
            });
            this.connection.connect(()=>{
                if (returned) {
                    return;
                }
                if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
                    this.connection.login(this.auth, (err)=>{
                        if (returned) {
                            return;
                        }
                        returned = true;
                        if (err) {
                            this.connection.close();
                            this.emit("error", err);
                            return callback(err);
                        }
                        this._connected = true;
                        callback(null, true);
                    });
                } else {
                    returned = true;
                    this._connected = true;
                    return callback(null, true);
                }
            });
        });
    }
    /**
     * Sends an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        if (!this._connected) {
            return this.connect((err)=>{
                if (err) {
                    return callback(err);
                }
                return this.send(mail, callback);
            });
        }
        let envelope = mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId,
            cid: this.id
        }, "Sending message %s using #%s to <%s>", messageId, this.id, recipients.join(", "));
        if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
        }
        this.connection.send(envelope, mail.message.createReadStream(), (err, info)=>{
            this.messages++;
            if (err) {
                this.connection.close();
                this.emit("error", err);
                return callback(err);
            }
            info.envelope = {
                from: envelope.from,
                to: envelope.to
            };
            info.messageId = messageId;
            setImmediate(()=>{
                let err;
                if (this.messages >= this.options.maxMessages) {
                    err = new Error("Resource exhausted");
                    err.code = "EMAXLIMIT";
                    this.connection.close();
                    this.emit("error", err);
                } else {
                    this.pool._checkRateLimit(()=>{
                        this.available = true;
                        this.emit("available");
                    });
                }
            });
            callback(null, info);
        });
    }
    /**
     * Closes the connection
     */ close() {
        this._connected = false;
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        if (this.connection) {
            this.connection.close();
        }
        this.emit("close");
    }
}
module.exports = PoolResource;


/***/ }),

/***/ 96911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(82361);
const SMTPConnection = __webpack_require__(29003);
const wellKnown = __webpack_require__(18205);
const shared = __webpack_require__(33050);
const XOAuth2 = __webpack_require__(19011);
const packageData = __webpack_require__(60983);
/**
 * Creates a SMTP transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options Connection options
 */ class SMTPTransport extends EventEmitter {
    constructor(options){
        super();
        options = options || {};
        if (typeof options === "string") {
            options = {
                url: options
            };
        }
        let urlData;
        let service = options.service;
        if (typeof options.getSocket === "function") {
            this.getSocket = options.getSocket;
        }
        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }
        this.options = shared.assign(false, options, urlData, service && wellKnown(service) // wellknown options
        );
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "smtp-transport"
        });
        // temporary object
        let connection = new SMTPConnection(this.options);
        this.name = "SMTP";
        this.version = packageData.version + "[client:" + connection.version + "]";
        if (this.options.auth) {
            this.auth = this.getAuth({});
        }
    }
    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */ getSocket(options, callback) {
        // return immediatelly
        return setImmediate(()=>callback(null, false));
    }
    getAuth(authOpts) {
        if (!authOpts) {
            return this.auth;
        }
        let hasAuth = false;
        let authData = {};
        if (this.options.auth && typeof this.options.auth === "object") {
            Object.keys(this.options.auth).forEach((key)=>{
                hasAuth = true;
                authData[key] = this.options.auth[key];
            });
        }
        if (authOpts && typeof authOpts === "object") {
            Object.keys(authOpts).forEach((key)=>{
                hasAuth = true;
                authData[key] = authOpts[key];
            });
        }
        if (!hasAuth) {
            return false;
        }
        switch((authData.type || "").toString().toUpperCase()){
            case "OAUTH2":
                {
                    if (!authData.service && !authData.user) {
                        return false;
                    }
                    let oauth2 = new XOAuth2(authData, this.logger);
                    oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
                    oauth2.on("token", (token)=>this.mailer.emit("token", token));
                    oauth2.on("error", (err)=>this.emit("error", err));
                    return {
                        type: "OAUTH2",
                        user: authData.user,
                        oauth2,
                        method: "XOAUTH2"
                    };
                }
            default:
                return {
                    type: (authData.type || "").toString().toUpperCase() || "LOGIN",
                    user: authData.user,
                    credentials: {
                        user: authData.user || "",
                        pass: authData.pass,
                        options: authData.options
                    },
                    method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
                };
        }
    }
    /**
     * Sends an e-mail using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */ send(mail, callback) {
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                // only copy options if we need to modify it
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                let timer = setTimeout(()=>{
                    if (returned) {
                        return;
                    }
                    returned = true;
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error("Unexpected socket close");
                    if (connection && connection._socket && connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = "ETLS";
                    }
                    callback(err);
                }, 1000);
                try {
                    timer.unref();
                } catch (E) {
                // Ignore. Happens on envs with non-node timer implementation
                }
            });
            let sendMessage = ()=>{
                let envelope = mail.message.getEnvelope();
                let messageId = mail.message.messageId();
                let recipients = [].concat(envelope.to || []);
                if (recipients.length > 3) {
                    recipients.push("...and " + recipients.splice(2).length + " more");
                }
                if (mail.data.dsn) {
                    envelope.dsn = mail.data.dsn;
                }
                this.logger.info({
                    tnx: "send",
                    messageId
                }, "Sending message %s to <%s>", messageId, recipients.join(", "));
                connection.send(envelope, mail.message.createReadStream(), (err, info)=>{
                    returned = true;
                    connection.close();
                    if (err) {
                        this.logger.error({
                            err,
                            tnx: "send"
                        }, "Send error for %s: %s", messageId, err.message);
                        return callback(err);
                    }
                    info.envelope = {
                        from: envelope.from,
                        to: envelope.to
                    };
                    info.messageId = messageId;
                    try {
                        return callback(null, info);
                    } catch (E) {
                        this.logger.error({
                            err: E,
                            tnx: "callback"
                        }, "Callback error for %s: %s", messageId, E.message);
                    }
                });
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                let auth = this.getAuth(mail.data.auth);
                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, (err)=>{
                        if (auth && auth !== this.auth && auth.oauth2) {
                            auth.oauth2.removeAllListeners();
                        }
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        sendMessage();
                    });
                } else {
                    sendMessage();
                }
            });
        });
    }
    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */ verify(callback) {
        let promise;
        if (!callback) {
            promise = new Promise((resolve, reject)=>{
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        this.getSocket(this.options, (err, socketOptions)=>{
            if (err) {
                return callback(err);
            }
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info({
                    tnx: "proxy",
                    remoteAddress: socketOptions.connection.remoteAddress,
                    remotePort: socketOptions.connection.remotePort,
                    destHost: options.host || "",
                    destPort: options.port || "",
                    action: "connected"
                }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach((key)=>{
                    options[key] = socketOptions[key];
                });
            }
            let connection = new SMTPConnection(options);
            let returned = false;
            connection.once("error", (err)=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });
            connection.once("end", ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error("Connection closed"));
            });
            let finalize = ()=>{
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };
            connection.connect(()=>{
                if (returned) {
                    return;
                }
                let authData = this.getAuth({});
                if (authData && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(authData, (err)=>{
                        if (returned) {
                            return;
                        }
                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }
                        finalize();
                    });
                } else if (!authData && connection.allowsAuth && options.forceAuth) {
                    let err = new Error("Authentication info was not provided");
                    err.code = "NoAuth";
                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });
        return promise;
    }
    /**
     * Releases resources
     */ close() {
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        this.emit("close");
    }
}
// expose to the world
module.exports = SMTPTransport;


/***/ }),

/***/ 76203:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const packageData = __webpack_require__(60983);
const shared = __webpack_require__(33050);
/**
 * Generates a Transport object for streaming
 *
 * Possible options can be the following:
 *
 *  * **buffer** if true, then returns the message as a Buffer object instead of a stream
 *  * **newline** either 'windows' or 'unix'
 *
 * @constructor
 * @param {Object} optional config parameter
 */ class StreamTransport {
    constructor(options){
        options = options || {};
        this.options = options || {};
        this.name = "StreamTransport";
        this.version = packageData.version;
        this.logger = shared.getLogger(this.options, {
            component: this.options.component || "stream-transport"
        });
        this.winbreak = [
            "win",
            "windows",
            "dos",
            "\r\n"
        ].includes((options.newline || "").toString().toLowerCase());
    }
    /**
     * Compiles a mailcomposer message and forwards it to handler that sends it
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */ send(mail, done) {
        // We probably need this in the output
        mail.message.keepBcc = true;
        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
            tnx: "send",
            messageId
        }, "Sending message %s to <%s> using %s line breaks", messageId, recipients.join(", "), this.winbreak ? "<CR><LF>" : "<LF>");
        setImmediate(()=>{
            let stream;
            try {
                stream = mail.message.createReadStream();
            } catch (E) {
                this.logger.error({
                    err: E,
                    tnx: "send",
                    messageId
                }, "Creating send stream failed for %s. %s", messageId, E.message);
                return done(E);
            }
            if (!this.options.buffer) {
                stream.once("error", (err)=>{
                    this.logger.error({
                        err,
                        tnx: "send",
                        messageId
                    }, "Failed creating message for %s. %s", messageId, err.message);
                });
                return done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: stream
                });
            }
            let chunks = [];
            let chunklen = 0;
            stream.on("readable", ()=>{
                let chunk;
                while((chunk = stream.read()) !== null){
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });
            stream.once("error", (err)=>{
                this.logger.error({
                    err,
                    tnx: "send",
                    messageId
                }, "Failed creating message for %s. %s", messageId, err.message);
                return done(err);
            });
            stream.on("end", ()=>done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: Buffer.concat(chunks, chunklen)
                }));
        });
    }
}
module.exports = StreamTransport;


/***/ }),

/***/ 18205:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const services = __webpack_require__(90432);
const normalized = {};
Object.keys(services).forEach((key)=>{
    let service = services[key];
    normalized[normalizeKey(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias)=>{
        normalized[normalizeKey(alias)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain)=>{
        normalized[normalizeKey(domain)] = normalizeService(service);
    });
});
function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
}
function normalizeService(service) {
    let filter = [
        "domains",
        "aliases"
    ];
    let response = {};
    Object.keys(service).forEach((key)=>{
        if (filter.indexOf(key) < 0) {
            response[key] = service[key];
        }
    });
    return response;
}
/**
 * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or
 * an email address (like 'test@googlemail.com').
 *
 * @param {String} key [description]
 * @returns {Object} SMTP config or false if not found
 */ module.exports = function(key) {
    key = normalizeKey(key.split("@").pop());
    return normalized[key] || false;
};


/***/ }),

/***/ 19011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Stream = (__webpack_require__(12781).Stream);
const nmfetch = __webpack_require__(99075);
const crypto = __webpack_require__(6113);
const shared = __webpack_require__(33050);
/**
 * XOAUTH2 access_token generator for Gmail.
 * Create client ID for web applications in Google API console to use it.
 * See Offline Access for receiving the needed refreshToken for an user
 * https://developers.google.com/accounts/docs/OAuth2WebServer#offline
 *
 * Usage for generating access tokens with a custom method using provisionCallback:
 * provisionCallback(user, renew, callback)
 *   * user is the username to get the token for
 *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed
 *   * callback is the callback to run with (error, accessToken [, expires])
 *     * accessToken is a string
 *     * expires is an optional expire time in milliseconds
 * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself
 *
 * @constructor
 * @param {Object} options Client information for token generation
 * @param {String} options.user User e-mail address
 * @param {String} options.clientId Client ID value
 * @param {String} options.clientSecret Client secret value
 * @param {String} options.refreshToken Refresh token for an user
 * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'
 * @param {String} options.accessToken An existing valid accessToken
 * @param {String} options.privateKey Private key for JSW
 * @param {Number} options.expires Optional Access Token expire time in ms
 * @param {Number} options.timeout Optional TTL for Access Token in seconds
 * @param {Function} options.provisionCallback Function to run when a new access token is required
 */ class XOAuth2 extends Stream {
    constructor(options, logger){
        super();
        this.options = options || {};
        if (options && options.serviceClient) {
            if (!options.privateKey || !options.user) {
                setImmediate(()=>this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
                return;
            }
            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
        }
        this.logger = shared.getLogger({
            logger
        }, {
            component: this.options.component || "OAuth2"
        });
        this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
        this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
        this.options.customHeaders = this.options.customHeaders || {};
        this.options.customParams = this.options.customParams || {};
        this.accessToken = this.options.accessToken || false;
        if (this.options.expires && Number(this.options.expires)) {
            this.expires = this.options.expires;
        } else {
            let timeout = Math.max(Number(this.options.timeout) || 0, 0);
            this.expires = timeout && Date.now() + timeout * 1000 || 0;
        }
    }
    /**
     * Returns or generates (if previous has expired) a XOAuth2 token
     *
     * @param {Boolean} renew If false then use cached access token (if available)
     * @param {Function} callback Callback function with error object and token string
     */ getToken(renew, callback) {
        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
            return callback(null, this.accessToken);
        }
        let generateCallback = (...args)=>{
            if (args[0]) {
                this.logger.error({
                    err: args[0],
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "renew"
                }, "Failed generating new Access Token for %s", this.options.user);
            } else {
                this.logger.info({
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "renew"
                }, "Generated new Access Token for %s", this.options.user);
            }
            callback(...args);
        };
        if (this.provisionCallback) {
            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires)=>{
                if (!err && accessToken) {
                    this.accessToken = accessToken;
                    this.expires = expires || 0;
                }
                generateCallback(err, accessToken);
            });
        } else {
            this.generateToken(generateCallback);
        }
    }
    /**
     * Updates token values
     *
     * @param {String} accessToken New access token
     * @param {Number} timeout Access token lifetime in seconds
     *
     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
     */ updateToken(accessToken, timeout) {
        this.accessToken = accessToken;
        timeout = Math.max(Number(timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1000 || 0;
        this.emit("token", {
            user: this.options.user,
            accessToken: accessToken || "",
            expires: this.expires
        });
    }
    /**
     * Generates a new XOAuth2 token with the credentials provided at initialization
     *
     * @param {Function} callback Callback function with error object and token string
     */ generateToken(callback) {
        let urlOptions;
        let loggedUrlOptions;
        if (this.options.serviceClient) {
            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount
            let iat = Math.floor(Date.now() / 1000); // unix time
            let tokenData = {
                iss: this.options.serviceClient,
                scope: this.options.scope || "https://mail.google.com/",
                sub: this.options.user,
                aud: this.options.accessUrl,
                iat,
                exp: iat + this.options.serviceRequestTimeout
            };
            let token;
            try {
                token = this.jwtSignRS256(tokenData);
            } catch (err) {
                return callback(new Error("Can't generate token. Check your auth options"));
            }
            urlOptions = {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: token
            };
            loggedUrlOptions = {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: tokenData
            };
        } else {
            if (!this.options.refreshToken) {
                return callback(new Error("Can't create new access token for user"));
            }
            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer
            urlOptions = {
                client_id: this.options.clientId || "",
                client_secret: this.options.clientSecret || "",
                refresh_token: this.options.refreshToken,
                grant_type: "refresh_token"
            };
            loggedUrlOptions = {
                client_id: this.options.clientId || "",
                client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
                refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
                grant_type: "refresh_token"
            };
        }
        Object.keys(this.options.customParams).forEach((key)=>{
            urlOptions[key] = this.options.customParams[key];
            loggedUrlOptions[key] = this.options.customParams[key];
        });
        this.logger.debug({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "generate"
        }, "Requesting token using: %s", JSON.stringify(loggedUrlOptions));
        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body)=>{
            let data;
            if (error) {
                return callback(error);
            }
            try {
                data = JSON.parse(body.toString());
            } catch (E) {
                return callback(E);
            }
            if (!data || typeof data !== "object") {
                this.logger.debug({
                    tnx: "OAUTH2",
                    user: this.options.user,
                    action: "post"
                }, "Response: %s", (body || "").toString());
                return callback(new Error("Invalid authentication response"));
            }
            let logData = {};
            Object.keys(data).forEach((key)=>{
                if (key !== "access_token") {
                    logData[key] = data[key];
                } else {
                    logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
                }
            });
            this.logger.debug({
                tnx: "OAUTH2",
                user: this.options.user,
                action: "post"
            }, "Response: %s", JSON.stringify(logData));
            if (data.error) {
                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2
                let errorMessage = data.error;
                if (data.error_description) {
                    errorMessage += ": " + data.error_description;
                }
                if (data.error_uri) {
                    errorMessage += " (" + data.error_uri + ")";
                }
                return callback(new Error(errorMessage));
            }
            if (data.access_token) {
                this.updateToken(data.access_token, data.expires_in);
                return callback(null, this.accessToken);
            }
            return callback(new Error("No access token"));
        });
    }
    /**
     * Converts an access_token and user id into a base64 encoded XOAuth2 token
     *
     * @param {String} [accessToken] Access token string
     * @return {String} Base64 encoded token for IMAP or SMTP login
     */ buildXOAuth2Token(accessToken) {
        let authData = [
            "user=" + (this.options.user || ""),
            "auth=Bearer " + (accessToken || this.accessToken),
            "",
            ""
        ];
        return Buffer.from(authData.join("\x01"), "utf-8").toString("base64");
    }
    /**
     * Custom POST request handler.
     * This is only needed to keep paths short in Windows – usually this module
     * is a dependency of a dependency and if it tries to require something
     * like the request module the paths get way too long to handle for Windows.
     * As we do only a simple POST request we do not actually require complicated
     * logic support (no redirects, no nothing) anyway.
     *
     * @param {String} url Url to POST to
     * @param {String|Buffer} payload Payload to POST
     * @param {Function} callback Callback function with (err, buff)
     */ postRequest(url, payload, params, callback) {
        let returned = false;
        let chunks = [];
        let chunklen = 0;
        let req = nmfetch(url, {
            method: "post",
            headers: params.customHeaders,
            body: payload,
            allowErrorResponse: true
        });
        req.on("readable", ()=>{
            let chunk;
            while((chunk = req.read()) !== null){
                chunks.push(chunk);
                chunklen += chunk.length;
            }
        });
        req.once("error", (err)=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });
        req.once("end", ()=>{
            if (returned) {
                return;
            }
            returned = true;
            return callback(null, Buffer.concat(chunks, chunklen));
        });
    }
    /**
     * Encodes a buffer or a string into Base64url format
     *
     * @param {Buffer|String} data The data to convert
     * @return {String} The encoded string
     */ toBase64URL(data) {
        if (typeof data === "string") {
            data = Buffer.from(data);
        }
        return data.toString("base64").replace(/[=]+/g, "") // remove '='s
        .replace(/\+/g, "-") // '+' → '-'
        .replace(/\//g, "_"); // '/' → '_'
    }
    /**
     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
     *
     * @param {Object} payload The payload to include in the generated token
     * @return {String} The generated and signed token
     */ jwtSignRS256(payload) {
        payload = [
            '{"alg":"RS256","typ":"JWT"}',
            JSON.stringify(payload)
        ].map((val)=>this.toBase64URL(val)).join(".");
        let signature = crypto.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
        return payload + "." + this.toBase64URL(signature);
    }
}
module.exports = XOAuth2;


/***/ }),

/***/ 56061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var name = __webpack_require__(82444);
/**
 * Wrap callbacks to prevent double execution.
 *
 * @param {Function} fn Function that should only be called once.
 * @returns {Function} A wrapped callback which prevents multiple executions.
 * @public
 */ module.exports = function one(fn) {
    var called = 0, value;
    /**
   * The function that prevents double execution.
   *
   * @private
   */ function onetime() {
        if (called) return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
    }
    //
    // To make debugging more easy we want to use the name of the supplied
    // function. So when you look at the functions that are assigned to event
    // listeners you don't see a load of `onetime` functions but actually the
    // names of the functions that this module will call.
    //
    // NOTE: We cannot override the `name` property, as that is `readOnly`
    // property, so displayName will have to do.
    //
    onetime.displayName = name(fn);
    return onetime;
};


/***/ }),

/***/ 8231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * pretty <https://github.com/jonschlinkert/pretty>
 *
 * Copyright (c) 2013-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */ 
var beautify = __webpack_require__(45805);
var condense = __webpack_require__(55956);
var extend = __webpack_require__(87845);
var defaults = {
    unformatted: [
        "code",
        "pre",
        "em",
        "strong",
        "span"
    ],
    indent_inner_html: true,
    indent_char: " ",
    indent_size: 2,
    sep: "\n"
};
module.exports = function pretty(str, options) {
    var opts = extend({}, defaults, options);
    str = beautify.html(str, opts);
    if (opts.ocd === true) {
        if (opts.newlines) opts.sep = opts.newlines;
        return ocd(str, opts);
    }
    return str;
};
function ocd(str, options) {
    // Normalize and condense all newlines
    return condense(str, options)// Remove empty whitespace the top of a file.
    .replace(/^\s+/g, "")// Remove extra whitespace from eof
    .replace(/\s+$/g, "\n")// Add a space above each comment
    .replace(/(\s*<!--)/g, "\n$1")// Bring closing comments up to the same line as closing tag.
    .replace(/>(\s*)(?=<!--\s*\/)/g, "> ");
}


/***/ }),

/***/ 38880:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.
var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC = 6;
function getPropertyInfo(name) {
    return properties.hasOwnProperty(name) ? properties[name] : null;
}
function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
    this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
    this.attributeName = attributeName;
    this.attributeNamespace = attributeNamespace;
    this.mustUseProperty = mustUseProperty;
    this.propertyName = name;
    this.type = type;
    this.sanitizeURL = sanitizeURL;
    this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
var reservedProps = [
    "children",
    "dangerouslySetInnerHTML",
    // elements (not just inputs). Now that ReactDOMInput assigns to the
    // defaultValue property -- do we need this?
    "defaultValue",
    "defaultChecked",
    "innerHTML",
    "suppressContentEditableWarning",
    "suppressHydrationWarning",
    "style"
];
reservedProps.forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[
    [
        "acceptCharset",
        "accept-charset"
    ],
    [
        "className",
        "class"
    ],
    [
        "htmlFor",
        "for"
    ],
    [
        "httpEquiv",
        "http-equiv"
    ]
].forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), name = _ref2[0], attributeName = _ref2[1];
    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
[
    "contentEditable",
    "draggable",
    "spellCheck",
    "value"
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
[
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha"
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
}); // These are HTML boolean attributes.
[
    "allowFullScreen",
    "async",
    // on the client side because the browsers are inconsistent. Instead we call focus().
    "autoFocus",
    "autoPlay",
    "controls",
    "default",
    "defer",
    "disabled",
    "disablePictureInPicture",
    "disableRemotePlayback",
    "formNoValidate",
    "hidden",
    "loop",
    "noModule",
    "noValidate",
    "open",
    "playsInline",
    "readOnly",
    "required",
    "reversed",
    "scoped",
    "seamless",
    "itemScope"
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
[
    "checked",
    // disabled with `removeAttribute`. We have special logic for handling this.
    "multiple",
    "muted",
    "selected" // NOTE: if you add a camelCased prop to this list,
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
[
    "capture",
    "download" // NOTE: if you add a camelCased prop to this list,
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
}); // These are HTML attributes that must be positive numbers.
[
    "cols",
    "rows",
    "size",
    "span" // NOTE: if you add a camelCased prop to this list,
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
}); // These are HTML attributes that must be numbers.
[
    "rowSpan",
    "start"
].forEach(function(name) {
    properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
});
var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function capitalize(token) {
    return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.
[
    "accent-height",
    "alignment-baseline",
    "arabic-form",
    "baseline-shift",
    "cap-height",
    "clip-path",
    "clip-rule",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "dominant-baseline",
    "enable-background",
    "fill-opacity",
    "fill-rule",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "glyph-name",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "horiz-adv-x",
    "horiz-origin-x",
    "image-rendering",
    "letter-spacing",
    "lighting-color",
    "marker-end",
    "marker-mid",
    "marker-start",
    "overline-position",
    "overline-thickness",
    "paint-order",
    "panose-1",
    "pointer-events",
    "rendering-intent",
    "shape-rendering",
    "stop-color",
    "stop-opacity",
    "strikethrough-position",
    "strikethrough-thickness",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "underline-position",
    "underline-thickness",
    "unicode-bidi",
    "unicode-range",
    "units-per-em",
    "v-alphabetic",
    "v-hanging",
    "v-ideographic",
    "v-mathematical",
    "vector-effect",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "word-spacing",
    "writing-mode",
    "xmlns:xlink",
    "x-height" // NOTE: if you add a camelCased prop to this list,
].forEach(function(attributeName) {
    var name = attributeName.replace(CAMELIZE, capitalize);
    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
}); // String SVG attributes with the xlink namespace.
[
    "xlink:actuate",
    "xlink:arcrole",
    "xlink:role",
    "xlink:show",
    "xlink:title",
    "xlink:type" // NOTE: if you add a camelCased prop to this list,
].forEach(function(attributeName) {
    var name = attributeName.replace(CAMELIZE, capitalize);
    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
}); // String SVG attributes with the xml namespace.
[
    "xml:base",
    "xml:lang",
    "xml:space" // NOTE: if you add a camelCased prop to this list,
].forEach(function(attributeName) {
    var name = attributeName.replace(CAMELIZE, capitalize);
    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
[
    "tabIndex",
    "crossOrigin"
].forEach(function(attributeName) {
    properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.
var xlinkHref = "xlinkHref";
properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
[
    "src",
    "href",
    "action",
    "formAction"
].forEach(function(attributeName) {
    properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
});
var _require = __webpack_require__(69479), CAMELCASE = _require.CAMELCASE, SAME = _require.SAME, possibleStandardNamesOptimized = _require.possibleStandardNames;
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
/**
 * Checks whether a property name is a custom attribute.
 *
 * @see {@link https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/HTMLDOMPropertyConfig.js#L23-L25}
 *
 * @param {string}
 * @return {boolean}
 */ var isCustomAttribute = RegExp.prototype.test.bind(new RegExp("^(data|aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"));
var possibleStandardNames = Object.keys(possibleStandardNamesOptimized).reduce(function(accumulator, standardName) {
    var propName = possibleStandardNamesOptimized[standardName];
    if (propName === SAME) {
        accumulator[standardName] = standardName;
    } else if (propName === CAMELCASE) {
        accumulator[standardName.toLowerCase()] = standardName;
    } else {
        accumulator[standardName] = propName;
    }
    return accumulator;
}, {});
exports.BOOLEAN = BOOLEAN;
exports.BOOLEANISH_STRING = BOOLEANISH_STRING;
exports.NUMERIC = NUMERIC;
exports.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
exports.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
exports.RESERVED = RESERVED;
exports.STRING = STRING;
exports.getPropertyInfo = getPropertyInfo;
exports.isCustomAttribute = isCustomAttribute;
exports.possibleStandardNames = possibleStandardNames;


/***/ }),

/***/ 69479:
/***/ ((__unused_webpack_module, exports) => {

// An attribute in which the DOM/SVG standard name is the same as the React prop name (e.g., 'accept').
var SAME = 0;
exports.SAME = SAME;
// An attribute in which the React prop name is the camelcased version of the DOM/SVG standard name (e.g., 'acceptCharset').
var CAMELCASE = 1;
exports.CAMELCASE = CAMELCASE;
exports.possibleStandardNames = {
    accept: 0,
    acceptCharset: 1,
    "accept-charset": "acceptCharset",
    accessKey: 1,
    action: 0,
    allowFullScreen: 1,
    alt: 0,
    as: 0,
    async: 0,
    autoCapitalize: 1,
    autoComplete: 1,
    autoCorrect: 1,
    autoFocus: 1,
    autoPlay: 1,
    autoSave: 1,
    capture: 0,
    cellPadding: 1,
    cellSpacing: 1,
    challenge: 0,
    charSet: 1,
    checked: 0,
    children: 0,
    cite: 0,
    class: "className",
    classID: 1,
    className: 1,
    cols: 0,
    colSpan: 1,
    content: 0,
    contentEditable: 1,
    contextMenu: 1,
    controls: 0,
    controlsList: 1,
    coords: 0,
    crossOrigin: 1,
    dangerouslySetInnerHTML: 1,
    data: 0,
    dateTime: 1,
    default: 0,
    defaultChecked: 1,
    defaultValue: 1,
    defer: 0,
    dir: 0,
    disabled: 0,
    disablePictureInPicture: 1,
    disableRemotePlayback: 1,
    download: 0,
    draggable: 0,
    encType: 1,
    enterKeyHint: 1,
    for: "htmlFor",
    form: 0,
    formMethod: 1,
    formAction: 1,
    formEncType: 1,
    formNoValidate: 1,
    formTarget: 1,
    frameBorder: 1,
    headers: 0,
    height: 0,
    hidden: 0,
    high: 0,
    href: 0,
    hrefLang: 1,
    htmlFor: 1,
    httpEquiv: 1,
    "http-equiv": "httpEquiv",
    icon: 0,
    id: 0,
    innerHTML: 1,
    inputMode: 1,
    integrity: 0,
    is: 0,
    itemID: 1,
    itemProp: 1,
    itemRef: 1,
    itemScope: 1,
    itemType: 1,
    keyParams: 1,
    keyType: 1,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: 0,
    low: 0,
    manifest: 0,
    marginWidth: 1,
    marginHeight: 1,
    max: 0,
    maxLength: 1,
    media: 0,
    mediaGroup: 1,
    method: 0,
    min: 0,
    minLength: 1,
    multiple: 0,
    muted: 0,
    name: 0,
    noModule: 1,
    nonce: 0,
    noValidate: 1,
    open: 0,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: 1,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 1,
    readOnly: 1,
    referrerPolicy: 1,
    rel: 0,
    required: 0,
    reversed: 0,
    role: 0,
    rows: 0,
    rowSpan: 1,
    sandbox: 0,
    scope: 0,
    scoped: 0,
    scrolling: 0,
    seamless: 0,
    selected: 0,
    shape: 0,
    size: 0,
    sizes: 0,
    span: 0,
    spellCheck: 1,
    src: 0,
    srcDoc: 1,
    srcLang: 1,
    srcSet: 1,
    start: 0,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 1,
    target: 0,
    title: 0,
    type: 0,
    useMap: 1,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,
    about: 0,
    accentHeight: 1,
    "accent-height": "accentHeight",
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 1,
    "alignment-baseline": "alignmentBaseline",
    allowReorder: 1,
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 1,
    "arabic-form": "arabicForm",
    ascent: 0,
    attributeName: 1,
    attributeType: 1,
    autoReverse: 1,
    azimuth: 0,
    baseFrequency: 1,
    baselineShift: 1,
    "baseline-shift": "baselineShift",
    baseProfile: 1,
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 1,
    capHeight: 1,
    "cap-height": "capHeight",
    clip: 0,
    clipPath: 1,
    "clip-path": "clipPath",
    clipPathUnits: 1,
    clipRule: 1,
    "clip-rule": "clipRule",
    color: 0,
    colorInterpolation: 1,
    "color-interpolation": "colorInterpolation",
    colorInterpolationFilters: 1,
    "color-interpolation-filters": "colorInterpolationFilters",
    colorProfile: 1,
    "color-profile": "colorProfile",
    colorRendering: 1,
    "color-rendering": "colorRendering",
    contentScriptType: 1,
    contentStyleType: 1,
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    datatype: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 1,
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 1,
    "dominant-baseline": "dominantBaseline",
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 1,
    elevation: 0,
    enableBackground: 1,
    "enable-background": "enableBackground",
    end: 0,
    exponent: 0,
    externalResourcesRequired: 1,
    fill: 0,
    fillOpacity: 1,
    "fill-opacity": "fillOpacity",
    fillRule: 1,
    "fill-rule": "fillRule",
    filter: 0,
    filterRes: 1,
    filterUnits: 1,
    floodOpacity: 1,
    "flood-opacity": "floodOpacity",
    floodColor: 1,
    "flood-color": "floodColor",
    focusable: 0,
    fontFamily: 1,
    "font-family": "fontFamily",
    fontSize: 1,
    "font-size": "fontSize",
    fontSizeAdjust: 1,
    "font-size-adjust": "fontSizeAdjust",
    fontStretch: 1,
    "font-stretch": "fontStretch",
    fontStyle: 1,
    "font-style": "fontStyle",
    fontVariant: 1,
    "font-variant": "fontVariant",
    fontWeight: 1,
    "font-weight": "fontWeight",
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 1,
    "glyph-name": "glyphName",
    glyphOrientationHorizontal: 1,
    "glyph-orientation-horizontal": "glyphOrientationHorizontal",
    glyphOrientationVertical: 1,
    "glyph-orientation-vertical": "glyphOrientationVertical",
    glyphRef: 1,
    gradientTransform: 1,
    gradientUnits: 1,
    hanging: 0,
    horizAdvX: 1,
    "horiz-adv-x": "horizAdvX",
    horizOriginX: 1,
    "horiz-origin-x": "horizOriginX",
    ideographic: 0,
    imageRendering: 1,
    "image-rendering": "imageRendering",
    in2: 0,
    in: 0,
    inlist: 0,
    intercept: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    k: 0,
    kernelMatrix: 1,
    kernelUnitLength: 1,
    kerning: 0,
    keyPoints: 1,
    keySplines: 1,
    keyTimes: 1,
    lengthAdjust: 1,
    letterSpacing: 1,
    "letter-spacing": "letterSpacing",
    lightingColor: 1,
    "lighting-color": "lightingColor",
    limitingConeAngle: 1,
    local: 0,
    markerEnd: 1,
    "marker-end": "markerEnd",
    markerHeight: 1,
    markerMid: 1,
    "marker-mid": "markerMid",
    markerStart: 1,
    "marker-start": "markerStart",
    markerUnits: 1,
    markerWidth: 1,
    mask: 0,
    maskContentUnits: 1,
    maskUnits: 1,
    mathematical: 0,
    mode: 0,
    numOctaves: 1,
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 1,
    "overline-position": "overlinePosition",
    overlineThickness: 1,
    "overline-thickness": "overlineThickness",
    paintOrder: 1,
    "paint-order": "paintOrder",
    panose1: 0,
    "panose-1": "panose1",
    pathLength: 1,
    patternContentUnits: 1,
    patternTransform: 1,
    patternUnits: 1,
    pointerEvents: 1,
    "pointer-events": "pointerEvents",
    points: 0,
    pointsAtX: 1,
    pointsAtY: 1,
    pointsAtZ: 1,
    prefix: 0,
    preserveAlpha: 1,
    preserveAspectRatio: 1,
    primitiveUnits: 1,
    property: 0,
    r: 0,
    radius: 0,
    refX: 1,
    refY: 1,
    renderingIntent: 1,
    "rendering-intent": "renderingIntent",
    repeatCount: 1,
    repeatDur: 1,
    requiredExtensions: 1,
    requiredFeatures: 1,
    resource: 0,
    restart: 0,
    result: 0,
    results: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    security: 0,
    seed: 0,
    shapeRendering: 1,
    "shape-rendering": "shapeRendering",
    slope: 0,
    spacing: 0,
    specularConstant: 1,
    specularExponent: 1,
    speed: 0,
    spreadMethod: 1,
    startOffset: 1,
    stdDeviation: 1,
    stemh: 0,
    stemv: 0,
    stitchTiles: 1,
    stopColor: 1,
    "stop-color": "stopColor",
    stopOpacity: 1,
    "stop-opacity": "stopOpacity",
    strikethroughPosition: 1,
    "strikethrough-position": "strikethroughPosition",
    strikethroughThickness: 1,
    "strikethrough-thickness": "strikethroughThickness",
    string: 0,
    stroke: 0,
    strokeDasharray: 1,
    "stroke-dasharray": "strokeDasharray",
    strokeDashoffset: 1,
    "stroke-dashoffset": "strokeDashoffset",
    strokeLinecap: 1,
    "stroke-linecap": "strokeLinecap",
    strokeLinejoin: 1,
    "stroke-linejoin": "strokeLinejoin",
    strokeMiterlimit: 1,
    "stroke-miterlimit": "strokeMiterlimit",
    strokeWidth: 1,
    "stroke-width": "strokeWidth",
    strokeOpacity: 1,
    "stroke-opacity": "strokeOpacity",
    suppressContentEditableWarning: 1,
    suppressHydrationWarning: 1,
    surfaceScale: 1,
    systemLanguage: 1,
    tableValues: 1,
    targetX: 1,
    targetY: 1,
    textAnchor: 1,
    "text-anchor": "textAnchor",
    textDecoration: 1,
    "text-decoration": "textDecoration",
    textLength: 1,
    textRendering: 1,
    "text-rendering": "textRendering",
    to: 0,
    transform: 0,
    typeof: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 1,
    "underline-position": "underlinePosition",
    underlineThickness: 1,
    "underline-thickness": "underlineThickness",
    unicode: 0,
    unicodeBidi: 1,
    "unicode-bidi": "unicodeBidi",
    unicodeRange: 1,
    "unicode-range": "unicodeRange",
    unitsPerEm: 1,
    "units-per-em": "unitsPerEm",
    unselectable: 0,
    vAlphabetic: 1,
    "v-alphabetic": "vAlphabetic",
    values: 0,
    vectorEffect: 1,
    "vector-effect": "vectorEffect",
    version: 0,
    vertAdvY: 1,
    "vert-adv-y": "vertAdvY",
    vertOriginX: 1,
    "vert-origin-x": "vertOriginX",
    vertOriginY: 1,
    "vert-origin-y": "vertOriginY",
    vHanging: 1,
    "v-hanging": "vHanging",
    vIdeographic: 1,
    "v-ideographic": "vIdeographic",
    viewBox: 1,
    viewTarget: 1,
    visibility: 0,
    vMathematical: 1,
    "v-mathematical": "vMathematical",
    vocab: 0,
    widths: 0,
    wordSpacing: 1,
    "word-spacing": "wordSpacing",
    writingMode: 1,
    "writing-mode": "writingMode",
    x1: 0,
    x2: 0,
    x: 0,
    xChannelSelector: 1,
    xHeight: 1,
    "x-height": "xHeight",
    xlinkActuate: 1,
    "xlink:actuate": "xlinkActuate",
    xlinkArcrole: 1,
    "xlink:arcrole": "xlinkArcrole",
    xlinkHref: 1,
    "xlink:href": "xlinkHref",
    xlinkRole: 1,
    "xlink:role": "xlinkRole",
    xlinkShow: 1,
    "xlink:show": "xlinkShow",
    xlinkTitle: 1,
    "xlink:title": "xlinkTitle",
    xlinkType: 1,
    "xlink:type": "xlinkType",
    xmlBase: 1,
    "xml:base": "xmlBase",
    xmlLang: 1,
    "xml:lang": "xmlLang",
    xmlns: 0,
    "xml:space": "xmlSpace",
    xmlnsXlink: 1,
    "xmlns:xlink": "xmlnsXlink",
    xmlSpace: 1,
    y1: 0,
    y2: 0,
    y: 0,
    yChannelSelector: 1,
    z: 0,
    zoomAndPan: 1
};


/***/ }),

/***/ 14698:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 69380:
/***/ ((module, exports) => {

"use strict";

const { hasOwnProperty } = Object.prototype;
const stringify = configure();
// @ts-expect-error
stringify.configure = configure;
// @ts-expect-error
stringify.stringify = stringify;
// @ts-expect-error
stringify.default = stringify;
// @ts-expect-error used for named export
exports.stringify = stringify;
// @ts-expect-error used for named export
exports.configure = configure;
module.exports = stringify;
// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape(str) {
    // Some magic numbers that worked out fine while benchmarking with v8 8.0
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
    }
    return JSON.stringify(str);
}
function insertSort(array) {
    // Insertion sort is very efficient for small input sizes but it has a bad
    // worst case complexity. Thus, use native array sort for bigger values.
    if (array.length > 2e2) {
        return array.sort();
    }
    for(let i = 1; i < array.length; i++){
        const currentValue = array[i];
        let position = i;
        while(position !== 0 && array[position - 1] > currentValue){
            array[position] = array[position - 1];
            position--;
        }
        array[position] = currentValue;
    }
    return array;
}
const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
}
function stringifyTypedArray(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for(let i = 1; i < maximumBreadth; i++){
        res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
}
function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
            return `"${circularValue}"`;
        }
        if (circularValue == null) {
            return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
            return {
                toString () {
                    throw new TypeError("Converting circular structure to JSON");
                }
            };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
}
function getBooleanOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
            throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
    }
    return value === undefined ? true : value;
}
function getPositiveIntegerOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
            throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
            throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
            throw new RangeError(`The "${key}" argument must be >= 1`);
        }
    }
    return value === undefined ? Infinity : value;
}
function getItemCount(number) {
    if (number === 1) {
        return "1 item";
    }
    return `${number} items`;
}
function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set();
    for (const value of replacerArray){
        if (typeof value === "string" || typeof value === "number") {
            replacerSet.add(String(value));
        }
    }
    return replacerSet;
}
function getStrictOption(options) {
    if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
            throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
            return (value)=>{
                let message = `Object can not safely be stringified. Received type ${typeof value}`;
                if (typeof value !== "function") message += ` (${value.toString()})`;
                throw new Error(message);
            };
        }
    }
}
function configure(options) {
    options = {
        ...options
    };
    const fail = getStrictOption(options);
    if (fail) {
        if (options.bigint === undefined) {
            options.bigint = false;
        }
        if (!("circularValue" in options)) {
            options.circularValue = Error;
        }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getBooleanOption(options, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch(typeof value){
            case "string":
                return strEscape(value);
            case "object":
                {
                    if (value === null) {
                        return "null";
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = "";
                    let join = ",";
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return "[]";
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== "") {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : "null";
                            res += join;
                        }
                        const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : "null";
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== "") {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return "{}";
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let whitespace = "";
                    let separator = "";
                    if (spacer !== "") {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = " ";
                    }
                    const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (deterministic && !isTypedArrayWithEntries(value)) {
                        keys = insertSort(keys);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (spacer !== "" && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
            case "boolean":
                return value === true ? "true" : "false";
            case "undefined":
                return undefined;
            case "bigint":
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }
        switch(typeof value){
            case "string":
                return strEscape(value);
            case "object":
                {
                    if (value === null) {
                        return "null";
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    let res = "";
                    let join = ",";
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return "[]";
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== "") {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : "null";
                            res += join;
                        }
                        const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : "null";
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== "") {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    stack.push(value);
                    let whitespace = "";
                    if (spacer !== "") {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = " ";
                    }
                    let separator = "";
                    for (const key of replacer){
                        const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (spacer !== "" && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
            case "boolean":
                return value === true ? "true" : "false";
            case "undefined":
                return undefined;
            case "bigint":
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
        switch(typeof value){
            case "string":
                return strEscape(value);
            case "object":
                {
                    if (value === null) {
                        return "null";
                    }
                    if (typeof value.toJSON === "function") {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again.
                        if (typeof value !== "object") {
                            return stringifyIndent(key, value, stack, spacer, indentation);
                        }
                        if (value === null) {
                            return "null";
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return "[]";
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        indentation += spacer;
                        let res = `\n${indentation}`;
                        const join = `,\n${indentation}`;
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                            res += tmp !== undefined ? tmp : "null";
                            res += join;
                        }
                        const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                        res += tmp !== undefined ? tmp : "null";
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        res += `\n${originalIndentation}`;
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return "{}";
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    indentation += spacer;
                    const join = `,\n${indentation}`;
                    let res = "";
                    let separator = "";
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, join, maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = join;
                    }
                    if (deterministic) {
                        keys = insertSort(keys);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}: ${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (separator !== "") {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
            case "boolean":
                return value === true ? "true" : "false";
            case "undefined":
                return undefined;
            case "bigint":
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifySimple(key, value, stack) {
        switch(typeof value){
            case "string":
                return strEscape(value);
            case "object":
                {
                    if (value === null) {
                        return "null";
                    }
                    if (typeof value.toJSON === "function") {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again
                        if (typeof value !== "object") {
                            return stringifySimple(key, value, stack);
                        }
                        if (value === null) {
                            return "null";
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = "";
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return "[]";
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifySimple(String(i), value[i], stack);
                            res += tmp !== undefined ? tmp : "null";
                            res += ",";
                        }
                        const tmp = stringifySimple(String(i), value[i], stack);
                        res += tmp !== undefined ? tmp : "null";
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return "{}";
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let separator = "";
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, ",", maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = ",";
                    }
                    if (deterministic) {
                        keys = insertSort(keys);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifySimple(key, value[key], stack);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${tmp}`;
                            separator = ",";
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
            case "boolean":
                return value === true ? "true" : "false";
            case "undefined":
                return undefined;
            case "bigint":
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringify(value, replacer, space) {
        if (arguments.length > 1) {
            let spacer = "";
            if (typeof space === "number") {
                spacer = " ".repeat(Math.min(space, 10));
            } else if (typeof space === "string") {
                spacer = space.slice(0, 10);
            }
            if (replacer != null) {
                if (typeof replacer === "function") {
                    return stringifyFnReplacer("", {
                        "": value
                    }, [], replacer, spacer, "");
                }
                if (Array.isArray(replacer)) {
                    return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
                }
            }
            if (spacer.length !== 0) {
                return stringifyIndent("", value, [], spacer, "");
            }
        }
        return stringifySimple("", value, []);
    }
    return stringify;
}


/***/ }),

/***/ 69165:
/***/ ((__unused_webpack_module, exports) => {

exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
        return v8StackTrace;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
};
exports.parse = function(err) {
    if (!err.stack) {
        return [];
    }
    var self = this;
    var lines = err.stack.split("\n").slice(1);
    return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
            return self._createParsedCallSite({
                fileName: line,
                lineNumber: null,
                functionName: null,
                typeName: null,
                methodName: null,
                columnNumber: null,
                "native": null
            });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
            return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
            functionName = lineMatch[1];
            var methodStart = functionName.lastIndexOf(".");
            if (functionName[methodStart - 1] == ".") methodStart--;
            if (methodStart > 0) {
                object = functionName.substr(0, methodStart);
                method = functionName.substr(methodStart + 1);
                var objectEnd = object.indexOf(".Module");
                if (objectEnd > 0) {
                    functionName = functionName.substr(objectEnd + 1);
                    object = object.substr(0, objectEnd);
                }
            }
            typeName = null;
        }
        if (method) {
            typeName = object;
            methodName = method;
        }
        if (method === "<anonymous>") {
            methodName = null;
            functionName = null;
        }
        var properties = {
            fileName: lineMatch[2] || null,
            lineNumber: parseInt(lineMatch[3], 10) || null,
            functionName: functionName,
            typeName: typeName,
            methodName: methodName,
            columnNumber: parseInt(lineMatch[4], 10) || null,
            "native": isNative
        };
        return self._createParsedCallSite(properties);
    }).filter(function(callSite) {
        return !!callSite;
    });
};
function CallSite(properties) {
    for(var property in properties){
        this[property] = properties[property];
    }
}
var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
];
var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
];
strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
    };
});
boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
    };
});
exports._createParsedCallSite = function(properties) {
    return new CallSite(properties);
};


/***/ }),

/***/ 27356:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * cli.js: Config that conform to commonly used CLI logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * Default levels for the CLI configuration.
 * @type {Object}
 */ exports.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
};
/**
 * Default colors for the CLI configuration.
 * @type {Object}
 */ exports.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
};


/***/ }),

/***/ 7382:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * Export config set for the CLI.
 * @type {Object}
 */ Object.defineProperty(exports, "cli", ({
    value: __webpack_require__(27356)
}));
/**
 * Export config set for npm.
 * @type {Object}
 */ Object.defineProperty(exports, "npm", ({
    value: __webpack_require__(72847)
}));
/**
 * Export config set for the syslog.
 * @type {Object}
 */ Object.defineProperty(exports, "syslog", ({
    value: __webpack_require__(27875)
}));


/***/ }),

/***/ 72847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * npm.js: Config that conform to npm logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * Default levels for the npm configuration.
 * @type {Object}
 */ exports.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
};
/**
 * Default levels for the npm configuration.
 * @type {Object}
 */ exports.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
};


/***/ }),

/***/ 27875:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * syslog.js: Config that conform to syslog logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */ exports.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
};
/**
 * Default levels for the syslog configuration.
 * @type {Object}
 */ exports.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
};


/***/ }),

/***/ 68635:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden level identifier
 * to allow the readable level property to be mutable for
 * operations like colorization
 *
 * @type {Symbol}
 */ Object.defineProperty(exports, "LEVEL", ({
    value: Symbol.for("level")
}));
/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the final message property to not have
 * side effects on another.
 *
 * @type {Symbol}
 */ Object.defineProperty(exports, "MESSAGE", ({
    value: Symbol.for("message")
}));
/**
 * A shareable symbol constant that can be used
 * as a non-enumerable / semi-hidden message identifier
 * to allow the extracted splat property be hidden
 *
 * @type {Symbol}
 */ Object.defineProperty(exports, "SPLAT", ({
    value: Symbol.for("splat")
}));
/**
 * A shareable object constant  that can be used
 * as a standard configuration for winston@3.
 *
 * @type {Object}
 */ Object.defineProperty(exports, "configs", ({
    value: __webpack_require__(7382)
}));


/***/ }),

/***/ 97959:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;
var Ep = Object.create;
var gr = Object.defineProperty;
var Ap = Object.getOwnPropertyDescriptor;
var Op = Object.getOwnPropertyNames;
var _p = Object.getPrototypeOf, Tp = Object.prototype.hasOwnProperty;
var Ye = (t, e)=>()=>(t && (e = t(t = 0)), e);
var S = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports), He = (t, e)=>{
    for(var r in e)gr(t, r, {
        get: e[r],
        enumerable: !0
    });
}, Ta = (t, e, r, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let i of Op(e))!Tp.call(t, i) && i !== r && gr(t, i, {
        get: ()=>e[i],
        enumerable: !(n = Ap(e, i)) || n.enumerable
    });
    return t;
};
var Y = (t, e, r)=>(r = t != null ? Ep(_p(t)) : {}, Ta(e || !t || !t.__esModule ? gr(r, "default", {
        value: t,
        enumerable: !0
    }) : r, t)), ke = (t)=>Ta(gr({}, "__esModule", {
        value: !0
    }), t);
var Ia, Ra = Ye(()=>{
    Ia = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Da = {};
He(Da, {
    default: ()=>ht
});
var ht, yr = Ye(()=>{
    Ra();
    ht = {
        readFileSync: ()=>Ia
    };
});
var La = S((gb, Ma)=>{
    "use strict";
    var qn = class {
        constructor(e = {}){
            if (!(e.maxSize && e.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
            this.maxSize = e.maxSize, this.onEviction = e.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0;
        }
        _set(e, r) {
            if (this.cache.set(e, r), this._size++, this._size >= this.maxSize) {
                if (this._size = 0, typeof this.onEviction == "function") for (let [n, i] of this.oldCache.entries())this.onEviction(n, i);
                this.oldCache = this.cache, this.cache = new Map;
            }
        }
        get(e) {
            if (this.cache.has(e)) return this.cache.get(e);
            if (this.oldCache.has(e)) {
                let r = this.oldCache.get(e);
                return this.oldCache.delete(e), this._set(e, r), r;
            }
        }
        set(e, r) {
            return this.cache.has(e) ? this.cache.set(e, r) : this._set(e, r), this;
        }
        has(e) {
            return this.cache.has(e) || this.oldCache.has(e);
        }
        peek(e) {
            if (this.cache.has(e)) return this.cache.get(e);
            if (this.oldCache.has(e)) return this.oldCache.get(e);
        }
        delete(e) {
            let r = this.cache.delete(e);
            return r && this._size--, this.oldCache.delete(e) || r;
        }
        clear() {
            this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
        *keys() {
            for (let [e] of this)yield e;
        }
        *values() {
            for (let [, e] of this)yield e;
        }
        *[Symbol.iterator]() {
            for (let e of this.cache)yield e;
            for (let e of this.oldCache){
                let [r] = e;
                this.cache.has(r) || (yield e);
            }
        }
        get size() {
            let e = 0;
            for (let r of this.oldCache.keys())this.cache.has(r) || e++;
            return Math.min(this._size + e, this.maxSize);
        }
    };
    Ma.exports = qn;
});
var qa = {};
He(qa, {
    default: ()=>zn
});
var zn, Vn = Ye(()=>{
    zn = {
        yellow: (t)=>t
    };
});
var Wn = S(()=>{});
var vr = S((xb, ja)=>{
    "use strict";
    var $a = (Vn(), ke(qa)), Ua = Wn(), Ue = class extends Error {
        constructor(e, r, n, i, s, a){
            super(e), this.name = "CssSyntaxError", this.reason = e, s && (this.file = s), i && (this.source = i), a && (this.plugin = a), typeof r < "u" && typeof n < "u" && (typeof r == "number" ? (this.line = r, this.column = n) : (this.line = r.line, this.column = r.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue);
        }
        setMessage() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
        }
        showSourceCode(e) {
            if (!this.source) return "";
            let r = this.source;
            e == null && (e = $a.isColorSupported), Ua && e && (r = Ua(r));
            let n = r.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, n.length), a = String(s).length, o, l;
            if (e) {
                let { bold: u, red: f, gray: p } = $a.createColors(!0);
                o = (c)=>u(f(c)), l = (c)=>p(c);
            } else o = l = (u)=>u;
            return n.slice(i, s).map((u, f)=>{
                let p = i + 1 + f, c = " " + (" " + p).slice(-a) + " | ";
                if (p === this.line) {
                    let d = l(c.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
                    return o(">") + l(c) + u + `
 ` + d + o("^");
                }
                return " " + l(c) + u;
            }).join(`
`);
        }
        toString() {
            let e = this.showSourceCode();
            return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
        }
    };
    ja.exports = Ue;
    Ue.default = Ue;
});
var br = S((Sb, Bn)=>{
    "use strict";
    Bn.exports.isClean = Symbol("isClean");
    Bn.exports.my = Symbol("my");
});
var Gn = S((kb, Va)=>{
    "use strict";
    var za = {
        colon: ": ",
        indent: "    ",
        beforeDecl: `
`,
        beforeRule: `
`,
        beforeOpen: " ",
        beforeClose: `
`,
        beforeComment: `
`,
        after: `
`,
        emptyBody: "",
        commentLeft: " ",
        commentRight: " ",
        semicolon: !1
    };
    function Mp(t) {
        return t[0].toUpperCase() + t.slice(1);
    }
    var gt = class {
        constructor(e){
            this.builder = e;
        }
        stringify(e, r) {
            if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
            this[e.type](e, r);
        }
        document(e) {
            this.body(e);
        }
        root(e) {
            this.body(e), e.raws.after && this.builder(e.raws.after);
        }
        comment(e) {
            let r = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
            this.builder("/*" + r + e.text + n + "*/", e);
        }
        decl(e, r) {
            let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
            e.important && (i += e.raws.important || " !important"), r && (i += ";"), this.builder(i, e);
        }
        rule(e) {
            this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
        }
        atrule(e, r) {
            let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
            if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes) this.block(e, n + i);
            else {
                let s = (e.raws.between || "") + (r ? ";" : "");
                this.builder(n + i + s, e);
            }
        }
        body(e) {
            let r = e.nodes.length - 1;
            for(; r > 0 && e.nodes[r].type === "comment";)r -= 1;
            let n = this.raw(e, "semicolon");
            for(let i = 0; i < e.nodes.length; i++){
                let s = e.nodes[i], a = this.raw(s, "before");
                a && this.builder(a), this.stringify(s, r !== i || n);
            }
        }
        block(e, r) {
            let n = this.raw(e, "between", "beforeOpen");
            this.builder(r + n + "{", e, "start");
            let i;
            e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
        }
        raw(e, r, n) {
            let i;
            if (n || (n = r), r && (i = e.raws[r], typeof i < "u")) return i;
            let s = e.parent;
            if (n === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document")) return "";
            if (!s) return za[n];
            let a = e.root();
            if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[n] < "u") return a.rawCache[n];
            if (n === "before" || n === "after") return this.beforeAfter(e, n);
            {
                let o = "raw" + Mp(n);
                this[o] ? i = this[o](a, e) : a.walk((l)=>{
                    if (i = l.raws[r], typeof i < "u") return !1;
                });
            }
            return typeof i > "u" && (i = za[n]), a.rawCache[n] = i, i;
        }
        rawSemicolon(e) {
            let r;
            return e.walk((n)=>{
                if (n.nodes && n.nodes.length && n.last.type === "decl" && (r = n.raws.semicolon, typeof r < "u")) return !1;
            }), r;
        }
        rawEmptyBody(e) {
            let r;
            return e.walk((n)=>{
                if (n.nodes && n.nodes.length === 0 && (r = n.raws.after, typeof r < "u")) return !1;
            }), r;
        }
        rawIndent(e) {
            if (e.raws.indent) return e.raws.indent;
            let r;
            return e.walk((n)=>{
                let i = n.parent;
                if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
                    let s = n.raws.before.split(`
`);
                    return r = s[s.length - 1], r = r.replace(/\S/g, ""), !1;
                }
            }), r;
        }
        rawBeforeComment(e, r) {
            let n;
            return e.walkComments((i)=>{
                if (typeof i.raws.before < "u") return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
            }), typeof n > "u" ? n = this.raw(r, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
        }
        rawBeforeDecl(e, r) {
            let n;
            return e.walkDecls((i)=>{
                if (typeof i.raws.before < "u") return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
            }), typeof n > "u" ? n = this.raw(r, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
        }
        rawBeforeRule(e) {
            let r;
            return e.walk((n)=>{
                if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
            }), r && (r = r.replace(/\S/g, "")), r;
        }
        rawBeforeClose(e) {
            let r;
            return e.walk((n)=>{
                if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u") return r = n.raws.after, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
            }), r && (r = r.replace(/\S/g, "")), r;
        }
        rawBeforeOpen(e) {
            let r;
            return e.walk((n)=>{
                if (n.type !== "decl" && (r = n.raws.between, typeof r < "u")) return !1;
            }), r;
        }
        rawColon(e) {
            let r;
            return e.walkDecls((n)=>{
                if (typeof n.raws.between < "u") return r = n.raws.between.replace(/[^\s:]/g, ""), !1;
            }), r;
        }
        beforeAfter(e, r) {
            let n;
            e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : r === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
            let i = e.parent, s = 0;
            for(; i && i.type !== "root";)s += 1, i = i.parent;
            if (n.includes(`
`)) {
                let a = this.raw(e, null, "indent");
                if (a.length) for(let o = 0; o < s; o++)n += a;
            }
            return n;
        }
        rawValue(e, r) {
            let n = e[r], i = e.raws[r];
            return i && i.value === n ? i.raw : n;
        }
    };
    Va.exports = gt;
    gt.default = gt;
});
var yt = S((Cb, Wa)=>{
    "use strict";
    var Lp = Gn();
    function Yn(t, e) {
        new Lp(e).stringify(t);
    }
    Wa.exports = Yn;
    Yn.default = Yn;
});
var vt = S((Eb, Ba)=>{
    "use strict";
    var { isClean: xr, my: Fp } = br(), Np = vr(), qp = Gn(), $p = yt();
    function Hn(t, e) {
        let r = new t.constructor;
        for(let n in t){
            if (!Object.prototype.hasOwnProperty.call(t, n) || n === "proxyCache") continue;
            let i = t[n], s = typeof i;
            n === "parent" && s === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : Array.isArray(i) ? r[n] = i.map((a)=>Hn(a, r)) : (s === "object" && i !== null && (i = Hn(i)), r[n] = i);
        }
        return r;
    }
    var wt = class {
        constructor(e = {}){
            this.raws = {}, this[xr] = !1, this[Fp] = !0;
            for(let r in e)if (r === "nodes") {
                this.nodes = [];
                for (let n of e[r])typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
            } else this[r] = e[r];
        }
        error(e, r = {}) {
            if (this.source) {
                let { start: n, end: i } = this.rangeBy(r);
                return this.source.input.error(e, {
                    line: n.line,
                    column: n.column
                }, {
                    line: i.line,
                    column: i.column
                }, r);
            }
            return new Np(e);
        }
        warn(e, r, n) {
            let i = {
                node: this
            };
            for(let s in n)i[s] = n[s];
            return e.warn(r, i);
        }
        remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }
        toString(e = $p) {
            e.stringify && (e = e.stringify);
            let r = "";
            return e(this, (n)=>{
                r += n;
            }), r;
        }
        assign(e = {}) {
            for(let r in e)this[r] = e[r];
            return this;
        }
        clone(e = {}) {
            let r = Hn(this);
            for(let n in e)r[n] = e[n];
            return r;
        }
        cloneBefore(e = {}) {
            let r = this.clone(e);
            return this.parent.insertBefore(this, r), r;
        }
        cloneAfter(e = {}) {
            let r = this.clone(e);
            return this.parent.insertAfter(this, r), r;
        }
        replaceWith(...e) {
            if (this.parent) {
                let r = this, n = !1;
                for (let i of e)i === this ? n = !0 : n ? (this.parent.insertAfter(r, i), r = i) : this.parent.insertBefore(r, i);
                n || this.remove();
            }
            return this;
        }
        next() {
            if (!this.parent) return;
            let e = this.parent.index(this);
            return this.parent.nodes[e + 1];
        }
        prev() {
            if (!this.parent) return;
            let e = this.parent.index(this);
            return this.parent.nodes[e - 1];
        }
        before(e) {
            return this.parent.insertBefore(this, e), this;
        }
        after(e) {
            return this.parent.insertAfter(this, e), this;
        }
        root() {
            let e = this;
            for(; e.parent && e.parent.type !== "document";)e = e.parent;
            return e;
        }
        raw(e, r) {
            return new qp().raw(this, e, r);
        }
        cleanRaws(e) {
            delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
        }
        toJSON(e, r) {
            let n = {}, i = r == null;
            r = r || new Map;
            let s = 0;
            for(let a in this){
                if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue;
                let o = this[a];
                if (Array.isArray(o)) n[a] = o.map((l)=>typeof l == "object" && l.toJSON ? l.toJSON(null, r) : l);
                else if (typeof o == "object" && o.toJSON) n[a] = o.toJSON(null, r);
                else if (a === "source") {
                    let l = r.get(o.input);
                    l == null && (l = s, r.set(o.input, s), s++), n[a] = {
                        inputId: l,
                        start: o.start,
                        end: o.end
                    };
                } else n[a] = o;
            }
            return i && (n.inputs = [
                ...r.keys()
            ].map((a)=>a.toJSON())), n;
        }
        positionInside(e) {
            let r = this.toString(), n = this.source.start.column, i = this.source.start.line;
            for(let s = 0; s < e; s++)r[s] === `
` ? (n = 1, i += 1) : n += 1;
            return {
                line: i,
                column: n
            };
        }
        positionBy(e) {
            let r = this.source.start;
            if (e.index) r = this.positionInside(e.index);
            else if (e.word) {
                let n = this.toString().indexOf(e.word);
                n !== -1 && (r = this.positionInside(n));
            }
            return r;
        }
        rangeBy(e) {
            let r = {
                line: this.source.start.line,
                column: this.source.start.column
            }, n = this.source.end ? {
                line: this.source.end.line,
                column: this.source.end.column + 1
            } : {
                line: r.line,
                column: r.column + 1
            };
            if (e.word) {
                let i = this.toString().indexOf(e.word);
                i !== -1 && (r = this.positionInside(i), n = this.positionInside(i + e.word.length));
            } else e.start ? r = {
                line: e.start.line,
                column: e.start.column
            } : e.index && (r = this.positionInside(e.index)), e.end ? n = {
                line: e.end.line,
                column: e.end.column
            } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
            return (n.line < r.line || n.line === r.line && n.column <= r.column) && (n = {
                line: r.line,
                column: r.column + 1
            }), {
                start: r,
                end: n
            };
        }
        getProxyProcessor() {
            return {
                set (e, r, n) {
                    return e[r] === n || (e[r] = n, (r === "prop" || r === "value" || r === "name" || r === "params" || r === "important" || r === "text") && e.markDirty()), !0;
                },
                get (e, r) {
                    return r === "proxyOf" ? e : r === "root" ? ()=>e.root().toProxy() : e[r];
                }
            };
        }
        toProxy() {
            return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
        }
        addToError(e) {
            if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
                let r = this.source;
                e.stack = e.stack.replace(/\n\s{4}at /, `$&${r.input.from}:${r.start.line}:${r.start.column}$&`);
            }
            return e;
        }
        markDirty() {
            if (this[xr]) {
                this[xr] = !1;
                let e = this;
                for(; e = e.parent;)e[xr] = !1;
            }
        }
        get proxyOf() {
            return this;
        }
    };
    Ba.exports = wt;
    wt.default = wt;
});
var xt = S((Ab, Ga)=>{
    "use strict";
    var Up = vt(), bt = class extends Up {
        constructor(e){
            e && typeof e.value < "u" && typeof e.value != "string" && (e = {
                ...e,
                value: String(e.value)
            }), super(e), this.type = "decl";
        }
        get variable() {
            return this.prop.startsWith("--") || this.prop[0] === "$";
        }
    };
    Ga.exports = bt;
    bt.default = bt;
});
var Sr = S(()=>{});
var St = {};
He(St, {
    join: ()=>Qn
});
var Qn, kt = Ye(()=>{
    Qn = ()=>"";
});
var Jn = {};
He(Jn, {
    default: ()=>jp
});
var jp, Xn = Ye(()=>{
    jp = null;
});
var Ha = S((Tb, Ya)=>{
    var zp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Vp = (t, e = 21)=>(r = e)=>{
            let n = "", i = r;
            for(; i--;)n += t[Math.random() * t.length | 0];
            return n;
        }, Wp = (t = 21)=>{
        let e = "", r = t;
        for(; r--;)e += zp[Math.random() * 64 | 0];
        return e;
    };
    Ya.exports = {
        nanoid: Wp,
        customAlphabet: Vp
    };
});
var Zn = S((Pb, Xa)=>{
    "use strict";
    var { SourceMapConsumer: Qa, SourceMapGenerator: Ja } = Sr(), { existsSync: Bp, readFileSync: Gp } = (yr(), ke(Da)), { dirname: Kn, join: Yp } = (kt(), ke(St));
    function Hp(t) {
        return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
    }
    var Ct = class {
        constructor(e, r){
            if (r.map === !1) return;
            this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
            let n = r.map ? r.map.prev : void 0, i = this.loadMap(r.from, n);
            !this.mapFile && r.from && (this.mapFile = r.from), this.mapFile && (this.root = Kn(this.mapFile)), i && (this.text = i);
        }
        consumer() {
            return this.consumerCache || (this.consumerCache = new Qa(this.text)), this.consumerCache;
        }
        withContent() {
            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
        startWith(e, r) {
            return e ? e.substr(0, r.length) === r : !1;
        }
        getAnnotationURL(e) {
            return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        loadAnnotation(e) {
            let r = e.match(/\/\*\s*# sourceMappingURL=/gm);
            if (!r) return;
            let n = e.lastIndexOf(r.pop()), i = e.indexOf("*/", n);
            n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
        }
        decodeInline(e) {
            let r = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/;
            if (i.test(e) || s.test(e)) return decodeURIComponent(e.substr(RegExp.lastMatch.length));
            if (r.test(e) || n.test(e)) return Hp(e.substr(RegExp.lastMatch.length));
            let a = e.match(/data:application\/json;([^,]+),/)[1];
            throw new Error("Unsupported source map encoding " + a);
        }
        loadFile(e) {
            if (this.root = Kn(e), Bp(e)) return this.mapFile = e, Gp(e, "utf-8").toString().trim();
        }
        loadMap(e, r) {
            if (r === !1) return !1;
            if (r) {
                if (typeof r == "string") return r;
                if (typeof r == "function") {
                    let n = r(e);
                    if (n) {
                        let i = this.loadFile(n);
                        if (!i) throw new Error("Unable to load previous source map: " + n.toString());
                        return i;
                    }
                } else {
                    if (r instanceof Qa) return Ja.fromSourceMap(r).toString();
                    if (r instanceof Ja) return r.toString();
                    if (this.isMap(r)) return JSON.stringify(r);
                    throw new Error("Unsupported previous source map format: " + r.toString());
                }
            } else {
                if (this.inline) return this.decodeInline(this.annotation);
                if (this.annotation) {
                    let n = this.annotation;
                    return e && (n = Yp(Kn(e), n)), this.loadFile(n);
                }
            }
        }
        isMap(e) {
            return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
        }
    };
    Xa.exports = Ct;
    Ct.default = Ct;
});
var Et = S((Rb, to)=>{
    "use strict";
    var { SourceMapConsumer: Qp, SourceMapGenerator: Jp } = Sr(), { fileURLToPath: Ka, pathToFileURL: kr } = (Xn(), ke(Jn)), { resolve: ri, isAbsolute: ni } = (kt(), ke(St)), { nanoid: Xp } = Ha(), ei = Wn(), Za = vr(), Kp = Zn(), ti = Symbol("fromOffsetCache"), Zp = Boolean(Qp && Jp), eo = Boolean(ri && ni), Qe = class {
        constructor(e, r = {}){
            if (e === null || typeof e > "u" || typeof e == "object" && !e.toString) throw new Error(`PostCSS received ${e} instead of CSS string`);
            if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, r.from && (!eo || /^\w+:\/\//.test(r.from) || ni(r.from) ? this.file = r.from : this.file = ri(r.from)), eo && Zp) {
                let n = new Kp(this.css, r);
                if (n.text) {
                    this.map = n;
                    let i = n.consumer().file;
                    !this.file && i && (this.file = this.mapResolve(i));
                }
            }
            this.file || (this.id = "<input css " + Xp(6) + ">"), this.map && (this.map.file = this.from);
        }
        fromOffset(e) {
            let r, n;
            if (this[ti]) n = this[ti];
            else {
                let s = this.css.split(`
`);
                n = new Array(s.length);
                let a = 0;
                for(let o = 0, l = s.length; o < l; o++)n[o] = a, a += s[o].length + 1;
                this[ti] = n;
            }
            r = n[n.length - 1];
            let i = 0;
            if (e >= r) i = n.length - 1;
            else {
                let s = n.length - 2, a;
                for(; i < s;)if (a = i + (s - i >> 1), e < n[a]) s = a - 1;
                else if (e >= n[a + 1]) i = a + 1;
                else {
                    i = a;
                    break;
                }
            }
            return {
                line: i + 1,
                col: e - n[i] + 1
            };
        }
        error(e, r, n, i = {}) {
            let s, a, o;
            if (r && typeof r == "object") {
                let u = r, f = n;
                if (typeof u.offset == "number") {
                    let p = this.fromOffset(u.offset);
                    r = p.line, n = p.col;
                } else r = u.line, n = u.column;
                if (typeof f.offset == "number") {
                    let p = this.fromOffset(f.offset);
                    a = p.line, o = p.col;
                } else a = f.line, o = f.column;
            } else if (!n) {
                let u = this.fromOffset(r);
                r = u.line, n = u.col;
            }
            let l = this.origin(r, n, a, o);
            return l ? s = new Za(e, l.endLine === void 0 ? l.line : {
                line: l.line,
                column: l.column
            }, l.endLine === void 0 ? l.column : {
                line: l.endLine,
                column: l.endColumn
            }, l.source, l.file, i.plugin) : s = new Za(e, a === void 0 ? r : {
                line: r,
                column: n
            }, a === void 0 ? n : {
                line: a,
                column: o
            }, this.css, this.file, i.plugin), s.input = {
                line: r,
                column: n,
                endLine: a,
                endColumn: o,
                source: this.css
            }, this.file && (kr && (s.input.url = kr(this.file).toString()), s.input.file = this.file), s;
        }
        origin(e, r, n, i) {
            if (!this.map) return !1;
            let s = this.map.consumer(), a = s.originalPositionFor({
                line: e,
                column: r
            });
            if (!a.source) return !1;
            let o;
            typeof n == "number" && (o = s.originalPositionFor({
                line: n,
                column: i
            }));
            let l;
            ni(a.source) ? l = kr(a.source) : l = new URL(a.source, this.map.consumer().sourceRoot || kr(this.map.mapFile));
            let u = {
                url: l.toString(),
                line: a.line,
                column: a.column,
                endLine: o && o.line,
                endColumn: o && o.column
            };
            if (l.protocol === "file:") if (Ka) u.file = Ka(l);
            else throw new Error("file: protocol is not available in this PostCSS build");
            let f = s.sourceContentFor(a.source);
            return f && (u.source = f), u;
        }
        mapResolve(e) {
            return /^\w+:\/\//.test(e) ? e : ri(this.map.consumer().sourceRoot || this.map.root || ".", e);
        }
        get from() {
            return this.file || this.id;
        }
        toJSON() {
            let e = {};
            for (let r of [
                "hasBOM",
                "css",
                "file",
                "id"
            ])this[r] != null && (e[r] = this[r]);
            return this.map && (e.map = {
                ...this.map
            }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
        }
    };
    to.exports = Qe;
    Qe.default = Qe;
    ei && ei.registerInput && ei.registerInput(Qe);
});
var si = S((Ib, oo)=>{
    "use strict";
    var { SourceMapConsumer: no, SourceMapGenerator: Cr } = Sr(), { dirname: Er, resolve: io, relative: so, sep: ao } = (kt(), ke(St)), { pathToFileURL: ro } = (Xn(), ke(Jn)), ed = Et(), td = Boolean(no && Cr), rd = Boolean(Er && io && so && ao), ii = class {
        constructor(e, r, n, i){
            this.stringify = e, this.mapOpts = n.map || {}, this.root = r, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        }
        isMap() {
            return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
        }
        previous() {
            if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((e)=>{
                if (e.source && e.source.input.map) {
                    let r = e.source.input.map;
                    this.previousMaps.includes(r) || this.previousMaps.push(r);
                }
            });
            else {
                let e = new ed(this.css, this.opts);
                e.map && this.previousMaps.push(e.map);
            }
            return this.previousMaps;
        }
        isInline() {
            if (typeof this.mapOpts.inline < "u") return this.mapOpts.inline;
            let e = this.mapOpts.annotation;
            return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((r)=>r.inline) : !0;
        }
        isSourcesContent() {
            return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e)=>e.withContent()) : !0;
        }
        clearAnnotation() {
            if (this.mapOpts.annotation !== !1) if (this.root) {
                let e;
                for(let r = this.root.nodes.length - 1; r >= 0; r--)e = this.root.nodes[r], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r);
            } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
        }
        setSourcesContent() {
            let e = {};
            if (this.root) this.root.walk((r)=>{
                if (r.source) {
                    let n = r.source.input.from;
                    if (n && !e[n]) {
                        e[n] = !0;
                        let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
                        this.map.setSourceContent(i, r.source.input.css);
                    }
                }
            });
            else if (this.css) {
                let r = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
                this.map.setSourceContent(r, this.css);
            }
        }
        applyPrevMaps() {
            for (let e of this.previous()){
                let r = this.toUrl(this.path(e.file)), n = e.root || Er(e.file), i;
                this.mapOpts.sourcesContent === !1 ? (i = new no(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(()=>null))) : i = e.consumer(), this.map.applySourceMap(i, r, this.toUrl(this.path(n)));
            }
        }
        isAnnotation() {
            return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e)=>e.annotation) : !0;
        }
        toBase64(e) {
            return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
        }
        addAnnotation() {
            let e;
            this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
            let r = `
`;
            this.css.includes(`\r
`) && (r = `\r
`), this.css += r + "/*# sourceMappingURL=" + e + " */";
        }
        outputFile() {
            return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
        }
        generateMap() {
            if (this.root) this.generateString();
            else if (this.previous().length === 1) {
                let e = this.previous()[0].consumer();
                e.file = this.outputFile(), this.map = Cr.fromSourceMap(e);
            } else this.map = new Cr({
                file: this.outputFile()
            }), this.map.addMapping({
                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
                generated: {
                    line: 1,
                    column: 0
                },
                original: {
                    line: 1,
                    column: 0
                }
            });
            return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [
                this.css
            ] : [
                this.css,
                this.map
            ];
        }
        path(e) {
            if (e.indexOf("<") === 0 || /^\w+:\/\//.test(e) || this.mapOpts.absolute) return e;
            let r = this.opts.to ? Er(this.opts.to) : ".";
            return typeof this.mapOpts.annotation == "string" && (r = Er(io(r, this.mapOpts.annotation))), e = so(r, e), e;
        }
        toUrl(e) {
            return ao === "\\" && (e = e.replace(/\\/g, "/")), encodeURI(e).replace(/[#?]/g, encodeURIComponent);
        }
        toFileUrl(e) {
            if (ro) return ro(e).toString();
            throw new Error("`map.absolute` option is not available in this PostCSS build");
        }
        sourcePath(e) {
            return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
        }
        generateString() {
            this.css = "", this.map = new Cr({
                file: this.outputFile()
            });
            let e = 1, r = 1, n = "<no source>", i = {
                source: "",
                generated: {
                    line: 0,
                    column: 0
                },
                original: {
                    line: 0,
                    column: 0
                }
            }, s, a;
            this.stringify(this.root, (o, l, u)=>{
                if (this.css += o, l && u !== "end" && (i.generated.line = e, i.generated.column = r - 1, l.source && l.source.start ? (i.source = this.sourcePath(l), i.original.line = l.source.start.line, i.original.column = l.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), s = o.match(/\n/g), s ? (e += s.length, a = o.lastIndexOf(`
`), r = o.length - a) : r += o.length, l && u !== "start") {
                    let f = l.parent || {
                        raws: {}
                    };
                    (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== f.last || f.raws.semicolon) && (l.source && l.source.end ? (i.source = this.sourcePath(l), i.original.line = l.source.end.line, i.original.column = l.source.end.column - 1, i.generated.line = e, i.generated.column = r - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = r - 1, this.map.addMapping(i)));
                }
            });
        }
        generate() {
            if (this.clearAnnotation(), rd && td && this.isMap()) return this.generateMap();
            {
                let e = "";
                return this.stringify(this.root, (r)=>{
                    e += r;
                }), [
                    e
                ];
            }
        }
    };
    oo.exports = ii;
});
var Ot = S((Db, lo)=>{
    "use strict";
    var nd = vt(), At = class extends nd {
        constructor(e){
            super(e), this.type = "comment";
        }
    };
    lo.exports = At;
    At.default = At;
});
var Te = S((Mb, wo)=>{
    "use strict";
    var { isClean: uo, my: fo } = br(), co = xt(), po = Ot(), id = vt(), ho, ai, oi, mo;
    function go(t) {
        return t.map((e)=>(e.nodes && (e.nodes = go(e.nodes)), delete e.source, e));
    }
    function yo(t) {
        if (t[uo] = !1, t.proxyOf.nodes) for (let e of t.proxyOf.nodes)yo(e);
    }
    var ae = class extends id {
        push(e) {
            return e.parent = this, this.proxyOf.nodes.push(e), this;
        }
        each(e) {
            if (!this.proxyOf.nodes) return;
            let r = this.getIterator(), n, i;
            for(; this.indexes[r] < this.proxyOf.nodes.length && (n = this.indexes[r], i = e(this.proxyOf.nodes[n], n), i !== !1);)this.indexes[r] += 1;
            return delete this.indexes[r], i;
        }
        walk(e) {
            return this.each((r, n)=>{
                let i;
                try {
                    i = e(r, n);
                } catch (s) {
                    throw r.addToError(s);
                }
                return i !== !1 && r.walk && (i = r.walk(e)), i;
            });
        }
        walkDecls(e, r) {
            return r ? e instanceof RegExp ? this.walk((n, i)=>{
                if (n.type === "decl" && e.test(n.prop)) return r(n, i);
            }) : this.walk((n, i)=>{
                if (n.type === "decl" && n.prop === e) return r(n, i);
            }) : (r = e, this.walk((n, i)=>{
                if (n.type === "decl") return r(n, i);
            }));
        }
        walkRules(e, r) {
            return r ? e instanceof RegExp ? this.walk((n, i)=>{
                if (n.type === "rule" && e.test(n.selector)) return r(n, i);
            }) : this.walk((n, i)=>{
                if (n.type === "rule" && n.selector === e) return r(n, i);
            }) : (r = e, this.walk((n, i)=>{
                if (n.type === "rule") return r(n, i);
            }));
        }
        walkAtRules(e, r) {
            return r ? e instanceof RegExp ? this.walk((n, i)=>{
                if (n.type === "atrule" && e.test(n.name)) return r(n, i);
            }) : this.walk((n, i)=>{
                if (n.type === "atrule" && n.name === e) return r(n, i);
            }) : (r = e, this.walk((n, i)=>{
                if (n.type === "atrule") return r(n, i);
            }));
        }
        walkComments(e) {
            return this.walk((r, n)=>{
                if (r.type === "comment") return e(r, n);
            });
        }
        append(...e) {
            for (let r of e){
                let n = this.normalize(r, this.last);
                for (let i of n)this.proxyOf.nodes.push(i);
            }
            return this.markDirty(), this;
        }
        prepend(...e) {
            e = e.reverse();
            for (let r of e){
                let n = this.normalize(r, this.first, "prepend").reverse();
                for (let i of n)this.proxyOf.nodes.unshift(i);
                for(let i in this.indexes)this.indexes[i] = this.indexes[i] + n.length;
            }
            return this.markDirty(), this;
        }
        cleanRaws(e) {
            if (super.cleanRaws(e), this.nodes) for (let r of this.nodes)r.cleanRaws(e);
        }
        insertBefore(e, r) {
            let n = this.index(e), i = n === 0 ? "prepend" : !1, s = this.normalize(r, this.proxyOf.nodes[n], i).reverse();
            n = this.index(e);
            for (let o of s)this.proxyOf.nodes.splice(n, 0, o);
            let a;
            for(let o in this.indexes)a = this.indexes[o], n <= a && (this.indexes[o] = a + s.length);
            return this.markDirty(), this;
        }
        insertAfter(e, r) {
            let n = this.index(e), i = this.normalize(r, this.proxyOf.nodes[n]).reverse();
            n = this.index(e);
            for (let a of i)this.proxyOf.nodes.splice(n + 1, 0, a);
            let s;
            for(let a in this.indexes)s = this.indexes[a], n < s && (this.indexes[a] = s + i.length);
            return this.markDirty(), this;
        }
        removeChild(e) {
            e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
            let r;
            for(let n in this.indexes)r = this.indexes[n], r >= e && (this.indexes[n] = r - 1);
            return this.markDirty(), this;
        }
        removeAll() {
            for (let e of this.proxyOf.nodes)e.parent = void 0;
            return this.proxyOf.nodes = [], this.markDirty(), this;
        }
        replaceValues(e, r, n) {
            return n || (n = r, r = {}), this.walkDecls((i)=>{
                r.props && !r.props.includes(i.prop) || r.fast && !i.value.includes(r.fast) || (i.value = i.value.replace(e, n));
            }), this.markDirty(), this;
        }
        every(e) {
            return this.nodes.every(e);
        }
        some(e) {
            return this.nodes.some(e);
        }
        index(e) {
            return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
        }
        get first() {
            if (!!this.proxyOf.nodes) return this.proxyOf.nodes[0];
        }
        get last() {
            if (!!this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
        normalize(e, r) {
            if (typeof e == "string") e = go(ho(e).nodes);
            else if (Array.isArray(e)) {
                e = e.slice(0);
                for (let i of e)i.parent && i.parent.removeChild(i, "ignore");
            } else if (e.type === "root" && this.type !== "document") {
                e = e.nodes.slice(0);
                for (let i of e)i.parent && i.parent.removeChild(i, "ignore");
            } else if (e.type) e = [
                e
            ];
            else if (e.prop) {
                if (typeof e.value > "u") throw new Error("Value field is missed in node creation");
                typeof e.value != "string" && (e.value = String(e.value)), e = [
                    new co(e)
                ];
            } else if (e.selector) e = [
                new ai(e)
            ];
            else if (e.name) e = [
                new oi(e)
            ];
            else if (e.text) e = [
                new po(e)
            ];
            else throw new Error("Unknown node type in node creation");
            return e.map((i)=>(i[fo] || ae.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[uo] && yo(i), typeof i.raws.before > "u" && r && typeof r.raws.before < "u" && (i.raws.before = r.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
        }
        getProxyProcessor() {
            return {
                set (e, r, n) {
                    return e[r] === n || (e[r] = n, (r === "name" || r === "params" || r === "selector") && e.markDirty()), !0;
                },
                get (e, r) {
                    return r === "proxyOf" ? e : e[r] ? r === "each" || typeof r == "string" && r.startsWith("walk") ? (...n)=>e[r](...n.map((i)=>typeof i == "function" ? (s, a)=>i(s.toProxy(), a) : i)) : r === "every" || r === "some" ? (n)=>e[r]((i, ...s)=>n(i.toProxy(), ...s)) : r === "root" ? ()=>e.root().toProxy() : r === "nodes" ? e.nodes.map((n)=>n.toProxy()) : r === "first" || r === "last" ? e[r].toProxy() : e[r] : e[r];
                }
            };
        }
        getIterator() {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let e = this.lastEach;
            return this.indexes[e] = 0, e;
        }
    };
    ae.registerParse = (t)=>{
        ho = t;
    };
    ae.registerRule = (t)=>{
        ai = t;
    };
    ae.registerAtRule = (t)=>{
        oi = t;
    };
    ae.registerRoot = (t)=>{
        mo = t;
    };
    wo.exports = ae;
    ae.default = ae;
    ae.rebuild = (t)=>{
        t.type === "atrule" ? Object.setPrototypeOf(t, oi.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, ai.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, co.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, po.prototype) : t.type === "root" && Object.setPrototypeOf(t, mo.prototype), t[fo] = !0, t.nodes && t.nodes.forEach((e)=>{
            ae.rebuild(e);
        });
    };
});
var Ar = S((Lb, xo)=>{
    "use strict";
    var sd = Te(), vo, bo, je = class extends sd {
        constructor(e){
            super({
                type: "document",
                ...e
            }), this.nodes || (this.nodes = []);
        }
        toResult(e = {}) {
            return new vo(new bo, this, e).stringify();
        }
    };
    je.registerLazyResult = (t)=>{
        vo = t;
    };
    je.registerProcessor = (t)=>{
        bo = t;
    };
    xo.exports = je;
    je.default = je;
});
var li = S((Fb, ko)=>{
    "use strict";
    var So = {};
    ko.exports = function(e) {
        So[e] || (So[e] = !0, typeof console < "u" && console.warn && console.warn(e));
    };
});
var ui = S((Nb, Co)=>{
    "use strict";
    var _t = class {
        constructor(e, r = {}){
            if (this.type = "warning", this.text = e, r.node && r.node.source) {
                let n = r.node.rangeBy(r);
                this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
            }
            for(let n in r)this[n] = r[n];
        }
        toString() {
            return this.node ? this.node.error(this.text, {
                plugin: this.plugin,
                index: this.index,
                word: this.word
            }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
        }
    };
    Co.exports = _t;
    _t.default = _t;
});
var Or = S((qb, Eo)=>{
    "use strict";
    var ad = ui(), Tt = class {
        constructor(e, r, n){
            this.processor = e, this.messages = [], this.root = r, this.opts = n, this.css = void 0, this.map = void 0;
        }
        toString() {
            return this.css;
        }
        warn(e, r = {}) {
            r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
            let n = new ad(e, r);
            return this.messages.push(n), n;
        }
        warnings() {
            return this.messages.filter((e)=>e.type === "warning");
        }
        get content() {
            return this.css;
        }
    };
    Eo.exports = Tt;
    Tt.default = Tt;
});
var Po = S(($b, To)=>{
    "use strict";
    var fi = "'".charCodeAt(0), Ao = '"'.charCodeAt(0), _r = "\\".charCodeAt(0), Oo = "/".charCodeAt(0), Tr = `
`.charCodeAt(0), Pt = " ".charCodeAt(0), Pr = "\f".charCodeAt(0), Rr = "	".charCodeAt(0), Ir = "\r".charCodeAt(0), od = "[".charCodeAt(0), ld = "]".charCodeAt(0), ud = "(".charCodeAt(0), fd = ")".charCodeAt(0), cd = "{".charCodeAt(0), pd = "}".charCodeAt(0), dd = ";".charCodeAt(0), hd = "*".charCodeAt(0), md = ":".charCodeAt(0), gd = "@".charCodeAt(0), Dr = /[\t\n\f\r "#'()/;[\\\]{}]/g, Mr = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, yd = /.[\n"'(/\\]/, _o = /[\da-f]/i;
    To.exports = function(e, r = {}) {
        let n = e.css.valueOf(), i = r.ignoreErrors, s, a, o, l, u, f, p, c, d, h, y = n.length, m = 0, g = [], w = [];
        function b() {
            return m;
        }
        function v(E) {
            throw e.error("Unclosed " + E, m);
        }
        function C() {
            return w.length === 0 && m >= y;
        }
        function x(E) {
            if (w.length) return w.pop();
            if (m >= y) return;
            let R = E ? E.ignoreUnclosed : !1;
            switch(s = n.charCodeAt(m), s){
                case Tr:
                case Pt:
                case Rr:
                case Ir:
                case Pr:
                    {
                        a = m;
                        do a += 1, s = n.charCodeAt(a);
                        while (s === Pt || s === Tr || s === Rr || s === Ir || s === Pr);
                        h = [
                            "space",
                            n.slice(m, a)
                        ], m = a - 1;
                        break;
                    }
                case od:
                case ld:
                case cd:
                case pd:
                case md:
                case dd:
                case fd:
                    {
                        let L = String.fromCharCode(s);
                        h = [
                            L,
                            L,
                            m
                        ];
                        break;
                    }
                case ud:
                    {
                        if (c = g.length ? g.pop()[1] : "", d = n.charCodeAt(m + 1), c === "url" && d !== fi && d !== Ao && d !== Pt && d !== Tr && d !== Rr && d !== Pr && d !== Ir) {
                            a = m;
                            do {
                                if (f = !1, a = n.indexOf(")", a + 1), a === -1) if (i || R) {
                                    a = m;
                                    break;
                                } else v("bracket");
                                for(p = a; n.charCodeAt(p - 1) === _r;)p -= 1, f = !f;
                            }while (f);
                            h = [
                                "brackets",
                                n.slice(m, a + 1),
                                m,
                                a
                            ], m = a;
                        } else a = n.indexOf(")", m + 1), l = n.slice(m, a + 1), a === -1 || yd.test(l) ? h = [
                            "(",
                            "(",
                            m
                        ] : (h = [
                            "brackets",
                            l,
                            m,
                            a
                        ], m = a);
                        break;
                    }
                case fi:
                case Ao:
                    {
                        o = s === fi ? "'" : '"', a = m;
                        do {
                            if (f = !1, a = n.indexOf(o, a + 1), a === -1) if (i || R) {
                                a = m + 1;
                                break;
                            } else v("string");
                            for(p = a; n.charCodeAt(p - 1) === _r;)p -= 1, f = !f;
                        }while (f);
                        h = [
                            "string",
                            n.slice(m, a + 1),
                            m,
                            a
                        ], m = a;
                        break;
                    }
                case gd:
                    {
                        Dr.lastIndex = m + 1, Dr.test(n), Dr.lastIndex === 0 ? a = n.length - 1 : a = Dr.lastIndex - 2, h = [
                            "at-word",
                            n.slice(m, a + 1),
                            m,
                            a
                        ], m = a;
                        break;
                    }
                case _r:
                    {
                        for(a = m, u = !0; n.charCodeAt(a + 1) === _r;)a += 1, u = !u;
                        if (s = n.charCodeAt(a + 1), u && s !== Oo && s !== Pt && s !== Tr && s !== Rr && s !== Ir && s !== Pr && (a += 1, _o.test(n.charAt(a)))) {
                            for(; _o.test(n.charAt(a + 1));)a += 1;
                            n.charCodeAt(a + 1) === Pt && (a += 1);
                        }
                        h = [
                            "word",
                            n.slice(m, a + 1),
                            m,
                            a
                        ], m = a;
                        break;
                    }
                default:
                    {
                        s === Oo && n.charCodeAt(m + 1) === hd ? (a = n.indexOf("*/", m + 2) + 1, a === 0 && (i || R ? a = n.length : v("comment")), h = [
                            "comment",
                            n.slice(m, a + 1),
                            m,
                            a
                        ], m = a) : (Mr.lastIndex = m + 1, Mr.test(n), Mr.lastIndex === 0 ? a = n.length - 1 : a = Mr.lastIndex - 2, h = [
                            "word",
                            n.slice(m, a + 1),
                            m,
                            a
                        ], g.push(h), m = a);
                        break;
                    }
            }
            return m++, h;
        }
        function O(E) {
            w.push(E);
        }
        return {
            back: O,
            nextToken: x,
            endOfFile: C,
            position: b
        };
    };
});
var Lr = S((Ub, Io)=>{
    "use strict";
    var Ro = Te(), Je = class extends Ro {
        constructor(e){
            super(e), this.type = "atrule";
        }
        append(...e) {
            return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
        }
        prepend(...e) {
            return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
        }
    };
    Io.exports = Je;
    Je.default = Je;
    Ro.registerAtRule(Je);
});
var Xe = S((jb, Fo)=>{
    "use strict";
    var Do = Te(), Mo, Lo, Pe = class extends Do {
        constructor(e){
            super(e), this.type = "root", this.nodes || (this.nodes = []);
        }
        removeChild(e, r) {
            let n = this.index(e);
            return !r && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
        }
        normalize(e, r, n) {
            let i = super.normalize(e);
            if (r) {
                if (n === "prepend") this.nodes.length > 1 ? r.raws.before = this.nodes[1].raws.before : delete r.raws.before;
                else if (this.first !== r) for (let s of i)s.raws.before = r.raws.before;
            }
            return i;
        }
        toResult(e = {}) {
            return new Mo(new Lo, this, e).stringify();
        }
    };
    Pe.registerLazyResult = (t)=>{
        Mo = t;
    };
    Pe.registerProcessor = (t)=>{
        Lo = t;
    };
    Fo.exports = Pe;
    Pe.default = Pe;
    Do.registerRoot(Pe);
});
var ci = S((zb, No)=>{
    "use strict";
    var Rt = {
        split (t, e, r) {
            let n = [], i = "", s = !1, a = 0, o = !1, l = "", u = !1;
            for (let f of t)u ? u = !1 : f === "\\" ? u = !0 : o ? f === l && (o = !1) : f === '"' || f === "'" ? (o = !0, l = f) : f === "(" ? a += 1 : f === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(f) && (s = !0), s ? (i !== "" && n.push(i.trim()), i = "", s = !1) : i += f;
            return (r || i !== "") && n.push(i.trim()), n;
        },
        space (t) {
            let e = [
                " ",
                `
`,
                "	"
            ];
            return Rt.split(t, e);
        },
        comma (t) {
            return Rt.split(t, [
                ","
            ], !0);
        }
    };
    No.exports = Rt;
    Rt.default = Rt;
});
var Fr = S((Vb, $o)=>{
    "use strict";
    var qo = Te(), wd = ci(), Ke = class extends qo {
        constructor(e){
            super(e), this.type = "rule", this.nodes || (this.nodes = []);
        }
        get selectors() {
            return wd.comma(this.selector);
        }
        set selectors(e) {
            let r = this.selector ? this.selector.match(/,\s*/) : null, n = r ? r[0] : "," + this.raw("between", "beforeOpen");
            this.selector = e.join(n);
        }
    };
    $o.exports = Ke;
    Ke.default = Ke;
    qo.registerRule(Ke);
});
var Vo = S((Wb, zo)=>{
    "use strict";
    var vd = xt(), bd = Po(), xd = Ot(), Sd = Lr(), kd = Xe(), Uo = Fr(), jo = {
        empty: !0,
        space: !0
    };
    function Cd(t) {
        for(let e = t.length - 1; e >= 0; e--){
            let r = t[e], n = r[3] || r[2];
            if (n) return n;
        }
    }
    var pi = class {
        constructor(e){
            this.input = e, this.root = new kd, this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = {
                input: e,
                start: {
                    offset: 0,
                    line: 1,
                    column: 1
                }
            };
        }
        createTokenizer() {
            this.tokenizer = bd(this.input);
        }
        parse() {
            let e;
            for(; !this.tokenizer.endOfFile();)switch(e = this.tokenizer.nextToken(), e[0]){
                case "space":
                    this.spaces += e[1];
                    break;
                case ";":
                    this.freeSemicolon(e);
                    break;
                case "}":
                    this.end(e);
                    break;
                case "comment":
                    this.comment(e);
                    break;
                case "at-word":
                    this.atrule(e);
                    break;
                case "{":
                    this.emptyRule(e);
                    break;
                default:
                    this.other(e);
                    break;
            }
            this.endFile();
        }
        comment(e) {
            let r = new xd;
            this.init(r, e[2]), r.source.end = this.getPosition(e[3] || e[2]);
            let n = e[1].slice(2, -2);
            if (/^\s*$/.test(n)) r.text = "", r.raws.left = n, r.raws.right = "";
            else {
                let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
                r.text = i[2], r.raws.left = i[1], r.raws.right = i[3];
            }
        }
        emptyRule(e) {
            let r = new Uo;
            this.init(r, e[2]), r.selector = "", r.raws.between = "", this.current = r;
        }
        other(e) {
            let r = !1, n = null, i = !1, s = null, a = [], o = e[1].startsWith("--"), l = [], u = e;
            for(; u;){
                if (n = u[0], l.push(u), n === "(" || n === "[") s || (s = u), a.push(n === "(" ? ")" : "]");
                else if (o && i && n === "{") s || (s = u), a.push("}");
                else if (a.length === 0) if (n === ";") if (i) {
                    this.decl(l, o);
                    return;
                } else break;
                else if (n === "{") {
                    this.rule(l);
                    return;
                } else if (n === "}") {
                    this.tokenizer.back(l.pop()), r = !0;
                    break;
                } else n === ":" && (i = !0);
                else n === a[a.length - 1] && (a.pop(), a.length === 0 && (s = null));
                u = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile() && (r = !0), a.length > 0 && this.unclosedBracket(s), r && i) {
                if (!o) for(; l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment"));)this.tokenizer.back(l.pop());
                this.decl(l, o);
            } else this.unknownWord(l);
        }
        rule(e) {
            e.pop();
            let r = new Uo;
            this.init(r, e[0][2]), r.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(r, "selector", e), this.current = r;
        }
        decl(e, r) {
            let n = new vd;
            this.init(n, e[0][2]);
            let i = e[e.length - 1];
            for(i[0] === ";" && (this.semicolon = !0, e.pop()), n.source.end = this.getPosition(i[3] || i[2] || Cd(e)); e[0][0] !== "word";)e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
            for(n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length;){
                let u = e[0][0];
                if (u === ":" || u === "space" || u === "comment") break;
                n.prop += e.shift()[1];
            }
            n.raws.between = "";
            let s;
            for(; e.length;)if (s = e.shift(), s[0] === ":") {
                n.raws.between += s[1];
                break;
            } else s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([
                s
            ]), n.raws.between += s[1];
            (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
            let a = [], o;
            for(; e.length && (o = e[0][0], !(o !== "space" && o !== "comment"));)a.push(e.shift());
            this.precheckMissedSemicolon(e);
            for(let u = e.length - 1; u >= 0; u--){
                if (s = e[u], s[1].toLowerCase() === "!important") {
                    n.important = !0;
                    let f = this.stringFrom(e, u);
                    f = this.spacesFromEnd(e) + f, f !== " !important" && (n.raws.important = f);
                    break;
                } else if (s[1].toLowerCase() === "important") {
                    let f = e.slice(0), p = "";
                    for(let c = u; c > 0; c--){
                        let d = f[c][0];
                        if (p.trim().indexOf("!") === 0 && d !== "space") break;
                        p = f.pop()[1] + p;
                    }
                    p.trim().indexOf("!") === 0 && (n.important = !0, n.raws.important = p, e = f);
                }
                if (s[0] !== "space" && s[0] !== "comment") break;
            }
            e.some((u)=>u[0] !== "space" && u[0] !== "comment") && (n.raws.between += a.map((u)=>u[1]).join(""), a = []), this.raw(n, "value", a.concat(e), r), n.value.includes(":") && !r && this.checkMissedSemicolon(e);
        }
        atrule(e) {
            let r = new Sd;
            r.name = e[1].slice(1), r.name === "" && this.unnamedAtrule(r, e), this.init(r, e[2]);
            let n, i, s, a = !1, o = !1, l = [], u = [];
            for(; !this.tokenizer.endOfFile();){
                if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? u.push(n === "(" ? ")" : "]") : n === "{" && u.length > 0 ? u.push("}") : n === u[u.length - 1] && u.pop(), u.length === 0) if (n === ";") {
                    r.source.end = this.getPosition(e[2]), this.semicolon = !0;
                    break;
                } else if (n === "{") {
                    o = !0;
                    break;
                } else if (n === "}") {
                    if (l.length > 0) {
                        for(s = l.length - 1, i = l[s]; i && i[0] === "space";)i = l[--s];
                        i && (r.source.end = this.getPosition(i[3] || i[2]));
                    }
                    this.end(e);
                    break;
                } else l.push(e);
                else l.push(e);
                if (this.tokenizer.endOfFile()) {
                    a = !0;
                    break;
                }
            }
            r.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (r.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(r, "params", l), a && (e = l[l.length - 1], r.source.end = this.getPosition(e[3] || e[2]), this.spaces = r.raws.between, r.raws.between = "")) : (r.raws.afterName = "", r.params = ""), o && (r.nodes = [], this.current = r);
        }
        end(e) {
            this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
        }
        endFile() {
            this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        }
        freeSemicolon(e) {
            if (this.spaces += e[1], this.current.nodes) {
                let r = this.current.nodes[this.current.nodes.length - 1];
                r && r.type === "rule" && !r.raws.ownSemicolon && (r.raws.ownSemicolon = this.spaces, this.spaces = "");
            }
        }
        getPosition(e) {
            let r = this.input.fromOffset(e);
            return {
                offset: e,
                line: r.line,
                column: r.col
            };
        }
        init(e, r) {
            this.current.push(e), e.source = {
                start: this.getPosition(r),
                input: this.input
            }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
        }
        raw(e, r, n, i) {
            let s, a, o = n.length, l = "", u = !0, f, p;
            for(let c = 0; c < o; c += 1)s = n[c], a = s[0], a === "space" && c === o - 1 && !i ? u = !1 : a === "comment" ? (p = n[c - 1] ? n[c - 1][0] : "empty", f = n[c + 1] ? n[c + 1][0] : "empty", !jo[p] && !jo[f] ? l.slice(-1) === "," ? u = !1 : l += s[1] : u = !1) : l += s[1];
            if (!u) {
                let c = n.reduce((d, h)=>d + h[1], "");
                e.raws[r] = {
                    value: l,
                    raw: c
                };
            }
            e[r] = l;
        }
        spacesAndCommentsFromEnd(e) {
            let r, n = "";
            for(; e.length && (r = e[e.length - 1][0], !(r !== "space" && r !== "comment"));)n = e.pop()[1] + n;
            return n;
        }
        spacesAndCommentsFromStart(e) {
            let r, n = "";
            for(; e.length && (r = e[0][0], !(r !== "space" && r !== "comment"));)n += e.shift()[1];
            return n;
        }
        spacesFromEnd(e) {
            let r, n = "";
            for(; e.length && (r = e[e.length - 1][0], r === "space");)n = e.pop()[1] + n;
            return n;
        }
        stringFrom(e, r) {
            let n = "";
            for(let i = r; i < e.length; i++)n += e[i][1];
            return e.splice(r, e.length - r), n;
        }
        colon(e) {
            let r = 0, n, i, s;
            for (let [a, o] of e.entries()){
                if (n = o, i = n[0], i === "(" && (r += 1), i === ")" && (r -= 1), r === 0 && i === ":") if (!s) this.doubleColon(n);
                else {
                    if (s[0] === "word" && s[1] === "progid") continue;
                    return a;
                }
                s = n;
            }
            return !1;
        }
        unclosedBracket(e) {
            throw this.input.error("Unclosed bracket", {
                offset: e[2]
            }, {
                offset: e[2] + 1
            });
        }
        unknownWord(e) {
            throw this.input.error("Unknown word", {
                offset: e[0][2]
            }, {
                offset: e[0][2] + e[0][1].length
            });
        }
        unexpectedClose(e) {
            throw this.input.error("Unexpected }", {
                offset: e[2]
            }, {
                offset: e[2] + 1
            });
        }
        unclosedBlock() {
            let e = this.current.source.start;
            throw this.input.error("Unclosed block", e.line, e.column);
        }
        doubleColon(e) {
            throw this.input.error("Double colon", {
                offset: e[2]
            }, {
                offset: e[2] + e[1].length
            });
        }
        unnamedAtrule(e, r) {
            throw this.input.error("At-rule without name", {
                offset: r[2]
            }, {
                offset: r[2] + r[1].length
            });
        }
        precheckMissedSemicolon() {}
        checkMissedSemicolon(e) {
            let r = this.colon(e);
            if (r === !1) return;
            let n = 0, i;
            for(let s = r - 1; s >= 0 && (i = e[s], !(i[0] !== "space" && (n += 1, n === 2))); s--);
            throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2]);
        }
    };
    zo.exports = pi;
});
var qr = S((Bb, Wo)=>{
    "use strict";
    var Ed = Te(), Ad = Vo(), Od = Et();
    function Nr(t, e) {
        let r = new Od(t, e), n = new Ad(r);
        try {
            n.parse();
        } catch (i) {
            throw i;
        }
        return n.root;
    }
    Wo.exports = Nr;
    Nr.default = Nr;
    Ed.registerParse(Nr);
});
var mi = S((Yb, Ho)=>{
    "use strict";
    var { isClean: ge, my: _d } = br(), Td = si(), Pd = yt(), Rd = Te(), Id = Ar(), Gb = li(), Bo = Or(), Dd = qr(), Md = Xe(), Ld = {
        document: "Document",
        root: "Root",
        atrule: "AtRule",
        rule: "Rule",
        decl: "Declaration",
        comment: "Comment"
    }, Fd = {
        postcssPlugin: !0,
        prepare: !0,
        Once: !0,
        Document: !0,
        Root: !0,
        Declaration: !0,
        Rule: !0,
        AtRule: !0,
        Comment: !0,
        DeclarationExit: !0,
        RuleExit: !0,
        AtRuleExit: !0,
        CommentExit: !0,
        RootExit: !0,
        DocumentExit: !0,
        OnceExit: !0
    }, Nd = {
        postcssPlugin: !0,
        prepare: !0,
        Once: !0
    }, Ze = 0;
    function It(t) {
        return typeof t == "object" && typeof t.then == "function";
    }
    function Yo(t) {
        let e = !1, r = Ld[t.type];
        return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
            r,
            r + "-" + e,
            Ze,
            r + "Exit",
            r + "Exit-" + e
        ] : e ? [
            r,
            r + "-" + e,
            r + "Exit",
            r + "Exit-" + e
        ] : t.append ? [
            r,
            Ze,
            r + "Exit"
        ] : [
            r,
            r + "Exit"
        ];
    }
    function Go(t) {
        let e;
        return t.type === "document" ? e = [
            "Document",
            Ze,
            "DocumentExit"
        ] : t.type === "root" ? e = [
            "Root",
            Ze,
            "RootExit"
        ] : e = Yo(t), {
            node: t,
            events: e,
            eventIndex: 0,
            visitors: [],
            visitorIndex: 0,
            iterator: 0
        };
    }
    function di(t) {
        return t[ge] = !1, t.nodes && t.nodes.forEach((e)=>di(e)), t;
    }
    var hi = {}, ye = class {
        constructor(e, r, n){
            this.stringified = !1, this.processed = !1;
            let i;
            if (typeof r == "object" && r !== null && (r.type === "root" || r.type === "document")) i = di(r);
            else if (r instanceof ye || r instanceof Bo) i = di(r.root), r.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = r.map);
            else {
                let s = Dd;
                n.syntax && (s = n.syntax.parse), n.parser && (s = n.parser), s.parse && (s = s.parse);
                try {
                    i = s(r, n);
                } catch (a) {
                    this.processed = !0, this.error = a;
                }
                i && !i[_d] && Rd.rebuild(i);
            }
            this.result = new Bo(e, i, n), this.helpers = {
                ...hi,
                result: this.result,
                postcss: hi
            }, this.plugins = this.processor.plugins.map((s)=>typeof s == "object" && s.prepare ? {
                    ...s,
                    ...s.prepare(this.result)
                } : s);
        }
        get [Symbol.toStringTag]() {
            return "LazyResult";
        }
        get processor() {
            return this.result.processor;
        }
        get opts() {
            return this.result.opts;
        }
        get css() {
            return this.stringify().css;
        }
        get content() {
            return this.stringify().content;
        }
        get map() {
            return this.stringify().map;
        }
        get root() {
            return this.sync().root;
        }
        get messages() {
            return this.sync().messages;
        }
        warnings() {
            return this.sync().warnings();
        }
        toString() {
            return this.css;
        }
        then(e, r) {
            return this.async().then(e, r);
        }
        catch(e) {
            return this.async().catch(e);
        }
        finally(e) {
            return this.async().then(e, e);
        }
        async() {
            return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
        }
        sync() {
            if (this.error) throw this.error;
            if (this.processed) return this.result;
            if (this.processed = !0, this.processing) throw this.getAsyncError();
            for (let e of this.plugins){
                let r = this.runOnRoot(e);
                if (It(r)) throw this.getAsyncError();
            }
            if (this.prepareVisitors(), this.hasListener) {
                let e = this.result.root;
                for(; !e[ge];)e[ge] = !0, this.walkSync(e);
                if (this.listeners.OnceExit) if (e.type === "document") for (let r of e.nodes)this.visitSync(this.listeners.OnceExit, r);
                else this.visitSync(this.listeners.OnceExit, e);
            }
            return this.result;
        }
        stringify() {
            if (this.error) throw this.error;
            if (this.stringified) return this.result;
            this.stringified = !0, this.sync();
            let e = this.result.opts, r = Pd;
            e.syntax && (r = e.syntax.stringify), e.stringifier && (r = e.stringifier), r.stringify && (r = r.stringify);
            let i = new Td(r, this.result.root, this.result.opts).generate();
            return this.result.css = i[0], this.result.map = i[1], this.result;
        }
        walkSync(e) {
            e[ge] = !0;
            let r = Yo(e);
            for (let n of r)if (n === Ze) e.nodes && e.each((i)=>{
                i[ge] || this.walkSync(i);
            });
            else {
                let i = this.listeners[n];
                if (i && this.visitSync(i, e.toProxy())) return;
            }
        }
        visitSync(e, r) {
            for (let [n, i] of e){
                this.result.lastPlugin = n;
                let s;
                try {
                    s = i(r, this.helpers);
                } catch (a) {
                    throw this.handleError(a, r.proxyOf);
                }
                if (r.type !== "root" && r.type !== "document" && !r.parent) return !0;
                if (It(s)) throw this.getAsyncError();
            }
        }
        runOnRoot(e) {
            this.result.lastPlugin = e;
            try {
                if (typeof e == "object" && e.Once) {
                    if (this.result.root.type === "document") {
                        let r = this.result.root.nodes.map((n)=>e.Once(n, this.helpers));
                        return It(r[0]) ? Promise.all(r) : r;
                    }
                    return e.Once(this.result.root, this.helpers);
                } else if (typeof e == "function") return e(this.result.root, this.result);
            } catch (r) {
                throw this.handleError(r);
            }
        }
        getAsyncError() {
            throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(e, r) {
            let n = this.result.lastPlugin;
            try {
                r && r.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = n.postcssPlugin, e.setMessage()) : n.postcssVersion;
            } catch (i) {
                console && console.error && console.error(i);
            }
            return e;
        }
        async runAsync() {
            this.plugin = 0;
            for(let e = 0; e < this.plugins.length; e++){
                let r = this.plugins[e], n = this.runOnRoot(r);
                if (It(n)) try {
                    await n;
                } catch (i) {
                    throw this.handleError(i);
                }
            }
            if (this.prepareVisitors(), this.hasListener) {
                let e = this.result.root;
                for(; !e[ge];){
                    e[ge] = !0;
                    let r = [
                        Go(e)
                    ];
                    for(; r.length > 0;){
                        let n = this.visitTick(r);
                        if (It(n)) try {
                            await n;
                        } catch (i) {
                            let s = r[r.length - 1].node;
                            throw this.handleError(i, s);
                        }
                    }
                }
                if (this.listeners.OnceExit) for (let [r, n] of this.listeners.OnceExit){
                    this.result.lastPlugin = r;
                    try {
                        if (e.type === "document") {
                            let i = e.nodes.map((s)=>n(s, this.helpers));
                            await Promise.all(i);
                        } else await n(e, this.helpers);
                    } catch (i) {
                        throw this.handleError(i);
                    }
                }
            }
            return this.processed = !0, this.stringify();
        }
        prepareVisitors() {
            this.listeners = {};
            let e = (r, n, i)=>{
                this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([
                    r,
                    i
                ]);
            };
            for (let r of this.plugins)if (typeof r == "object") for(let n in r){
                if (!Fd[n] && /^[A-Z]/.test(n)) throw new Error(`Unknown event ${n} in ${r.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
                if (!Nd[n]) if (typeof r[n] == "object") for(let i in r[n])i === "*" ? e(r, n, r[n][i]) : e(r, n + "-" + i.toLowerCase(), r[n][i]);
                else typeof r[n] == "function" && e(r, n, r[n]);
            }
            this.hasListener = Object.keys(this.listeners).length > 0;
        }
        visitTick(e) {
            let r = e[e.length - 1], { node: n, visitors: i } = r;
            if (n.type !== "root" && n.type !== "document" && !n.parent) {
                e.pop();
                return;
            }
            if (i.length > 0 && r.visitorIndex < i.length) {
                let [a, o] = i[r.visitorIndex];
                r.visitorIndex += 1, r.visitorIndex === i.length && (r.visitors = [], r.visitorIndex = 0), this.result.lastPlugin = a;
                try {
                    return o(n.toProxy(), this.helpers);
                } catch (l) {
                    throw this.handleError(l, n);
                }
            }
            if (r.iterator !== 0) {
                let a = r.iterator, o;
                for(; o = n.nodes[n.indexes[a]];)if (n.indexes[a] += 1, !o[ge]) {
                    o[ge] = !0, e.push(Go(o));
                    return;
                }
                r.iterator = 0, delete n.indexes[a];
            }
            let s = r.events;
            for(; r.eventIndex < s.length;){
                let a = s[r.eventIndex];
                if (r.eventIndex += 1, a === Ze) {
                    n.nodes && n.nodes.length && (n[ge] = !0, r.iterator = n.getIterator());
                    return;
                } else if (this.listeners[a]) {
                    r.visitors = this.listeners[a];
                    return;
                }
            }
            e.pop();
        }
    };
    ye.registerPostcss = (t)=>{
        hi = t;
    };
    Ho.exports = ye;
    ye.default = ye;
    Md.registerLazyResult(ye);
    Id.registerLazyResult(ye);
});
var Jo = S((Qb, Qo)=>{
    "use strict";
    var qd = si(), $d = yt(), Hb = li(), Ud = qr(), jd = Or(), Dt = class {
        constructor(e, r, n){
            r = r.toString(), this.stringified = !1, this._processor = e, this._css = r, this._opts = n, this._map = void 0;
            let i, s = $d;
            this.result = new jd(this._processor, i, this._opts), this.result.css = r;
            let a = this;
            Object.defineProperty(this.result, "root", {
                get () {
                    return a.root;
                }
            });
            let o = new qd(s, i, this._opts, r);
            if (o.isMap()) {
                let [l, u] = o.generate();
                l && (this.result.css = l), u && (this.result.map = u);
            }
        }
        get [Symbol.toStringTag]() {
            return "NoWorkResult";
        }
        get processor() {
            return this.result.processor;
        }
        get opts() {
            return this.result.opts;
        }
        get css() {
            return this.result.css;
        }
        get content() {
            return this.result.css;
        }
        get map() {
            return this.result.map;
        }
        get root() {
            if (this._root) return this._root;
            let e, r = Ud;
            try {
                e = r(this._css, this._opts);
            } catch (n) {
                this.error = n;
            }
            if (this.error) throw this.error;
            return this._root = e, e;
        }
        get messages() {
            return [];
        }
        warnings() {
            return [];
        }
        toString() {
            return this._css;
        }
        then(e, r) {
            return this.async().then(e, r);
        }
        catch(e) {
            return this.async().catch(e);
        }
        finally(e) {
            return this.async().then(e, e);
        }
        async() {
            return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
        }
        sync() {
            if (this.error) throw this.error;
            return this.result;
        }
    };
    Qo.exports = Dt;
    Dt.default = Dt;
});
var Ko = S((Jb, Xo)=>{
    "use strict";
    var zd = Jo(), Vd = mi(), Wd = Ar(), Bd = Xe(), ze = class {
        constructor(e = []){
            this.version = "8.4.21", this.plugins = this.normalize(e);
        }
        use(e) {
            return this.plugins = this.plugins.concat(this.normalize([
                e
            ])), this;
        }
        process(e, r = {}) {
            return this.plugins.length === 0 && typeof r.parser > "u" && typeof r.stringifier > "u" && typeof r.syntax > "u" ? new zd(this, e, r) : new Vd(this, e, r);
        }
        normalize(e) {
            let r = [];
            for (let n of e)if (n.postcss === !0 ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins)) r = r.concat(n.plugins);
            else if (typeof n == "object" && n.postcssPlugin) r.push(n);
            else if (typeof n == "function") r.push(n);
            else if (!(typeof n == "object" && (n.parse || n.stringify))) throw new Error(n + " is not a PostCSS plugin");
            return r;
        }
    };
    Xo.exports = ze;
    ze.default = ze;
    Bd.registerProcessor(ze);
    Wd.registerProcessor(ze);
});
var el = S((Xb, Zo)=>{
    "use strict";
    var Gd = xt(), Yd = Zn(), Hd = Ot(), Qd = Lr(), Jd = Et(), Xd = Xe(), Kd = Fr();
    function Mt(t, e) {
        if (Array.isArray(t)) return t.map((i)=>Mt(i));
        let { inputs: r, ...n } = t;
        if (r) {
            e = [];
            for (let i of r){
                let s = {
                    ...i,
                    __proto__: Jd.prototype
                };
                s.map && (s.map = {
                    ...s.map,
                    __proto__: Yd.prototype
                }), e.push(s);
            }
        }
        if (n.nodes && (n.nodes = t.nodes.map((i)=>Mt(i, e))), n.source) {
            let { inputId: i, ...s } = n.source;
            n.source = s, i != null && (n.source.input = e[i]);
        }
        if (n.type === "root") return new Xd(n);
        if (n.type === "decl") return new Gd(n);
        if (n.type === "rule") return new Kd(n);
        if (n.type === "comment") return new Hd(n);
        if (n.type === "atrule") return new Qd(n);
        throw new Error("Unknown node type: " + t.type);
    }
    Zo.exports = Mt;
    Mt.default = Mt;
});
var et = S((Kb, ol)=>{
    "use strict";
    var Zd = vr(), tl = xt(), eh = mi(), th = Te(), gi = Ko(), rh = yt(), nh = el(), rl = Ar(), ih = ui(), nl = Ot(), il = Lr(), sh = Or(), ah = Et(), oh = qr(), lh = ci(), sl = Fr(), al = Xe(), uh = vt();
    function F(...t) {
        return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new gi(t);
    }
    F.plugin = function(e, r) {
        let n = !1;
        function i(...a) {
            console && console.warn && !n && (n = !0, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
            let o = r(...a);
            return o.postcssPlugin = e, o.postcssVersion = new gi().version, o;
        }
        let s;
        return Object.defineProperty(i, "postcss", {
            get () {
                return s || (s = i()), s;
            }
        }), i.process = function(a, o, l) {
            return F([
                i(l)
            ]).process(a, o);
        }, i;
    };
    F.stringify = rh;
    F.parse = oh;
    F.fromJSON = nh;
    F.list = lh;
    F.comment = (t)=>new nl(t);
    F.atRule = (t)=>new il(t);
    F.decl = (t)=>new tl(t);
    F.rule = (t)=>new sl(t);
    F.root = (t)=>new al(t);
    F.document = (t)=>new rl(t);
    F.CssSyntaxError = Zd;
    F.Declaration = tl;
    F.Container = th;
    F.Processor = gi;
    F.Document = rl;
    F.Comment = nl;
    F.Warning = ih;
    F.AtRule = il;
    F.Result = sh;
    F.Input = ah;
    F.Rule = sl;
    F.Root = al;
    F.Node = uh;
    eh.registerPostcss(F);
    ol.exports = F;
    F.default = F;
});
var Ur = S(($r, ll)=>{
    "use strict";
    $r.__esModule = !0;
    $r.default = ph;
    function fh(t) {
        for(var e = t.toLowerCase(), r = "", n = !1, i = 0; i < 6 && e[i] !== void 0; i++){
            var s = e.charCodeAt(i), a = s >= 97 && s <= 102 || s >= 48 && s <= 57;
            if (n = s === 32, !a) break;
            r += e[i];
        }
        if (r.length !== 0) {
            var o = parseInt(r, 16), l = o >= 55296 && o <= 57343;
            return l || o === 0 || o > 1114111 ? [
                "�",
                r.length + (n ? 1 : 0)
            ] : [
                String.fromCodePoint(o),
                r.length + (n ? 1 : 0)
            ];
        }
    }
    var ch = /\\/;
    function ph(t) {
        var e = ch.test(t);
        if (!e) return t;
        for(var r = "", n = 0; n < t.length; n++){
            if (t[n] === "\\") {
                var i = fh(t.slice(n + 1, n + 7));
                if (i !== void 0) {
                    r += i[0], n += i[1];
                    continue;
                }
                if (t[n + 1] === "\\") {
                    r += "\\", n++;
                    continue;
                }
                t.length === n + 1 && (r += t[n]);
                continue;
            }
            r += t[n];
        }
        return r;
    }
    ll.exports = $r.default;
});
var fl = S((jr, ul)=>{
    "use strict";
    jr.__esModule = !0;
    jr.default = dh;
    function dh(t) {
        for(var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)r[n - 1] = arguments[n];
        for(; r.length > 0;){
            var i = r.shift();
            if (!t[i]) return;
            t = t[i];
        }
        return t;
    }
    ul.exports = jr.default;
});
var pl = S((zr, cl)=>{
    "use strict";
    zr.__esModule = !0;
    zr.default = hh;
    function hh(t) {
        for(var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)r[n - 1] = arguments[n];
        for(; r.length > 0;){
            var i = r.shift();
            t[i] || (t[i] = {}), t = t[i];
        }
    }
    cl.exports = zr.default;
});
var hl = S((Vr, dl)=>{
    "use strict";
    Vr.__esModule = !0;
    Vr.default = mh;
    function mh(t) {
        for(var e = "", r = t.indexOf("/*"), n = 0; r >= 0;){
            e = e + t.slice(n, r);
            var i = t.indexOf("*/", r + 2);
            if (i < 0) return e;
            n = i + 2, r = t.indexOf("/*", n);
        }
        return e = e + t.slice(n), e;
    }
    dl.exports = Vr.default;
});
var Lt = S((we)=>{
    "use strict";
    we.__esModule = !0;
    we.stripComments = we.ensureObject = we.getProp = we.unesc = void 0;
    var gh = Wr(Ur());
    we.unesc = gh.default;
    var yh = Wr(fl());
    we.getProp = yh.default;
    var wh = Wr(pl());
    we.ensureObject = wh.default;
    var vh = Wr(hl());
    we.stripComments = vh.default;
    function Wr(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
});
var Ee = S((Ft, yl)=>{
    "use strict";
    Ft.__esModule = !0;
    Ft.default = void 0;
    var ml = Lt();
    function gl(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function bh(t, e, r) {
        return e && gl(t.prototype, e), r && gl(t, r), t;
    }
    var xh = function t(e, r) {
        if (typeof e != "object" || e === null) return e;
        var n = new e.constructor;
        for(var i in e)if (!!e.hasOwnProperty(i)) {
            var s = e[i], a = typeof s;
            i === "parent" && a === "object" ? r && (n[i] = r) : s instanceof Array ? n[i] = s.map(function(o) {
                return t(o, n);
            }) : n[i] = t(s, n);
        }
        return n;
    }, Sh = function() {
        function t(r) {
            r === void 0 && (r = {}), Object.assign(this, r), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
        }
        var e = t.prototype;
        return e.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }, e.replaceWith = function() {
            if (this.parent) {
                for(var n in arguments)this.parent.insertBefore(this, arguments[n]);
                this.remove();
            }
            return this;
        }, e.next = function() {
            return this.parent.at(this.parent.index(this) + 1);
        }, e.prev = function() {
            return this.parent.at(this.parent.index(this) - 1);
        }, e.clone = function(n) {
            n === void 0 && (n = {});
            var i = xh(this);
            for(var s in n)i[s] = n[s];
            return i;
        }, e.appendToPropertyAndEscape = function(n, i, s) {
            this.raws || (this.raws = {});
            var a = this[n], o = this.raws[n];
            this[n] = a + i, o || s !== i ? this.raws[n] = (o || a) + s : delete this.raws[n];
        }, e.setPropertyAndEscape = function(n, i, s) {
            this.raws || (this.raws = {}), this[n] = i, this.raws[n] = s;
        }, e.setPropertyWithoutEscape = function(n, i) {
            this[n] = i, this.raws && delete this.raws[n];
        }, e.isAtPosition = function(n, i) {
            if (this.source && this.source.start && this.source.end) return !(this.source.start.line > n || this.source.end.line < n || this.source.start.line === n && this.source.start.column > i || this.source.end.line === n && this.source.end.column < i);
        }, e.stringifyProperty = function(n) {
            return this.raws && this.raws[n] || this[n];
        }, e.valueToString = function() {
            return String(this.stringifyProperty("value"));
        }, e.toString = function() {
            return [
                this.rawSpaceBefore,
                this.valueToString(),
                this.rawSpaceAfter
            ].join("");
        }, bh(t, [
            {
                key: "rawSpaceBefore",
                get: function() {
                    var n = this.raws && this.raws.spaces && this.raws.spaces.before;
                    return n === void 0 && (n = this.spaces && this.spaces.before), n || "";
                },
                set: function(n) {
                    (0, ml.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n;
                }
            },
            {
                key: "rawSpaceAfter",
                get: function() {
                    var n = this.raws && this.raws.spaces && this.raws.spaces.after;
                    return n === void 0 && (n = this.spaces.after), n || "";
                },
                set: function(n) {
                    (0, ml.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n;
                }
            }
        ]), t;
    }();
    Ft.default = Sh;
    yl.exports = Ft.default;
});
var J = S((U)=>{
    "use strict";
    U.__esModule = !0;
    U.UNIVERSAL = U.ATTRIBUTE = U.CLASS = U.COMBINATOR = U.COMMENT = U.ID = U.NESTING = U.PSEUDO = U.ROOT = U.SELECTOR = U.STRING = U.TAG = void 0;
    var kh = "tag";
    U.TAG = kh;
    var Ch = "string";
    U.STRING = Ch;
    var Eh = "selector";
    U.SELECTOR = Eh;
    var Ah = "root";
    U.ROOT = Ah;
    var Oh = "pseudo";
    U.PSEUDO = Oh;
    var _h = "nesting";
    U.NESTING = _h;
    var Th = "id";
    U.ID = Th;
    var Ph = "comment";
    U.COMMENT = Ph;
    var Rh = "combinator";
    U.COMBINATOR = Rh;
    var Ih = "class";
    U.CLASS = Ih;
    var Dh = "attribute";
    U.ATTRIBUTE = Dh;
    var Mh = "universal";
    U.UNIVERSAL = Mh;
});
var Br = S((Nt, xl)=>{
    "use strict";
    Nt.__esModule = !0;
    Nt.default = void 0;
    var Lh = Nh(Ee()), Ae = Fh(J());
    function bl() {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap;
        return bl = function() {
            return t;
        }, t;
    }
    function Fh(t) {
        if (t && t.__esModule) return t;
        if (t === null || typeof t != "object" && typeof t != "function") return {
            default: t
        };
        var e = bl();
        if (e && e.has(t)) return e.get(t);
        var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var i in t)if (Object.prototype.hasOwnProperty.call(t, i)) {
            var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
        }
        return r.default = t, e && e.set(t, r), r;
    }
    function Nh(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function qh(t, e) {
        var r;
        if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
            if (Array.isArray(t) || (r = $h(t)) || e && t && typeof t.length == "number") {
                r && (t = r);
                var n = 0;
                return function() {
                    return n >= t.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: t[n++]
                    };
                };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        return r = t[Symbol.iterator](), r.next.bind(r);
    }
    function $h(t, e) {
        if (!!t) {
            if (typeof t == "string") return wl(t, e);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
            if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return wl(t, e);
        }
    }
    function wl(t, e) {
        (e == null || e > t.length) && (e = t.length);
        for(var r = 0, n = new Array(e); r < e; r++)n[r] = t[r];
        return n;
    }
    function vl(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function Uh(t, e, r) {
        return e && vl(t.prototype, e), r && vl(t, r), t;
    }
    function jh(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, yi(t, e);
    }
    function yi(t, e) {
        return yi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, yi(t, e);
    }
    var zh = function(t) {
        jh(e, t);
        function e(n) {
            var i;
            return i = t.call(this, n) || this, i.nodes || (i.nodes = []), i;
        }
        var r = e.prototype;
        return r.append = function(i) {
            return i.parent = this, this.nodes.push(i), this;
        }, r.prepend = function(i) {
            return i.parent = this, this.nodes.unshift(i), this;
        }, r.at = function(i) {
            return this.nodes[i];
        }, r.index = function(i) {
            return typeof i == "number" ? i : this.nodes.indexOf(i);
        }, r.removeChild = function(i) {
            i = this.index(i), this.at(i).parent = void 0, this.nodes.splice(i, 1);
            var s;
            for(var a in this.indexes)s = this.indexes[a], s >= i && (this.indexes[a] = s - 1);
            return this;
        }, r.removeAll = function() {
            for(var i = qh(this.nodes), s; !(s = i()).done;){
                var a = s.value;
                a.parent = void 0;
            }
            return this.nodes = [], this;
        }, r.empty = function() {
            return this.removeAll();
        }, r.insertAfter = function(i, s) {
            s.parent = this;
            var a = this.index(i);
            this.nodes.splice(a + 1, 0, s), s.parent = this;
            var o;
            for(var l in this.indexes)o = this.indexes[l], a <= o && (this.indexes[l] = o + 1);
            return this;
        }, r.insertBefore = function(i, s) {
            s.parent = this;
            var a = this.index(i);
            this.nodes.splice(a, 0, s), s.parent = this;
            var o;
            for(var l in this.indexes)o = this.indexes[l], o <= a && (this.indexes[l] = o + 1);
            return this;
        }, r._findChildAtPosition = function(i, s) {
            var a = void 0;
            return this.each(function(o) {
                if (o.atPosition) {
                    var l = o.atPosition(i, s);
                    if (l) return a = l, !1;
                } else if (o.isAtPosition(i, s)) return a = o, !1;
            }), a;
        }, r.atPosition = function(i, s) {
            if (this.isAtPosition(i, s)) return this._findChildAtPosition(i, s) || this;
        }, r._inferEndPosition = function() {
            this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
        }, r.each = function(i) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
            var s = this.lastEach;
            if (this.indexes[s] = 0, !!this.length) {
                for(var a, o; this.indexes[s] < this.length && (a = this.indexes[s], o = i(this.at(a), a), o !== !1);)this.indexes[s] += 1;
                if (delete this.indexes[s], o === !1) return !1;
            }
        }, r.walk = function(i) {
            return this.each(function(s, a) {
                var o = i(s, a);
                if (o !== !1 && s.length && (o = s.walk(i)), o === !1) return !1;
            });
        }, r.walkAttributes = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.ATTRIBUTE) return i.call(s, a);
            });
        }, r.walkClasses = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.CLASS) return i.call(s, a);
            });
        }, r.walkCombinators = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.COMBINATOR) return i.call(s, a);
            });
        }, r.walkComments = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.COMMENT) return i.call(s, a);
            });
        }, r.walkIds = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.ID) return i.call(s, a);
            });
        }, r.walkNesting = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.NESTING) return i.call(s, a);
            });
        }, r.walkPseudos = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.PSEUDO) return i.call(s, a);
            });
        }, r.walkTags = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.TAG) return i.call(s, a);
            });
        }, r.walkUniversals = function(i) {
            var s = this;
            return this.walk(function(a) {
                if (a.type === Ae.UNIVERSAL) return i.call(s, a);
            });
        }, r.split = function(i) {
            var s = this, a = [];
            return this.reduce(function(o, l, u) {
                var f = i.call(s, l);
                return a.push(l), f ? (o.push(a), a = []) : u === s.length - 1 && o.push(a), o;
            }, []);
        }, r.map = function(i) {
            return this.nodes.map(i);
        }, r.reduce = function(i, s) {
            return this.nodes.reduce(i, s);
        }, r.every = function(i) {
            return this.nodes.every(i);
        }, r.some = function(i) {
            return this.nodes.some(i);
        }, r.filter = function(i) {
            return this.nodes.filter(i);
        }, r.sort = function(i) {
            return this.nodes.sort(i);
        }, r.toString = function() {
            return this.map(String).join("");
        }, Uh(e, [
            {
                key: "first",
                get: function() {
                    return this.at(0);
                }
            },
            {
                key: "last",
                get: function() {
                    return this.at(this.length - 1);
                }
            },
            {
                key: "length",
                get: function() {
                    return this.nodes.length;
                }
            }
        ]), e;
    }(Lh.default);
    Nt.default = zh;
    xl.exports = Nt.default;
});
var vi = S((qt, kl)=>{
    "use strict";
    qt.__esModule = !0;
    qt.default = void 0;
    var Vh = Bh(Br()), Wh = J();
    function Bh(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Sl(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function Gh(t, e, r) {
        return e && Sl(t.prototype, e), r && Sl(t, r), t;
    }
    function Yh(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, wi(t, e);
    }
    function wi(t, e) {
        return wi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, wi(t, e);
    }
    var Hh = function(t) {
        Yh(e, t);
        function e(n) {
            var i;
            return i = t.call(this, n) || this, i.type = Wh.ROOT, i;
        }
        var r = e.prototype;
        return r.toString = function() {
            var i = this.reduce(function(s, a) {
                return s.push(String(a)), s;
            }, []).join(",");
            return this.trailingComma ? i + "," : i;
        }, r.error = function(i, s) {
            return this._error ? this._error(i, s) : new Error(i);
        }, Gh(e, [
            {
                key: "errorGenerator",
                set: function(i) {
                    this._error = i;
                }
            }
        ]), e;
    }(Vh.default);
    qt.default = Hh;
    kl.exports = qt.default;
});
var xi = S(($t, Cl)=>{
    "use strict";
    $t.__esModule = !0;
    $t.default = void 0;
    var Qh = Xh(Br()), Jh = J();
    function Xh(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Kh(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, bi(t, e);
    }
    function bi(t, e) {
        return bi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, bi(t, e);
    }
    var Zh = function(t) {
        Kh(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = Jh.SELECTOR, n;
        }
        return e;
    }(Qh.default);
    $t.default = Zh;
    Cl.exports = $t.default;
});
var Gr = S((Ax, El)=>{
    "use strict";
    var em = {}, tm = em.hasOwnProperty, rm = function(e, r) {
        if (!e) return r;
        var n = {};
        for(var i in r)n[i] = tm.call(e, i) ? e[i] : r[i];
        return n;
    }, nm = /[ -,\.\/:-@\[-\^`\{-~]/, im = /[ -,\.\/:-@\[\]\^`\{-~]/, sm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Si = function t(e, r) {
        r = rm(r, t.options), r.quotes != "single" && r.quotes != "double" && (r.quotes = "single");
        for(var n = r.quotes == "double" ? '"' : "'", i = r.isIdentifier, s = e.charAt(0), a = "", o = 0, l = e.length; o < l;){
            var u = e.charAt(o++), f = u.charCodeAt(), p = void 0;
            if (f < 32 || f > 126) {
                if (f >= 55296 && f <= 56319 && o < l) {
                    var c = e.charCodeAt(o++);
                    (c & 64512) == 56320 ? f = ((f & 1023) << 10) + (c & 1023) + 65536 : o--;
                }
                p = "\\" + f.toString(16).toUpperCase() + " ";
            } else r.escapeEverything ? nm.test(u) ? p = "\\" + u : p = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u) ? p = "\\" + f.toString(16).toUpperCase() + " " : u == "\\" || !i && (u == '"' && n == u || u == "'" && n == u) || i && im.test(u) ? p = "\\" + u : p = u;
            a += p;
        }
        return i && (/^-[-\d]/.test(a) ? a = "\\-" + a.slice(1) : /\d/.test(s) && (a = "\\3" + s + " " + a.slice(1))), a = a.replace(sm, function(d, h, y) {
            return h && h.length % 2 ? d : (h || "") + y;
        }), !i && r.wrap ? n + a + n : a;
    };
    Si.options = {
        escapeEverything: !1,
        isIdentifier: !1,
        quotes: "single",
        wrap: !1
    };
    Si.version = "3.0.0";
    El.exports = Si;
});
var Ci = S((Ut, _l)=>{
    "use strict";
    Ut.__esModule = !0;
    Ut.default = void 0;
    var am = Ol(Gr()), om = Lt(), lm = Ol(Ee()), um = J();
    function Ol(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Al(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function fm(t, e, r) {
        return e && Al(t.prototype, e), r && Al(t, r), t;
    }
    function cm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, ki(t, e);
    }
    function ki(t, e) {
        return ki = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, ki(t, e);
    }
    var pm = function(t) {
        cm(e, t);
        function e(n) {
            var i;
            return i = t.call(this, n) || this, i.type = um.CLASS, i._constructed = !0, i;
        }
        var r = e.prototype;
        return r.valueToString = function() {
            return "." + t.prototype.valueToString.call(this);
        }, fm(e, [
            {
                key: "value",
                get: function() {
                    return this._value;
                },
                set: function(i) {
                    if (this._constructed) {
                        var s = (0, am.default)(i, {
                            isIdentifier: !0
                        });
                        s !== i ? ((0, om.ensureObject)(this, "raws"), this.raws.value = s) : this.raws && delete this.raws.value;
                    }
                    this._value = i;
                }
            }
        ]), e;
    }(lm.default);
    Ut.default = pm;
    _l.exports = Ut.default;
});
var Ai = S((jt, Tl)=>{
    "use strict";
    jt.__esModule = !0;
    jt.default = void 0;
    var dm = mm(Ee()), hm = J();
    function mm(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function gm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ei(t, e);
    }
    function Ei(t, e) {
        return Ei = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Ei(t, e);
    }
    var ym = function(t) {
        gm(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = hm.COMMENT, n;
        }
        return e;
    }(dm.default);
    jt.default = ym;
    Tl.exports = jt.default;
});
var _i = S((zt, Pl)=>{
    "use strict";
    zt.__esModule = !0;
    zt.default = void 0;
    var wm = bm(Ee()), vm = J();
    function bm(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function xm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Oi(t, e);
    }
    function Oi(t, e) {
        return Oi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Oi(t, e);
    }
    var Sm = function(t) {
        xm(e, t);
        function e(n) {
            var i;
            return i = t.call(this, n) || this, i.type = vm.ID, i;
        }
        var r = e.prototype;
        return r.valueToString = function() {
            return "#" + t.prototype.valueToString.call(this);
        }, e;
    }(wm.default);
    zt.default = Sm;
    Pl.exports = zt.default;
});
var Yr = S((Vt, Dl)=>{
    "use strict";
    Vt.__esModule = !0;
    Vt.default = void 0;
    var km = Il(Gr()), Cm = Lt(), Em = Il(Ee());
    function Il(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Rl(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function Am(t, e, r) {
        return e && Rl(t.prototype, e), r && Rl(t, r), t;
    }
    function Om(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ti(t, e);
    }
    function Ti(t, e) {
        return Ti = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Ti(t, e);
    }
    var _m = function(t) {
        Om(e, t);
        function e() {
            return t.apply(this, arguments) || this;
        }
        var r = e.prototype;
        return r.qualifiedName = function(i) {
            return this.namespace ? this.namespaceString + "|" + i : i;
        }, r.valueToString = function() {
            return this.qualifiedName(t.prototype.valueToString.call(this));
        }, Am(e, [
            {
                key: "namespace",
                get: function() {
                    return this._namespace;
                },
                set: function(i) {
                    if (i === !0 || i === "*" || i === "&") {
                        this._namespace = i, this.raws && delete this.raws.namespace;
                        return;
                    }
                    var s = (0, km.default)(i, {
                        isIdentifier: !0
                    });
                    this._namespace = i, s !== i ? ((0, Cm.ensureObject)(this, "raws"), this.raws.namespace = s) : this.raws && delete this.raws.namespace;
                }
            },
            {
                key: "ns",
                get: function() {
                    return this._namespace;
                },
                set: function(i) {
                    this.namespace = i;
                }
            },
            {
                key: "namespaceString",
                get: function() {
                    if (this.namespace) {
                        var i = this.stringifyProperty("namespace");
                        return i === !0 ? "" : i;
                    } else return "";
                }
            }
        ]), e;
    }(Em.default);
    Vt.default = _m;
    Dl.exports = Vt.default;
});
var Ri = S((Wt, Ml)=>{
    "use strict";
    Wt.__esModule = !0;
    Wt.default = void 0;
    var Tm = Rm(Yr()), Pm = J();
    function Rm(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Im(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Pi(t, e);
    }
    function Pi(t, e) {
        return Pi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Pi(t, e);
    }
    var Dm = function(t) {
        Im(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = Pm.TAG, n;
        }
        return e;
    }(Tm.default);
    Wt.default = Dm;
    Ml.exports = Wt.default;
});
var Di = S((Bt, Ll)=>{
    "use strict";
    Bt.__esModule = !0;
    Bt.default = void 0;
    var Mm = Fm(Ee()), Lm = J();
    function Fm(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Nm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ii(t, e);
    }
    function Ii(t, e) {
        return Ii = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Ii(t, e);
    }
    var qm = function(t) {
        Nm(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = Lm.STRING, n;
        }
        return e;
    }(Mm.default);
    Bt.default = qm;
    Ll.exports = Bt.default;
});
var Li = S((Gt, Fl)=>{
    "use strict";
    Gt.__esModule = !0;
    Gt.default = void 0;
    var $m = jm(Br()), Um = J();
    function jm(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function zm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Mi(t, e);
    }
    function Mi(t, e) {
        return Mi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Mi(t, e);
    }
    var Vm = function(t) {
        zm(e, t);
        function e(n) {
            var i;
            return i = t.call(this, n) || this, i.type = Um.PSEUDO, i;
        }
        var r = e.prototype;
        return r.toString = function() {
            var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [
                this.rawSpaceBefore,
                this.stringifyProperty("value"),
                i,
                this.rawSpaceAfter
            ].join("");
        }, e;
    }($m.default);
    Gt.default = Vm;
    Fl.exports = Gt.default;
});
var ql = S((Ox, Nl)=>{
    Nl.exports = Wm;
    function Wm(t, e) {
        if (Fi("noDeprecation")) return t;
        var r = !1;
        function n() {
            if (!r) {
                if (Fi("throwDeprecation")) throw new Error(e);
                Fi("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0;
            }
            return t.apply(this, arguments);
        }
        return n;
    }
    function Fi(t) {
        try {
            if (!global.localStorage) return !1;
        } catch  {
            return !1;
        }
        var e = global.localStorage[t];
        return e == null ? !1 : String(e).toLowerCase() === "true";
    }
});
var zi = S((Qt)=>{
    "use strict";
    Qt.__esModule = !0;
    Qt.unescapeValue = ji;
    Qt.default = void 0;
    var Yt = Ui(Gr()), Bm = Ui(Ur()), Gm = Ui(Yr()), Ym = J(), Ni;
    function Ui(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function $l(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function Hm(t, e, r) {
        return e && $l(t.prototype, e), r && $l(t, r), t;
    }
    function Qm(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, $i(t, e);
    }
    function $i(t, e) {
        return $i = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, $i(t, e);
    }
    var Ht = ql(), Jm = /^('|")([^]*)\1$/, Xm = Ht(function() {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Km = Ht(function() {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Zm = Ht(function() {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function ji(t) {
        var e = !1, r = null, n = t, i = n.match(Jm);
        return i && (r = i[1], n = i[2]), n = (0, Bm.default)(n), n !== t && (e = !0), {
            deprecatedUsage: e,
            unescaped: n,
            quoteMark: r
        };
    }
    function eg(t) {
        if (t.quoteMark !== void 0 || t.value === void 0) return t;
        Zm();
        var e = ji(t.value), r = e.quoteMark, n = e.unescaped;
        return t.raws || (t.raws = {}), t.raws.value === void 0 && (t.raws.value = t.value), t.value = n, t.quoteMark = r, t;
    }
    var Hr = function(t) {
        Qm(e, t);
        function e(n) {
            var i;
            return n === void 0 && (n = {}), i = t.call(this, eg(n)) || this, i.type = Ym.ATTRIBUTE, i.raws = i.raws || {}, Object.defineProperty(i.raws, "unquoted", {
                get: Ht(function() {
                    return i.value;
                }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
                set: Ht(function() {
                    return i.value;
                }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
            }), i._constructed = !0, i;
        }
        var r = e.prototype;
        return r.getQuotedValue = function(i) {
            i === void 0 && (i = {});
            var s = this._determineQuoteMark(i), a = qi[s], o = (0, Yt.default)(this._value, a);
            return o;
        }, r._determineQuoteMark = function(i) {
            return i.smart ? this.smartQuoteMark(i) : this.preferredQuoteMark(i);
        }, r.setValue = function(i, s) {
            s === void 0 && (s = {}), this._value = i, this._quoteMark = this._determineQuoteMark(s), this._syncRawValue();
        }, r.smartQuoteMark = function(i) {
            var s = this.value, a = s.replace(/[^']/g, "").length, o = s.replace(/[^"]/g, "").length;
            if (a + o === 0) {
                var l = (0, Yt.default)(s, {
                    isIdentifier: !0
                });
                if (l === s) return e.NO_QUOTE;
                var u = this.preferredQuoteMark(i);
                if (u === e.NO_QUOTE) {
                    var f = this.quoteMark || i.quoteMark || e.DOUBLE_QUOTE, p = qi[f], c = (0, Yt.default)(s, p);
                    if (c.length < l.length) return f;
                }
                return u;
            } else return o === a ? this.preferredQuoteMark(i) : o < a ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE;
        }, r.preferredQuoteMark = function(i) {
            var s = i.preferCurrentQuoteMark ? this.quoteMark : i.quoteMark;
            return s === void 0 && (s = i.preferCurrentQuoteMark ? i.quoteMark : this.quoteMark), s === void 0 && (s = e.DOUBLE_QUOTE), s;
        }, r._syncRawValue = function() {
            var i = (0, Yt.default)(this._value, qi[this.quoteMark]);
            i === this._value ? this.raws && delete this.raws.value : this.raws.value = i;
        }, r._handleEscapes = function(i, s) {
            if (this._constructed) {
                var a = (0, Yt.default)(s, {
                    isIdentifier: !0
                });
                a !== s ? this.raws[i] = a : delete this.raws[i];
            }
        }, r._spacesFor = function(i) {
            var s = {
                before: "",
                after: ""
            }, a = this.spaces[i] || {}, o = this.raws.spaces && this.raws.spaces[i] || {};
            return Object.assign(s, a, o);
        }, r._stringFor = function(i, s, a) {
            s === void 0 && (s = i), a === void 0 && (a = Ul);
            var o = this._spacesFor(s);
            return a(this.stringifyProperty(i), o);
        }, r.offsetOf = function(i) {
            var s = 1, a = this._spacesFor("attribute");
            if (s += a.before.length, i === "namespace" || i === "ns") return this.namespace ? s : -1;
            if (i === "attributeNS" || (s += this.namespaceString.length, this.namespace && (s += 1), i === "attribute")) return s;
            s += this.stringifyProperty("attribute").length, s += a.after.length;
            var o = this._spacesFor("operator");
            s += o.before.length;
            var l = this.stringifyProperty("operator");
            if (i === "operator") return l ? s : -1;
            s += l.length, s += o.after.length;
            var u = this._spacesFor("value");
            s += u.before.length;
            var f = this.stringifyProperty("value");
            if (i === "value") return f ? s : -1;
            s += f.length, s += u.after.length;
            var p = this._spacesFor("insensitive");
            return s += p.before.length, i === "insensitive" && this.insensitive ? s : -1;
        }, r.toString = function() {
            var i = this, s = [
                this.rawSpaceBefore,
                "["
            ];
            return s.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (s.push(this._stringFor("operator")), s.push(this._stringFor("value")), s.push(this._stringFor("insensitiveFlag", "insensitive", function(a, o) {
                return a.length > 0 && !i.quoted && o.before.length === 0 && !(i.spaces.value && i.spaces.value.after) && (o.before = " "), Ul(a, o);
            }))), s.push("]"), s.push(this.rawSpaceAfter), s.join("");
        }, Hm(e, [
            {
                key: "quoted",
                get: function() {
                    var i = this.quoteMark;
                    return i === "'" || i === '"';
                },
                set: function(i) {
                    Km();
                }
            },
            {
                key: "quoteMark",
                get: function() {
                    return this._quoteMark;
                },
                set: function(i) {
                    if (!this._constructed) {
                        this._quoteMark = i;
                        return;
                    }
                    this._quoteMark !== i && (this._quoteMark = i, this._syncRawValue());
                }
            },
            {
                key: "qualifiedAttribute",
                get: function() {
                    return this.qualifiedName(this.raws.attribute || this.attribute);
                }
            },
            {
                key: "insensitiveFlag",
                get: function() {
                    return this.insensitive ? "i" : "";
                }
            },
            {
                key: "value",
                get: function() {
                    return this._value;
                },
                set: function(i) {
                    if (this._constructed) {
                        var s = ji(i), a = s.deprecatedUsage, o = s.unescaped, l = s.quoteMark;
                        if (a && Xm(), o === this._value && l === this._quoteMark) return;
                        this._value = o, this._quoteMark = l, this._syncRawValue();
                    } else this._value = i;
                }
            },
            {
                key: "insensitive",
                get: function() {
                    return this._insensitive;
                },
                set: function(i) {
                    i || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = i;
                }
            },
            {
                key: "attribute",
                get: function() {
                    return this._attribute;
                },
                set: function(i) {
                    this._handleEscapes("attribute", i), this._attribute = i;
                }
            }
        ]), e;
    }(Gm.default);
    Qt.default = Hr;
    Hr.NO_QUOTE = null;
    Hr.SINGLE_QUOTE = "'";
    Hr.DOUBLE_QUOTE = '"';
    var qi = (Ni = {
        "'": {
            quotes: "single",
            wrap: !0
        },
        '"': {
            quotes: "double",
            wrap: !0
        }
    }, Ni[null] = {
        isIdentifier: !0
    }, Ni);
    function Ul(t, e) {
        return "" + e.before + t + e.after;
    }
});
var Wi = S((Jt, jl)=>{
    "use strict";
    Jt.__esModule = !0;
    Jt.default = void 0;
    var tg = ng(Yr()), rg = J();
    function ng(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function ig(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Vi(t, e);
    }
    function Vi(t, e) {
        return Vi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Vi(t, e);
    }
    var sg = function(t) {
        ig(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = rg.UNIVERSAL, n.value = "*", n;
        }
        return e;
    }(tg.default);
    Jt.default = sg;
    jl.exports = Jt.default;
});
var Gi = S((Xt, zl)=>{
    "use strict";
    Xt.__esModule = !0;
    Xt.default = void 0;
    var ag = lg(Ee()), og = J();
    function lg(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function ug(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Bi(t, e);
    }
    function Bi(t, e) {
        return Bi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Bi(t, e);
    }
    var fg = function(t) {
        ug(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = og.COMBINATOR, n;
        }
        return e;
    }(ag.default);
    Xt.default = fg;
    zl.exports = Xt.default;
});
var Hi = S((Kt, Vl)=>{
    "use strict";
    Kt.__esModule = !0;
    Kt.default = void 0;
    var cg = dg(Ee()), pg = J();
    function dg(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function hg(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Yi(t, e);
    }
    function Yi(t, e) {
        return Yi = Object.setPrototypeOf || function(n, i) {
            return n.__proto__ = i, n;
        }, Yi(t, e);
    }
    var mg = function(t) {
        hg(e, t);
        function e(r) {
            var n;
            return n = t.call(this, r) || this, n.type = pg.NESTING, n.value = "&", n;
        }
        return e;
    }(cg.default);
    Kt.default = mg;
    Vl.exports = Kt.default;
});
var Bl = S((Qr, Wl)=>{
    "use strict";
    Qr.__esModule = !0;
    Qr.default = gg;
    function gg(t) {
        return t.sort(function(e, r) {
            return e - r;
        });
    }
    Wl.exports = Qr.default;
});
var Qi = S((P)=>{
    "use strict";
    P.__esModule = !0;
    P.combinator = P.word = P.comment = P.str = P.tab = P.newline = P.feed = P.cr = P.backslash = P.bang = P.slash = P.doubleQuote = P.singleQuote = P.space = P.greaterThan = P.pipe = P.equals = P.plus = P.caret = P.tilde = P.dollar = P.closeSquare = P.openSquare = P.closeParenthesis = P.openParenthesis = P.semicolon = P.colon = P.comma = P.at = P.asterisk = P.ampersand = void 0;
    var yg = 38;
    P.ampersand = yg;
    var wg = 42;
    P.asterisk = wg;
    var vg = 64;
    P.at = vg;
    var bg = 44;
    P.comma = bg;
    var xg = 58;
    P.colon = xg;
    var Sg = 59;
    P.semicolon = Sg;
    var kg = 40;
    P.openParenthesis = kg;
    var Cg = 41;
    P.closeParenthesis = Cg;
    var Eg = 91;
    P.openSquare = Eg;
    var Ag = 93;
    P.closeSquare = Ag;
    var Og = 36;
    P.dollar = Og;
    var _g = 126;
    P.tilde = _g;
    var Tg = 94;
    P.caret = Tg;
    var Pg = 43;
    P.plus = Pg;
    var Rg = 61;
    P.equals = Rg;
    var Ig = 124;
    P.pipe = Ig;
    var Dg = 62;
    P.greaterThan = Dg;
    var Mg = 32;
    P.space = Mg;
    var Gl = 39;
    P.singleQuote = Gl;
    var Lg = 34;
    P.doubleQuote = Lg;
    var Fg = 47;
    P.slash = Fg;
    var Ng = 33;
    P.bang = Ng;
    var qg = 92;
    P.backslash = qg;
    var $g = 13;
    P.cr = $g;
    var Ug = 12;
    P.feed = Ug;
    var jg = 10;
    P.newline = jg;
    var zg = 9;
    P.tab = zg;
    var Vg = Gl;
    P.str = Vg;
    var Wg = -1;
    P.comment = Wg;
    var Bg = -2;
    P.word = Bg;
    var Gg = -3;
    P.combinator = Gg;
});
var Ql = S((Zt)=>{
    "use strict";
    Zt.__esModule = !0;
    Zt.default = Zg;
    Zt.FIELDS = void 0;
    var A = Yg(Qi()), tt, q;
    function Hl() {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap;
        return Hl = function() {
            return t;
        }, t;
    }
    function Yg(t) {
        if (t && t.__esModule) return t;
        if (t === null || typeof t != "object" && typeof t != "function") return {
            default: t
        };
        var e = Hl();
        if (e && e.has(t)) return e.get(t);
        var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var i in t)if (Object.prototype.hasOwnProperty.call(t, i)) {
            var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
        }
        return r.default = t, e && e.set(t, r), r;
    }
    var Hg = (tt = {}, tt[A.tab] = !0, tt[A.newline] = !0, tt[A.cr] = !0, tt[A.feed] = !0, tt), Qg = (q = {}, q[A.space] = !0, q[A.tab] = !0, q[A.newline] = !0, q[A.cr] = !0, q[A.feed] = !0, q[A.ampersand] = !0, q[A.asterisk] = !0, q[A.bang] = !0, q[A.comma] = !0, q[A.colon] = !0, q[A.semicolon] = !0, q[A.openParenthesis] = !0, q[A.closeParenthesis] = !0, q[A.openSquare] = !0, q[A.closeSquare] = !0, q[A.singleQuote] = !0, q[A.doubleQuote] = !0, q[A.plus] = !0, q[A.pipe] = !0, q[A.tilde] = !0, q[A.greaterThan] = !0, q[A.equals] = !0, q[A.dollar] = !0, q[A.caret] = !0, q[A.slash] = !0, q), Ji = {}, Yl = "0123456789abcdefABCDEF";
    for(Jr = 0; Jr < Yl.length; Jr++)Ji[Yl.charCodeAt(Jr)] = !0;
    var Jr;
    function Jg(t, e) {
        var r = e, n;
        do {
            if (n = t.charCodeAt(r), Qg[n]) return r - 1;
            n === A.backslash ? r = Xg(t, r) + 1 : r++;
        }while (r < t.length);
        return r - 1;
    }
    function Xg(t, e) {
        var r = e, n = t.charCodeAt(r + 1);
        if (!Hg[n]) if (Ji[n]) {
            var i = 0;
            do r++, i++, n = t.charCodeAt(r + 1);
            while (Ji[n] && i < 6);
            i < 6 && n === A.space && r++;
        } else r++;
        return r;
    }
    var Kg = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
    };
    Zt.FIELDS = Kg;
    function Zg(t) {
        var e = [], r = t.css.valueOf(), n = r, i = n.length, s = -1, a = 1, o = 0, l = 0, u, f, p, c, d, h, y, m, g, w, b, v, C;
        function x(O, E) {
            if (t.safe) r += E, g = r.length - 1;
            else throw t.error("Unclosed " + O, a, o - s, o);
        }
        for(; o < i;){
            switch(u = r.charCodeAt(o), u === A.newline && (s = o, a += 1), u){
                case A.space:
                case A.tab:
                case A.newline:
                case A.cr:
                case A.feed:
                    g = o;
                    do g += 1, u = r.charCodeAt(g), u === A.newline && (s = g, a += 1);
                    while (u === A.space || u === A.newline || u === A.tab || u === A.cr || u === A.feed);
                    C = A.space, c = a, p = g - s - 1, l = g;
                    break;
                case A.plus:
                case A.greaterThan:
                case A.tilde:
                case A.pipe:
                    g = o;
                    do g += 1, u = r.charCodeAt(g);
                    while (u === A.plus || u === A.greaterThan || u === A.tilde || u === A.pipe);
                    C = A.combinator, c = a, p = o - s, l = g;
                    break;
                case A.asterisk:
                case A.ampersand:
                case A.bang:
                case A.comma:
                case A.equals:
                case A.dollar:
                case A.caret:
                case A.openSquare:
                case A.closeSquare:
                case A.colon:
                case A.semicolon:
                case A.openParenthesis:
                case A.closeParenthesis:
                    g = o, C = u, c = a, p = o - s, l = g + 1;
                    break;
                case A.singleQuote:
                case A.doubleQuote:
                    v = u === A.singleQuote ? "'" : '"', g = o;
                    do for(d = !1, g = r.indexOf(v, g + 1), g === -1 && x("quote", v), h = g; r.charCodeAt(h - 1) === A.backslash;)h -= 1, d = !d;
                    while (d);
                    C = A.str, c = a, p = o - s, l = g + 1;
                    break;
                default:
                    u === A.slash && r.charCodeAt(o + 1) === A.asterisk ? (g = r.indexOf("*/", o + 2) + 1, g === 0 && x("comment", "*/"), f = r.slice(o, g + 1), m = f.split(`
`), y = m.length - 1, y > 0 ? (w = a + y, b = g - m[y].length) : (w = a, b = s), C = A.comment, a = w, c = w, p = g - b) : u === A.slash ? (g = o, C = u, c = a, p = o - s, l = g + 1) : (g = Jg(r, o), C = A.word, c = a, p = g - s), l = g + 1;
                    break;
            }
            e.push([
                C,
                a,
                o - s,
                c,
                p,
                o,
                l
            ]), b && (s = b, b = null), o = l;
        }
        return e;
    }
});
var nu = S((er, ru)=>{
    "use strict";
    er.__esModule = !0;
    er.default = void 0;
    var ey = le(vi()), Xi = le(xi()), ty = le(Ci()), Jl = le(Ai()), ry = le(_i()), ny = le(Ri()), Ki = le(Di()), iy = le(Li()), Xl = Xr(zi()), sy = le(Wi()), Zi = le(Gi()), ay = le(Hi()), oy = le(Bl()), k = Xr(Ql()), _ = Xr(Qi()), ly = Xr(J()), V = Lt(), Ve, es;
    function tu() {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap;
        return tu = function() {
            return t;
        }, t;
    }
    function Xr(t) {
        if (t && t.__esModule) return t;
        if (t === null || typeof t != "object" && typeof t != "function") return {
            default: t
        };
        var e = tu();
        if (e && e.has(t)) return e.get(t);
        var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var i in t)if (Object.prototype.hasOwnProperty.call(t, i)) {
            var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
        }
        return r.default = t, e && e.set(t, r), r;
    }
    function le(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    function Kl(t, e) {
        for(var r = 0; r < e.length; r++){
            var n = e[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
        }
    }
    function uy(t, e, r) {
        return e && Kl(t.prototype, e), r && Kl(t, r), t;
    }
    var ns = (Ve = {}, Ve[_.space] = !0, Ve[_.cr] = !0, Ve[_.feed] = !0, Ve[_.newline] = !0, Ve[_.tab] = !0, Ve), fy = Object.assign({}, ns, (es = {}, es[_.comment] = !0, es));
    function Zl(t) {
        return {
            line: t[k.FIELDS.START_LINE],
            column: t[k.FIELDS.START_COL]
        };
    }
    function eu(t) {
        return {
            line: t[k.FIELDS.END_LINE],
            column: t[k.FIELDS.END_COL]
        };
    }
    function We(t, e, r, n) {
        return {
            start: {
                line: t,
                column: e
            },
            end: {
                line: r,
                column: n
            }
        };
    }
    function rt(t) {
        return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], t[k.FIELDS.END_LINE], t[k.FIELDS.END_COL]);
    }
    function ts(t, e) {
        if (!!t) return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], e[k.FIELDS.END_LINE], e[k.FIELDS.END_COL]);
    }
    function nt(t, e) {
        var r = t[e];
        if (typeof r == "string") return r.indexOf("\\") !== -1 && ((0, V.ensureObject)(t, "raws"), t[e] = (0, V.unesc)(r), t.raws[e] === void 0 && (t.raws[e] = r)), t;
    }
    function rs(t, e) {
        for(var r = -1, n = []; (r = t.indexOf(e, r + 1)) !== -1;)n.push(r);
        return n;
    }
    function cy() {
        var t = Array.prototype.concat.apply([], arguments);
        return t.filter(function(e, r) {
            return r === t.indexOf(e);
        });
    }
    var py = function() {
        function t(r, n) {
            n === void 0 && (n = {}), this.rule = r, this.options = Object.assign({
                lossy: !1,
                safe: !1
            }, n), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k.default)({
                css: this.css,
                error: this._errorGenerator(),
                safe: this.options.safe
            });
            var i = ts(this.tokens[0], this.tokens[this.tokens.length - 1]);
            this.root = new ey.default({
                source: i
            }), this.root.errorGenerator = this._errorGenerator();
            var s = new Xi.default({
                source: {
                    start: {
                        line: 1,
                        column: 1
                    }
                }
            });
            this.root.append(s), this.current = s, this.loop();
        }
        var e = t.prototype;
        return e._errorGenerator = function() {
            var n = this;
            return function(i, s) {
                return typeof n.rule == "string" ? new Error(i) : n.rule.error(i, s);
            };
        }, e.attribute = function() {
            var n = [], i = this.currToken;
            for(this.position++; this.position < this.tokens.length && this.currToken[k.FIELDS.TYPE] !== _.closeSquare;)n.push(this.currToken), this.position++;
            if (this.currToken[k.FIELDS.TYPE] !== _.closeSquare) return this.expected("closing square bracket", this.currToken[k.FIELDS.START_POS]);
            var s = n.length, a = {
                source: We(i[1], i[2], this.currToken[3], this.currToken[4]),
                sourceIndex: i[k.FIELDS.START_POS]
            };
            if (s === 1 && !~[
                _.word
            ].indexOf(n[0][k.FIELDS.TYPE])) return this.expected("attribute", n[0][k.FIELDS.START_POS]);
            for(var o = 0, l = "", u = "", f = null, p = !1; o < s;){
                var c = n[o], d = this.content(c), h = n[o + 1];
                switch(c[k.FIELDS.TYPE]){
                    case _.space:
                        if (p = !0, this.options.lossy) break;
                        if (f) {
                            (0, V.ensureObject)(a, "spaces", f);
                            var y = a.spaces[f].after || "";
                            a.spaces[f].after = y + d;
                            var m = (0, V.getProp)(a, "raws", "spaces", f, "after") || null;
                            m && (a.raws.spaces[f].after = m + d);
                        } else l = l + d, u = u + d;
                        break;
                    case _.asterisk:
                        if (h[k.FIELDS.TYPE] === _.equals) a.operator = d, f = "operator";
                        else if ((!a.namespace || f === "namespace" && !p) && h) {
                            l && ((0, V.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = l, u = ""), a.namespace = (a.namespace || "") + d;
                            var g = (0, V.getProp)(a, "raws", "namespace") || null;
                            g && (a.raws.namespace += d), f = "namespace";
                        }
                        p = !1;
                        break;
                    case _.dollar:
                        if (f === "value") {
                            var w = (0, V.getProp)(a, "raws", "value");
                            a.value += "$", w && (a.raws.value = w + "$");
                            break;
                        }
                    case _.caret:
                        h[k.FIELDS.TYPE] === _.equals && (a.operator = d, f = "operator"), p = !1;
                        break;
                    case _.combinator:
                        if (d === "~" && h[k.FIELDS.TYPE] === _.equals && (a.operator = d, f = "operator"), d !== "|") {
                            p = !1;
                            break;
                        }
                        h[k.FIELDS.TYPE] === _.equals ? (a.operator = d, f = "operator") : !a.namespace && !a.attribute && (a.namespace = !0), p = !1;
                        break;
                    case _.word:
                        if (h && this.content(h) === "|" && n[o + 2] && n[o + 2][k.FIELDS.TYPE] !== _.equals && !a.operator && !a.namespace) a.namespace = d, f = "namespace";
                        else if (!a.attribute || f === "attribute" && !p) {
                            l && ((0, V.ensureObject)(a, "spaces", "attribute"), a.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(a, "raws", "spaces", "attribute"), a.raws.spaces.attribute.before = u, u = ""), a.attribute = (a.attribute || "") + d;
                            var b = (0, V.getProp)(a, "raws", "attribute") || null;
                            b && (a.raws.attribute += d), f = "attribute";
                        } else if (!a.value && a.value !== "" || f === "value" && !(p || a.quoteMark)) {
                            var v = (0, V.unesc)(d), C = (0, V.getProp)(a, "raws", "value") || "", x = a.value || "";
                            a.value = x + v, a.quoteMark = null, (v !== d || C) && ((0, V.ensureObject)(a, "raws"), a.raws.value = (C || x) + d), f = "value";
                        } else {
                            var O = d === "i" || d === "I";
                            (a.value || a.value === "") && (a.quoteMark || p) ? (a.insensitive = O, (!O || d === "I") && ((0, V.ensureObject)(a, "raws"), a.raws.insensitiveFlag = d), f = "insensitive", l && ((0, V.ensureObject)(a, "spaces", "insensitive"), a.spaces.insensitive.before = l, l = ""), u && ((0, V.ensureObject)(a, "raws", "spaces", "insensitive"), a.raws.spaces.insensitive.before = u, u = "")) : (a.value || a.value === "") && (f = "value", a.value += d, a.raws.value && (a.raws.value += d));
                        }
                        p = !1;
                        break;
                    case _.str:
                        if (!a.attribute || !a.operator) return this.error("Expected an attribute followed by an operator preceding the string.", {
                            index: c[k.FIELDS.START_POS]
                        });
                        var E = (0, Xl.unescapeValue)(d), R = E.unescaped, L = E.quoteMark;
                        a.value = R, a.quoteMark = L, f = "value", (0, V.ensureObject)(a, "raws"), a.raws.value = d, p = !1;
                        break;
                    case _.equals:
                        if (!a.attribute) return this.expected("attribute", c[k.FIELDS.START_POS], d);
                        if (a.value) return this.error('Unexpected "=" found; an operator was already defined.', {
                            index: c[k.FIELDS.START_POS]
                        });
                        a.operator = a.operator ? a.operator + d : d, f = "operator", p = !1;
                        break;
                    case _.comment:
                        if (f) if (p || h && h[k.FIELDS.TYPE] === _.space || f === "insensitive") {
                            var B = (0, V.getProp)(a, "spaces", f, "after") || "", Q = (0, V.getProp)(a, "raws", "spaces", f, "after") || B;
                            (0, V.ensureObject)(a, "raws", "spaces", f), a.raws.spaces[f].after = Q + d;
                        } else {
                            var K = a[f] || "", $e = (0, V.getProp)(a, "raws", f) || K;
                            (0, V.ensureObject)(a, "raws"), a.raws[f] = $e + d;
                        }
                        else u = u + d;
                        break;
                    default:
                        return this.error('Unexpected "' + d + '" found.', {
                            index: c[k.FIELDS.START_POS]
                        });
                }
                o++;
            }
            nt(a, "attribute"), nt(a, "namespace"), this.newNode(new Xl.default(a)), this.position++;
        }, e.parseWhitespaceEquivalentTokens = function(n) {
            n < 0 && (n = this.tokens.length);
            var i = this.position, s = [], a = "", o = void 0;
            do if (ns[this.currToken[k.FIELDS.TYPE]]) this.options.lossy || (a += this.content());
            else if (this.currToken[k.FIELDS.TYPE] === _.comment) {
                var l = {};
                a && (l.before = a, a = ""), o = new Jl.default({
                    value: this.content(),
                    source: rt(this.currToken),
                    sourceIndex: this.currToken[k.FIELDS.START_POS],
                    spaces: l
                }), s.push(o);
            }
            while (++this.position < n);
            if (a) {
                if (o) o.spaces.after = a;
                else if (!this.options.lossy) {
                    var u = this.tokens[i], f = this.tokens[this.position - 1];
                    s.push(new Ki.default({
                        value: "",
                        source: We(u[k.FIELDS.START_LINE], u[k.FIELDS.START_COL], f[k.FIELDS.END_LINE], f[k.FIELDS.END_COL]),
                        sourceIndex: u[k.FIELDS.START_POS],
                        spaces: {
                            before: a,
                            after: ""
                        }
                    }));
                }
            }
            return s;
        }, e.convertWhitespaceNodesToSpace = function(n, i) {
            var s = this;
            i === void 0 && (i = !1);
            var a = "", o = "";
            n.forEach(function(u) {
                var f = s.lossySpace(u.spaces.before, i), p = s.lossySpace(u.rawSpaceBefore, i);
                a += f + s.lossySpace(u.spaces.after, i && f.length === 0), o += f + u.value + s.lossySpace(u.rawSpaceAfter, i && p.length === 0);
            }), o === a && (o = void 0);
            var l = {
                space: a,
                rawSpace: o
            };
            return l;
        }, e.isNamedCombinator = function(n) {
            return n === void 0 && (n = this.position), this.tokens[n + 0] && this.tokens[n + 0][k.FIELDS.TYPE] === _.slash && this.tokens[n + 1] && this.tokens[n + 1][k.FIELDS.TYPE] === _.word && this.tokens[n + 2] && this.tokens[n + 2][k.FIELDS.TYPE] === _.slash;
        }, e.namedCombinator = function() {
            if (this.isNamedCombinator()) {
                var n = this.content(this.tokens[this.position + 1]), i = (0, V.unesc)(n).toLowerCase(), s = {};
                i !== n && (s.value = "/" + n + "/");
                var a = new Zi.default({
                    value: "/" + i + "/",
                    source: We(this.currToken[k.FIELDS.START_LINE], this.currToken[k.FIELDS.START_COL], this.tokens[this.position + 2][k.FIELDS.END_LINE], this.tokens[this.position + 2][k.FIELDS.END_COL]),
                    sourceIndex: this.currToken[k.FIELDS.START_POS],
                    raws: s
                });
                return this.position = this.position + 3, a;
            } else this.unexpected();
        }, e.combinator = function() {
            var n = this;
            if (this.content() === "|") return this.namespace();
            var i = this.locateNextMeaningfulToken(this.position);
            if (i < 0 || this.tokens[i][k.FIELDS.TYPE] === _.comma) {
                var s = this.parseWhitespaceEquivalentTokens(i);
                if (s.length > 0) {
                    var a = this.current.last;
                    if (a) {
                        var o = this.convertWhitespaceNodesToSpace(s), l = o.space, u = o.rawSpace;
                        u !== void 0 && (a.rawSpaceAfter += u), a.spaces.after += l;
                    } else s.forEach(function(C) {
                        return n.newNode(C);
                    });
                }
                return;
            }
            var f = this.currToken, p = void 0;
            i > this.position && (p = this.parseWhitespaceEquivalentTokens(i));
            var c;
            if (this.isNamedCombinator() ? c = this.namedCombinator() : this.currToken[k.FIELDS.TYPE] === _.combinator ? (c = new Zi.default({
                value: this.content(),
                source: rt(this.currToken),
                sourceIndex: this.currToken[k.FIELDS.START_POS]
            }), this.position++) : ns[this.currToken[k.FIELDS.TYPE]] || p || this.unexpected(), c) {
                if (p) {
                    var d = this.convertWhitespaceNodesToSpace(p), h = d.space, y = d.rawSpace;
                    c.spaces.before = h, c.rawSpaceBefore = y;
                }
            } else {
                var m = this.convertWhitespaceNodesToSpace(p, !0), g = m.space, w = m.rawSpace;
                w || (w = g);
                var b = {}, v = {
                    spaces: {}
                };
                g.endsWith(" ") && w.endsWith(" ") ? (b.before = g.slice(0, g.length - 1), v.spaces.before = w.slice(0, w.length - 1)) : g.startsWith(" ") && w.startsWith(" ") ? (b.after = g.slice(1), v.spaces.after = w.slice(1)) : v.value = w, c = new Zi.default({
                    value: " ",
                    source: ts(f, this.tokens[this.position - 1]),
                    sourceIndex: f[k.FIELDS.START_POS],
                    spaces: b,
                    raws: v
                });
            }
            return this.currToken && this.currToken[k.FIELDS.TYPE] === _.space && (c.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c);
        }, e.comma = function() {
            if (this.position === this.tokens.length - 1) {
                this.root.trailingComma = !0, this.position++;
                return;
            }
            this.current._inferEndPosition();
            var n = new Xi.default({
                source: {
                    start: Zl(this.tokens[this.position + 1])
                }
            });
            this.current.parent.append(n), this.current = n, this.position++;
        }, e.comment = function() {
            var n = this.currToken;
            this.newNode(new Jl.default({
                value: this.content(),
                source: rt(n),
                sourceIndex: n[k.FIELDS.START_POS]
            })), this.position++;
        }, e.error = function(n, i) {
            throw this.root.error(n, i);
        }, e.missingBackslash = function() {
            return this.error("Expected a backslash preceding the semicolon.", {
                index: this.currToken[k.FIELDS.START_POS]
            });
        }, e.missingParenthesis = function() {
            return this.expected("opening parenthesis", this.currToken[k.FIELDS.START_POS]);
        }, e.missingSquareBracket = function() {
            return this.expected("opening square bracket", this.currToken[k.FIELDS.START_POS]);
        }, e.unexpected = function() {
            return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k.FIELDS.START_POS]);
        }, e.namespace = function() {
            var n = this.prevToken && this.content(this.prevToken) || !0;
            if (this.nextToken[k.FIELDS.TYPE] === _.word) return this.position++, this.word(n);
            if (this.nextToken[k.FIELDS.TYPE] === _.asterisk) return this.position++, this.universal(n);
        }, e.nesting = function() {
            if (this.nextToken) {
                var n = this.content(this.nextToken);
                if (n === "|") {
                    this.position++;
                    return;
                }
            }
            var i = this.currToken;
            this.newNode(new ay.default({
                value: this.content(),
                source: rt(i),
                sourceIndex: i[k.FIELDS.START_POS]
            })), this.position++;
        }, e.parentheses = function() {
            var n = this.current.last, i = 1;
            if (this.position++, n && n.type === ly.PSEUDO) {
                var s = new Xi.default({
                    source: {
                        start: Zl(this.tokens[this.position - 1])
                    }
                }), a = this.current;
                for(n.append(s), this.current = s; this.position < this.tokens.length && i;)this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, i ? this.parse() : (this.current.source.end = eu(this.currToken), this.current.parent.source.end = eu(this.currToken), this.position++);
                this.current = a;
            } else {
                for(var o = this.currToken, l = "(", u; this.position < this.tokens.length && i;)this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, u = this.currToken, l += this.parseParenthesisToken(this.currToken), this.position++;
                n ? n.appendToPropertyAndEscape("value", l, l) : this.newNode(new Ki.default({
                    value: l,
                    source: We(o[k.FIELDS.START_LINE], o[k.FIELDS.START_COL], u[k.FIELDS.END_LINE], u[k.FIELDS.END_COL]),
                    sourceIndex: o[k.FIELDS.START_POS]
                }));
            }
            if (i) return this.expected("closing parenthesis", this.currToken[k.FIELDS.START_POS]);
        }, e.pseudo = function() {
            for(var n = this, i = "", s = this.currToken; this.currToken && this.currToken[k.FIELDS.TYPE] === _.colon;)i += this.content(), this.position++;
            if (!this.currToken) return this.expected([
                "pseudo-class",
                "pseudo-element"
            ], this.position - 1);
            if (this.currToken[k.FIELDS.TYPE] === _.word) this.splitWord(!1, function(a, o) {
                i += a, n.newNode(new iy.default({
                    value: i,
                    source: ts(s, n.currToken),
                    sourceIndex: s[k.FIELDS.START_POS]
                })), o > 1 && n.nextToken && n.nextToken[k.FIELDS.TYPE] === _.openParenthesis && n.error("Misplaced parenthesis.", {
                    index: n.nextToken[k.FIELDS.START_POS]
                });
            });
            else return this.expected([
                "pseudo-class",
                "pseudo-element"
            ], this.currToken[k.FIELDS.START_POS]);
        }, e.space = function() {
            var n = this.content();
            this.position === 0 || this.prevToken[k.FIELDS.TYPE] === _.comma || this.prevToken[k.FIELDS.TYPE] === _.openParenthesis || this.current.nodes.every(function(i) {
                return i.type === "comment";
            }) ? (this.spaces = this.optionalSpace(n), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k.FIELDS.TYPE] === _.comma || this.nextToken[k.FIELDS.TYPE] === _.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n), this.position++) : this.combinator();
        }, e.string = function() {
            var n = this.currToken;
            this.newNode(new Ki.default({
                value: this.content(),
                source: rt(n),
                sourceIndex: n[k.FIELDS.START_POS]
            })), this.position++;
        }, e.universal = function(n) {
            var i = this.nextToken;
            if (i && this.content(i) === "|") return this.position++, this.namespace();
            var s = this.currToken;
            this.newNode(new sy.default({
                value: this.content(),
                source: rt(s),
                sourceIndex: s[k.FIELDS.START_POS]
            }), n), this.position++;
        }, e.splitWord = function(n, i) {
            for(var s = this, a = this.nextToken, o = this.content(); a && ~[
                _.dollar,
                _.caret,
                _.equals,
                _.word
            ].indexOf(a[k.FIELDS.TYPE]);){
                this.position++;
                var l = this.content();
                if (o += l, l.lastIndexOf("\\") === l.length - 1) {
                    var u = this.nextToken;
                    u && u[k.FIELDS.TYPE] === _.space && (o += this.requiredSpace(this.content(u)), this.position++);
                }
                a = this.nextToken;
            }
            var f = rs(o, ".").filter(function(h) {
                var y = o[h - 1] === "\\", m = /^\d+\.\d+%$/.test(o);
                return !y && !m;
            }), p = rs(o, "#").filter(function(h) {
                return o[h - 1] !== "\\";
            }), c = rs(o, "#{");
            c.length && (p = p.filter(function(h) {
                return !~c.indexOf(h);
            }));
            var d = (0, oy.default)(cy([
                0
            ].concat(f, p)));
            d.forEach(function(h, y) {
                var m = d[y + 1] || o.length, g = o.slice(h, m);
                if (y === 0 && i) return i.call(s, g, d.length);
                var w, b = s.currToken, v = b[k.FIELDS.START_POS] + d[y], C = We(b[1], b[2] + h, b[3], b[2] + (m - 1));
                if (~f.indexOf(h)) {
                    var x = {
                        value: g.slice(1),
                        source: C,
                        sourceIndex: v
                    };
                    w = new ty.default(nt(x, "value"));
                } else if (~p.indexOf(h)) {
                    var O = {
                        value: g.slice(1),
                        source: C,
                        sourceIndex: v
                    };
                    w = new ry.default(nt(O, "value"));
                } else {
                    var E = {
                        value: g,
                        source: C,
                        sourceIndex: v
                    };
                    nt(E, "value"), w = new ny.default(E);
                }
                s.newNode(w, n), n = null;
            }), this.position++;
        }, e.word = function(n) {
            var i = this.nextToken;
            return i && this.content(i) === "|" ? (this.position++, this.namespace()) : this.splitWord(n);
        }, e.loop = function() {
            for(; this.position < this.tokens.length;)this.parse(!0);
            return this.current._inferEndPosition(), this.root;
        }, e.parse = function(n) {
            switch(this.currToken[k.FIELDS.TYPE]){
                case _.space:
                    this.space();
                    break;
                case _.comment:
                    this.comment();
                    break;
                case _.openParenthesis:
                    this.parentheses();
                    break;
                case _.closeParenthesis:
                    n && this.missingParenthesis();
                    break;
                case _.openSquare:
                    this.attribute();
                    break;
                case _.dollar:
                case _.caret:
                case _.equals:
                case _.word:
                    this.word();
                    break;
                case _.colon:
                    this.pseudo();
                    break;
                case _.comma:
                    this.comma();
                    break;
                case _.asterisk:
                    this.universal();
                    break;
                case _.ampersand:
                    this.nesting();
                    break;
                case _.slash:
                case _.combinator:
                    this.combinator();
                    break;
                case _.str:
                    this.string();
                    break;
                case _.closeSquare:
                    this.missingSquareBracket();
                case _.semicolon:
                    this.missingBackslash();
                default:
                    this.unexpected();
            }
        }, e.expected = function(n, i, s) {
            if (Array.isArray(n)) {
                var a = n.pop();
                n = n.join(", ") + " or " + a;
            }
            var o = /^[aeiou]/.test(n[0]) ? "an" : "a";
            return s ? this.error("Expected " + o + " " + n + ', found "' + s + '" instead.', {
                index: i
            }) : this.error("Expected " + o + " " + n + ".", {
                index: i
            });
        }, e.requiredSpace = function(n) {
            return this.options.lossy ? " " : n;
        }, e.optionalSpace = function(n) {
            return this.options.lossy ? "" : n;
        }, e.lossySpace = function(n, i) {
            return this.options.lossy ? i ? " " : "" : n;
        }, e.parseParenthesisToken = function(n) {
            var i = this.content(n);
            return n[k.FIELDS.TYPE] === _.space ? this.requiredSpace(i) : i;
        }, e.newNode = function(n, i) {
            return i && (/^ +$/.test(i) && (this.options.lossy || (this.spaces = (this.spaces || "") + i), i = !0), n.namespace = i, nt(n, "namespace")), this.spaces && (n.spaces.before = this.spaces, this.spaces = ""), this.current.append(n);
        }, e.content = function(n) {
            return n === void 0 && (n = this.currToken), this.css.slice(n[k.FIELDS.START_POS], n[k.FIELDS.END_POS]);
        }, e.locateNextMeaningfulToken = function(n) {
            n === void 0 && (n = this.position + 1);
            for(var i = n; i < this.tokens.length;)if (fy[this.tokens[i][k.FIELDS.TYPE]]) {
                i++;
                continue;
            } else return i;
            return -1;
        }, uy(t, [
            {
                key: "currToken",
                get: function() {
                    return this.tokens[this.position];
                }
            },
            {
                key: "nextToken",
                get: function() {
                    return this.tokens[this.position + 1];
                }
            },
            {
                key: "prevToken",
                get: function() {
                    return this.tokens[this.position - 1];
                }
            }
        ]), t;
    }();
    er.default = py;
    ru.exports = er.default;
});
var su = S((tr, iu)=>{
    "use strict";
    tr.__esModule = !0;
    tr.default = void 0;
    var dy = hy(nu());
    function hy(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    var my = function() {
        function t(r, n) {
            this.func = r || function() {}, this.funcRes = null, this.options = n;
        }
        var e = t.prototype;
        return e._shouldUpdateSelector = function(n, i) {
            i === void 0 && (i = {});
            var s = Object.assign({}, this.options, i);
            return s.updateSelector === !1 ? !1 : typeof n != "string";
        }, e._isLossy = function(n) {
            n === void 0 && (n = {});
            var i = Object.assign({}, this.options, n);
            return i.lossless === !1;
        }, e._root = function(n, i) {
            i === void 0 && (i = {});
            var s = new dy.default(n, this._parseOptions(i));
            return s.root;
        }, e._parseOptions = function(n) {
            return {
                lossy: this._isLossy(n)
            };
        }, e._run = function(n, i) {
            var s = this;
            return i === void 0 && (i = {}), new Promise(function(a, o) {
                try {
                    var l = s._root(n, i);
                    Promise.resolve(s.func(l)).then(function(u) {
                        var f = void 0;
                        return s._shouldUpdateSelector(n, i) && (f = l.toString(), n.selector = f), {
                            transform: u,
                            root: l,
                            string: f
                        };
                    }).then(a, o);
                } catch (u) {
                    o(u);
                    return;
                }
            });
        }, e._runSync = function(n, i) {
            i === void 0 && (i = {});
            var s = this._root(n, i), a = this.func(s);
            if (a && typeof a.then == "function") throw new Error("Selector processor returned a promise to a synchronous call.");
            var o = void 0;
            return i.updateSelector && typeof n != "string" && (o = s.toString(), n.selector = o), {
                transform: a,
                root: s,
                string: o
            };
        }, e.ast = function(n, i) {
            return this._run(n, i).then(function(s) {
                return s.root;
            });
        }, e.astSync = function(n, i) {
            return this._runSync(n, i).root;
        }, e.transform = function(n, i) {
            return this._run(n, i).then(function(s) {
                return s.transform;
            });
        }, e.transformSync = function(n, i) {
            return this._runSync(n, i).transform;
        }, e.process = function(n, i) {
            return this._run(n, i).then(function(s) {
                return s.string || s.root.toString();
            });
        }, e.processSync = function(n, i) {
            var s = this._runSync(n, i);
            return s.string || s.root.toString();
        }, t;
    }();
    tr.default = my;
    iu.exports = tr.default;
});
var au = S((j)=>{
    "use strict";
    j.__esModule = !0;
    j.universal = j.tag = j.string = j.selector = j.root = j.pseudo = j.nesting = j.id = j.comment = j.combinator = j.className = j.attribute = void 0;
    var gy = ue(zi()), yy = ue(Ci()), wy = ue(Gi()), vy = ue(Ai()), by = ue(_i()), xy = ue(Hi()), Sy = ue(Li()), ky = ue(vi()), Cy = ue(xi()), Ey = ue(Di()), Ay = ue(Ri()), Oy = ue(Wi());
    function ue(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    var _y = function(e) {
        return new gy.default(e);
    };
    j.attribute = _y;
    var Ty = function(e) {
        return new yy.default(e);
    };
    j.className = Ty;
    var Py = function(e) {
        return new wy.default(e);
    };
    j.combinator = Py;
    var Ry = function(e) {
        return new vy.default(e);
    };
    j.comment = Ry;
    var Iy = function(e) {
        return new by.default(e);
    };
    j.id = Iy;
    var Dy = function(e) {
        return new xy.default(e);
    };
    j.nesting = Dy;
    var My = function(e) {
        return new Sy.default(e);
    };
    j.pseudo = My;
    var Ly = function(e) {
        return new ky.default(e);
    };
    j.root = Ly;
    var Fy = function(e) {
        return new Cy.default(e);
    };
    j.selector = Fy;
    var Ny = function(e) {
        return new Ey.default(e);
    };
    j.string = Ny;
    var qy = function(e) {
        return new Ay.default(e);
    };
    j.tag = qy;
    var $y = function(e) {
        return new Oy.default(e);
    };
    j.universal = $y;
});
var fu = S((M)=>{
    "use strict";
    M.__esModule = !0;
    M.isNode = is;
    M.isPseudoElement = uu;
    M.isPseudoClass = Jy;
    M.isContainer = Xy;
    M.isNamespace = Ky;
    M.isUniversal = M.isTag = M.isString = M.isSelector = M.isRoot = M.isPseudo = M.isNesting = M.isIdentifier = M.isComment = M.isCombinator = M.isClassName = M.isAttribute = void 0;
    var W = J(), Z, Uy = (Z = {}, Z[W.ATTRIBUTE] = !0, Z[W.CLASS] = !0, Z[W.COMBINATOR] = !0, Z[W.COMMENT] = !0, Z[W.ID] = !0, Z[W.NESTING] = !0, Z[W.PSEUDO] = !0, Z[W.ROOT] = !0, Z[W.SELECTOR] = !0, Z[W.STRING] = !0, Z[W.TAG] = !0, Z[W.UNIVERSAL] = !0, Z);
    function is(t) {
        return typeof t == "object" && Uy[t.type];
    }
    function fe(t, e) {
        return is(e) && e.type === t;
    }
    var ou = fe.bind(null, W.ATTRIBUTE);
    M.isAttribute = ou;
    var jy = fe.bind(null, W.CLASS);
    M.isClassName = jy;
    var zy = fe.bind(null, W.COMBINATOR);
    M.isCombinator = zy;
    var Vy = fe.bind(null, W.COMMENT);
    M.isComment = Vy;
    var Wy = fe.bind(null, W.ID);
    M.isIdentifier = Wy;
    var By = fe.bind(null, W.NESTING);
    M.isNesting = By;
    var ss = fe.bind(null, W.PSEUDO);
    M.isPseudo = ss;
    var Gy = fe.bind(null, W.ROOT);
    M.isRoot = Gy;
    var Yy = fe.bind(null, W.SELECTOR);
    M.isSelector = Yy;
    var Hy = fe.bind(null, W.STRING);
    M.isString = Hy;
    var lu = fe.bind(null, W.TAG);
    M.isTag = lu;
    var Qy = fe.bind(null, W.UNIVERSAL);
    M.isUniversal = Qy;
    function uu(t) {
        return ss(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
    }
    function Jy(t) {
        return ss(t) && !uu(t);
    }
    function Xy(t) {
        return !!(is(t) && t.walk);
    }
    function Ky(t) {
        return ou(t) || lu(t);
    }
});
var cu = S((de)=>{
    "use strict";
    de.__esModule = !0;
    var as = J();
    Object.keys(as).forEach(function(t) {
        t === "default" || t === "__esModule" || t in de && de[t] === as[t] || (de[t] = as[t]);
    });
    var os = au();
    Object.keys(os).forEach(function(t) {
        t === "default" || t === "__esModule" || t in de && de[t] === os[t] || (de[t] = os[t]);
    });
    var ls = fu();
    Object.keys(ls).forEach(function(t) {
        t === "default" || t === "__esModule" || t in de && de[t] === ls[t] || (de[t] = ls[t]);
    });
});
var Oe = S((rr, du)=>{
    "use strict";
    rr.__esModule = !0;
    rr.default = void 0;
    var Zy = rw(su()), ew = tw(cu());
    function pu() {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap;
        return pu = function() {
            return t;
        }, t;
    }
    function tw(t) {
        if (t && t.__esModule) return t;
        if (t === null || typeof t != "object" && typeof t != "function") return {
            default: t
        };
        var e = pu();
        if (e && e.has(t)) return e.get(t);
        var r = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for(var i in t)if (Object.prototype.hasOwnProperty.call(t, i)) {
            var s = n ? Object.getOwnPropertyDescriptor(t, i) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, i, s) : r[i] = t[i];
        }
        return r.default = t, e && e.set(t, r), r;
    }
    function rw(t) {
        return t && t.__esModule ? t : {
            default: t
        };
    }
    var us = function(e) {
        return new Zy.default(e);
    };
    Object.assign(us, ew);
    delete us.__esModule;
    var nw = us;
    rr.default = nw;
    du.exports = rr.default;
});
var bu = S((Mx, hs)=>{
    var { Rule: mu, AtRule: iw } = et(), gu = Oe();
    function ps(t, e) {
        let r;
        try {
            gu((n)=>{
                r = n;
            }).processSync(t);
        } catch (n) {
            throw t.includes(":") ? e ? e.error("Missed semicolon") : n : e ? e.error(n.message) : n;
        }
        return r.at(0);
    }
    function yu(t, e) {
        let r = !1;
        return t.each((n)=>{
            if (n.type === "nesting") {
                let i = e.clone({});
                n.value !== "&" ? n.replaceWith(ps(n.value.replace("&", i.toString()))) : n.replaceWith(i), r = !0;
            } else "nodes" in n && n.nodes && yu(n, e) && (r = !0);
        }), r;
    }
    function wu(t, e) {
        let r = [];
        return t.selectors.forEach((n)=>{
            let i = ps(n, t);
            e.selectors.forEach((s)=>{
                if (!s) return;
                let a = ps(s, e);
                yu(a, i) || (a.prepend(gu.combinator({
                    value: " "
                })), a.prepend(i.clone({}))), r.push(a.toString());
            });
        }), r;
    }
    function Kr(t, e) {
        let r = t.prev();
        for(e.after(t); r && r.type === "comment";){
            let n = r.prev();
            e.after(r), r = n;
        }
        return t;
    }
    function sw(t) {
        return function e(r, n, i, s = i) {
            let a = [];
            if (n.each((o)=>{
                o.type === "rule" && i ? s && (o.selectors = wu(r, o)) : o.type === "atrule" && o.nodes ? t[o.name] ? e(r, o, s) : n[ds] !== !1 && a.push(o) : a.push(o);
            }), i && a.length) {
                let o = r.clone({
                    nodes: []
                });
                for (let l of a)o.append(l);
                n.prepend(o);
            }
        };
    }
    function fs(t, e, r) {
        let n = new mu({
            selector: t,
            nodes: []
        });
        return n.append(e), r.after(n), n;
    }
    function hu(t, e) {
        let r = {};
        for (let n of t)r[n] = !0;
        if (e) for (let n of e)r[n.replace(/^@/, "")] = !0;
        return r;
    }
    function aw(t) {
        t = t.trim();
        let e = t.match(/^\((.*)\)$/);
        if (!e) return {
            type: "basic",
            selector: t
        };
        let r = e[1].match(/^(with(?:out)?):(.+)$/);
        if (r) {
            let n = r[1] === "with", i = Object.fromEntries(r[2].trim().split(/\s+/).map((a)=>[
                    a,
                    !0
                ]));
            if (n && i.all) return {
                type: "noop"
            };
            let s = (a)=>!!i[a];
            return i.all ? s = ()=>!0 : n && (s = (a)=>a === "all" ? !1 : !i[a]), {
                type: "withrules",
                escapes: s
            };
        }
        return {
            type: "unknown"
        };
    }
    function ow(t) {
        let e = [], r = t.parent;
        for(; r && r instanceof iw;)e.push(r), r = r.parent;
        return e;
    }
    function lw(t) {
        let e = t[vu];
        if (!e) t.after(t.nodes);
        else {
            let r = t.nodes, n, i = -1, s, a, o, l = ow(t);
            if (l.forEach((u, f)=>{
                if (e(u.name)) n = u, i = f, a = o;
                else {
                    let p = o;
                    o = u.clone({
                        nodes: []
                    }), p && o.append(p), s = s || o;
                }
            }), n ? a ? (s.append(r), n.after(a)) : n.after(r) : t.after(r), t.next() && n) {
                let u;
                l.slice(0, i + 1).forEach((f, p, c)=>{
                    let d = u;
                    u = f.clone({
                        nodes: []
                    }), d && u.append(d);
                    let h = [], m = (c[p - 1] || t).next();
                    for(; m;)h.push(m), m = m.next();
                    u.append(h);
                }), u && (a || r[r.length - 1]).after(u);
            }
        }
        t.remove();
    }
    var ds = Symbol("rootRuleMergeSel"), vu = Symbol("rootRuleEscapes");
    function uw(t) {
        let { params: e } = t, { type: r, selector: n, escapes: i } = aw(e);
        if (r === "unknown") throw t.error(`Unknown @${t.name} parameter ${JSON.stringify(e)}`);
        if (r === "basic" && n) {
            let s = new mu({
                selector: n,
                nodes: t.nodes
            });
            t.removeAll(), t.append(s);
        }
        t[vu] = i, t[ds] = i ? !i("all") : r === "noop";
    }
    var cs = Symbol("hasRootRule");
    hs.exports = (t = {})=>{
        let e = hu([
            "media",
            "supports",
            "layer"
        ], t.bubble), r = sw(e), n = hu([
            "document",
            "font-face",
            "keyframes",
            "-webkit-keyframes",
            "-moz-keyframes"
        ], t.unwrap), i = (t.rootRuleName || "at-root").replace(/^@/, ""), s = t.preserveEmpty;
        return {
            postcssPlugin: "postcss-nested",
            Once (a) {
                a.walkAtRules(i, (o)=>{
                    uw(o), a[cs] = !0;
                });
            },
            Rule (a) {
                let o = !1, l = a, u = !1, f = [];
                a.each((p)=>{
                    p.type === "rule" ? (f.length && (l = fs(a.selector, f, l), f = []), u = !0, o = !0, p.selectors = wu(a, p), l = Kr(p, l)) : p.type === "atrule" ? (f.length && (l = fs(a.selector, f, l), f = []), p.name === i ? (o = !0, r(a, p, !0, p[ds]), l = Kr(p, l)) : e[p.name] ? (u = !0, o = !0, r(a, p, !0), l = Kr(p, l)) : n[p.name] ? (u = !0, o = !0, r(a, p, !1), l = Kr(p, l)) : u && f.push(p)) : p.type === "decl" && u && f.push(p);
                }), f.length && (l = fs(a.selector, f, l)), o && s !== !0 && (a.raws.semicolon = !0, a.nodes.length === 0 && a.remove());
            },
            RootExit (a) {
                a[cs] && (a.walkAtRules(i, lw), a[cs] = !1);
            }
        };
    };
    hs.exports.postcss = !0;
});
var Cu = S((Lx, ku)=>{
    "use strict";
    var xu = /-(\w|$)/g, Su = function(e, r) {
        return r.toUpperCase();
    }, fw = function(e) {
        return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(xu, Su) : e.replace(xu, Su);
    };
    ku.exports = fw;
});
var ys = S((Fx, Eu)=>{
    var cw = Cu(), pw = {
        boxFlex: !0,
        boxFlexGroup: !0,
        columnCount: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        strokeDashoffset: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    };
    function ms(t) {
        return typeof t.nodes > "u" ? !0 : gs(t);
    }
    function gs(t) {
        let e, r = {};
        return t.each((n)=>{
            if (n.type === "atrule") e = "@" + n.name, n.params && (e += " " + n.params), typeof r[e] > "u" ? r[e] = ms(n) : Array.isArray(r[e]) ? r[e].push(ms(n)) : r[e] = [
                r[e],
                ms(n)
            ];
            else if (n.type === "rule") {
                let i = gs(n);
                if (r[n.selector]) for(let s in i)r[n.selector][s] = i[s];
                else r[n.selector] = i;
            } else if (n.type === "decl") {
                n.prop[0] === "-" && n.prop[1] === "-" ? e = n.prop : e = cw(n.prop);
                let i = n.value;
                !isNaN(n.value) && pw[e] && (i = parseFloat(n.value)), n.important && (i += " !important"), typeof r[e] > "u" ? r[e] = i : Array.isArray(r[e]) ? r[e].push(i) : r[e] = [
                    r[e],
                    i
                ];
            }
        }), r;
    }
    Eu.exports = gs;
});
var Zr = S((Nx, Tu)=>{
    var nr = et(), Au = /\s*!important\s*$/i, dw = {
        "box-flex": !0,
        "box-flex-group": !0,
        "column-count": !0,
        flex: !0,
        "flex-grow": !0,
        "flex-positive": !0,
        "flex-shrink": !0,
        "flex-negative": !0,
        "font-weight": !0,
        "line-clamp": !0,
        "line-height": !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        "tab-size": !0,
        widows: !0,
        "z-index": !0,
        zoom: !0,
        "fill-opacity": !0,
        "stroke-dashoffset": !0,
        "stroke-opacity": !0,
        "stroke-width": !0
    };
    function hw(t) {
        return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
    }
    function Ou(t, e, r) {
        r === !1 || r === null || (e.startsWith("--") || (e = hw(e)), typeof r == "number" && (r === 0 || dw[e] ? r = r.toString() : r += "px"), e === "css-float" && (e = "float"), Au.test(r) ? (r = r.replace(Au, ""), t.push(nr.decl({
            prop: e,
            value: r,
            important: !0
        }))) : t.push(nr.decl({
            prop: e,
            value: r
        })));
    }
    function _u(t, e, r) {
        let n = nr.atRule({
            name: e[1],
            params: e[3] || ""
        });
        typeof r == "object" && (n.nodes = [], ws(r, n)), t.push(n);
    }
    function ws(t, e) {
        let r, n, i;
        for(r in t)if (n = t[r], !(n === null || typeof n > "u")) if (r[0] === "@") {
            let s = r.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
            if (Array.isArray(n)) for (let a of n)_u(e, s, a);
            else _u(e, s, n);
        } else if (Array.isArray(n)) for (let s of n)Ou(e, r, s);
        else typeof n == "object" ? (i = nr.rule({
            selector: r
        }), ws(n, i), e.push(i)) : Ou(e, r, n);
    }
    Tu.exports = function(t) {
        let e = nr.root();
        return ws(t, e), e;
    };
});
var vs = S((qx, Pu)=>{
    var mw = ys();
    Pu.exports = function(e) {
        return console && console.warn && e.warnings().forEach((r)=>{
            let n = r.plugin || "PostCSS";
            console.warn(n + ": " + r.text);
        }), mw(e.root);
    };
});
var Iu = S(($x, Ru)=>{
    var gw = et(), yw = vs(), ww = Zr();
    Ru.exports = function(e) {
        let r = gw(e);
        return async (n)=>{
            let i = await r.process(n, {
                parser: ww,
                from: void 0
            });
            return yw(i);
        };
    };
});
var Mu = S((Ux, Du)=>{
    var vw = et(), bw = vs(), xw = Zr();
    Du.exports = function(t) {
        let e = vw(t);
        return (r)=>{
            let n = e.process(r, {
                parser: xw,
                from: void 0
            });
            return bw(n);
        };
    };
});
var Fu = S((jx, Lu)=>{
    var Sw = ys(), kw = Zr(), Cw = Iu(), Ew = Mu();
    Lu.exports = {
        objectify: Sw,
        parse: kw,
        async: Cw,
        sync: Ew
    };
});
var Uu = S((Zx, $u)=>{
    "use strict";
    $u.exports = {
        aliceblue: [
            240,
            248,
            255
        ],
        antiquewhite: [
            250,
            235,
            215
        ],
        aqua: [
            0,
            255,
            255
        ],
        aquamarine: [
            127,
            255,
            212
        ],
        azure: [
            240,
            255,
            255
        ],
        beige: [
            245,
            245,
            220
        ],
        bisque: [
            255,
            228,
            196
        ],
        black: [
            0,
            0,
            0
        ],
        blanchedalmond: [
            255,
            235,
            205
        ],
        blue: [
            0,
            0,
            255
        ],
        blueviolet: [
            138,
            43,
            226
        ],
        brown: [
            165,
            42,
            42
        ],
        burlywood: [
            222,
            184,
            135
        ],
        cadetblue: [
            95,
            158,
            160
        ],
        chartreuse: [
            127,
            255,
            0
        ],
        chocolate: [
            210,
            105,
            30
        ],
        coral: [
            255,
            127,
            80
        ],
        cornflowerblue: [
            100,
            149,
            237
        ],
        cornsilk: [
            255,
            248,
            220
        ],
        crimson: [
            220,
            20,
            60
        ],
        cyan: [
            0,
            255,
            255
        ],
        darkblue: [
            0,
            0,
            139
        ],
        darkcyan: [
            0,
            139,
            139
        ],
        darkgoldenrod: [
            184,
            134,
            11
        ],
        darkgray: [
            169,
            169,
            169
        ],
        darkgreen: [
            0,
            100,
            0
        ],
        darkgrey: [
            169,
            169,
            169
        ],
        darkkhaki: [
            189,
            183,
            107
        ],
        darkmagenta: [
            139,
            0,
            139
        ],
        darkolivegreen: [
            85,
            107,
            47
        ],
        darkorange: [
            255,
            140,
            0
        ],
        darkorchid: [
            153,
            50,
            204
        ],
        darkred: [
            139,
            0,
            0
        ],
        darksalmon: [
            233,
            150,
            122
        ],
        darkseagreen: [
            143,
            188,
            143
        ],
        darkslateblue: [
            72,
            61,
            139
        ],
        darkslategray: [
            47,
            79,
            79
        ],
        darkslategrey: [
            47,
            79,
            79
        ],
        darkturquoise: [
            0,
            206,
            209
        ],
        darkviolet: [
            148,
            0,
            211
        ],
        deeppink: [
            255,
            20,
            147
        ],
        deepskyblue: [
            0,
            191,
            255
        ],
        dimgray: [
            105,
            105,
            105
        ],
        dimgrey: [
            105,
            105,
            105
        ],
        dodgerblue: [
            30,
            144,
            255
        ],
        firebrick: [
            178,
            34,
            34
        ],
        floralwhite: [
            255,
            250,
            240
        ],
        forestgreen: [
            34,
            139,
            34
        ],
        fuchsia: [
            255,
            0,
            255
        ],
        gainsboro: [
            220,
            220,
            220
        ],
        ghostwhite: [
            248,
            248,
            255
        ],
        gold: [
            255,
            215,
            0
        ],
        goldenrod: [
            218,
            165,
            32
        ],
        gray: [
            128,
            128,
            128
        ],
        green: [
            0,
            128,
            0
        ],
        greenyellow: [
            173,
            255,
            47
        ],
        grey: [
            128,
            128,
            128
        ],
        honeydew: [
            240,
            255,
            240
        ],
        hotpink: [
            255,
            105,
            180
        ],
        indianred: [
            205,
            92,
            92
        ],
        indigo: [
            75,
            0,
            130
        ],
        ivory: [
            255,
            255,
            240
        ],
        khaki: [
            240,
            230,
            140
        ],
        lavender: [
            230,
            230,
            250
        ],
        lavenderblush: [
            255,
            240,
            245
        ],
        lawngreen: [
            124,
            252,
            0
        ],
        lemonchiffon: [
            255,
            250,
            205
        ],
        lightblue: [
            173,
            216,
            230
        ],
        lightcoral: [
            240,
            128,
            128
        ],
        lightcyan: [
            224,
            255,
            255
        ],
        lightgoldenrodyellow: [
            250,
            250,
            210
        ],
        lightgray: [
            211,
            211,
            211
        ],
        lightgreen: [
            144,
            238,
            144
        ],
        lightgrey: [
            211,
            211,
            211
        ],
        lightpink: [
            255,
            182,
            193
        ],
        lightsalmon: [
            255,
            160,
            122
        ],
        lightseagreen: [
            32,
            178,
            170
        ],
        lightskyblue: [
            135,
            206,
            250
        ],
        lightslategray: [
            119,
            136,
            153
        ],
        lightslategrey: [
            119,
            136,
            153
        ],
        lightsteelblue: [
            176,
            196,
            222
        ],
        lightyellow: [
            255,
            255,
            224
        ],
        lime: [
            0,
            255,
            0
        ],
        limegreen: [
            50,
            205,
            50
        ],
        linen: [
            250,
            240,
            230
        ],
        magenta: [
            255,
            0,
            255
        ],
        maroon: [
            128,
            0,
            0
        ],
        mediumaquamarine: [
            102,
            205,
            170
        ],
        mediumblue: [
            0,
            0,
            205
        ],
        mediumorchid: [
            186,
            85,
            211
        ],
        mediumpurple: [
            147,
            112,
            219
        ],
        mediumseagreen: [
            60,
            179,
            113
        ],
        mediumslateblue: [
            123,
            104,
            238
        ],
        mediumspringgreen: [
            0,
            250,
            154
        ],
        mediumturquoise: [
            72,
            209,
            204
        ],
        mediumvioletred: [
            199,
            21,
            133
        ],
        midnightblue: [
            25,
            25,
            112
        ],
        mintcream: [
            245,
            255,
            250
        ],
        mistyrose: [
            255,
            228,
            225
        ],
        moccasin: [
            255,
            228,
            181
        ],
        navajowhite: [
            255,
            222,
            173
        ],
        navy: [
            0,
            0,
            128
        ],
        oldlace: [
            253,
            245,
            230
        ],
        olive: [
            128,
            128,
            0
        ],
        olivedrab: [
            107,
            142,
            35
        ],
        orange: [
            255,
            165,
            0
        ],
        orangered: [
            255,
            69,
            0
        ],
        orchid: [
            218,
            112,
            214
        ],
        palegoldenrod: [
            238,
            232,
            170
        ],
        palegreen: [
            152,
            251,
            152
        ],
        paleturquoise: [
            175,
            238,
            238
        ],
        palevioletred: [
            219,
            112,
            147
        ],
        papayawhip: [
            255,
            239,
            213
        ],
        peachpuff: [
            255,
            218,
            185
        ],
        peru: [
            205,
            133,
            63
        ],
        pink: [
            255,
            192,
            203
        ],
        plum: [
            221,
            160,
            221
        ],
        powderblue: [
            176,
            224,
            230
        ],
        purple: [
            128,
            0,
            128
        ],
        rebeccapurple: [
            102,
            51,
            153
        ],
        red: [
            255,
            0,
            0
        ],
        rosybrown: [
            188,
            143,
            143
        ],
        royalblue: [
            65,
            105,
            225
        ],
        saddlebrown: [
            139,
            69,
            19
        ],
        salmon: [
            250,
            128,
            114
        ],
        sandybrown: [
            244,
            164,
            96
        ],
        seagreen: [
            46,
            139,
            87
        ],
        seashell: [
            255,
            245,
            238
        ],
        sienna: [
            160,
            82,
            45
        ],
        silver: [
            192,
            192,
            192
        ],
        skyblue: [
            135,
            206,
            235
        ],
        slateblue: [
            106,
            90,
            205
        ],
        slategray: [
            112,
            128,
            144
        ],
        slategrey: [
            112,
            128,
            144
        ],
        snow: [
            255,
            250,
            250
        ],
        springgreen: [
            0,
            255,
            127
        ],
        steelblue: [
            70,
            130,
            180
        ],
        tan: [
            210,
            180,
            140
        ],
        teal: [
            0,
            128,
            128
        ],
        thistle: [
            216,
            191,
            216
        ],
        tomato: [
            255,
            99,
            71
        ],
        turquoise: [
            64,
            224,
            208
        ],
        violet: [
            238,
            130,
            238
        ],
        wheat: [
            245,
            222,
            179
        ],
        white: [
            255,
            255,
            255
        ],
        whitesmoke: [
            245,
            245,
            245
        ],
        yellow: [
            255,
            255,
            0
        ],
        yellowgreen: [
            154,
            205,
            50
        ]
    };
});
var Ms = S((Is, Ds)=>{
    (function(t, e) {
        typeof Is == "object" && typeof Ds < "u" ? Ds.exports = function(r, n, i, s, a) {
            for(n = n.split ? n.split(".") : n, s = 0; s < n.length; s++)r = r ? r[n[s]] : a;
            return r === a ? i : r;
        } :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return function(r, n, i, s, a) {
                for(n = n.split ? n.split(".") : n, s = 0; s < n.length; s++)r = r ? r[n[s]] : a;
                return r === a ? i : r;
            };
        }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
    })(Is);
});
var Lf = {};
He(Lf, {
    default: ()=>Nv
});
var Nv, Ff = Ye(()=>{
    Nv = null;
});
var Bf = S((dk, xn)=>{
    (function() {
        "use strict";
        function t(n, i, s) {
            if (!n) return null;
            t.caseSensitive || (n = n.toLowerCase());
            var a = t.threshold === null ? null : t.threshold * n.length, o = t.thresholdAbsolute, l;
            a !== null && o !== null ? l = Math.min(a, o) : a !== null ? l = a : o !== null ? l = o : l = null;
            var u, f, p, c, d, h = i.length;
            for(d = 0; d < h; d++)if (f = i[d], s && (f = f[s]), !!f && (t.caseSensitive ? p = f : p = f.toLowerCase(), c = r(n, p, l), (l === null || c < l) && (l = c, s && t.returnWinningObject ? u = i[d] : u = f, t.returnFirstMatch))) return u;
            return u || t.nullResultValue;
        }
        t.threshold = .4, t.thresholdAbsolute = 20, t.caseSensitive = !1, t.nullResultValue = null, t.returnWinningObject = null, t.returnFirstMatch = !1, typeof xn < "u" && xn.exports ? xn.exports = t : window.didYouMean = t;
        var e = Math.pow(2, 32) - 1;
        function r(n, i, s) {
            s = s || s === 0 ? s : e;
            var a = n.length, o = i.length;
            if (a === 0) return Math.min(s + 1, o);
            if (o === 0) return Math.min(s + 1, a);
            if (Math.abs(a - o) > s) return s + 1;
            var l = [], u, f, p, c, d;
            for(u = 0; u <= o; u++)l[u] = [
                u
            ];
            for(f = 0; f <= a; f++)l[0][f] = f;
            for(u = 1; u <= o; u++){
                for(p = e, c = 1, u > s && (c = u - s), d = o + 1, d > s + u && (d = s + u), f = 1; f <= a; f++)f < c || f > d ? l[u][f] = s + 1 : i.charAt(u - 1) === n.charAt(f - 1) ? l[u][f] = l[u - 1][f - 1] : l[u][f] = Math.min(l[u - 1][f - 1] + 1, Math.min(l[u][f - 1] + 1, l[u - 1][f] + 1)), l[u][f] < p && (p = l[u][f]);
                if (p > s) return s + 1;
            }
            return l[o][a];
        }
    })();
});
var Yf = S((hk, Gf)=>{
    var Hs = "(".charCodeAt(0), Qs = ")".charCodeAt(0), Sn = "'".charCodeAt(0), Js = '"'.charCodeAt(0), Xs = "\\".charCodeAt(0), ct = "/".charCodeAt(0), Ks = ",".charCodeAt(0), Zs = ":".charCodeAt(0), kn = "*".charCodeAt(0), Qv = "u".charCodeAt(0), Jv = "U".charCodeAt(0), Xv = "+".charCodeAt(0), Kv = /^[a-f0-9?-]+$/i;
    Gf.exports = function(t) {
        for(var e = [], r = t, n, i, s, a, o, l, u, f, p = 0, c = r.charCodeAt(p), d = r.length, h = [
            {
                nodes: e
            }
        ], y = 0, m, g = "", w = "", b = ""; p < d;)if (c <= 32) {
            n = p;
            do n += 1, c = r.charCodeAt(n);
            while (c <= 32);
            a = r.slice(p, n), s = e[e.length - 1], c === Qs && y ? b = a : s && s.type === "div" ? (s.after = a, s.sourceEndIndex += a.length) : c === Ks || c === Zs || c === ct && r.charCodeAt(n + 1) !== kn && (!m || m && m.type === "function" && m.value !== "calc") ? w = a : e.push({
                type: "space",
                sourceIndex: p,
                sourceEndIndex: n,
                value: a
            }), p = n;
        } else if (c === Sn || c === Js) {
            n = p, i = c === Sn ? "'" : '"', a = {
                type: "string",
                sourceIndex: p,
                quote: i
            };
            do if (o = !1, n = r.indexOf(i, n + 1), ~n) for(l = n; r.charCodeAt(l - 1) === Xs;)l -= 1, o = !o;
            else r += i, n = r.length - 1, a.unclosed = !0;
            while (o);
            a.value = r.slice(p + 1, n), a.sourceEndIndex = a.unclosed ? n : n + 1, e.push(a), p = n + 1, c = r.charCodeAt(p);
        } else if (c === ct && r.charCodeAt(p + 1) === kn) n = r.indexOf("*/", p), a = {
            type: "comment",
            sourceIndex: p,
            sourceEndIndex: n + 2
        }, n === -1 && (a.unclosed = !0, n = r.length, a.sourceEndIndex = n), a.value = r.slice(p + 2, n), e.push(a), p = n + 2, c = r.charCodeAt(p);
        else if ((c === ct || c === kn) && m && m.type === "function" && m.value === "calc") a = r[p], e.push({
            type: "word",
            sourceIndex: p - w.length,
            sourceEndIndex: p + a.length,
            value: a
        }), p += 1, c = r.charCodeAt(p);
        else if (c === ct || c === Ks || c === Zs) a = r[p], e.push({
            type: "div",
            sourceIndex: p - w.length,
            sourceEndIndex: p + a.length,
            value: a,
            before: w,
            after: ""
        }), w = "", p += 1, c = r.charCodeAt(p);
        else if (Hs === c) {
            n = p;
            do n += 1, c = r.charCodeAt(n);
            while (c <= 32);
            if (f = p, a = {
                type: "function",
                sourceIndex: p - g.length,
                value: g,
                before: r.slice(f + 1, n)
            }, p = n, g === "url" && c !== Sn && c !== Js) {
                n -= 1;
                do if (o = !1, n = r.indexOf(")", n + 1), ~n) for(l = n; r.charCodeAt(l - 1) === Xs;)l -= 1, o = !o;
                else r += ")", n = r.length - 1, a.unclosed = !0;
                while (o);
                u = n;
                do u -= 1, c = r.charCodeAt(u);
                while (c <= 32);
                f < u ? (p !== u + 1 ? a.nodes = [
                    {
                        type: "word",
                        sourceIndex: p,
                        sourceEndIndex: u + 1,
                        value: r.slice(p, u + 1)
                    }
                ] : a.nodes = [], a.unclosed && u + 1 !== n ? (a.after = "", a.nodes.push({
                    type: "space",
                    sourceIndex: u + 1,
                    sourceEndIndex: n,
                    value: r.slice(u + 1, n)
                })) : (a.after = r.slice(u + 1, n), a.sourceEndIndex = n)) : (a.after = "", a.nodes = []), p = n + 1, a.sourceEndIndex = a.unclosed ? n : p, c = r.charCodeAt(p), e.push(a);
            } else y += 1, a.after = "", a.sourceEndIndex = p + 1, e.push(a), h.push(a), e = a.nodes = [], m = a;
            g = "";
        } else if (Qs === c && y) p += 1, c = r.charCodeAt(p), m.after = b, m.sourceEndIndex += b.length, b = "", y -= 1, h[h.length - 1].sourceEndIndex = p, h.pop(), m = h[y], e = m.nodes;
        else {
            n = p;
            do c === Xs && (n += 1), n += 1, c = r.charCodeAt(n);
            while (n < d && !(c <= 32 || c === Sn || c === Js || c === Ks || c === Zs || c === ct || c === Hs || c === kn && m && m.type === "function" && m.value === "calc" || c === ct && m.type === "function" && m.value === "calc" || c === Qs && y));
            a = r.slice(p, n), Hs === c ? g = a : (Qv === a.charCodeAt(0) || Jv === a.charCodeAt(0)) && Xv === a.charCodeAt(1) && Kv.test(a.slice(2)) ? e.push({
                type: "unicode-range",
                sourceIndex: p,
                sourceEndIndex: n,
                value: a
            }) : e.push({
                type: "word",
                sourceIndex: p,
                sourceEndIndex: n,
                value: a
            }), p = n;
        }
        for(p = h.length - 1; p; p -= 1)h[p].unclosed = !0, h[p].sourceEndIndex = r.length;
        return h[0].nodes;
    };
});
var Qf = S((mk, Hf)=>{
    Hf.exports = function t(e, r, n) {
        var i, s, a, o;
        for(i = 0, s = e.length; i < s; i += 1)a = e[i], n || (o = r(a, i, e)), o !== !1 && a.type === "function" && Array.isArray(a.nodes) && t(a.nodes, r, n), n && r(a, i, e);
    };
});
var Zf = S((gk, Kf)=>{
    function Jf(t, e) {
        var r = t.type, n = t.value, i, s;
        return e && (s = e(t)) !== void 0 ? s : r === "word" || r === "space" ? n : r === "string" ? (i = t.quote || "", i + n + (t.unclosed ? "" : i)) : r === "comment" ? "/*" + n + (t.unclosed ? "" : "*/") : r === "div" ? (t.before || "") + n + (t.after || "") : Array.isArray(t.nodes) ? (i = Xf(t.nodes, e), r !== "function" ? i : n + "(" + (t.before || "") + i + (t.after || "") + (t.unclosed ? "" : ")")) : n;
    }
    function Xf(t, e) {
        var r, n;
        if (Array.isArray(t)) {
            for(r = "", n = t.length - 1; ~n; n -= 1)r = Jf(t[n], e) + r;
            return r;
        }
        return Jf(t, e);
    }
    Kf.exports = Xf;
});
var tc = S((yk, ec)=>{
    var Cn = "-".charCodeAt(0), En = "+".charCodeAt(0), ea = ".".charCodeAt(0), Zv = "e".charCodeAt(0), e0 = "E".charCodeAt(0);
    function t0(t) {
        var e = t.charCodeAt(0), r;
        if (e === En || e === Cn) {
            if (r = t.charCodeAt(1), r >= 48 && r <= 57) return !0;
            var n = t.charCodeAt(2);
            return r === ea && n >= 48 && n <= 57;
        }
        return e === ea ? (r = t.charCodeAt(1), r >= 48 && r <= 57) : e >= 48 && e <= 57;
    }
    ec.exports = function(t) {
        var e = 0, r = t.length, n, i, s;
        if (r === 0 || !t0(t)) return !1;
        for(n = t.charCodeAt(e), (n === En || n === Cn) && e++; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57));)e += 1;
        if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), n === ea && i >= 48 && i <= 57) for(e += 2; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57));)e += 1;
        if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), s = t.charCodeAt(e + 2), (n === Zv || n === e0) && (i >= 48 && i <= 57 || (i === En || i === Cn) && s >= 48 && s <= 57)) for(e += i === En || i === Cn ? 3 : 2; e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57));)e += 1;
        return {
            number: t.slice(0, e),
            unit: t.slice(e)
        };
    };
});
var sc = S((wk, ic)=>{
    var r0 = Yf(), rc = Qf(), nc = Zf();
    function qe(t) {
        return this instanceof qe ? (this.nodes = r0(t), this) : new qe(t);
    }
    qe.prototype.toString = function() {
        return Array.isArray(this.nodes) ? nc(this.nodes) : "";
    };
    qe.prototype.walk = function(t, e) {
        return rc(this.nodes, t, e), this;
    };
    qe.unit = tc();
    qe.walk = rc;
    qe.stringify = nc;
    ic.exports = qe;
});
var Rc = S((_C, Pc)=>{
    "use strict";
    var Pn = Object.prototype.hasOwnProperty, Tc = Object.prototype.toString, kc = Object.defineProperty, Cc = Object.getOwnPropertyDescriptor, Ec = function(e) {
        return typeof Array.isArray == "function" ? Array.isArray(e) : Tc.call(e) === "[object Array]";
    }, Ac = function(e) {
        if (!e || Tc.call(e) !== "[object Object]") return !1;
        var r = Pn.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Pn.call(e.constructor.prototype, "isPrototypeOf");
        if (e.constructor && !r && !n) return !1;
        var i;
        for(i in e);
        return typeof i > "u" || Pn.call(e, i);
    }, Oc = function(e, r) {
        kc && r.name === "__proto__" ? kc(e, r.name, {
            enumerable: !0,
            configurable: !0,
            value: r.newValue,
            writable: !0
        }) : e[r.name] = r.newValue;
    }, _c = function(e, r) {
        if (r === "__proto__") if (Pn.call(e, r)) {
            if (Cc) return Cc(e, r).value;
        } else return;
        return e[r];
    };
    Pc.exports = function t() {
        var e, r, n, i, s, a, o = arguments[0], l = 1, u = arguments.length, f = !1;
        for(typeof o == "boolean" && (f = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); l < u; ++l)if (e = arguments[l], e != null) for(r in e)n = _c(o, r), i = _c(e, r), o !== i && (f && i && (Ac(i) || (s = Ec(i))) ? (s ? (s = !1, a = n && Ec(n) ? n : []) : a = n && Ac(n) ? n : {}, Oc(o, {
            name: r,
            newValue: t(f, a, i)
        })) : typeof i < "u" && Oc(o, {
            name: r,
            newValue: i
        }));
        return o;
    };
});
var Rn = S((TC, Ic)=>{
    var da = function(t, e) {
        var r = new t.constructor;
        return Object.keys(t).forEach(function(n) {
            if (!!t.hasOwnProperty(n)) {
                var i = t[n], s = typeof i;
                n === "parent" && s === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : i instanceof Array ? n === "nodes" ? r[n] = [] : r[n] = i.map(function(a) {
                    da(a, r);
                }) : n !== "before" && n !== "after" && n !== "between" && n !== "semicolon" && (s === "object" && (i = da(i)), r[n] = i);
            }
        }), r;
    };
    Ic.exports = da;
});
var Nc = S((PC, Fc)=>{
    "use strict";
    Fc.exports = Mc;
    function Mc(t, e, r) {
        t instanceof RegExp && (t = Dc(t, r)), e instanceof RegExp && (e = Dc(e, r));
        var n = Lc(t, e, r);
        return n && {
            start: n[0],
            end: n[1],
            pre: r.slice(0, n[0]),
            body: r.slice(n[0] + t.length, n[1]),
            post: r.slice(n[1] + e.length)
        };
    }
    function Dc(t, e) {
        var r = e.match(t);
        return r ? r[0] : null;
    }
    Mc.range = Lc;
    function Lc(t, e, r) {
        var n, i, s, a, o, l = r.indexOf(t), u = r.indexOf(e, l + 1), f = l;
        if (l >= 0 && u > 0) {
            if (t === e) return [
                l,
                u
            ];
            for(n = [], s = r.length; f >= 0 && !o;)f == l ? (n.push(f), l = r.indexOf(t, f + 1)) : n.length == 1 ? o = [
                n.pop(),
                u
            ] : (i = n.pop(), i < s && (s = i, a = u), u = r.indexOf(e, f + 1)), f = l < u && l >= 0 ? l : u;
            n.length && (o = [
                s,
                a
            ]);
        }
        return o;
    }
});
var $c = S((RC, qc)=>{
    var A0 = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, O0 = function(t) {
        return t.split(A0).filter(function(e) {
            return e.length > 0;
        }).map(function(e) {
            return e.trim().replace(/\s*?>>\s*?/g, "");
        });
    };
    qc.exports = O0;
});
var dr = S((IC, Uc)=>{
    var _0 = $c(), T0 = function(t, e) {
        e = e || !1;
        for(var r = [
            []
        ], n = e ? t : t.parent; n;){
            var i = (n.selectors || []).map(function(a) {
                return {
                    value: a,
                    type: "selector"
                };
            });
            n.type === "atrule" && (i = [].concat(n.params).map(function(a) {
                return {
                    value: "@" + n.name + " " + a,
                    type: "atrule"
                };
            }));
            var s = (i.length > 0 ? i : [
                1
            ]).map(function() {
                return r.map(function(a) {
                    return a.slice(0);
                });
            });
            i.forEach(function(a, o) {
                s[o] = s[o].map(function(l) {
                    var u = [
                        a.value
                    ];
                    return a.type === "selector" && (u = _0(a.value)), l.unshift.apply(l, u), l;
                });
            }), r = [], s.forEach(function(a) {
                r = r.concat(a);
            }), n = n.parent;
        }
        return r;
    };
    Uc.exports = T0;
});
var zc = S((DC, jc)=>{
    "use strict";
    var P0 = /[|\\{}()[\]^$+*?.]/g;
    jc.exports = function(t) {
        if (typeof t != "string") throw new TypeError("Expected a string");
        return t.replace(P0, "\\$&");
    };
});
var Wc = S((MC, Vc)=>{
    var R0 = {
        "*": !0,
        ":root": !0,
        html: !0
    }, I0 = function(t) {
        return !!R0[t];
    };
    Vc.exports = I0;
});
var Gc = S((LC, Bc)=>{
    var D0 = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, M0 = function(t) {
        return t.split(D0).filter(function(e) {
            return e.length > 0;
        }).map(function(e) {
            return e.trim().replace(/\s*?>\s*?/g, "");
        });
    };
    Bc.exports = M0;
});
var ha = S((FC, Zc)=>{
    var L0 = zc(), Yc = Wc(), Hc = Gc(), F0 = /^@.*/, Jc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
    function Xc(t, e) {
        var r, n, i = e.some(function(s) {
            return t.some(function(a) {
                r = null;
                var o = !0;
                for(n = 0; n < s.length; n++){
                    for(var l = s[n], u = r || 0, f = -1, p = a.slice(u), c = 0; c < p.length; c++){
                        var d = p[c], h = u + c;
                        if (new RegExp(L0(l) + "$").test(d)) {
                            f = h;
                            break;
                        }
                        if (Yc(l) || Yc(d)) {
                            f = h;
                            break;
                        }
                        var y = Hc(d);
                        if (y.length > 1) {
                            var m = [].concat([
                                y
                            ]), g = [].concat([
                                s.slice(n).reduce(function(v, C) {
                                    return v.concat(Hc(C));
                                }, [])
                            ]), w = Xc(m, g);
                            (w.doesMatchScope || n + 1 < s.length) && (f = h, n += w.scopePieceIndex - 1);
                            break;
                        }
                    }
                    var b = f >= u;
                    if (r = f + 1, o = o && b, !o) break;
                }
                return o;
            });
        });
        return {
            doesMatchScope: i,
            nodeScopePieceIndex: r - 1,
            scopePieceIndex: n
        };
    }
    var Qc = function(t) {
        return t.map(function(e) {
            return e.map(function(r) {
                return F0.test(r) ? r : r.replace(new RegExp(Jc.source, "g"), function(n, i, s, a) {
                    return i + a;
                });
            });
        });
    }, Kc = function(t, e, r) {
        return t = Qc(t), r && (e = Qc(e)), Xc(t, e).doesMatchScope;
    };
    Kc.RE_PSEUDO_SELECTOR = Jc;
    Zc.exports = Kc;
});
var ma = S((NC, tp)=>{
    var N0 = ha(), ep = dr(), q0 = function(t, e, r) {
        var n = ep(t, !0), i = ep(e, !0);
        return N0(n, i, r);
    };
    tp.exports = q0;
});
var ga = S((qC, np)=>{
    var rp = function(t, e, r) {
        r = r || [];
        var n = !1;
        return t && (r = t.reduce(function(i, s) {
            var a = !!e[s], o = a ? i.some(function(l) {
                return e[s].some(function(u) {
                    return l === u;
                });
            }) : !1;
            return n = n || o, a && !n && (i = i.concat(e[s]), (e[s] || []).forEach(function(l) {
                var u = rp(l.variablesUsed, e, i);
                i = u.deps, n = n || u.hasCircularOrSelfReference;
            })), i;
        }, r)), {
            deps: r,
            hasCircularOrSelfReference: n
        };
    };
    np.exports = rp;
});
var ya = S(($C, ip)=>{
    var $0 = dr(), U0 = function(t, e) {
        for(var r, n = e; n.parent && !r;){
            var i = $0(n.clone(), !0);
            i.some(function(s) {
                return s.some(function(a) {
                    return a === t ? (r = n, !0) : !1;
                });
            }), n = n.parent;
        }
        return r;
    };
    ip.exports = U0;
});
var wa = S((UC, ap)=>{
    var sp = Rn(), j0 = function(t, e, r) {
        r = r || function() {
            return !0;
        };
        for(var n = [], i = t, s = !1; i && !s;)i.type === "decl" ? n.push(i.clone()) : n.push(sp(i)), s = r(i), i = i.parent;
        for(var a = [], o = e; o;)a.push(sp(o)), o = o.parent;
        return a.forEach(function(l, u, f) {
            u + 1 < f.length && (l.parent = f[u + 1]);
        }), n.forEach(function(l, u, f) {
            u + 1 < f.length ? l.parent = f[u + 1] : (a.slice(-1)[0].parent = i, l.parent = a[0]);
        }), n[0];
    };
    ap.exports = j0;
});
var va = S((jC, lp)=>{
    var z0 = Nc(), V0 = dr(), op = ma(), W0 = ga(), B0 = ya(), G0 = wa(), Y0 = /var\(\s*(--[^,\s)]+)/;
    function H0(t) {
        return String(t);
    }
    function In(t) {
        var e = z0("(", ")", t);
        if (e) {
            if (/(?:^|[^\w-])var$/.test(e.pre)) return {
                pre: e.pre.slice(0, -3),
                body: e.body,
                post: e.post
            };
            var r = In(e.body);
            if (r) return {
                pre: e.pre + "(" + r.pre,
                body: r.body,
                post: r.post + ")" + e.post
            };
            var n = In(e.post);
            if (n) return {
                pre: e.pre + "(" + e.body + ")" + n.pre,
                body: n.body,
                post: n.post
            };
        }
    }
    var Dn = function(t, e, r, n) {
        for(var i = n ? "	" : "", s = void 0, a = H0(t.value), o = [], l = {}, u = a; s = In(u);){
            var f = s.body.split(","), p = f[0].trim();
            l[p] = !0, u = (s.pre || "") + s.body.replace(p, "") + (s.post || "");
        }
        u = void 0;
        for(var c = Object.keys(l), d = !1; s = In(a);){
            var h = void 0, f = s.body.split(","), p = f[0].trim(), y = f.length > 1 ? f.slice(1).join(",").trim() : void 0;
            (e[p] || []).forEach(function(O) {
                var E = O.parent.type === "root" || O.parent.selectors[0] === ":root", R = op(t.parent, O.parent), L = op(t.parent, O.parent, r);
                L && (!(h || {}).isImportant || O.isImportant) && (h = O);
            });
            var m = (h || {}).calculatedInPlaceValue || function() {
                var O = y;
                if (y) {
                    var E = t.clone({
                        parent: t.parent,
                        value: y
                    });
                    O = Dn(E, e, !1, !0).value;
                }
                return O;
            }();
            if (h !== void 0 && !W0(c, e).hasCircularOrSelfReference) {
                var g = V0(t.parent.parent, !0), w = g[0].slice(-1)[0], b = B0(w, h.decl.parent), v = G0(h.decl, t.parent.parent, function(O) {
                    return O === b;
                });
                m = Dn(v, e, !1, !0).value;
            }
            d = m === void 0, d && o.push([
                "variable " + p + " is undefined and used without a fallback",
                {
                    node: t
                }
            ]), a = (s.pre || "") + m + (s.post || "");
        }
        return {
            value: d ? void 0 : a,
            variablesUsed: c,
            warnings: o
        };
    };
    Dn.RE_VAR_FUNC = Y0;
    lp.exports = Dn;
});
var pp = S((zC, cp)=>{
    var up = va(), Q0 = dr(), J0 = ga(), fp = ha(), X0 = ma(), Mn = Rn(), K0 = ya(), Z0 = wa();
    function eb(t, e, r, n) {
        t.forEach(function(i) {
            J0(t, e).deps.forEach(function(s) {
                var a;
                if (s.isUnderAtRule) {
                    var o = Q0(s.parent, !0), l = o[0].slice(-1)[0], u = K0(l, r.parent), f = s.parent.parent;
                    a = Z0(r, f, function(h) {
                        return h === u;
                    });
                } else if (fp.RE_PSEUDO_SELECTOR.test(s.parent.selector)) {
                    var p = Mn(r.parent);
                    p.parent = r.parent.parent, a = r.clone(), p.append(a);
                    var c = s.parent.selector.match(new RegExp(fp.RE_PSEUDO_SELECTOR.source + "$")), d = c ? c[2] : "";
                    p.selector += d;
                }
                a && X0(a, s.parent, !0) && n(a, s);
            });
        });
    }
    function tb(t, e, r, n, i) {
        r = (typeof r == "function" ? r(t) : r) || !1, n = n || !1;
        var s = function(l) {
            return i && i(l), l;
        }, a = s(up(t, e)), o;
        eb(a.variablesUsed, e, t, function(l, u) {
            var f = Mn(t.parent), p = t.clone();
            f.append(p);
            let c;
            if (typeof r == "function" ? c = r(t) : c = r, c === !0 && p.cloneAfter(), p.value = s(up(l, e, !0)).value, u.isUnderAtRule) {
                var d = Mn(u.parent.parent);
                d.append(f);
                for(var h = d, y = u.parent.parent; y.parent.type === "atrule";){
                    var m = Mn(y.parent);
                    m.append(h), h = m, y = y.parent;
                }
                t.parent.parent.insertAfter(n && o || t.parent, h), o = h;
            } else f.selector = l.parent.selector, t.parent.parent.insertAfter(n && o || t.parent, f);
        }), r === !0 && t.value !== a.value && t.cloneAfter(), a.value === void 0 && (a.value = "undefined"), t.value = a.value;
    }
    cp.exports = tb;
});
var gp = S((VC, ba)=>{
    var dp = Rc(), rb = Rn(), hp = va(), nb = pp(), mp = /(--(.+))/;
    function ib(t, e) {
        t.walkDecls(function(r) {
            mp.test(r.prop) && e(r);
        });
    }
    function sb(t) {
        for(var e = t; e && e.nodes.length <= 0;){
            var r = e.type !== "root" ? e : null;
            r ? (e = r.parent, r.remove()) : e = null;
        }
    }
    var ab = {
        preserve: !1,
        variables: {},
        preserveInjectedVariables: !0,
        preserveAtRulesOrder: !1
    };
    ba.exports = (t = {})=>{
        var e = dp({}, ab, t);
        return {
            postcssPlugin: "postcss-css-variables",
            Once (r, { decl: n, result: i, rule: s }) {
                var a = [], o = [], l = {};
                l = dp(l, Object.keys(e.variables).reduce(function(p, c) {
                    var d = e.variables[c];
                    c = c.slice(0, 2) === "--" ? c : "--" + c;
                    var h = (d || {}).value || d, y = (d || {}).isImportant || !1, m = s({
                        selector: ":root"
                    });
                    r.root().prepend(m);
                    var g = n({
                        prop: c,
                        value: h,
                        important: y
                    });
                    return m.append(g), e.preserveInjectedVariables || o.push(g), p[c] = (p[c] || []).concat({
                        decl: g,
                        prop: c,
                        calculatedInPlaceValue: h,
                        isImportant: y,
                        variablesUsed: [],
                        parent: m,
                        isUnderAtRule: !1
                    }), p;
                }, {}));
                var u = function(p) {
                    var c = [].concat(p.warnings);
                    return c.forEach(function(d) {
                        d = [].concat(d), i.warn.apply(i, d);
                    }), p;
                };
                ib(r, function(p) {
                    var c = p.parent, d = u(hp(p, l));
                    p.parent.selectors.forEach(function(y) {
                        var m = rb(p.parent);
                        m.selector = y, m.parent = p.parent.parent;
                        var g = p.clone();
                        m.append(g);
                        var w = p.prop;
                        l[w] = (l[w] || []).concat({
                            decl: g,
                            prop: w,
                            calculatedInPlaceValue: d.value,
                            isImportant: p.important || !1,
                            variablesUsed: d.variablesUsed,
                            parent: m,
                            isUnderAtRule: m.parent.type === "atrule"
                        });
                    });
                    let h;
                    typeof e.preserve == "function" ? h = e.preserve(p) : h = e.preserve, h ? h === "computed" && (p.value = d.value) : p.remove(), c.nodes.length <= 0 && a.push(c);
                });
                var f = [];
                r.walk(function(p) {
                    if (p.nodes !== void 0) {
                        var c = p.nodes.some(function(d) {
                            if (d.type === "decl") {
                                var h = d;
                                if (hp.RE_VAR_FUNC.test(h.value) && !mp.test(h.prop)) return !0;
                            }
                            return !1;
                        });
                        c && f.push(p);
                    }
                }), f.forEach(function(p) {
                    var c = [].concat(p);
                    p.type === "rule" && p.selectors.length > 1 && (c = p.selectors.reverse().map(function(d) {
                        var h = p.cloneAfter();
                        return h.selector = d, h;
                    }), p.remove()), c.forEach(function(d) {
                        d.nodes.slice(0).forEach(function(h) {
                            if (h.type === "decl") {
                                var y = h;
                                nb(y, l, e.preserve, e.preserveAtRulesOrder, u);
                            }
                        });
                    });
                }), a.forEach(sb), o.forEach(function(p) {
                    p.remove();
                });
            }
        };
    };
    ba.exports.postcss = !0;
});
var lb = {};
He(lb, {
    tailwindToCSS: ()=>Sa,
    twToCSS: ()=>Cp,
    twi: ()=>xa,
    twj: ()=>kp
});
module.exports = ke(lb);
var Pa = (t)=>({
        extractCSS (e, r = !1) {
            let n = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i, s = {};
            for(; (i = n.exec(e)) !== null;){
                let { prop: a, value: o } = i.groups;
                s[a] = o;
            }
            return Object.entries(s).reduce((a, [o, l])=>a + `${r ? "	" : ""}${o}: ${l}; 
\r`, "");
        },
        merge () {
            let e = /(?<=\.)[^{]+\s*\{(?<content>[^{}]*(?:(?<=;)\s*\n\r?[^{}]*)*)\s*\}/gm, r, n = "";
            for(; (r = e.exec(t)) !== null;){
                let { content: o } = r.groups;
                n += o;
            }
            let i = this.extractCSS(n), s = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, a;
            for(; (a = s.exec(t)) !== null;){
                let { media: o, content: l } = a.groups;
                i += `
\r${o} {
\r${this.extractCSS(l, !0)}}
\r`;
            }
            return t = i, this;
        },
        removeUndefined () {
            let e = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
            return t = t.replace(e, ""), this;
        },
        combineMediaQueries () {
            let e = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r = new Map, n = (s)=>s.replace(e, (a, o, l)=>{
                    var f;
                    let u = (f = r.get(o)) != null ? f : "";
                    return r.set(o, u + n(l.trim())), n(l), "";
                }), i = [];
            return i.push(n(t)), i.push(...Array.from(r, ([s, a])=>`@media${s}{${a}}`)), t = i.join(""), this;
        },
        minify () {
            return t = t.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
        },
        fixRGB () {
            let e = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r;
            for(; (r = e.exec(t)) !== null;){
                let [n] = r, { red: i, green: s, blue: a, alpha: o = 1 } = r.groups;
                t = t.replace(n, `rgb(${i},${s},${a}${o === "1" ? "" : `,${o}`})`);
            }
            return this;
        },
        removeMediaQueries () {
            return t = t.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
        },
        get () {
            return t;
        }
    });
function Fn() {}
var D = {
    info: Fn,
    warn: Fn,
    risk: Fn
};
function Nn(t) {
    let e = new Set, r = new Set, n = new Set;
    if (t.walkAtRules((i)=>{
        i.name === "apply" && n.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), e.add(i.params)), [
            "layer",
            "responsive",
            "variants"
        ].includes(i.name) && ([
            "responsive",
            "variants"
        ].includes(i.name) && D.warn(`${i.name}-at-rule-deprecated`, [
            `The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
            "Use `@layer utilities` or `@layer components` instead.",
            "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
        ]), r.add(i));
    }), !e.has("base") || !e.has("components") || !e.has("utilities")) {
        for (let i of r)if (i.name === "layer" && [
            "base",
            "components",
            "utilities"
        ].includes(i.params)) {
            if (!e.has(i.params)) throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
        } else if (i.name === "responsive") {
            if (!e.has("utilities")) throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
        } else if (i.name === "variants" && !e.has("utilities")) throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
    }
    return {
        tailwindDirectives: e,
        applyDirectives: n
    };
}
yr();
var $f = Y(La());
var Na = "3.2.7";
var $n = {
    name: "tailwindcss",
    version: Na,
    description: "A utility-first CSS framework for rapidly building custom user interfaces.",
    license: "MIT",
    main: "lib/index.js",
    types: "types/index.d.ts",
    repository: "https://github.com/tailwindlabs/tailwindcss.git",
    bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
    homepage: "https://tailwindcss.com",
    bin: {
        tailwind: "lib/cli.js",
        tailwindcss: "lib/cli.js"
    },
    tailwindcss: {
        engine: "stable"
    },
    scripts: {
        prebuild: "npm run generate && rimraf lib",
        build: "swc src --out-dir lib --copy-files",
        postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
        "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
        style: "eslint .",
        pretest: "npm run generate",
        test: "jest",
        "test:integrations": "npm run test --prefix ./integrations",
        "install:integrations": "node scripts/install-integrations.js",
        "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
        "generate:types": "node -r @swc/register scripts/generate-types.js",
        generate: "npm run generate:plugin-list && npm run generate:types",
        "release-channel": "node ./scripts/release-channel.js",
        "release-notes": "node ./scripts/release-notes.js",
        prepublishOnly: "npm install --force && npm run build"
    },
    files: [
        "src/*",
        "cli/*",
        "lib/*",
        "peers/*",
        "scripts/*.js",
        "stubs/*.stub.js",
        "nesting/*",
        "types/**/*",
        "*.d.ts",
        "*.css",
        "*.js"
    ],
    devDependencies: {
        "@swc/cli": "0.1.59",
        "@swc/core": "1.3.24",
        "@swc/jest": "0.2.24",
        "@swc/register": "0.1.10",
        autoprefixer: "^10.4.13",
        browserslist: "^4.21.4",
        concurrently: "^7.5.0",
        cssnano: "^5.1.14",
        esbuild: "^0.16.10",
        eslint: "^8.31.0",
        "eslint-config-prettier": "^8.6.0",
        "eslint-plugin-prettier": "^4.2.1",
        jest: "^28.1.3",
        "jest-diff": "^28.1.3",
        lightningcss: "^1.18.0",
        prettier: "^2.8.1",
        rimraf: "^3.0.0",
        "source-map-js": "^1.0.2",
        turbo: "^1.6.3"
    },
    peerDependencies: {
        postcss: "^8.0.9"
    },
    dependencies: {
        arg: "^5.0.2",
        chokidar: "^3.5.3",
        "color-name": "^1.1.4",
        detective: "^5.2.1",
        didyoumean: "^1.2.2",
        dlv: "^1.1.3",
        "fast-glob": "^3.2.12",
        "glob-parent": "^6.0.2",
        "is-glob": "^4.0.3",
        lilconfig: "^2.0.6",
        micromatch: "^4.0.5",
        "normalize-path": "^3.0.0",
        "object-hash": "^3.0.0",
        picocolors: "^1.0.0",
        postcss: "^8.0.9",
        "postcss-import": "^14.1.0",
        "postcss-js": "^4.0.0",
        "postcss-load-config": "^3.1.4",
        "postcss-nested": "6.0.0",
        "postcss-selector-parser": "^6.0.11",
        "postcss-value-parser": "^4.2.0",
        "quick-lru": "^5.1.1",
        resolve: "^1.22.1"
    },
    browserslist: [
        "> 1%",
        "not edge <= 18",
        "not ie 11",
        "not op_mini all"
    ],
    jest: {
        testTimeout: 3e4,
        setupFilesAfterEnv: [
            "<rootDir>/jest/customMatchers.js"
        ],
        testPathIgnorePatterns: [
            "/node_modules/",
            "/integrations/",
            "/standalone-cli/",
            "\\.test\\.skip\\.js$"
        ],
        transformIgnorePatterns: [
            "node_modules/(?!lightningcss)"
        ],
        transform: {
            "\\.js$": "@swc/jest",
            "\\.ts$": "@swc/jest"
        }
    },
    engines: {
        node: ">=12.13.0"
    }
};
var Rp = $n.tailwindcss.engine === "oxide", Un = {
    NODE_ENV: "production",
    DEBUG: Dp(void 0),
    ENGINE: $n.tailwindcss.engine,
    OXIDE: Ip(void 0, Rp)
};
var jn = new Map;
var Ce = new String("*"), mt = Symbol("__NONE__");
function Ip(t, e) {
    return t === void 0 ? e : !(t === "0" || t === "false");
}
function Dp(t) {
    if (t === void 0) return !1;
    if (t === "true" || t === "1") return !0;
    if (t === "false" || t === "0") return !1;
    if (t === "*") return !0;
    let e = t.split(",").map((r)=>r.split(":")[0]);
    return e.includes("-tailwindcss") ? !1 : !!e.includes("tailwindcss");
}
var $ = Y(et(), 1), I = $.default, Zb = $.default.stringify, ex = $.default.fromJSON, tx = $.default.plugin, rx = $.default.parse, nx = $.default.list, ix = $.default.document, sx = $.default.comment, ax = $.default.atRule, ox = $.default.rule, lx = $.default.decl, ux = $.default.root, fx = $.default.CssSyntaxError, cx = $.default.Declaration, px = $.default.Container, dx = $.default.Processor, hx = $.default.Document, mx = $.default.Comment, gx = $.default.Warning, yx = $.default.AtRule, wx = $.default.Result, vx = $.default.Input, bx = $.default.Rule, xx = $.default.Root, Sx = $.default.Node;
var yn = Y(Oe());
var Nu = Y(bu());
var it = Y(Fu(), 1), en = it.default, zx = it.default.objectify, Vx = it.default.parse, Wx = it.default.async, Bx = it.default.sync;
function st(t) {
    return Array.isArray(t) ? t.flatMap((e)=>I([
            (0, Nu.default)({
                bubble: [
                    "screen"
                ]
            })
        ]).process(e, {
            parser: en
        }).root.nodes) : st([
        t
    ]);
}
function X(t) {
    if (Object.prototype.toString.call(t) !== "[object Object]") return !1;
    let e = Object.getPrototypeOf(t);
    return e === null || e === Object.prototype;
}
var qu = Y(Oe());
function at(t, e, r = !1) {
    if (t === "") return e;
    let n = typeof e == "string" ? (0, qu.default)().astSync(e) : e;
    return n.walkClasses((i)=>{
        let s = i.value, a = r && s.startsWith("-");
        i.value = a ? `-${t}${s.slice(1)}` : `${t}${s}`;
    }), typeof e == "string" ? n.toString() : n;
}
function Be(t) {
    return t.replace(/\\,/g, "\\2c ");
}
var bs = Y(Uu()), Aw = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, Ow = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, Re = /(?:\d+|\d*\.\d+)%?/, tn = /(?:\s*,\s*|\s+)/, ju = /\s*[,/]\s*/, Ie = /var\(--(?:[^ )]*?)\)/, _w = new RegExp(`^(rgba?)\\(\\s*(${Re.source}|${Ie.source})(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${ju.source}(${Re.source}|${Ie.source}))?\\s*\\)$`), Tw = new RegExp(`^(hsla?)\\(\\s*((?:${Re.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${tn.source}(${Re.source}|${Ie.source}))?(?:${ju.source}(${Re.source}|${Ie.source}))?\\s*\\)$`);
function ir(t, { loose: e = !1 } = {}) {
    var s, a, o;
    if (typeof t != "string") return null;
    if (t = t.trim(), t === "transparent") return {
        mode: "rgb",
        color: [
            "0",
            "0",
            "0"
        ],
        alpha: "0"
    };
    if (t in bs.default) return {
        mode: "rgb",
        color: bs.default[t].map((l)=>l.toString())
    };
    let r = t.replace(Ow, (l, u, f, p, c)=>[
            "#",
            u,
            u,
            f,
            f,
            p,
            p,
            c ? c + c : ""
        ].join("")).match(Aw);
    if (r !== null) return {
        mode: "rgb",
        color: [
            parseInt(r[1], 16),
            parseInt(r[2], 16),
            parseInt(r[3], 16)
        ].map((l)=>l.toString()),
        alpha: r[4] ? (parseInt(r[4], 16) / 255).toString() : void 0
    };
    let n = (s = t.match(_w)) != null ? s : t.match(Tw);
    if (n === null) return null;
    let i = [
        n[2],
        n[3],
        n[4]
    ].filter(Boolean).map((l)=>l.toString());
    return i.length === 2 && i[0].startsWith("var(") ? {
        mode: n[1],
        color: [
            i[0]
        ],
        alpha: i[1]
    } : !e && i.length !== 3 || i.length < 3 && !i.some((l)=>/^var\(.*?\)$/.test(l)) ? null : {
        mode: n[1],
        color: i,
        alpha: (o = (a = n[5]) == null ? void 0 : a.toString) == null ? void 0 : o.call(a)
    };
}
function xs({ mode: t, color: e, alpha: r }) {
    let n = r !== void 0;
    return t === "rgba" || t === "hsla" ? `${t}(${e.join(", ")}${n ? `, ${r}` : ""})` : `${t}(${e.join(" ")}${n ? ` / ${r}` : ""})`;
}
function ve(t, e, r) {
    if (typeof t == "function") return t({
        opacityValue: e
    });
    let n = ir(t, {
        loose: !0
    });
    return n === null ? r : xs({
        ...n,
        alpha: e
    });
}
function ee({ color: t, property: e, variable: r }) {
    let n = [].concat(e);
    if (typeof t == "function") return {
        [r]: "1",
        ...Object.fromEntries(n.map((s)=>[
                s,
                t({
                    opacityVariable: r,
                    opacityValue: `var(${r})`
                })
            ]))
    };
    let i = ir(t);
    return i === null ? Object.fromEntries(n.map((s)=>[
            s,
            t
        ])) : i.alpha !== void 0 ? Object.fromEntries(n.map((s)=>[
            s,
            t
        ])) : {
        [r]: "1",
        ...Object.fromEntries(n.map((s)=>[
                s,
                xs({
                    ...i,
                    alpha: `var(${r})`
                })
            ]))
    };
}
function te(t, e) {
    let r = [], n = [], i = 0;
    for(let s = 0; s < t.length; s++){
        let a = t[s];
        r.length === 0 && a === e[0] && (e.length === 1 || t.slice(s, s + e.length) === e) && (n.push(t.slice(i, s)), i = s + e.length), a === "(" || a === "[" || a === "{" ? r.push(a) : (a === ")" && r[r.length - 1] === "(" || a === "]" && r[r.length - 1] === "[" || a === "}" && r[r.length - 1] === "{") && r.pop();
    }
    return n.push(t.slice(i)), n;
}
var Pw = new Set([
    "inset",
    "inherit",
    "initial",
    "revert",
    "unset"
]), Rw = /\ +(?![^(]*\))/g, zu = /^-?(\d+|\.\d+)(.*?)$/g;
function rn(t) {
    return te(t, ",").map((r)=>{
        let n = r.trim(), i = {
            raw: n
        }, s = n.split(Rw), a = new Set;
        for (let o of s)zu.lastIndex = 0, !a.has("KEYWORD") && Pw.has(o) ? (i.keyword = o, a.add("KEYWORD")) : zu.test(o) ? a.has("X") ? a.has("Y") ? a.has("BLUR") ? a.has("SPREAD") || (i.spread = o, a.add("SPREAD")) : (i.blur = o, a.add("BLUR")) : (i.y = o, a.add("Y")) : (i.x = o, a.add("X")) : i.color ? (i.unknown || (i.unknown = []), i.unknown.push(o)) : i.color = o;
        return i.valid = i.x !== void 0 && i.y !== void 0, i;
    });
}
function Vu(t) {
    return t.map((e)=>e.valid ? [
            e.keyword,
            e.x,
            e.y,
            e.blur,
            e.spread,
            e.color
        ].filter(Boolean).join(" ") : e.raw).join(", ");
}
var Iw = [
    "min",
    "max",
    "clamp",
    "calc"
];
function Ss(t) {
    return Iw.some((e)=>new RegExp(`^${e}\\(.*\\)`).test(t));
}
var Wu = "--tw-placeholder", Dw = new RegExp(Wu, "g");
function z(t, e = !0) {
    return t.includes("url(") ? t.split(/(url\(.*?\))/g).filter(Boolean).map((r)=>/^url\(.*?\)$/.test(r) ? r : z(r, !1)).join("") : (t = t.replace(/([^\\])_+/g, (r, n)=>n + " ".repeat(r.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e && (t = t.trim()), t = t.replace(/(calc|min|max|clamp)\(.+\)/g, (r)=>{
        let n = [];
        return r.replace(/var\((--.+?)[,)]/g, (i, s)=>(n.push(s), i.replace(s, Wu))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(Dw, ()=>n.shift());
    }), t);
}
function ks(t) {
    return t.startsWith("url(");
}
function Cs(t) {
    return !isNaN(Number(t)) || Ss(t);
}
function sr(t) {
    return t.endsWith("%") && Cs(t.slice(0, -1)) || Ss(t);
}
var Mw = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], Lw = `(?:${Mw.join("|")})`;
function ar(t) {
    return t === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${Lw}$`).test(t) || Ss(t);
}
var Fw = new Set([
    "thin",
    "medium",
    "thick"
]);
function Bu(t) {
    return Fw.has(t);
}
function Gu(t) {
    let e = rn(z(t));
    for (let r of e)if (!r.valid) return !1;
    return !0;
}
function Yu(t) {
    let e = 0;
    return te(t, "_").every((n)=>(n = z(n), n.startsWith("var(") ? !0 : ir(n, {
            loose: !0
        }) !== null ? (e++, !0) : !1)) ? e > 0 : !1;
}
function Hu(t) {
    let e = 0;
    return te(t, ",").every((n)=>(n = z(n), n.startsWith("var(") ? !0 : ks(n) || qw(n) || [
            "element(",
            "image(",
            "cross-fade(",
            "image-set("
        ].some((i)=>n.startsWith(i)) ? (e++, !0) : !1)) ? e > 0 : !1;
}
var Nw = new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
]);
function qw(t) {
    t = z(t);
    for (let e of Nw)if (t.startsWith(`${e}(`)) return !0;
    return !1;
}
var $w = new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
]);
function Qu(t) {
    let e = 0;
    return te(t, "_").every((n)=>(n = z(n), n.startsWith("var(") ? !0 : $w.has(n) || ar(n) || sr(n) ? (e++, !0) : !1)) ? e > 0 : !1;
}
function Ju(t) {
    let e = 0;
    return te(t, ",").every((n)=>(n = z(n), n.startsWith("var(") ? !0 : n.includes(" ") && !/(['"])([^"']+)\1/g.test(n) || /^\d/g.test(n) ? !1 : (e++, !0))) ? e > 0 : !1;
}
var Uw = new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
]);
function Xu(t) {
    return Uw.has(t);
}
var jw = new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
]);
function Ku(t) {
    return jw.has(t);
}
var zw = new Set([
    "larger",
    "smaller"
]);
function Zu(t) {
    return zw.has(t);
}
function De(t) {
    if (t = `${t}`, t === "0") return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t)) return t.replace(/^[+-]?/, (r)=>r === "-" ? "" : "-");
    let e = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
    ];
    for (let r of e)if (t.includes(`${r}(`)) return `calc(${t} * -1)`;
}
function ef(t) {
    let e = [
        "cover",
        "contain"
    ];
    return te(t, ",").every((r)=>{
        let n = te(r, "_").filter(Boolean);
        return n.length === 1 && e.includes(n[0]) ? !0 : n.length !== 1 && n.length !== 2 ? !1 : n.every((i)=>ar(i) || sr(i) || i === "auto");
    });
}
Vn();
var tf = {
    optimizeUniversalDefaults: !1,
    generalizedModifiers: !0
}, nn = {
    future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
    ],
    experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
    ]
};
function G(t, e) {
    var r, n, i, s, a, o;
    return nn.future.includes(e) ? t.future === "all" || ((i = (n = (r = t == null ? void 0 : t.future) == null ? void 0 : r[e]) != null ? n : tf[e]) != null ? i : !1) : nn.experimental.includes(e) ? t.experimental === "all" || ((o = (a = (s = t == null ? void 0 : t.experimental) == null ? void 0 : s[e]) != null ? a : tf[e]) != null ? o : !1) : !1;
}
function rf(t) {
    var e;
    return t.experimental === "all" ? nn.experimental : Object.keys((e = t == null ? void 0 : t.experimental) != null ? e : {}).filter((r)=>nn.experimental.includes(r) && t.experimental[r]);
}
function nf(t) {
    if (1 === void 0 && rf(t).length > 0) {
        let e = rf(t).map((r)=>zn.yellow(r)).join(", ");
        D.warn("experimental-flags-enabled", [
            `You have enabled experimental features: ${e}`,
            "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
    }
}
function af(t, e) {
    t.walkClasses((r)=>{
        r.value = e(r.value), r.raws && r.raws.value && (r.raws.value = Be(r.raws.value));
    });
}
function of(t, e) {
    if (!Me(t)) return;
    let r = t.slice(1, -1);
    if (!!e(r)) return z(r);
}
function Vw(t, e = {}, r) {
    let n = e[t];
    if (n !== void 0) return De(n);
    if (Me(t)) {
        let i = of(t, r);
        return i === void 0 ? void 0 : De(i);
    }
}
function sn(t, e = {}, { validate: r = ()=>!0 } = {}) {
    var i;
    let n = (i = e.values) == null ? void 0 : i[t];
    return n !== void 0 ? n : e.supportsNegativeValues && t.startsWith("-") ? Vw(t.slice(1), e.values, r) : of(t, r);
}
function Me(t) {
    return t.startsWith("[") && t.endsWith("]");
}
function lf(t) {
    let e = t.lastIndexOf("/");
    return e === -1 || e === t.length - 1 ? [
        t,
        void 0
    ] : Me(t) && !t.includes("]/[") ? [
        t,
        void 0
    ] : [
        t.slice(0, e),
        t.slice(e + 1)
    ];
}
function ot(t) {
    if (typeof t == "string" && t.includes("<alpha-value>")) {
        let e = t;
        return ({ opacityValue: r = 1 })=>e.replace("<alpha-value>", r);
    }
    return t;
}
function Ww(t, e = {}, { tailwindConfig: r = {} } = {}) {
    var s, a, o, l, u, f;
    if (((s = e.values) == null ? void 0 : s[t]) !== void 0) return ot((a = e.values) == null ? void 0 : a[t]);
    let [n, i] = lf(t);
    if (i !== void 0) {
        let p = (l = (o = e.values) == null ? void 0 : o[n]) != null ? l : Me(n) ? n.slice(1, -1) : void 0;
        return p === void 0 ? void 0 : (p = ot(p), Me(i) ? ve(p, i.slice(1, -1)) : ((f = (u = r.theme) == null ? void 0 : u.opacity) == null ? void 0 : f[i]) === void 0 ? void 0 : ve(p, r.theme.opacity[i]));
    }
    return sn(t, e, {
        validate: Yu
    });
}
function Bw(t, e = {}) {
    var r;
    return (r = e.values) == null ? void 0 : r[t];
}
function oe(t) {
    return (e, r)=>sn(e, r, {
            validate: t
        });
}
var Es = {
    any: sn,
    color: Ww,
    url: oe(ks),
    image: oe(Hu),
    length: oe(ar),
    percentage: oe(sr),
    position: oe(Qu),
    lookup: Bw,
    "generic-name": oe(Xu),
    "family-name": oe(Ju),
    number: oe(Cs),
    "line-width": oe(Bu),
    "absolute-size": oe(Ku),
    "relative-size": oe(Zu),
    shadow: oe(Gu),
    size: oe(ef)
}, sf = Object.keys(Es);
function Gw(t, e) {
    let r = t.indexOf(e);
    return r === -1 ? [
        void 0,
        t
    ] : [
        t.slice(0, r),
        t.slice(r + 1)
    ];
}
function As(t, e, r, n) {
    if (r.values && e in r.values) for (let { type: s } of t != null ? t : []){
        let a = Es[s](e, r, {
            tailwindConfig: n
        });
        if (a !== void 0) return [
            a,
            s,
            null
        ];
    }
    if (Me(e)) {
        let s = e.slice(1, -1), [a, o] = Gw(s, ":");
        if (!/^[\w-_]+$/g.test(a)) o = s;
        else if (a !== void 0 && !sf.includes(a)) return [];
        if (o.length > 0 && sf.includes(a)) return [
            sn(`[${o}]`, r),
            a,
            null
        ];
    }
    let i = Os(t, e, r, n);
    for (let s of i)return s;
    return [];
}
function* Os(t, e, r, n) {
    var l, u;
    let i = G(n, "generalizedModifiers"), [s, a] = lf(e);
    if (i && r.modifiers != null && (r.modifiers === "any" || typeof r.modifiers == "object" && (a && Me(a) || a in r.modifiers)) || (s = e, a = void 0), a !== void 0 && s === "" && (s = "DEFAULT"), a !== void 0 && typeof r.modifiers == "object") {
        let f = (u = (l = r.modifiers) == null ? void 0 : l[a]) != null ? u : null;
        f !== null ? a = f : Me(a) && (a = a.slice(1, -1));
    }
    for (let { type: f } of t != null ? t : []){
        let p = Es[f](s, r, {
            tailwindConfig: n
        });
        p !== void 0 && (yield [
            p,
            f,
            a != null ? a : null
        ]);
    }
}
var be = Y(Oe()), cf = Y(Ur());
var uf = Y(Oe());
function re(t) {
    var r, n;
    let e = uf.default.className();
    return e.value = t, Be((n = (r = e == null ? void 0 : e.raws) == null ? void 0 : r.value) != null ? n : e.value);
}
var _s = ":merge";
function lt(t, { context: e, candidate: r }) {
    var a;
    let n = (a = e == null ? void 0 : e.tailwindConfig.prefix) != null ? a : "", i = t.map((o)=>{
        let l = (0, be.default)().astSync(o.format);
        return {
            ...o,
            ast: o.isArbitraryVariant ? l : at(n, l)
        };
    }), s = be.default.root({
        nodes: [
            be.default.selector({
                nodes: [
                    be.default.className({
                        value: re(r)
                    })
                ]
            })
        ]
    });
    for (let { ast: o } of i)[s, o] = Hw(s, o), o.walkNesting((l)=>l.replaceWith(...s.nodes[0].nodes)), s = o;
    return s;
}
function ff(t) {
    let e = [];
    for(; t.prev() && t.prev().type !== "combinator";)t = t.prev();
    for(; t && t.type !== "combinator";)e.push(t), t = t.next();
    return e;
}
function Yw(t) {
    return t.sort((e, r)=>e.type === "tag" && r.type === "class" ? -1 : e.type === "class" && r.type === "tag" ? 1 : e.type === "class" && r.type === "pseudo" && r.value.startsWith("::") ? -1 : e.type === "pseudo" && e.value.startsWith("::") && r.type === "class" ? 1 : t.index(e) - t.index(r)), t;
}
function Ps(t, e) {
    let r = !1;
    t.walk((n)=>{
        if (n.type === "class" && n.value === e) return r = !0, !1;
    }), r || t.remove();
}
function an(t, e, { context: r, candidate: n, base: i }) {
    var f, p;
    let s = (p = (f = r == null ? void 0 : r.tailwindConfig) == null ? void 0 : f.separator) != null ? p : ":";
    i = i != null ? i : n.split(new RegExp(`\\${s}(?![^[]*\\])`)).pop();
    let a = (0, be.default)().astSync(t);
    a.walkClasses((c)=>{
        c.raws && c.value.includes(i) && (c.raws.value = re((0, cf.default)(c.raws.value)));
    }), a.each((c)=>Ps(c, i));
    let o = Array.isArray(e) ? lt(e, {
        context: r,
        candidate: n
    }) : e;
    if (o === null) return a.toString();
    let l = be.default.comment({
        value: "/*__simple__*/"
    }), u = be.default.comment({
        value: "/*__simple__*/"
    });
    return a.walkClasses((c)=>{
        if (c.value !== i) return;
        let d = c.parent, h = o.nodes[0].nodes;
        if (d.nodes.length === 1) {
            c.replaceWith(...h);
            return;
        }
        let y = ff(c);
        d.insertBefore(y[0], l), d.insertAfter(y[y.length - 1], u);
        for (let g of h)d.insertBefore(y[0], g.clone());
        c.remove(), y = ff(l);
        let m = d.index(l);
        d.nodes.splice(m, y.length, ...Yw(be.default.selector({
            nodes: y
        })).nodes), l.remove(), u.remove();
    }), a.walkPseudos((c)=>{
        c.value === _s && c.replaceWith(c.nodes);
    }), a.each((c)=>{
        let d = pf(c);
        d.length > 0 && c.nodes.push(d.sort(Xw));
    }), a.toString();
}
function Hw(t, e) {
    let r = [];
    return t.walkPseudos((n)=>{
        n.value === _s && r.push({
            pseudo: n,
            value: n.nodes[0].toString()
        });
    }), e.walkPseudos((n)=>{
        if (n.value !== _s) return;
        let i = n.nodes[0].toString(), s = r.find((u)=>u.value === i);
        if (!s) return;
        let a = [], o = n.next();
        for(; o && o.type !== "combinator";)a.push(o), o = o.next();
        let l = o;
        s.pseudo.parent.insertAfter(s.pseudo, be.default.selector({
            nodes: a.map((u)=>u.clone())
        })), n.remove(), a.forEach((u)=>u.remove()), l && l.type === "combinator" && l.remove();
    }), [
        t,
        e
    ];
}
var Qw = [
    ":before",
    ":after",
    ":first-line",
    ":first-letter"
], Jw = [
    "::file-selector-button",
    "::-webkit-scrollbar",
    "::-webkit-scrollbar-button",
    "::-webkit-scrollbar-thumb",
    "::-webkit-scrollbar-track",
    "::-webkit-scrollbar-track-piece",
    "::-webkit-scrollbar-corner",
    "::-webkit-resizer"
];
function pf(t) {
    let e = [];
    for (let r of t.nodes)Ts(r) && (e.push(r), t.removeChild(r)), r != null && r.nodes && e.push(...pf(r));
    return e;
}
function Xw(t, e) {
    return t.type !== "pseudo" && e.type !== "pseudo" || t.type === "combinator" ^ e.type === "combinator" ? 0 : t.type === "pseudo" ^ e.type === "pseudo" ? (t.type === "pseudo") - (e.type === "pseudo") : Ts(t) - Ts(e);
}
function Ts(t) {
    return t.type !== "pseudo" || Jw.includes(t.value) ? !1 : t.value.startsWith("::") || Qw.includes(t.value);
}
function Rs(t) {
    return Be(`.${re(t)}`);
}
function on(t, e) {
    return Rs(or(t, e));
}
function or(t, e) {
    return e === "DEFAULT" ? t : e === "-" || e === "-DEFAULT" ? `-${t}` : e.startsWith("-") ? `-${t}${e}` : e.startsWith("/") ? `${t}${e}` : `${t}-${e}`;
}
var Cf = Y(Ms()), $s = Y(Oe());
function _e(t) {
    return [
        "fontSize",
        "outline"
    ].includes(t) ? (e)=>(typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e) : t === "fontFamily" ? (e)=>{
        typeof e == "function" && (e = e({}));
        let r = Array.isArray(e) && X(e[1]) ? e[0] : e;
        return Array.isArray(r) ? r.join(", ") : r;
    } : [
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
    ].includes(t) ? (e)=>(typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e) : [
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
    ].includes(t) ? (e)=>(typeof e == "function" && (e = e({})), typeof e == "string" && (e = I.list.comma(e).join(" ")), e) : (e, r = {})=>(typeof e == "function" && (e = e(r)), e);
}
yr();
kt();
function T(t, e = [
    [
        t,
        [
            t
        ]
    ]
], { filterDefault: r = !1, ...n } = {}) {
    let i = _e(t);
    return function({ matchUtilities: s, theme: a }) {
        var o;
        for (let l of e){
            let u = Array.isArray(l[0]) ? l : [
                l
            ];
            s(u.reduce((f, [p, c])=>Object.assign(f, {
                    [p]: (d)=>c.reduce((h, y)=>Array.isArray(y) ? Object.assign(h, {
                                [y[0]]: y[1]
                            }) : Object.assign(h, {
                                [y]: i(d)
                            }), {})
                }), {}), {
                ...n,
                values: r ? Object.fromEntries(Object.entries((o = a(t)) != null ? o : {}).filter(([f])=>f !== "DEFAULT")) : a(t)
            });
        }
    };
}
function Le(t) {
    return t = Array.isArray(t) ? t : [
        t
    ], t.map((e)=>{
        let r = e.values.map((n)=>n.raw !== void 0 ? n.raw : [
                n.min && `(min-width: ${n.min})`,
                n.max && `(max-width: ${n.max})`
            ].filter(Boolean).join(" and "));
        return e.not ? `not all and ${r}` : r;
    }).join(", ");
}
var Kw = new Set([
    "normal",
    "reverse",
    "alternate",
    "alternate-reverse"
]), Zw = new Set([
    "running",
    "paused"
]), ev = new Set([
    "none",
    "forwards",
    "backwards",
    "both"
]), tv = new Set([
    "infinite"
]), rv = new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
]), nv = [
    "cubic-bezier",
    "steps"
], iv = /\,(?![^(]*\))/g, sv = /\ +(?![^(]*\))/g, df = /^(-?[\d.]+m?s)$/, av = /^(\d+)$/;
function Ls(t) {
    return t.split(iv).map((r)=>{
        let n = r.trim(), i = {
            value: n
        }, s = n.split(sv), a = new Set;
        for (let o of s)!a.has("DIRECTIONS") && Kw.has(o) ? (i.direction = o, a.add("DIRECTIONS")) : !a.has("PLAY_STATES") && Zw.has(o) ? (i.playState = o, a.add("PLAY_STATES")) : !a.has("FILL_MODES") && ev.has(o) ? (i.fillMode = o, a.add("FILL_MODES")) : !a.has("ITERATION_COUNTS") && (tv.has(o) || av.test(o)) ? (i.iterationCount = o, a.add("ITERATION_COUNTS")) : !a.has("TIMING_FUNCTION") && rv.has(o) || !a.has("TIMING_FUNCTION") && nv.some((l)=>o.startsWith(`${l}(`)) ? (i.timingFunction = o, a.add("TIMING_FUNCTION")) : !a.has("DURATION") && df.test(o) ? (i.duration = o, a.add("DURATION")) : !a.has("DELAY") && df.test(o) ? (i.delay = o, a.add("DELAY")) : a.has("NAME") ? (i.unknown || (i.unknown = []), i.unknown.push(o)) : (i.name = o, a.add("NAME"));
        return i;
    });
}
var hf = (t)=>Object.assign({}, ...Object.entries(t != null ? t : {}).flatMap(([e, r])=>typeof r == "object" ? Object.entries(hf(r)).map(([n, i])=>({
                [e + (n === "DEFAULT" ? "" : `-${n}`)]: i
            })) : [
            {
                [`${e}`]: r
            }
        ])), H = hf;
function N(t) {
    return typeof t == "function" ? t({}) : t;
}
function Fe(t, e = !0) {
    return Array.isArray(t) ? t.map((r)=>{
        if (e && Array.isArray(r)) throw new Error("The tuple syntax is not supported for `screens`.");
        if (typeof r == "string") return {
            name: r.toString(),
            not: !1,
            values: [
                {
                    min: r,
                    max: void 0
                }
            ]
        };
        let [n, i] = r;
        return n = n.toString(), typeof i == "string" ? {
            name: n,
            not: !1,
            values: [
                {
                    min: i,
                    max: void 0
                }
            ]
        } : Array.isArray(i) ? {
            name: n,
            not: !1,
            values: i.map((s)=>mf(s))
        } : {
            name: n,
            not: !1,
            values: [
                mf(i)
            ]
        };
    }) : Fe(Object.entries(t != null ? t : {}), !1);
}
function ln(t) {
    return t.values.length !== 1 ? {
        result: !1,
        reason: "multiple-values"
    } : t.values[0].raw !== void 0 ? {
        result: !1,
        reason: "raw-values"
    } : t.values[0].min !== void 0 && t.values[0].max !== void 0 ? {
        result: !1,
        reason: "min-and-max"
    } : {
        result: !0,
        reason: null
    };
}
function gf(t, e, r) {
    let n = un(e, t), i = un(r, t), s = ln(n), a = ln(i);
    if (s.reason === "multiple-values" || a.reason === "multiple-values") throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (s.reason === "raw-values" || a.reason === "raw-values") throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (s.reason === "min-and-max" || a.reason === "min-and-max") throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    let { min: o, max: l } = n.values[0], { min: u, max: f } = i.values[0];
    e.not && ([o, l] = [
        l,
        o
    ]), r.not && ([u, f] = [
        f,
        u
    ]), o = o === void 0 ? o : parseFloat(o), l = l === void 0 ? l : parseFloat(l), u = u === void 0 ? u : parseFloat(u), f = f === void 0 ? f : parseFloat(f);
    let [p, c] = t === "min" ? [
        o,
        u
    ] : [
        f,
        l
    ];
    return p - c;
}
function un(t, e) {
    return typeof t == "object" ? t : {
        name: "arbitrary-screen",
        values: [
            {
                [e]: t
            }
        ]
    };
}
function mf({ "min-width": t, min: e = t, max: r, raw: n } = {}) {
    return {
        min: e,
        max: r,
        raw: n
    };
}
function fn(t, e) {
    t.walkDecls((r)=>{
        if (e.includes(r.prop)) {
            r.remove();
            return;
        }
        for (let n of e)r.value.includes(`/ var(${n})`) && (r.value = r.value.replace(`/ var(${n})`, ""));
    });
}
var ne = {
    pseudoElementVariants: ({ addVariant: t })=>{
        t("first-letter", "&::first-letter"), t("first-line", "&::first-line"), t("marker", [
            ({ container: e })=>(fn(e, [
                    "--tw-text-opacity"
                ]), "& *::marker"),
            ({ container: e })=>(fn(e, [
                    "--tw-text-opacity"
                ]), "&::marker")
        ]), t("selection", [
            "& *::selection",
            "&::selection"
        ]), t("file", "&::file-selector-button"), t("placeholder", "&::placeholder"), t("backdrop", "&::backdrop"), t("before", ({ container: e })=>(e.walkRules((r)=>{
                let n = !1;
                r.walkDecls("content", ()=>{
                    n = !0;
                }), n || r.prepend(I.decl({
                    prop: "content",
                    value: "var(--tw-content)"
                }));
            }), "&::before")), t("after", ({ container: e })=>(e.walkRules((r)=>{
                let n = !1;
                r.walkDecls("content", ()=>{
                    n = !0;
                }), n || r.prepend(I.decl({
                    prop: "content",
                    value: "var(--tw-content)"
                }));
            }), "&::after"));
    },
    pseudoClassVariants: ({ addVariant: t, matchVariant: e, config: r })=>{
        let n = [
            [
                "first",
                "&:first-child"
            ],
            [
                "last",
                "&:last-child"
            ],
            [
                "only",
                "&:only-child"
            ],
            [
                "odd",
                "&:nth-child(odd)"
            ],
            [
                "even",
                "&:nth-child(even)"
            ],
            "first-of-type",
            "last-of-type",
            "only-of-type",
            [
                "visited",
                ({ container: s })=>(fn(s, [
                        "--tw-text-opacity",
                        "--tw-border-opacity",
                        "--tw-bg-opacity"
                    ]), "&:visited")
            ],
            "target",
            [
                "open",
                "&[open]"
            ],
            "default",
            "checked",
            "indeterminate",
            "placeholder-shown",
            "autofill",
            "optional",
            "required",
            "valid",
            "invalid",
            "in-range",
            "out-of-range",
            "read-only",
            "empty",
            "focus-within",
            [
                "hover",
                G(r(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
            ],
            "focus",
            "focus-visible",
            "active",
            "enabled",
            "disabled"
        ].map((s)=>Array.isArray(s) ? s : [
                s,
                `&:${s}`
            ]);
        for (let [s, a] of n)t(s, (o)=>typeof a == "function" ? a(o) : a);
        let i = {
            group: (s, { modifier: a })=>a ? [
                    `:merge(.group\\/${re(a)})`,
                    " &"
                ] : [
                    ":merge(.group)",
                    " &"
                ],
            peer: (s, { modifier: a })=>a ? [
                    `:merge(.peer\\/${re(a)})`,
                    " ~ &"
                ] : [
                    ":merge(.peer)",
                    " ~ &"
                ]
        };
        for (let [s, a] of Object.entries(i))e(s, (o = "", l)=>{
            let u = z(typeof o == "function" ? o(l) : o);
            u.includes("&") || (u = "&" + u);
            let [f, p] = a("", l), c = null, d = null, h = 0;
            for(let y = 0; y < u.length; ++y){
                let m = u[y];
                m === "&" ? c = y : m === "'" || m === '"' ? h += 1 : c !== null && m === " " && !h && (d = y);
            }
            return c !== null && d === null && (d = u.length), u.slice(0, c) + f + u.slice(c + 1, d) + p + u.slice(d);
        }, {
            values: Object.fromEntries(n)
        });
    },
    directionVariants: ({ addVariant: t })=>{
        t("ltr", ()=>(D.warn("rtl-experimental", [
                "The RTL features in Tailwind CSS are currently in preview.",
                "Preview features are not covered by semver, and may be improved in breaking ways at any time."
            ]), '[dir="ltr"] &')), t("rtl", ()=>(D.warn("rtl-experimental", [
                "The RTL features in Tailwind CSS are currently in preview.",
                "Preview features are not covered by semver, and may be improved in breaking ways at any time."
            ]), '[dir="rtl"] &'));
    },
    reducedMotionVariants: ({ addVariant: t })=>{
        t("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config: t, addVariant: e })=>{
        let [r, n = ".dark"] = [].concat(t("darkMode", "media"));
        r === !1 && (r = "media", D.warn("darkmode-false", [
            "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
            "Change `darkMode` to `media` or remove it entirely.",
            "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ])), r === "class" ? e("dark", `${n} &`) : r === "media" && e("dark", "@media (prefers-color-scheme: dark)");
    },
    printVariant: ({ addVariant: t })=>{
        t("print", "@media print");
    },
    screenVariants: ({ theme: t, addVariant: e, matchVariant: r })=>{
        var g;
        let n = (g = t("screens")) != null ? g : {}, i = Object.values(n).every((w)=>typeof w == "string"), s = Fe(t("screens")), a = new Set([]);
        function o(w) {
            var b, v;
            return (v = (b = w.match(/(\D+)$/)) == null ? void 0 : b[1]) != null ? v : "(none)";
        }
        function l(w) {
            w !== void 0 && a.add(o(w));
        }
        function u(w) {
            return l(w), a.size === 1;
        }
        for (let w of s)for (let b of w.values)l(b.min), l(b.max);
        let f = a.size <= 1;
        function p(w) {
            return Object.fromEntries(s.filter((b)=>ln(b).result).map((b)=>{
                let { min: v, max: C } = b.values[0];
                if (w === "min" && v !== void 0) return b;
                if (w === "min" && C !== void 0) return {
                    ...b,
                    not: !b.not
                };
                if (w === "max" && C !== void 0) return b;
                if (w === "max" && v !== void 0) return {
                    ...b,
                    not: !b.not
                };
            }).map((b)=>[
                    b.name,
                    b
                ]));
        }
        function c(w) {
            return (b, v)=>gf(w, b.value, v.value);
        }
        let d = c("max"), h = c("min");
        function y(w) {
            return (b)=>{
                if (i) if (f) {
                    if (typeof b == "string" && !u(b)) return D.warn("minmax-have-mixed-units", [
                        "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                    ]), [];
                } else return D.warn("mixed-screen-units", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                ]), [];
                else return D.warn("complex-screen-config", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
                ]), [];
                return [
                    `@media ${Le(un(b, w))}`
                ];
            };
        }
        r("max", y("max"), {
            sort: d,
            values: i ? p("max") : {}
        });
        let m = "min-screens";
        for (let w of s)e(w.name, `@media ${Le(w)}`, {
            id: m,
            sort: i && f ? h : void 0,
            value: w
        });
        r("min", y("min"), {
            id: m,
            sort: h
        });
    },
    supportsVariants: ({ matchVariant: t, theme: e })=>{
        var r;
        t("supports", (n = "")=>{
            let i = z(n), s = /^\w*\s*\(/.test(i);
            return i = s ? i.replace(/\b(and|or|not)\b/g, " $1 ") : i, s ? `@supports ${i}` : (i.includes(":") || (i = `${i}: var(--tw)`), i.startsWith("(") && i.endsWith(")") || (i = `(${i})`), `@supports ${i}`);
        }, {
            values: (r = e("supports")) != null ? r : {}
        });
    },
    ariaVariants: ({ matchVariant: t, theme: e })=>{
        var r, n, i;
        t("aria", (s)=>`&[aria-${z(s)}]`, {
            values: (r = e("aria")) != null ? r : {}
        }), t("group-aria", (s, { modifier: a })=>a ? `:merge(.group\\/${a})[aria-${z(s)}] &` : `:merge(.group)[aria-${z(s)}] &`, {
            values: (n = e("aria")) != null ? n : {}
        }), t("peer-aria", (s, { modifier: a })=>a ? `:merge(.peer\\/${a})[aria-${z(s)}] ~ &` : `:merge(.peer)[aria-${z(s)}] ~ &`, {
            values: (i = e("aria")) != null ? i : {}
        });
    },
    dataVariants: ({ matchVariant: t, theme: e })=>{
        var r, n, i;
        t("data", (s)=>`&[data-${z(s)}]`, {
            values: (r = e("data")) != null ? r : {}
        }), t("group-data", (s, { modifier: a })=>a ? `:merge(.group\\/${a})[data-${z(s)}] &` : `:merge(.group)[data-${z(s)}] &`, {
            values: (n = e("data")) != null ? n : {}
        }), t("peer-data", (s, { modifier: a })=>a ? `:merge(.peer\\/${a})[data-${z(s)}] ~ &` : `:merge(.peer)[data-${z(s)}] ~ &`, {
            values: (i = e("data")) != null ? i : {}
        });
    },
    orientationVariants: ({ addVariant: t })=>{
        t("portrait", "@media (orientation: portrait)"), t("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant: t })=>{
        t("contrast-more", "@media (prefers-contrast: more)"), t("contrast-less", "@media (prefers-contrast: less)");
    }
}, he = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
].join(" "), xe = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
].join(" "), Se = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
].join(" "), yf = {
    preflight: ({ addBase: t })=>{
        let e = I.parse(ht.readFileSync(Qn("/", "./css/preflight.css"), "utf8"));
        t([
            I.comment({
                text: `! tailwindcss v${Na} | MIT License | https://tailwindcss.com`
            }),
            ...e.nodes
        ]);
    },
    container: (()=>{
        function t(r = []) {
            return r.flatMap((n)=>n.values.map((i)=>i.min)).filter((n)=>n !== void 0);
        }
        function e(r, n, i) {
            if (typeof i > "u") return [];
            if (!(typeof i == "object" && i !== null)) return [
                {
                    screen: "DEFAULT",
                    minWidth: 0,
                    padding: i
                }
            ];
            let s = [];
            i.DEFAULT && s.push({
                screen: "DEFAULT",
                minWidth: 0,
                padding: i.DEFAULT
            });
            for (let a of r)for (let o of n)for (let { min: l } of o.values)l === a && s.push({
                minWidth: a,
                padding: i[o.name]
            });
            return s;
        }
        return function({ addComponents: r, theme: n }) {
            let i = Fe(n("container.screens", n("screens"))), s = t(i), a = e(s, i, n("container.padding")), o = (u)=>{
                let f = a.find((p)=>p.minWidth === u);
                return f ? {
                    paddingRight: f.padding,
                    paddingLeft: f.padding
                } : {};
            }, l = Array.from(new Set(s.slice().sort((u, f)=>parseInt(u) - parseInt(f)))).map((u)=>({
                    [`@media (min-width: ${u})`]: {
                        ".container": {
                            "max-width": u,
                            ...o(u)
                        }
                    }
                }));
            r([
                {
                    ".container": Object.assign({
                        width: "100%"
                    }, n("container.center", !1) ? {
                        marginRight: "auto",
                        marginLeft: "auto"
                    } : {}, o(0))
                },
                ...l
            ]);
        };
    })(),
    accessibility: ({ addUtilities: t })=>{
        t({
            ".sr-only": {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: "0",
                margin: "-1px",
                overflow: "hidden",
                clip: "rect(0, 0, 0, 0)",
                whiteSpace: "nowrap",
                borderWidth: "0"
            },
            ".not-sr-only": {
                position: "static",
                width: "auto",
                height: "auto",
                padding: "0",
                margin: "0",
                overflow: "visible",
                clip: "auto",
                whiteSpace: "normal"
            }
        });
    },
    pointerEvents: ({ addUtilities: t })=>{
        t({
            ".pointer-events-none": {
                "pointer-events": "none"
            },
            ".pointer-events-auto": {
                "pointer-events": "auto"
            }
        });
    },
    visibility: ({ addUtilities: t })=>{
        t({
            ".visible": {
                visibility: "visible"
            },
            ".invisible": {
                visibility: "hidden"
            },
            ".collapse": {
                visibility: "collapse"
            }
        });
    },
    position: ({ addUtilities: t })=>{
        t({
            ".static": {
                position: "static"
            },
            ".fixed": {
                position: "fixed"
            },
            ".absolute": {
                position: "absolute"
            },
            ".relative": {
                position: "relative"
            },
            ".sticky": {
                position: "sticky"
            }
        });
    },
    inset: T("inset", [
        [
            "inset",
            [
                "top",
                "right",
                "bottom",
                "left"
            ]
        ],
        [
            [
                "inset-x",
                [
                    "left",
                    "right"
                ]
            ],
            [
                "inset-y",
                [
                    "top",
                    "bottom"
                ]
            ]
        ],
        [
            [
                "top",
                [
                    "top"
                ]
            ],
            [
                "right",
                [
                    "right"
                ]
            ],
            [
                "bottom",
                [
                    "bottom"
                ]
            ],
            [
                "left",
                [
                    "left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    isolation: ({ addUtilities: t })=>{
        t({
            ".isolate": {
                isolation: "isolate"
            },
            ".isolation-auto": {
                isolation: "auto"
            }
        });
    },
    zIndex: T("zIndex", [
        [
            "z",
            [
                "zIndex"
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    order: T("order", void 0, {
        supportsNegativeValues: !0
    }),
    gridColumn: T("gridColumn", [
        [
            "col",
            [
                "gridColumn"
            ]
        ]
    ]),
    gridColumnStart: T("gridColumnStart", [
        [
            "col-start",
            [
                "gridColumnStart"
            ]
        ]
    ]),
    gridColumnEnd: T("gridColumnEnd", [
        [
            "col-end",
            [
                "gridColumnEnd"
            ]
        ]
    ]),
    gridRow: T("gridRow", [
        [
            "row",
            [
                "gridRow"
            ]
        ]
    ]),
    gridRowStart: T("gridRowStart", [
        [
            "row-start",
            [
                "gridRowStart"
            ]
        ]
    ]),
    gridRowEnd: T("gridRowEnd", [
        [
            "row-end",
            [
                "gridRowEnd"
            ]
        ]
    ]),
    float: ({ addUtilities: t })=>{
        t({
            ".float-right": {
                float: "right"
            },
            ".float-left": {
                float: "left"
            },
            ".float-none": {
                float: "none"
            }
        });
    },
    clear: ({ addUtilities: t })=>{
        t({
            ".clear-left": {
                clear: "left"
            },
            ".clear-right": {
                clear: "right"
            },
            ".clear-both": {
                clear: "both"
            },
            ".clear-none": {
                clear: "none"
            }
        });
    },
    margin: T("margin", [
        [
            "m",
            [
                "margin"
            ]
        ],
        [
            [
                "mx",
                [
                    "margin-left",
                    "margin-right"
                ]
            ],
            [
                "my",
                [
                    "margin-top",
                    "margin-bottom"
                ]
            ]
        ],
        [
            [
                "mt",
                [
                    "margin-top"
                ]
            ],
            [
                "mr",
                [
                    "margin-right"
                ]
            ],
            [
                "mb",
                [
                    "margin-bottom"
                ]
            ],
            [
                "ml",
                [
                    "margin-left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    boxSizing: ({ addUtilities: t })=>{
        t({
            ".box-border": {
                "box-sizing": "border-box"
            },
            ".box-content": {
                "box-sizing": "content-box"
            }
        });
    },
    display: ({ addUtilities: t })=>{
        t({
            ".block": {
                display: "block"
            },
            ".inline-block": {
                display: "inline-block"
            },
            ".inline": {
                display: "inline"
            },
            ".flex": {
                display: "flex"
            },
            ".inline-flex": {
                display: "inline-flex"
            },
            ".table": {
                display: "table"
            },
            ".inline-table": {
                display: "inline-table"
            },
            ".table-caption": {
                display: "table-caption"
            },
            ".table-cell": {
                display: "table-cell"
            },
            ".table-column": {
                display: "table-column"
            },
            ".table-column-group": {
                display: "table-column-group"
            },
            ".table-footer-group": {
                display: "table-footer-group"
            },
            ".table-header-group": {
                display: "table-header-group"
            },
            ".table-row-group": {
                display: "table-row-group"
            },
            ".table-row": {
                display: "table-row"
            },
            ".flow-root": {
                display: "flow-root"
            },
            ".grid": {
                display: "grid"
            },
            ".inline-grid": {
                display: "inline-grid"
            },
            ".contents": {
                display: "contents"
            },
            ".list-item": {
                display: "list-item"
            },
            ".hidden": {
                display: "none"
            }
        });
    },
    aspectRatio: T("aspectRatio", [
        [
            "aspect",
            [
                "aspect-ratio"
            ]
        ]
    ]),
    height: T("height", [
        [
            "h",
            [
                "height"
            ]
        ]
    ]),
    maxHeight: T("maxHeight", [
        [
            "max-h",
            [
                "maxHeight"
            ]
        ]
    ]),
    minHeight: T("minHeight", [
        [
            "min-h",
            [
                "minHeight"
            ]
        ]
    ]),
    width: T("width", [
        [
            "w",
            [
                "width"
            ]
        ]
    ]),
    minWidth: T("minWidth", [
        [
            "min-w",
            [
                "minWidth"
            ]
        ]
    ]),
    maxWidth: T("maxWidth", [
        [
            "max-w",
            [
                "maxWidth"
            ]
        ]
    ]),
    flex: T("flex"),
    flexShrink: T("flexShrink", [
        [
            "flex-shrink",
            [
                "flex-shrink"
            ]
        ],
        [
            "shrink",
            [
                "flex-shrink"
            ]
        ]
    ]),
    flexGrow: T("flexGrow", [
        [
            "flex-grow",
            [
                "flex-grow"
            ]
        ],
        [
            "grow",
            [
                "flex-grow"
            ]
        ]
    ]),
    flexBasis: T("flexBasis", [
        [
            "basis",
            [
                "flex-basis"
            ]
        ]
    ]),
    tableLayout: ({ addUtilities: t })=>{
        t({
            ".table-auto": {
                "table-layout": "auto"
            },
            ".table-fixed": {
                "table-layout": "fixed"
            }
        });
    },
    borderCollapse: ({ addUtilities: t })=>{
        t({
            ".border-collapse": {
                "border-collapse": "collapse"
            },
            ".border-separate": {
                "border-collapse": "separate"
            }
        });
    },
    borderSpacing: ({ addDefaults: t, matchUtilities: e, theme: r })=>{
        t("border-spacing", {
            "--tw-border-spacing-x": 0,
            "--tw-border-spacing-y": 0
        }), e({
            "border-spacing": (n)=>({
                    "--tw-border-spacing-x": n,
                    "--tw-border-spacing-y": n,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                }),
            "border-spacing-x": (n)=>({
                    "--tw-border-spacing-x": n,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                }),
            "border-spacing-y": (n)=>({
                    "--tw-border-spacing-y": n,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                })
        }, {
            values: r("borderSpacing")
        });
    },
    transformOrigin: T("transformOrigin", [
        [
            "origin",
            [
                "transformOrigin"
            ]
        ]
    ]),
    translate: T("translate", [
        [
            [
                "translate-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-translate-x",
                    [
                        "transform",
                        he
                    ]
                ]
            ],
            [
                "translate-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-translate-y",
                    [
                        "transform",
                        he
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    rotate: T("rotate", [
        [
            "rotate",
            [
                [
                    "@defaults transform",
                    {}
                ],
                "--tw-rotate",
                [
                    "transform",
                    he
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    skew: T("skew", [
        [
            [
                "skew-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-skew-x",
                    [
                        "transform",
                        he
                    ]
                ]
            ],
            [
                "skew-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-skew-y",
                    [
                        "transform",
                        he
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    scale: T("scale", [
        [
            "scale",
            [
                [
                    "@defaults transform",
                    {}
                ],
                "--tw-scale-x",
                "--tw-scale-y",
                [
                    "transform",
                    he
                ]
            ]
        ],
        [
            [
                "scale-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-scale-x",
                    [
                        "transform",
                        he
                    ]
                ]
            ],
            [
                "scale-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-scale-y",
                    [
                        "transform",
                        he
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    transform: ({ addDefaults: t, addUtilities: e })=>{
        t("transform", {
            "--tw-translate-x": "0",
            "--tw-translate-y": "0",
            "--tw-rotate": "0",
            "--tw-skew-x": "0",
            "--tw-skew-y": "0",
            "--tw-scale-x": "1",
            "--tw-scale-y": "1"
        }), e({
            ".transform": {
                "@defaults transform": {},
                transform: he
            },
            ".transform-cpu": {
                transform: he
            },
            ".transform-gpu": {
                transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
            },
            ".transform-none": {
                transform: "none"
            }
        });
    },
    animation: ({ matchUtilities: t, theme: e, config: r })=>{
        var s;
        let n = (a)=>`${r("prefix")}${re(a)}`, i = Object.fromEntries(Object.entries((s = e("keyframes")) != null ? s : {}).map(([a, o])=>[
                a,
                {
                    [`@keyframes ${n(a)}`]: o
                }
            ]));
        t({
            animate: (a)=>{
                let o = Ls(a);
                return [
                    ...o.flatMap((l)=>i[l.name]),
                    {
                        animation: o.map(({ name: l, value: u })=>l === void 0 || i[l] === void 0 ? u : u.replace(l, n(l))).join(", ")
                    }
                ];
            }
        }, {
            values: e("animation")
        });
    },
    cursor: T("cursor"),
    touchAction: ({ addDefaults: t, addUtilities: e })=>{
        t("touch-action", {
            "--tw-pan-x": " ",
            "--tw-pan-y": " ",
            "--tw-pinch-zoom": " "
        });
        let r = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        e({
            ".touch-auto": {
                "touch-action": "auto"
            },
            ".touch-none": {
                "touch-action": "none"
            },
            ".touch-pan-x": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-x",
                "touch-action": r
            },
            ".touch-pan-left": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-left",
                "touch-action": r
            },
            ".touch-pan-right": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-right",
                "touch-action": r
            },
            ".touch-pan-y": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-y",
                "touch-action": r
            },
            ".touch-pan-up": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-up",
                "touch-action": r
            },
            ".touch-pan-down": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-down",
                "touch-action": r
            },
            ".touch-pinch-zoom": {
                "@defaults touch-action": {},
                "--tw-pinch-zoom": "pinch-zoom",
                "touch-action": r
            },
            ".touch-manipulation": {
                "touch-action": "manipulation"
            }
        });
    },
    userSelect: ({ addUtilities: t })=>{
        t({
            ".select-none": {
                "user-select": "none"
            },
            ".select-text": {
                "user-select": "text"
            },
            ".select-all": {
                "user-select": "all"
            },
            ".select-auto": {
                "user-select": "auto"
            }
        });
    },
    resize: ({ addUtilities: t })=>{
        t({
            ".resize-none": {
                resize: "none"
            },
            ".resize-y": {
                resize: "vertical"
            },
            ".resize-x": {
                resize: "horizontal"
            },
            ".resize": {
                resize: "both"
            }
        });
    },
    scrollSnapType: ({ addDefaults: t, addUtilities: e })=>{
        t("scroll-snap-type", {
            "--tw-scroll-snap-strictness": "proximity"
        }), e({
            ".snap-none": {
                "scroll-snap-type": "none"
            },
            ".snap-x": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
            },
            ".snap-y": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
            },
            ".snap-both": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
            },
            ".snap-mandatory": {
                "--tw-scroll-snap-strictness": "mandatory"
            },
            ".snap-proximity": {
                "--tw-scroll-snap-strictness": "proximity"
            }
        });
    },
    scrollSnapAlign: ({ addUtilities: t })=>{
        t({
            ".snap-start": {
                "scroll-snap-align": "start"
            },
            ".snap-end": {
                "scroll-snap-align": "end"
            },
            ".snap-center": {
                "scroll-snap-align": "center"
            },
            ".snap-align-none": {
                "scroll-snap-align": "none"
            }
        });
    },
    scrollSnapStop: ({ addUtilities: t })=>{
        t({
            ".snap-normal": {
                "scroll-snap-stop": "normal"
            },
            ".snap-always": {
                "scroll-snap-stop": "always"
            }
        });
    },
    scrollMargin: T("scrollMargin", [
        [
            "scroll-m",
            [
                "scroll-margin"
            ]
        ],
        [
            [
                "scroll-mx",
                [
                    "scroll-margin-left",
                    "scroll-margin-right"
                ]
            ],
            [
                "scroll-my",
                [
                    "scroll-margin-top",
                    "scroll-margin-bottom"
                ]
            ]
        ],
        [
            [
                "scroll-mt",
                [
                    "scroll-margin-top"
                ]
            ],
            [
                "scroll-mr",
                [
                    "scroll-margin-right"
                ]
            ],
            [
                "scroll-mb",
                [
                    "scroll-margin-bottom"
                ]
            ],
            [
                "scroll-ml",
                [
                    "scroll-margin-left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    scrollPadding: T("scrollPadding", [
        [
            "scroll-p",
            [
                "scroll-padding"
            ]
        ],
        [
            [
                "scroll-px",
                [
                    "scroll-padding-left",
                    "scroll-padding-right"
                ]
            ],
            [
                "scroll-py",
                [
                    "scroll-padding-top",
                    "scroll-padding-bottom"
                ]
            ]
        ],
        [
            [
                "scroll-pt",
                [
                    "scroll-padding-top"
                ]
            ],
            [
                "scroll-pr",
                [
                    "scroll-padding-right"
                ]
            ],
            [
                "scroll-pb",
                [
                    "scroll-padding-bottom"
                ]
            ],
            [
                "scroll-pl",
                [
                    "scroll-padding-left"
                ]
            ]
        ]
    ]),
    listStylePosition: ({ addUtilities: t })=>{
        t({
            ".list-inside": {
                "list-style-position": "inside"
            },
            ".list-outside": {
                "list-style-position": "outside"
            }
        });
    },
    listStyleType: T("listStyleType", [
        [
            "list",
            [
                "listStyleType"
            ]
        ]
    ]),
    appearance: ({ addUtilities: t })=>{
        t({
            ".appearance-none": {
                appearance: "none"
            }
        });
    },
    columns: T("columns", [
        [
            "columns",
            [
                "columns"
            ]
        ]
    ]),
    breakBefore: ({ addUtilities: t })=>{
        t({
            ".break-before-auto": {
                "break-before": "auto"
            },
            ".break-before-avoid": {
                "break-before": "avoid"
            },
            ".break-before-all": {
                "break-before": "all"
            },
            ".break-before-avoid-page": {
                "break-before": "avoid-page"
            },
            ".break-before-page": {
                "break-before": "page"
            },
            ".break-before-left": {
                "break-before": "left"
            },
            ".break-before-right": {
                "break-before": "right"
            },
            ".break-before-column": {
                "break-before": "column"
            }
        });
    },
    breakInside: ({ addUtilities: t })=>{
        t({
            ".break-inside-auto": {
                "break-inside": "auto"
            },
            ".break-inside-avoid": {
                "break-inside": "avoid"
            },
            ".break-inside-avoid-page": {
                "break-inside": "avoid-page"
            },
            ".break-inside-avoid-column": {
                "break-inside": "avoid-column"
            }
        });
    },
    breakAfter: ({ addUtilities: t })=>{
        t({
            ".break-after-auto": {
                "break-after": "auto"
            },
            ".break-after-avoid": {
                "break-after": "avoid"
            },
            ".break-after-all": {
                "break-after": "all"
            },
            ".break-after-avoid-page": {
                "break-after": "avoid-page"
            },
            ".break-after-page": {
                "break-after": "page"
            },
            ".break-after-left": {
                "break-after": "left"
            },
            ".break-after-right": {
                "break-after": "right"
            },
            ".break-after-column": {
                "break-after": "column"
            }
        });
    },
    gridAutoColumns: T("gridAutoColumns", [
        [
            "auto-cols",
            [
                "gridAutoColumns"
            ]
        ]
    ]),
    gridAutoFlow: ({ addUtilities: t })=>{
        t({
            ".grid-flow-row": {
                gridAutoFlow: "row"
            },
            ".grid-flow-col": {
                gridAutoFlow: "column"
            },
            ".grid-flow-dense": {
                gridAutoFlow: "dense"
            },
            ".grid-flow-row-dense": {
                gridAutoFlow: "row dense"
            },
            ".grid-flow-col-dense": {
                gridAutoFlow: "column dense"
            }
        });
    },
    gridAutoRows: T("gridAutoRows", [
        [
            "auto-rows",
            [
                "gridAutoRows"
            ]
        ]
    ]),
    gridTemplateColumns: T("gridTemplateColumns", [
        [
            "grid-cols",
            [
                "gridTemplateColumns"
            ]
        ]
    ]),
    gridTemplateRows: T("gridTemplateRows", [
        [
            "grid-rows",
            [
                "gridTemplateRows"
            ]
        ]
    ]),
    flexDirection: ({ addUtilities: t })=>{
        t({
            ".flex-row": {
                "flex-direction": "row"
            },
            ".flex-row-reverse": {
                "flex-direction": "row-reverse"
            },
            ".flex-col": {
                "flex-direction": "column"
            },
            ".flex-col-reverse": {
                "flex-direction": "column-reverse"
            }
        });
    },
    flexWrap: ({ addUtilities: t })=>{
        t({
            ".flex-wrap": {
                "flex-wrap": "wrap"
            },
            ".flex-wrap-reverse": {
                "flex-wrap": "wrap-reverse"
            },
            ".flex-nowrap": {
                "flex-wrap": "nowrap"
            }
        });
    },
    placeContent: ({ addUtilities: t })=>{
        t({
            ".place-content-center": {
                "place-content": "center"
            },
            ".place-content-start": {
                "place-content": "start"
            },
            ".place-content-end": {
                "place-content": "end"
            },
            ".place-content-between": {
                "place-content": "space-between"
            },
            ".place-content-around": {
                "place-content": "space-around"
            },
            ".place-content-evenly": {
                "place-content": "space-evenly"
            },
            ".place-content-baseline": {
                "place-content": "baseline"
            },
            ".place-content-stretch": {
                "place-content": "stretch"
            }
        });
    },
    placeItems: ({ addUtilities: t })=>{
        t({
            ".place-items-start": {
                "place-items": "start"
            },
            ".place-items-end": {
                "place-items": "end"
            },
            ".place-items-center": {
                "place-items": "center"
            },
            ".place-items-baseline": {
                "place-items": "baseline"
            },
            ".place-items-stretch": {
                "place-items": "stretch"
            }
        });
    },
    alignContent: ({ addUtilities: t })=>{
        t({
            ".content-center": {
                "align-content": "center"
            },
            ".content-start": {
                "align-content": "flex-start"
            },
            ".content-end": {
                "align-content": "flex-end"
            },
            ".content-between": {
                "align-content": "space-between"
            },
            ".content-around": {
                "align-content": "space-around"
            },
            ".content-evenly": {
                "align-content": "space-evenly"
            },
            ".content-baseline": {
                "align-content": "baseline"
            }
        });
    },
    alignItems: ({ addUtilities: t })=>{
        t({
            ".items-start": {
                "align-items": "flex-start"
            },
            ".items-end": {
                "align-items": "flex-end"
            },
            ".items-center": {
                "align-items": "center"
            },
            ".items-baseline": {
                "align-items": "baseline"
            },
            ".items-stretch": {
                "align-items": "stretch"
            }
        });
    },
    justifyContent: ({ addUtilities: t })=>{
        t({
            ".justify-start": {
                "justify-content": "flex-start"
            },
            ".justify-end": {
                "justify-content": "flex-end"
            },
            ".justify-center": {
                "justify-content": "center"
            },
            ".justify-between": {
                "justify-content": "space-between"
            },
            ".justify-around": {
                "justify-content": "space-around"
            },
            ".justify-evenly": {
                "justify-content": "space-evenly"
            }
        });
    },
    justifyItems: ({ addUtilities: t })=>{
        t({
            ".justify-items-start": {
                "justify-items": "start"
            },
            ".justify-items-end": {
                "justify-items": "end"
            },
            ".justify-items-center": {
                "justify-items": "center"
            },
            ".justify-items-stretch": {
                "justify-items": "stretch"
            }
        });
    },
    gap: T("gap", [
        [
            "gap",
            [
                "gap"
            ]
        ],
        [
            [
                "gap-x",
                [
                    "columnGap"
                ]
            ],
            [
                "gap-y",
                [
                    "rowGap"
                ]
            ]
        ]
    ]),
    space: ({ matchUtilities: t, addUtilities: e, theme: r })=>{
        t({
            "space-x": (n)=>(n = n === "0" ? "0px" : n, {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "--tw-space-x-reverse": "0",
                        "margin-right": `calc(${n} * var(--tw-space-x-reverse))`,
                        "margin-left": `calc(${n} * calc(1 - var(--tw-space-x-reverse)))`
                    }
                }),
            "space-y": (n)=>(n = n === "0" ? "0px" : n, {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "--tw-space-y-reverse": "0",
                        "margin-top": `calc(${n} * calc(1 - var(--tw-space-y-reverse)))`,
                        "margin-bottom": `calc(${n} * var(--tw-space-y-reverse))`
                    }
                })
        }, {
            values: r("space"),
            supportsNegativeValues: !0
        }), e({
            ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "1"
            },
            ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "1"
            }
        });
    },
    divideWidth: ({ matchUtilities: t, addUtilities: e, theme: r })=>{
        t({
            "divide-x": (n)=>(n = n === "0" ? "0px" : n, {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "@defaults border-width": {},
                        "--tw-divide-x-reverse": "0",
                        "border-right-width": `calc(${n} * var(--tw-divide-x-reverse))`,
                        "border-left-width": `calc(${n} * calc(1 - var(--tw-divide-x-reverse)))`
                    }
                }),
            "divide-y": (n)=>(n = n === "0" ? "0px" : n, {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "@defaults border-width": {},
                        "--tw-divide-y-reverse": "0",
                        "border-top-width": `calc(${n} * calc(1 - var(--tw-divide-y-reverse)))`,
                        "border-bottom-width": `calc(${n} * var(--tw-divide-y-reverse))`
                    }
                })
        }, {
            values: r("divideWidth"),
            type: [
                "line-width",
                "length",
                "any"
            ]
        }), e({
            ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "1"
            },
            ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "1"
            }
        });
    },
    divideStyle: ({ addUtilities: t })=>{
        t({
            ".divide-solid > :not([hidden]) ~ :not([hidden])": {
                "border-style": "solid"
            },
            ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
                "border-style": "dashed"
            },
            ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
                "border-style": "dotted"
            },
            ".divide-double > :not([hidden]) ~ :not([hidden])": {
                "border-style": "double"
            },
            ".divide-none > :not([hidden]) ~ :not([hidden])": {
                "border-style": "none"
            }
        });
    },
    divideColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            divide: (n)=>r("divideOpacity") ? {
                    ["& > :not([hidden]) ~ :not([hidden])"]: ee({
                        color: n,
                        property: "border-color",
                        variable: "--tw-divide-opacity"
                    })
                } : {
                    ["& > :not([hidden]) ~ :not([hidden])"]: {
                        "border-color": N(n)
                    }
                }
        }, {
            values: (({ DEFAULT: n, ...i })=>i)(H(e("divideColor"))),
            type: [
                "color",
                "any"
            ]
        });
    },
    divideOpacity: ({ matchUtilities: t, theme: e })=>{
        t({
            "divide-opacity": (r)=>({
                    ["& > :not([hidden]) ~ :not([hidden])"]: {
                        "--tw-divide-opacity": r
                    }
                })
        }, {
            values: e("divideOpacity")
        });
    },
    placeSelf: ({ addUtilities: t })=>{
        t({
            ".place-self-auto": {
                "place-self": "auto"
            },
            ".place-self-start": {
                "place-self": "start"
            },
            ".place-self-end": {
                "place-self": "end"
            },
            ".place-self-center": {
                "place-self": "center"
            },
            ".place-self-stretch": {
                "place-self": "stretch"
            }
        });
    },
    alignSelf: ({ addUtilities: t })=>{
        t({
            ".self-auto": {
                "align-self": "auto"
            },
            ".self-start": {
                "align-self": "flex-start"
            },
            ".self-end": {
                "align-self": "flex-end"
            },
            ".self-center": {
                "align-self": "center"
            },
            ".self-stretch": {
                "align-self": "stretch"
            },
            ".self-baseline": {
                "align-self": "baseline"
            }
        });
    },
    justifySelf: ({ addUtilities: t })=>{
        t({
            ".justify-self-auto": {
                "justify-self": "auto"
            },
            ".justify-self-start": {
                "justify-self": "start"
            },
            ".justify-self-end": {
                "justify-self": "end"
            },
            ".justify-self-center": {
                "justify-self": "center"
            },
            ".justify-self-stretch": {
                "justify-self": "stretch"
            }
        });
    },
    overflow: ({ addUtilities: t })=>{
        t({
            ".overflow-auto": {
                overflow: "auto"
            },
            ".overflow-hidden": {
                overflow: "hidden"
            },
            ".overflow-clip": {
                overflow: "clip"
            },
            ".overflow-visible": {
                overflow: "visible"
            },
            ".overflow-scroll": {
                overflow: "scroll"
            },
            ".overflow-x-auto": {
                "overflow-x": "auto"
            },
            ".overflow-y-auto": {
                "overflow-y": "auto"
            },
            ".overflow-x-hidden": {
                "overflow-x": "hidden"
            },
            ".overflow-y-hidden": {
                "overflow-y": "hidden"
            },
            ".overflow-x-clip": {
                "overflow-x": "clip"
            },
            ".overflow-y-clip": {
                "overflow-y": "clip"
            },
            ".overflow-x-visible": {
                "overflow-x": "visible"
            },
            ".overflow-y-visible": {
                "overflow-y": "visible"
            },
            ".overflow-x-scroll": {
                "overflow-x": "scroll"
            },
            ".overflow-y-scroll": {
                "overflow-y": "scroll"
            }
        });
    },
    overscrollBehavior: ({ addUtilities: t })=>{
        t({
            ".overscroll-auto": {
                "overscroll-behavior": "auto"
            },
            ".overscroll-contain": {
                "overscroll-behavior": "contain"
            },
            ".overscroll-none": {
                "overscroll-behavior": "none"
            },
            ".overscroll-y-auto": {
                "overscroll-behavior-y": "auto"
            },
            ".overscroll-y-contain": {
                "overscroll-behavior-y": "contain"
            },
            ".overscroll-y-none": {
                "overscroll-behavior-y": "none"
            },
            ".overscroll-x-auto": {
                "overscroll-behavior-x": "auto"
            },
            ".overscroll-x-contain": {
                "overscroll-behavior-x": "contain"
            },
            ".overscroll-x-none": {
                "overscroll-behavior-x": "none"
            }
        });
    },
    scrollBehavior: ({ addUtilities: t })=>{
        t({
            ".scroll-auto": {
                "scroll-behavior": "auto"
            },
            ".scroll-smooth": {
                "scroll-behavior": "smooth"
            }
        });
    },
    textOverflow: ({ addUtilities: t })=>{
        t({
            ".truncate": {
                overflow: "hidden",
                "text-overflow": "ellipsis",
                "white-space": "nowrap"
            },
            ".overflow-ellipsis": {
                "text-overflow": "ellipsis"
            },
            ".text-ellipsis": {
                "text-overflow": "ellipsis"
            },
            ".text-clip": {
                "text-overflow": "clip"
            }
        });
    },
    whitespace: ({ addUtilities: t })=>{
        t({
            ".whitespace-normal": {
                "white-space": "normal"
            },
            ".whitespace-nowrap": {
                "white-space": "nowrap"
            },
            ".whitespace-pre": {
                "white-space": "pre"
            },
            ".whitespace-pre-line": {
                "white-space": "pre-line"
            },
            ".whitespace-pre-wrap": {
                "white-space": "pre-wrap"
            }
        });
    },
    wordBreak: ({ addUtilities: t })=>{
        t({
            ".break-normal": {
                "overflow-wrap": "normal",
                "word-break": "normal"
            },
            ".break-words": {
                "overflow-wrap": "break-word"
            },
            ".break-all": {
                "word-break": "break-all"
            },
            ".break-keep": {
                "word-break": "keep-all"
            }
        });
    },
    borderRadius: T("borderRadius", [
        [
            "rounded",
            [
                "border-radius"
            ]
        ],
        [
            [
                "rounded-t",
                [
                    "border-top-left-radius",
                    "border-top-right-radius"
                ]
            ],
            [
                "rounded-r",
                [
                    "border-top-right-radius",
                    "border-bottom-right-radius"
                ]
            ],
            [
                "rounded-b",
                [
                    "border-bottom-right-radius",
                    "border-bottom-left-radius"
                ]
            ],
            [
                "rounded-l",
                [
                    "border-top-left-radius",
                    "border-bottom-left-radius"
                ]
            ]
        ],
        [
            [
                "rounded-tl",
                [
                    "border-top-left-radius"
                ]
            ],
            [
                "rounded-tr",
                [
                    "border-top-right-radius"
                ]
            ],
            [
                "rounded-br",
                [
                    "border-bottom-right-radius"
                ]
            ],
            [
                "rounded-bl",
                [
                    "border-bottom-left-radius"
                ]
            ]
        ]
    ]),
    borderWidth: T("borderWidth", [
        [
            "border",
            [
                [
                    "@defaults border-width",
                    {}
                ],
                "border-width"
            ]
        ],
        [
            [
                "border-x",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-left-width",
                    "border-right-width"
                ]
            ],
            [
                "border-y",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-top-width",
                    "border-bottom-width"
                ]
            ]
        ],
        [
            [
                "border-t",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-top-width"
                ]
            ],
            [
                "border-r",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-right-width"
                ]
            ],
            [
                "border-b",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-bottom-width"
                ]
            ],
            [
                "border-l",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-left-width"
                ]
            ]
        ]
    ], {
        type: [
            "line-width",
            "length"
        ]
    }),
    borderStyle: ({ addUtilities: t })=>{
        t({
            ".border-solid": {
                "border-style": "solid"
            },
            ".border-dashed": {
                "border-style": "dashed"
            },
            ".border-dotted": {
                "border-style": "dotted"
            },
            ".border-double": {
                "border-style": "double"
            },
            ".border-hidden": {
                "border-style": "hidden"
            },
            ".border-none": {
                "border-style": "none"
            }
        });
    },
    borderColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            border: (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: "border-color",
                    variable: "--tw-border-opacity"
                }) : {
                    "border-color": N(n)
                }
        }, {
            values: (({ DEFAULT: n, ...i })=>i)(H(e("borderColor"))),
            type: [
                "color",
                "any"
            ]
        }), t({
            "border-x": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: [
                        "border-left-color",
                        "border-right-color"
                    ],
                    variable: "--tw-border-opacity"
                }) : {
                    "border-left-color": N(n),
                    "border-right-color": N(n)
                },
            "border-y": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: [
                        "border-top-color",
                        "border-bottom-color"
                    ],
                    variable: "--tw-border-opacity"
                }) : {
                    "border-top-color": N(n),
                    "border-bottom-color": N(n)
                }
        }, {
            values: (({ DEFAULT: n, ...i })=>i)(H(e("borderColor"))),
            type: [
                "color",
                "any"
            ]
        }), t({
            "border-t": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: "border-top-color",
                    variable: "--tw-border-opacity"
                }) : {
                    "border-top-color": N(n)
                },
            "border-r": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: "border-right-color",
                    variable: "--tw-border-opacity"
                }) : {
                    "border-right-color": N(n)
                },
            "border-b": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: "border-bottom-color",
                    variable: "--tw-border-opacity"
                }) : {
                    "border-bottom-color": N(n)
                },
            "border-l": (n)=>r("borderOpacity") ? ee({
                    color: n,
                    property: "border-left-color",
                    variable: "--tw-border-opacity"
                }) : {
                    "border-left-color": N(n)
                }
        }, {
            values: (({ DEFAULT: n, ...i })=>i)(H(e("borderColor"))),
            type: [
                "color",
                "any"
            ]
        });
    },
    borderOpacity: T("borderOpacity", [
        [
            "border-opacity",
            [
                "--tw-border-opacity"
            ]
        ]
    ]),
    backgroundColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            bg: (n)=>r("backgroundOpacity") ? ee({
                    color: n,
                    property: "background-color",
                    variable: "--tw-bg-opacity"
                }) : {
                    "background-color": N(n)
                }
        }, {
            values: H(e("backgroundColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    backgroundOpacity: T("backgroundOpacity", [
        [
            "bg-opacity",
            [
                "--tw-bg-opacity"
            ]
        ]
    ]),
    backgroundImage: T("backgroundImage", [
        [
            "bg",
            [
                "background-image"
            ]
        ]
    ], {
        type: [
            "lookup",
            "image",
            "url"
        ]
    }),
    gradientColorStops: (()=>{
        function t(e) {
            return ve(e, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities: e, theme: r }) {
            let n = {
                values: H(r("gradientColorStops")),
                type: [
                    "color",
                    "any"
                ]
            };
            e({
                from: (i)=>{
                    let s = t(i);
                    return {
                        "--tw-gradient-from": N(i, "from"),
                        "--tw-gradient-to": s,
                        "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
                    };
                }
            }, n), e({
                via: (i)=>({
                        "--tw-gradient-to": t(i),
                        "--tw-gradient-stops": `var(--tw-gradient-from), ${N(i, "via")}, var(--tw-gradient-to)`
                    })
            }, n), e({
                to: (i)=>({
                        "--tw-gradient-to": N(i, "to")
                    })
            }, n);
        };
    })(),
    boxDecorationBreak: ({ addUtilities: t })=>{
        t({
            ".decoration-slice": {
                "box-decoration-break": "slice"
            },
            ".decoration-clone": {
                "box-decoration-break": "clone"
            },
            ".box-decoration-slice": {
                "box-decoration-break": "slice"
            },
            ".box-decoration-clone": {
                "box-decoration-break": "clone"
            }
        });
    },
    backgroundSize: T("backgroundSize", [
        [
            "bg",
            [
                "background-size"
            ]
        ]
    ], {
        type: [
            "lookup",
            "length",
            "percentage",
            "size"
        ]
    }),
    backgroundAttachment: ({ addUtilities: t })=>{
        t({
            ".bg-fixed": {
                "background-attachment": "fixed"
            },
            ".bg-local": {
                "background-attachment": "local"
            },
            ".bg-scroll": {
                "background-attachment": "scroll"
            }
        });
    },
    backgroundClip: ({ addUtilities: t })=>{
        t({
            ".bg-clip-border": {
                "background-clip": "border-box"
            },
            ".bg-clip-padding": {
                "background-clip": "padding-box"
            },
            ".bg-clip-content": {
                "background-clip": "content-box"
            },
            ".bg-clip-text": {
                "background-clip": "text"
            }
        });
    },
    backgroundPosition: T("backgroundPosition", [
        [
            "bg",
            [
                "background-position"
            ]
        ]
    ], {
        type: [
            "lookup",
            [
                "position",
                {
                    preferOnConflict: !0
                }
            ]
        ]
    }),
    backgroundRepeat: ({ addUtilities: t })=>{
        t({
            ".bg-repeat": {
                "background-repeat": "repeat"
            },
            ".bg-no-repeat": {
                "background-repeat": "no-repeat"
            },
            ".bg-repeat-x": {
                "background-repeat": "repeat-x"
            },
            ".bg-repeat-y": {
                "background-repeat": "repeat-y"
            },
            ".bg-repeat-round": {
                "background-repeat": "round"
            },
            ".bg-repeat-space": {
                "background-repeat": "space"
            }
        });
    },
    backgroundOrigin: ({ addUtilities: t })=>{
        t({
            ".bg-origin-border": {
                "background-origin": "border-box"
            },
            ".bg-origin-padding": {
                "background-origin": "padding-box"
            },
            ".bg-origin-content": {
                "background-origin": "content-box"
            }
        });
    },
    fill: ({ matchUtilities: t, theme: e })=>{
        t({
            fill: (r)=>({
                    fill: N(r)
                })
        }, {
            values: H(e("fill")),
            type: [
                "color",
                "any"
            ]
        });
    },
    stroke: ({ matchUtilities: t, theme: e })=>{
        t({
            stroke: (r)=>({
                    stroke: N(r)
                })
        }, {
            values: H(e("stroke")),
            type: [
                "color",
                "url",
                "any"
            ]
        });
    },
    strokeWidth: T("strokeWidth", [
        [
            "stroke",
            [
                "stroke-width"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage"
        ]
    }),
    objectFit: ({ addUtilities: t })=>{
        t({
            ".object-contain": {
                "object-fit": "contain"
            },
            ".object-cover": {
                "object-fit": "cover"
            },
            ".object-fill": {
                "object-fit": "fill"
            },
            ".object-none": {
                "object-fit": "none"
            },
            ".object-scale-down": {
                "object-fit": "scale-down"
            }
        });
    },
    objectPosition: T("objectPosition", [
        [
            "object",
            [
                "object-position"
            ]
        ]
    ]),
    padding: T("padding", [
        [
            "p",
            [
                "padding"
            ]
        ],
        [
            [
                "px",
                [
                    "padding-left",
                    "padding-right"
                ]
            ],
            [
                "py",
                [
                    "padding-top",
                    "padding-bottom"
                ]
            ]
        ],
        [
            [
                "pt",
                [
                    "padding-top"
                ]
            ],
            [
                "pr",
                [
                    "padding-right"
                ]
            ],
            [
                "pb",
                [
                    "padding-bottom"
                ]
            ],
            [
                "pl",
                [
                    "padding-left"
                ]
            ]
        ]
    ]),
    textAlign: ({ addUtilities: t })=>{
        t({
            ".text-left": {
                "text-align": "left"
            },
            ".text-center": {
                "text-align": "center"
            },
            ".text-right": {
                "text-align": "right"
            },
            ".text-justify": {
                "text-align": "justify"
            },
            ".text-start": {
                "text-align": "start"
            },
            ".text-end": {
                "text-align": "end"
            }
        });
    },
    textIndent: T("textIndent", [
        [
            "indent",
            [
                "text-indent"
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    verticalAlign: ({ addUtilities: t, matchUtilities: e })=>{
        t({
            ".align-baseline": {
                "vertical-align": "baseline"
            },
            ".align-top": {
                "vertical-align": "top"
            },
            ".align-middle": {
                "vertical-align": "middle"
            },
            ".align-bottom": {
                "vertical-align": "bottom"
            },
            ".align-text-top": {
                "vertical-align": "text-top"
            },
            ".align-text-bottom": {
                "vertical-align": "text-bottom"
            },
            ".align-sub": {
                "vertical-align": "sub"
            },
            ".align-super": {
                "vertical-align": "super"
            }
        }), e({
            align: (r)=>({
                    "vertical-align": r
                })
        });
    },
    fontFamily: ({ matchUtilities: t, theme: e })=>{
        t({
            font: (r)=>{
                let [n, i = {}] = Array.isArray(r) && X(r[1]) ? r : [
                    r
                ], { fontFeatureSettings: s } = i;
                return {
                    "font-family": Array.isArray(n) ? n.join(", ") : n,
                    ...s === void 0 ? {} : {
                        "font-feature-settings": s
                    }
                };
            }
        }, {
            values: e("fontFamily"),
            type: [
                "lookup",
                "generic-name",
                "family-name"
            ]
        });
    },
    fontSize: ({ matchUtilities: t, theme: e })=>{
        t({
            text: (r)=>{
                let [n, i] = Array.isArray(r) ? r : [
                    r
                ], { lineHeight: s, letterSpacing: a, fontWeight: o } = X(i) ? i : {
                    lineHeight: i
                };
                return {
                    "font-size": n,
                    ...s === void 0 ? {} : {
                        "line-height": s
                    },
                    ...a === void 0 ? {} : {
                        "letter-spacing": a
                    },
                    ...o === void 0 ? {} : {
                        "font-weight": o
                    }
                };
            }
        }, {
            values: e("fontSize"),
            type: [
                "absolute-size",
                "relative-size",
                "length",
                "percentage"
            ]
        });
    },
    fontWeight: T("fontWeight", [
        [
            "font",
            [
                "fontWeight"
            ]
        ]
    ], {
        type: [
            "lookup",
            "number",
            "any"
        ]
    }),
    textTransform: ({ addUtilities: t })=>{
        t({
            ".uppercase": {
                "text-transform": "uppercase"
            },
            ".lowercase": {
                "text-transform": "lowercase"
            },
            ".capitalize": {
                "text-transform": "capitalize"
            },
            ".normal-case": {
                "text-transform": "none"
            }
        });
    },
    fontStyle: ({ addUtilities: t })=>{
        t({
            ".italic": {
                "font-style": "italic"
            },
            ".not-italic": {
                "font-style": "normal"
            }
        });
    },
    fontVariantNumeric: ({ addDefaults: t, addUtilities: e })=>{
        let r = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        t("font-variant-numeric", {
            "--tw-ordinal": " ",
            "--tw-slashed-zero": " ",
            "--tw-numeric-figure": " ",
            "--tw-numeric-spacing": " ",
            "--tw-numeric-fraction": " "
        }), e({
            ".normal-nums": {
                "font-variant-numeric": "normal"
            },
            ".ordinal": {
                "@defaults font-variant-numeric": {},
                "--tw-ordinal": "ordinal",
                "font-variant-numeric": r
            },
            ".slashed-zero": {
                "@defaults font-variant-numeric": {},
                "--tw-slashed-zero": "slashed-zero",
                "font-variant-numeric": r
            },
            ".lining-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-figure": "lining-nums",
                "font-variant-numeric": r
            },
            ".oldstyle-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-figure": "oldstyle-nums",
                "font-variant-numeric": r
            },
            ".proportional-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-spacing": "proportional-nums",
                "font-variant-numeric": r
            },
            ".tabular-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-spacing": "tabular-nums",
                "font-variant-numeric": r
            },
            ".diagonal-fractions": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-fraction": "diagonal-fractions",
                "font-variant-numeric": r
            },
            ".stacked-fractions": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-fraction": "stacked-fractions",
                "font-variant-numeric": r
            }
        });
    },
    lineHeight: T("lineHeight", [
        [
            "leading",
            [
                "lineHeight"
            ]
        ]
    ]),
    letterSpacing: T("letterSpacing", [
        [
            "tracking",
            [
                "letterSpacing"
            ]
        ]
    ], {
        supportsNegativeValues: !0
    }),
    textColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            text: (n)=>r("textOpacity") ? ee({
                    color: n,
                    property: "color",
                    variable: "--tw-text-opacity"
                }) : {
                    color: N(n)
                }
        }, {
            values: H(e("textColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    textOpacity: T("textOpacity", [
        [
            "text-opacity",
            [
                "--tw-text-opacity"
            ]
        ]
    ]),
    textDecoration: ({ addUtilities: t })=>{
        t({
            ".underline": {
                "text-decoration-line": "underline"
            },
            ".overline": {
                "text-decoration-line": "overline"
            },
            ".line-through": {
                "text-decoration-line": "line-through"
            },
            ".no-underline": {
                "text-decoration-line": "none"
            }
        });
    },
    textDecorationColor: ({ matchUtilities: t, theme: e })=>{
        t({
            decoration: (r)=>({
                    "text-decoration-color": N(r)
                })
        }, {
            values: H(e("textDecorationColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    textDecorationStyle: ({ addUtilities: t })=>{
        t({
            ".decoration-solid": {
                "text-decoration-style": "solid"
            },
            ".decoration-double": {
                "text-decoration-style": "double"
            },
            ".decoration-dotted": {
                "text-decoration-style": "dotted"
            },
            ".decoration-dashed": {
                "text-decoration-style": "dashed"
            },
            ".decoration-wavy": {
                "text-decoration-style": "wavy"
            }
        });
    },
    textDecorationThickness: T("textDecorationThickness", [
        [
            "decoration",
            [
                "text-decoration-thickness"
            ]
        ]
    ], {
        type: [
            "length",
            "percentage"
        ]
    }),
    textUnderlineOffset: T("textUnderlineOffset", [
        [
            "underline-offset",
            [
                "text-underline-offset"
            ]
        ]
    ], {
        type: [
            "length",
            "percentage",
            "any"
        ]
    }),
    fontSmoothing: ({ addUtilities: t })=>{
        t({
            ".antialiased": {
                "-webkit-font-smoothing": "antialiased",
                "-moz-osx-font-smoothing": "grayscale"
            },
            ".subpixel-antialiased": {
                "-webkit-font-smoothing": "auto",
                "-moz-osx-font-smoothing": "auto"
            }
        });
    },
    placeholderColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            placeholder: (n)=>r("placeholderOpacity") ? {
                    "&::placeholder": ee({
                        color: n,
                        property: "color",
                        variable: "--tw-placeholder-opacity"
                    })
                } : {
                    "&::placeholder": {
                        color: N(n)
                    }
                }
        }, {
            values: H(e("placeholderColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    placeholderOpacity: ({ matchUtilities: t, theme: e })=>{
        t({
            "placeholder-opacity": (r)=>({
                    ["&::placeholder"]: {
                        "--tw-placeholder-opacity": r
                    }
                })
        }, {
            values: e("placeholderOpacity")
        });
    },
    caretColor: ({ matchUtilities: t, theme: e })=>{
        t({
            caret: (r)=>({
                    "caret-color": N(r)
                })
        }, {
            values: H(e("caretColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    accentColor: ({ matchUtilities: t, theme: e })=>{
        t({
            accent: (r)=>({
                    "accent-color": N(r)
                })
        }, {
            values: H(e("accentColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    opacity: T("opacity", [
        [
            "opacity",
            [
                "opacity"
            ]
        ]
    ]),
    backgroundBlendMode: ({ addUtilities: t })=>{
        t({
            ".bg-blend-normal": {
                "background-blend-mode": "normal"
            },
            ".bg-blend-multiply": {
                "background-blend-mode": "multiply"
            },
            ".bg-blend-screen": {
                "background-blend-mode": "screen"
            },
            ".bg-blend-overlay": {
                "background-blend-mode": "overlay"
            },
            ".bg-blend-darken": {
                "background-blend-mode": "darken"
            },
            ".bg-blend-lighten": {
                "background-blend-mode": "lighten"
            },
            ".bg-blend-color-dodge": {
                "background-blend-mode": "color-dodge"
            },
            ".bg-blend-color-burn": {
                "background-blend-mode": "color-burn"
            },
            ".bg-blend-hard-light": {
                "background-blend-mode": "hard-light"
            },
            ".bg-blend-soft-light": {
                "background-blend-mode": "soft-light"
            },
            ".bg-blend-difference": {
                "background-blend-mode": "difference"
            },
            ".bg-blend-exclusion": {
                "background-blend-mode": "exclusion"
            },
            ".bg-blend-hue": {
                "background-blend-mode": "hue"
            },
            ".bg-blend-saturation": {
                "background-blend-mode": "saturation"
            },
            ".bg-blend-color": {
                "background-blend-mode": "color"
            },
            ".bg-blend-luminosity": {
                "background-blend-mode": "luminosity"
            }
        });
    },
    mixBlendMode: ({ addUtilities: t })=>{
        t({
            ".mix-blend-normal": {
                "mix-blend-mode": "normal"
            },
            ".mix-blend-multiply": {
                "mix-blend-mode": "multiply"
            },
            ".mix-blend-screen": {
                "mix-blend-mode": "screen"
            },
            ".mix-blend-overlay": {
                "mix-blend-mode": "overlay"
            },
            ".mix-blend-darken": {
                "mix-blend-mode": "darken"
            },
            ".mix-blend-lighten": {
                "mix-blend-mode": "lighten"
            },
            ".mix-blend-color-dodge": {
                "mix-blend-mode": "color-dodge"
            },
            ".mix-blend-color-burn": {
                "mix-blend-mode": "color-burn"
            },
            ".mix-blend-hard-light": {
                "mix-blend-mode": "hard-light"
            },
            ".mix-blend-soft-light": {
                "mix-blend-mode": "soft-light"
            },
            ".mix-blend-difference": {
                "mix-blend-mode": "difference"
            },
            ".mix-blend-exclusion": {
                "mix-blend-mode": "exclusion"
            },
            ".mix-blend-hue": {
                "mix-blend-mode": "hue"
            },
            ".mix-blend-saturation": {
                "mix-blend-mode": "saturation"
            },
            ".mix-blend-color": {
                "mix-blend-mode": "color"
            },
            ".mix-blend-luminosity": {
                "mix-blend-mode": "luminosity"
            },
            ".mix-blend-plus-lighter": {
                "mix-blend-mode": "plus-lighter"
            }
        });
    },
    boxShadow: (()=>{
        let t = _e("boxShadow"), e = [
            "var(--tw-ring-offset-shadow, 0 0 #0000)",
            "var(--tw-ring-shadow, 0 0 #0000)",
            "var(--tw-shadow)"
        ].join(", ");
        return function({ matchUtilities: r, addDefaults: n, theme: i }) {
            n(" box-shadow", {
                "--tw-ring-offset-shadow": "0 0 #0000",
                "--tw-ring-shadow": "0 0 #0000",
                "--tw-shadow": "0 0 #0000",
                "--tw-shadow-colored": "0 0 #0000"
            }), r({
                shadow: (s)=>{
                    s = t(s);
                    let a = rn(s);
                    for (let o of a)!o.valid || (o.color = "var(--tw-shadow-color)");
                    return {
                        "@defaults box-shadow": {},
                        "--tw-shadow": s === "none" ? "0 0 #0000" : s,
                        "--tw-shadow-colored": s === "none" ? "0 0 #0000" : Vu(a),
                        "box-shadow": e
                    };
                }
            }, {
                values: i("boxShadow"),
                type: [
                    "shadow"
                ]
            });
        };
    })(),
    boxShadowColor: ({ matchUtilities: t, theme: e })=>{
        t({
            shadow: (r)=>({
                    "--tw-shadow-color": N(r),
                    "--tw-shadow": "var(--tw-shadow-colored)"
                })
        }, {
            values: H(e("boxShadowColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    outlineStyle: ({ addUtilities: t })=>{
        t({
            ".outline-none": {
                outline: "2px solid transparent",
                "outline-offset": "2px"
            },
            ".outline": {
                "outline-style": "solid"
            },
            ".outline-dashed": {
                "outline-style": "dashed"
            },
            ".outline-dotted": {
                "outline-style": "dotted"
            },
            ".outline-double": {
                "outline-style": "double"
            }
        });
    },
    outlineWidth: T("outlineWidth", [
        [
            "outline",
            [
                "outline-width"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage"
        ]
    }),
    outlineOffset: T("outlineOffset", [
        [
            "outline-offset",
            [
                "outline-offset"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage",
            "any"
        ],
        supportsNegativeValues: !0
    }),
    outlineColor: ({ matchUtilities: t, theme: e })=>{
        t({
            outline: (r)=>({
                    "outline-color": N(r)
                })
        }, {
            values: H(e("outlineColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    ringWidth: ({ matchUtilities: t, addDefaults: e, addUtilities: r, theme: n, config: i })=>{
        let s = (()=>{
            var o, l;
            if (G(i(), "respectDefaultRingColorOpacity")) return n("ringColor.DEFAULT");
            let a = n("ringOpacity.DEFAULT", "0.5");
            return (o = n("ringColor")) != null && o.DEFAULT ? ve((l = n("ringColor")) == null ? void 0 : l.DEFAULT, a, `rgb(147 197 253 / ${a})`) : `rgb(147 197 253 / ${a})`;
        })();
        e("ring-width", {
            "--tw-ring-inset": " ",
            "--tw-ring-offset-width": n("ringOffsetWidth.DEFAULT", "0px"),
            "--tw-ring-offset-color": n("ringOffsetColor.DEFAULT", "#fff"),
            "--tw-ring-color": s,
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
        }), t({
            ring: (a)=>({
                    "@defaults ring-width": {},
                    "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
                    "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${a} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                    "box-shadow": [
                        "var(--tw-ring-offset-shadow)",
                        "var(--tw-ring-shadow)",
                        "var(--tw-shadow, 0 0 #0000)"
                    ].join(", ")
                })
        }, {
            values: n("ringWidth"),
            type: "length"
        }), r({
            ".ring-inset": {
                "@defaults ring-width": {},
                "--tw-ring-inset": "inset"
            }
        });
    },
    ringColor: ({ matchUtilities: t, theme: e, corePlugins: r })=>{
        t({
            ring: (n)=>r("ringOpacity") ? ee({
                    color: n,
                    property: "--tw-ring-color",
                    variable: "--tw-ring-opacity"
                }) : {
                    "--tw-ring-color": N(n)
                }
        }, {
            values: Object.fromEntries(Object.entries(H(e("ringColor"))).filter(([n])=>n !== "DEFAULT")),
            type: [
                "color",
                "any"
            ]
        });
    },
    ringOpacity: (t)=>{
        let { config: e } = t;
        return T("ringOpacity", [
            [
                "ring-opacity",
                [
                    "--tw-ring-opacity"
                ]
            ]
        ], {
            filterDefault: !G(e(), "respectDefaultRingColorOpacity")
        })(t);
    },
    ringOffsetWidth: T("ringOffsetWidth", [
        [
            "ring-offset",
            [
                "--tw-ring-offset-width"
            ]
        ]
    ], {
        type: "length"
    }),
    ringOffsetColor: ({ matchUtilities: t, theme: e })=>{
        t({
            "ring-offset": (r)=>({
                    "--tw-ring-offset-color": N(r)
                })
        }, {
            values: H(e("ringOffsetColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    blur: ({ matchUtilities: t, theme: e })=>{
        t({
            blur: (r)=>({
                    "--tw-blur": `blur(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("blur")
        });
    },
    brightness: ({ matchUtilities: t, theme: e })=>{
        t({
            brightness: (r)=>({
                    "--tw-brightness": `brightness(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("brightness")
        });
    },
    contrast: ({ matchUtilities: t, theme: e })=>{
        t({
            contrast: (r)=>({
                    "--tw-contrast": `contrast(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("contrast")
        });
    },
    dropShadow: ({ matchUtilities: t, theme: e })=>{
        t({
            "drop-shadow": (r)=>({
                    "--tw-drop-shadow": Array.isArray(r) ? r.map((n)=>`drop-shadow(${n})`).join(" ") : `drop-shadow(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("dropShadow")
        });
    },
    grayscale: ({ matchUtilities: t, theme: e })=>{
        t({
            grayscale: (r)=>({
                    "--tw-grayscale": `grayscale(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("grayscale")
        });
    },
    hueRotate: ({ matchUtilities: t, theme: e })=>{
        t({
            "hue-rotate": (r)=>({
                    "--tw-hue-rotate": `hue-rotate(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("hueRotate"),
            supportsNegativeValues: !0
        });
    },
    invert: ({ matchUtilities: t, theme: e })=>{
        t({
            invert: (r)=>({
                    "--tw-invert": `invert(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("invert")
        });
    },
    saturate: ({ matchUtilities: t, theme: e })=>{
        t({
            saturate: (r)=>({
                    "--tw-saturate": `saturate(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("saturate")
        });
    },
    sepia: ({ matchUtilities: t, theme: e })=>{
        t({
            sepia: (r)=>({
                    "--tw-sepia": `sepia(${r})`,
                    "@defaults filter": {},
                    filter: xe
                })
        }, {
            values: e("sepia")
        });
    },
    filter: ({ addDefaults: t, addUtilities: e })=>{
        t("filter", {
            "--tw-blur": " ",
            "--tw-brightness": " ",
            "--tw-contrast": " ",
            "--tw-grayscale": " ",
            "--tw-hue-rotate": " ",
            "--tw-invert": " ",
            "--tw-saturate": " ",
            "--tw-sepia": " ",
            "--tw-drop-shadow": " "
        }), e({
            ".filter": {
                "@defaults filter": {},
                filter: xe
            },
            ".filter-none": {
                filter: "none"
            }
        });
    },
    backdropBlur: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-blur": (r)=>({
                    "--tw-backdrop-blur": `blur(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropBlur")
        });
    },
    backdropBrightness: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-brightness": (r)=>({
                    "--tw-backdrop-brightness": `brightness(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropBrightness")
        });
    },
    backdropContrast: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-contrast": (r)=>({
                    "--tw-backdrop-contrast": `contrast(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropContrast")
        });
    },
    backdropGrayscale: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-grayscale": (r)=>({
                    "--tw-backdrop-grayscale": `grayscale(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropGrayscale")
        });
    },
    backdropHueRotate: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-hue-rotate": (r)=>({
                    "--tw-backdrop-hue-rotate": `hue-rotate(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropHueRotate"),
            supportsNegativeValues: !0
        });
    },
    backdropInvert: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-invert": (r)=>({
                    "--tw-backdrop-invert": `invert(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropInvert")
        });
    },
    backdropOpacity: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-opacity": (r)=>({
                    "--tw-backdrop-opacity": `opacity(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropOpacity")
        });
    },
    backdropSaturate: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-saturate": (r)=>({
                    "--tw-backdrop-saturate": `saturate(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropSaturate")
        });
    },
    backdropSepia: ({ matchUtilities: t, theme: e })=>{
        t({
            "backdrop-sepia": (r)=>({
                    "--tw-backdrop-sepia": `sepia(${r})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": Se
                })
        }, {
            values: e("backdropSepia")
        });
    },
    backdropFilter: ({ addDefaults: t, addUtilities: e })=>{
        t("backdrop-filter", {
            "--tw-backdrop-blur": " ",
            "--tw-backdrop-brightness": " ",
            "--tw-backdrop-contrast": " ",
            "--tw-backdrop-grayscale": " ",
            "--tw-backdrop-hue-rotate": " ",
            "--tw-backdrop-invert": " ",
            "--tw-backdrop-opacity": " ",
            "--tw-backdrop-saturate": " ",
            "--tw-backdrop-sepia": " "
        }), e({
            ".backdrop-filter": {
                "@defaults backdrop-filter": {},
                "backdrop-filter": Se
            },
            ".backdrop-filter-none": {
                "backdrop-filter": "none"
            }
        });
    },
    transitionProperty: ({ matchUtilities: t, theme: e })=>{
        let r = e("transitionTimingFunction.DEFAULT"), n = e("transitionDuration.DEFAULT");
        t({
            transition: (i)=>({
                    "transition-property": i,
                    ...i === "none" ? {} : {
                        "transition-timing-function": r,
                        "transition-duration": n
                    }
                })
        }, {
            values: e("transitionProperty")
        });
    },
    transitionDelay: T("transitionDelay", [
        [
            "delay",
            [
                "transitionDelay"
            ]
        ]
    ]),
    transitionDuration: T("transitionDuration", [
        [
            "duration",
            [
                "transitionDuration"
            ]
        ]
    ], {
        filterDefault: !0
    }),
    transitionTimingFunction: T("transitionTimingFunction", [
        [
            "ease",
            [
                "transitionTimingFunction"
            ]
        ]
    ], {
        filterDefault: !0
    }),
    willChange: T("willChange", [
        [
            "will-change",
            [
                "will-change"
            ]
        ]
    ]),
    content: T("content", [
        [
            "content",
            [
                "--tw-content",
                [
                    "content",
                    "var(--tw-content)"
                ]
            ]
        ]
    ])
};
function Ne(t) {
    if (Array.isArray(t)) return t;
    let e = t.split("[").length - 1, r = t.split("]").length - 1;
    if (e !== r) throw new Error(`Path is invalid. Has unbalanced brackets: ${t}`);
    return t.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var vf = new Map([
    [
        "{",
        "}"
    ],
    [
        "[",
        "]"
    ],
    [
        "(",
        ")"
    ]
]), wf = new Map(Array.from(vf.entries()).map(([t, e])=>[
        e,
        t
    ])), ov = new Set([
    '"',
    "'",
    "`"
]);
function ut(t) {
    let e = [], r = !1;
    for(let n = 0; n < t.length; n++){
        let i = t[n];
        if (i === ":" && !r && e.length === 0) return !1;
        if (ov.has(i) && t[n - 1] !== "\\" && (r = !r), !r && t[n - 1] !== "\\") {
            if (vf.has(i)) e.push(i);
            else if (wf.has(i)) {
                let s = wf.get(i);
                if (e.length <= 0 || e.pop() !== s) return !1;
            }
        }
    }
    return !(e.length > 0);
}
function cn(t) {
    return (t > 0n) - (t < 0n);
}
function bf(t, e) {
    let r = 0n, n = 0n;
    for (let [i, s] of e)t & i && (r = r | i, n = n | s);
    return t & ~r | n;
}
var pn = class {
    constructor(){
        this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        }, this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            user: 4n,
            variants: 5n
        }, this.reservedVariantBits = 0n, this.variantOffsets = new Map;
    }
    create(e) {
        return {
            layer: e,
            parentLayer: e,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[e]++,
            options: []
        };
    }
    arbitraryProperty() {
        return {
            ...this.create("utilities"),
            arbitrary: 1n
        };
    }
    forVariant(e, r = 0) {
        let n = this.variantOffsets.get(e);
        if (n === void 0) throw new Error(`Cannot find offset for unknown variant ${e}`);
        return {
            ...this.create("variants"),
            variants: n << BigInt(r)
        };
    }
    applyVariantOffset(e, r, n) {
        return n.variant = r.variants, {
            ...e,
            layer: "variants",
            parentLayer: e.layer === "variants" ? e.parentLayer : e.layer,
            variants: e.variants | r.variants,
            options: n.sort ? [].concat(n, e.options) : e.options,
            parallelIndex: xf([
                e.parallelIndex,
                r.parallelIndex
            ])
        };
    }
    applyParallelOffset(e, r) {
        return {
            ...e,
            parallelIndex: BigInt(r)
        };
    }
    recordVariants(e, r) {
        for (let n of e)this.recordVariant(n, r(n));
    }
    recordVariant(e, r = 1) {
        return this.variantOffsets.set(e, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r), {
            ...this.create("variants"),
            variants: this.variantOffsets.get(e)
        };
    }
    compare(e, r) {
        var n;
        if (e.layer !== r.layer) return this.layerPositions[e.layer] - this.layerPositions[r.layer];
        if (e.parentLayer !== r.parentLayer) return this.layerPositions[e.parentLayer] - this.layerPositions[r.parentLayer];
        for (let i of e.options)for (let s of r.options){
            if (i.id !== s.id || !i.sort || !s.sort) continue;
            let a = (n = xf([
                i.variant,
                s.variant
            ])) != null ? n : 0n, o = ~(a | a - 1n), l = e.variants & o, u = r.variants & o;
            if (l !== u) continue;
            let f = i.sort({
                value: i.value,
                modifier: i.modifier
            }, {
                value: s.value,
                modifier: s.modifier
            });
            if (f !== 0) return f;
        }
        return e.variants !== r.variants ? e.variants - r.variants : e.parallelIndex !== r.parallelIndex ? e.parallelIndex - r.parallelIndex : e.arbitrary !== r.arbitrary ? e.arbitrary - r.arbitrary : e.index - r.index;
    }
    recalculateVariantOffsets() {
        let e = Array.from(this.variantOffsets.entries()).filter(([i])=>i.startsWith("[")).sort(([i], [s])=>lv(i, s)), r = e.map(([, i])=>i).sort((i, s)=>cn(i - s));
        return e.map(([, i], s)=>[
                i,
                r[s]
            ]).filter(([i, s])=>i !== s);
    }
    remapArbitraryVariantOffsets(e) {
        let r = this.recalculateVariantOffsets();
        return r.length === 0 ? e : e.map((n)=>{
            let [i, s] = n;
            return i = {
                ...i,
                variants: bf(i.variants, r)
            }, [
                i,
                s
            ];
        });
    }
    sort(e) {
        return e = this.remapArbitraryVariantOffsets(e), e.sort(([r], [n])=>cn(this.compare(r, n)));
    }
};
function xf(t) {
    let e = null;
    for (let r of t)e = e != null ? e : r, e = e > r ? e : r;
    return e;
}
function lv(t, e) {
    let r = t.length, n = e.length, i = r < n ? r : n;
    for(let s = 0; s < i; s++){
        let a = t.charCodeAt(s) - e.charCodeAt(s);
        if (a !== 0) return a;
    }
    return r - n;
}
var Fs = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
}, qs = {
    Base: 1 << 0,
    Dynamic: 1 << 1
};
function Ns(t, e) {
    let r = t.tailwindConfig.prefix;
    return typeof r == "function" ? r(e) : r + e;
}
function Sf({ type: t = "any", ...e }) {
    let r = [].concat(t);
    return {
        ...e,
        types: r.map((n)=>Array.isArray(n) ? {
                type: n[0],
                ...n[1]
            } : {
                type: n,
                preferOnConflict: !1
            })
    };
}
function uv(t) {
    let e = [], r = "", n = 0;
    for(let i = 0; i < t.length; i++){
        let s = t[i];
        if (s === "\\") r += "\\" + t[++i];
        else if (s === "{") ++n, e.push(r.trim()), r = "";
        else if (s === "}") {
            if (--n < 0) throw new Error("Your { and } are unbalanced.");
            e.push(r.trim()), r = "";
        } else r += s;
    }
    return r.length > 0 && e.push(r.trim()), e = e.filter((i)=>i !== ""), e;
}
function fv(t, e, { before: r = [] } = {}) {
    if (r = [].concat(r), r.length <= 0) {
        t.push(e);
        return;
    }
    let n = t.length - 1;
    for (let i of r){
        let s = t.indexOf(i);
        s !== -1 && (n = Math.min(n, s));
    }
    t.splice(n, 0, e);
}
function Ef(t) {
    return Array.isArray(t) ? t.flatMap((e)=>!Array.isArray(e) && !X(e) ? e : st(e)) : Ef([
        t
    ]);
}
function kf(t, e) {
    return (0, $s.default)((n)=>{
        let i = [];
        return e && e(n), n.walkClasses((s)=>{
            i.push(s.value);
        }), i;
    }).transformSync(t);
}
function cv(t, e = {
    containsNonOnDemandable: !1
}, r = 0) {
    let n = [];
    if (t.type === "rule") {
        let i = function(s) {
            s.walkPseudos((a)=>{
                a.value === ":not" && a.remove();
            });
        };
        for (let s of t.selectors){
            let a = kf(s, i);
            a.length === 0 && (e.containsNonOnDemandable = !0);
            for (let o of a)n.push(o);
        }
    } else t.type === "atrule" && t.walkRules((i)=>{
        for (let s of i.selectors.flatMap((a)=>kf(a)))n.push(s);
    });
    return r === 0 ? [
        e.containsNonOnDemandable || n.length === 0,
        n
    ] : n;
}
function dn(t) {
    return Ef(t).flatMap((e)=>{
        let r = new Map, [n, i] = cv(e);
        return n && i.unshift(Ce), i.map((s)=>(r.has(e) || r.set(e, e), [
                s,
                r.get(e)
            ]));
    });
}
function hn(t) {
    return t.startsWith("@") || t.includes("&");
}
function lr(t) {
    t = t.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let e = uv(t).map((r)=>{
        if (!r.startsWith("@")) return ({ format: s })=>s(r);
        let [, n, i] = /@(.*?)( .+|[({].*)/g.exec(r);
        return ({ wrap: s })=>s(I.atRule({
                name: n,
                params: i.trim()
            }));
    }).reverse();
    return (r)=>{
        for (let n of e)n(r);
    };
}
function pv(t, e, { variantList: r, variantMap: n, offsets: i, classList: s }) {
    function a(c, d) {
        return c ? (0, Cf.default)(t, c, d) : t;
    }
    function o(c) {
        return at(t.prefix, c);
    }
    function l(c, d) {
        return c === Ce ? Ce : d.respectPrefix ? e.tailwindConfig.prefix + c : c;
    }
    function u(c, d, h = {}) {
        let y = Ne(c), m = a([
            "theme",
            ...y
        ], d);
        return _e(y[0])(m, h);
    }
    let f = 0, p = {
        postcss: I,
        prefix: o,
        e: re,
        config: a,
        theme: u,
        corePlugins: (c)=>Array.isArray(t.corePlugins) ? t.corePlugins.includes(c) : a([
                "corePlugins",
                c
            ], !0),
        variants: ()=>[],
        addBase (c) {
            for (let [d, h] of dn(c)){
                let y = l(d, {}), m = i.create("base");
                e.candidateRuleMap.has(y) || e.candidateRuleMap.set(y, []), e.candidateRuleMap.get(y).push([
                    {
                        sort: m,
                        layer: "base"
                    },
                    h
                ]);
            }
        },
        addDefaults (c, d) {
            let h = {
                [`@defaults ${c}`]: d
            };
            for (let [y, m] of dn(h)){
                let g = l(y, {});
                e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([
                    {
                        sort: i.create("defaults"),
                        layer: "defaults"
                    },
                    m
                ]);
            }
        },
        addComponents (c, d) {
            d = Object.assign({}, {
                preserveSource: !1,
                respectPrefix: !0,
                respectImportant: !1
            }, Array.isArray(d) ? {} : d);
            for (let [y, m] of dn(c)){
                let g = l(y, d);
                s.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([
                    {
                        sort: i.create("components"),
                        layer: "components",
                        options: d
                    },
                    m
                ]);
            }
        },
        addUtilities (c, d) {
            d = Object.assign({}, {
                preserveSource: !1,
                respectPrefix: !0,
                respectImportant: !0
            }, Array.isArray(d) ? {} : d);
            for (let [y, m] of dn(c)){
                let g = l(y, d);
                s.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([
                    {
                        sort: i.create("utilities"),
                        layer: "utilities",
                        options: d
                    },
                    m
                ]);
            }
        },
        matchUtilities: function(c, d) {
            d = Sf({
                ...{
                    respectPrefix: !0,
                    respectImportant: !0,
                    modifiers: !1
                },
                ...d
            });
            let y = i.create("utilities");
            for(let m in c){
                let b = function(C, { isOnlyPlugin: x }) {
                    let [O, E, R] = As(d.types, C, d, t);
                    if (O === void 0) return [];
                    if (!d.types.some(({ type: K })=>K === E)) if (x) D.warn([
                        `Unnecessary typehint \`${E}\` in \`${m}-${C}\`.`,
                        `You can safely update it to \`${m}-${C.replace(E + ":", "")}\`.`
                    ]);
                    else return [];
                    if (!ut(O)) return [];
                    let L = {
                        get modifier () {
                            return d.modifiers || D.warn(`modifier-used-without-options-for-${m}`, [
                                "Your plugin must set `modifiers: true` in its options to support modifiers."
                            ]), R;
                        }
                    }, B = G(t, "generalizedModifiers");
                    return [].concat(B ? w(O, L) : w(O)).filter(Boolean).map((K)=>({
                            [on(m, C)]: K
                        }));
                }, g = l(m, d), w = c[m];
                s.add([
                    g,
                    d
                ]);
                let v = [
                    {
                        sort: y,
                        layer: "utilities",
                        options: d
                    },
                    b
                ];
                e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
            }
        },
        matchComponents: function(c, d) {
            d = Sf({
                ...{
                    respectPrefix: !0,
                    respectImportant: !1,
                    modifiers: !1
                },
                ...d
            });
            let y = i.create("components");
            for(let m in c){
                let b = function(C, { isOnlyPlugin: x }) {
                    let [O, E, R] = As(d.types, C, d, t);
                    if (O === void 0) return [];
                    if (!d.types.some(({ type: K })=>K === E)) if (x) D.warn([
                        `Unnecessary typehint \`${E}\` in \`${m}-${C}\`.`,
                        `You can safely update it to \`${m}-${C.replace(E + ":", "")}\`.`
                    ]);
                    else return [];
                    if (!ut(O)) return [];
                    let L = {
                        get modifier () {
                            return d.modifiers || D.warn(`modifier-used-without-options-for-${m}`, [
                                "Your plugin must set `modifiers: true` in its options to support modifiers."
                            ]), R;
                        }
                    }, B = G(t, "generalizedModifiers");
                    return [].concat(B ? w(O, L) : w(O)).filter(Boolean).map((K)=>({
                            [on(m, C)]: K
                        }));
                }, g = l(m, d), w = c[m];
                s.add([
                    g,
                    d
                ]);
                let v = [
                    {
                        sort: y,
                        layer: "components",
                        options: d
                    },
                    b
                ];
                e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
            }
        },
        addVariant (c, d, h = {}) {
            d = [].concat(d).map((y)=>{
                if (typeof y != "string") return (m = {})=>{
                    let { args: g, modifySelectors: w, container: b, separator: v, wrap: C, format: x } = m, O = y(Object.assign({
                        modifySelectors: w,
                        container: b,
                        separator: v
                    }, h.type === Fs.MatchVariant && {
                        args: g,
                        wrap: C,
                        format: x
                    }));
                    if (typeof O == "string" && !hn(O)) throw new Error(`Your custom variant \`${c}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                    return Array.isArray(O) ? O.filter((E)=>typeof E == "string").map((E)=>lr(E)) : O && typeof O == "string" && lr(O)(m);
                };
                if (!hn(y)) throw new Error(`Your custom variant \`${c}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return lr(y);
            }), fv(r, c, h), n.set(c, d), e.variantOptions.set(c, h);
        },
        matchVariant (c, d, h) {
            var b, v, C;
            let y = (b = h == null ? void 0 : h.id) != null ? b : ++f, m = c === "@", g = G(t, "generalizedModifiers");
            for (let [x, O] of Object.entries((v = h == null ? void 0 : h.values) != null ? v : {}))x !== "DEFAULT" && p.addVariant(m ? `${c}${x}` : `${c}-${x}`, ({ args: E, container: R })=>d(O, g ? {
                    modifier: E == null ? void 0 : E.modifier,
                    container: R
                } : {
                    container: R
                }), {
                ...h,
                value: O,
                id: y,
                type: Fs.MatchVariant,
                variantInfo: qs.Base
            });
            let w = "DEFAULT" in ((C = h == null ? void 0 : h.values) != null ? C : {});
            p.addVariant(c, ({ args: x, container: O })=>{
                var E;
                return (x == null ? void 0 : x.value) === mt && !w ? null : d((x == null ? void 0 : x.value) === mt ? h.values.DEFAULT : (E = x == null ? void 0 : x.value) != null ? E : typeof x == "string" ? x : "", g ? {
                    modifier: x == null ? void 0 : x.modifier,
                    container: O
                } : {
                    container: O
                });
            }, {
                ...h,
                id: y,
                type: Fs.MatchVariant,
                variantInfo: qs.Dynamic
            });
        }
    };
    return p;
}
function Af(t) {
    t.walkAtRules((e)=>{
        [
            "responsive",
            "variants"
        ].includes(e.name) && (Af(e), e.before(e.nodes), e.remove());
    });
}
function dv(t) {
    let e = [];
    return t.each((r)=>{
        r.type === "atrule" && [
            "responsive",
            "variants"
        ].includes(r.name) && (r.name = "layer", r.params = "utilities");
    }), t.walkAtRules("layer", (r)=>{
        if (Af(r), r.params === "base") {
            for (let n of r.nodes)e.push(function({ addBase: i }) {
                i(n, {
                    respectPrefix: !1
                });
            });
            r.remove();
        } else if (r.params === "components") {
            for (let n of r.nodes)e.push(function({ addComponents: i }) {
                i(n, {
                    respectPrefix: !1,
                    preserveSource: !0
                });
            });
            r.remove();
        } else if (r.params === "utilities") {
            for (let n of r.nodes)e.push(function({ addUtilities: i }) {
                i(n, {
                    respectPrefix: !1,
                    preserveSource: !0
                });
            });
            r.remove();
        }
    }), e;
}
function hv(t, e) {
    let r = Object.entries({
        ...ne,
        ...yf
    }).map(([o, l])=>t.tailwindConfig.corePlugins.includes(o) ? l : null).filter(Boolean), n = t.tailwindConfig.plugins.map((o)=>(o.__isOptionsFunction && (o = o()), typeof o == "function" ? o : o.handler)), i = dv(e), s = [
        ne.pseudoElementVariants,
        ne.pseudoClassVariants,
        ne.ariaVariants,
        ne.dataVariants
    ], a = [
        ne.supportsVariants,
        ne.directionVariants,
        ne.reducedMotionVariants,
        ne.prefersContrastVariants,
        ne.darkVariants,
        ne.printVariant,
        ne.screenVariants,
        ne.orientationVariants
    ];
    return [
        ...r,
        ...s,
        ...n,
        ...a,
        ...i
    ];
}
function mv(t, e) {
    var f, p, c;
    let r = [], n = new Map;
    e.variantMap = n;
    let i = new pn;
    e.offsets = i;
    let s = new Set, a = pv(e.tailwindConfig, e, {
        variantList: r,
        variantMap: n,
        offsets: i,
        classList: s
    });
    for (let d of t)if (Array.isArray(d)) for (let h of d)h(a);
    else d == null || d(a);
    i.recordVariants(r, (d)=>n.get(d).length);
    for (let [d, h] of n.entries())e.variantMap.set(d, h.map((y, m)=>[
            i.forVariant(d, m),
            y
        ]));
    let o = ((f = e.tailwindConfig.safelist) != null ? f : []).filter(Boolean);
    if (o.length > 0) {
        let d = [];
        for (let h of o){
            if (typeof h == "string") {
                e.changedContent.push({
                    content: h,
                    extension: "html"
                });
                continue;
            }
            if (h instanceof RegExp) {
                D.warn("root-regex", [
                    "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
                    "Update your `safelist` configuration to eliminate this warning.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
                continue;
            }
            d.push(h);
        }
        if (d.length > 0) {
            let h = new Map, y = e.tailwindConfig.prefix.length, m = d.some((g)=>g.pattern.source.includes("!"));
            for (let g of s){
                let w = Array.isArray(g) ? (()=>{
                    var O;
                    let [b, v] = g, x = Object.keys((O = v == null ? void 0 : v.values) != null ? O : {}).map((E)=>or(b, E));
                    return v != null && v.supportsNegativeValues && (x = [
                        ...x,
                        ...x.map((E)=>"-" + E)
                    ], x = [
                        ...x,
                        ...x.map((E)=>E.slice(0, y) + "-" + E.slice(y))
                    ]), v.types.some(({ type: E })=>E === "color") && (x = [
                        ...x,
                        ...x.flatMap((E)=>Object.keys(e.tailwindConfig.theme.opacity).map((R)=>`${E}/${R}`))
                    ]), m && (v == null ? void 0 : v.respectImportant) && (x = [
                        ...x,
                        ...x.map((E)=>"!" + E)
                    ]), x;
                })() : [
                    g
                ];
                for (let b of w)for (let { pattern: v, variants: C = [] } of d)if (v.lastIndex = 0, h.has(v) || h.set(v, 0), !!v.test(b)) {
                    h.set(v, h.get(v) + 1), e.changedContent.push({
                        content: b,
                        extension: "html"
                    });
                    for (let x of C)e.changedContent.push({
                        content: x + e.tailwindConfig.separator + b,
                        extension: "html"
                    });
                }
            }
            for (let [g, w] of h.entries())w === 0 && D.warn([
                `The safelist pattern \`${g}\` doesn't match any Tailwind CSS classes.`,
                "Fix this pattern or remove it from your `safelist` configuration.",
                "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
    }
    let l = (c = [].concat((p = e.tailwindConfig.darkMode) != null ? p : "media")[1]) != null ? c : "dark", u = [
        Ns(e, l),
        Ns(e, "group"),
        Ns(e, "peer")
    ];
    e.getClassOrder = function(h) {
        let y = new Map(h.map((w)=>[
                w,
                null
            ])), m = mn(new Set(h), e);
        m = e.offsets.sort(m);
        let g = BigInt(u.length);
        for (let [, w] of m)y.set(w.raws.tailwind.candidate, g++);
        return h.map((w)=>{
            var C;
            let b = (C = y.get(w)) != null ? C : null, v = u.indexOf(w);
            return b === null && v !== -1 && (b = BigInt(v)), [
                w,
                b
            ];
        });
    }, e.getClassList = function(h = {}) {
        var m, g, w, b;
        let y = [];
        for (let v of s)if (Array.isArray(v)) {
            let [C, x] = v, O = [], E = Object.keys((m = x == null ? void 0 : x.modifiers) != null ? m : {});
            (g = x == null ? void 0 : x.types) != null && g.some(({ type: B })=>B === "color") && E.push(...Object.keys((w = e.tailwindConfig.theme.opacity) != null ? w : {}));
            let R = {
                modifiers: E
            }, L = h.includeMetadata && E.length > 0;
            for (let [B, Q] of Object.entries((b = x == null ? void 0 : x.values) != null ? b : {})){
                if (Q == null) continue;
                let K = or(C, B);
                if (y.push(L ? [
                    K,
                    R
                ] : K), (x == null ? void 0 : x.supportsNegativeValues) && De(Q)) {
                    let $e = or(C, `-${B}`);
                    O.push(L ? [
                        $e,
                        R
                    ] : $e);
                }
            }
            y.push(...O);
        } else y.push(v);
        return y;
    }, e.getVariants = function() {
        var y;
        let h = [];
        for (let [m, g] of e.variantOptions.entries())g.variantInfo !== qs.Base && h.push({
            name: m,
            isArbitrary: g.type === Symbol.for("MATCH_VARIANT"),
            values: Object.keys((y = g.values) != null ? y : {}),
            hasDash: m !== "@",
            selectors ({ modifier: w, value: b } = {}) {
                var Ca, Ea, Aa, Oa;
                let v = "__TAILWIND_PLACEHOLDER__", C = I.rule({
                    selector: `.${v}`
                }), x = I.root({
                    nodes: [
                        C.clone()
                    ]
                }), O = x.toString(), E = ((Ca = e.variantMap.get(m)) != null ? Ca : []).flatMap(([ie, se])=>se), R = [];
                for (let ie of E){
                    let se = [], hr = {
                        args: {
                            modifier: w,
                            value: (Aa = (Ea = g.values) == null ? void 0 : Ea[b]) != null ? Aa : b
                        },
                        separator: e.tailwindConfig.separator,
                        modifySelectors (pe) {
                            return x.each((Ln)=>{
                                Ln.type === "rule" && (Ln.selectors = Ln.selectors.map((_a)=>pe({
                                        get className () {
                                            return Us(_a);
                                        },
                                        selector: _a
                                    })));
                            }), x;
                        },
                        format (pe) {
                            se.push(pe);
                        },
                        wrap (pe) {
                            se.push(`@${pe.name} ${pe.params} { & }`);
                        },
                        container: x
                    }, mr = ie(hr);
                    if (se.length > 0 && R.push(se), Array.isArray(mr)) for (let pe of mr)se = [], pe(hr), R.push(se);
                }
                let L = [], B = x.toString();
                O !== B && (x.walkRules((ie)=>{
                    let se = ie.selector, hr = (0, $s.default)((mr)=>{
                        mr.walkClasses((pe)=>{
                            pe.value = `${m}${e.tailwindConfig.separator}${pe.value}`;
                        });
                    }).processSync(se);
                    L.push(se.replace(hr, "&").replace(v, "&"));
                }), x.walkAtRules((ie)=>{
                    L.push(`@${ie.name} (${ie.params}) { & }`);
                }));
                let Q = !(b in ((Oa = g.values) != null ? Oa : {}));
                R = R.map((ie)=>ie.map((se)=>({
                            format: se,
                            isArbitraryVariant: Q
                        }))), L = L.map((ie)=>({
                        format: ie,
                        isArbitraryVariant: Q
                    }));
                let K = {
                    candidate: v,
                    context: e
                }, $e = R.map((ie)=>an(`.${v}`, lt(ie, K), K).replace(`.${v}`, "&").replace("{ & }", "").trim());
                return L.length > 0 && $e.push(lt(L, K).toString().replace(`.${v}`, "&")), $e;
            }
        });
        return h;
    };
}
function Of(t, e) {
    !t.classCache.has(e) || (t.notClassCache.add(e), t.classCache.delete(e), t.applyClassCache.delete(e), t.candidateRuleMap.delete(e), t.candidateRuleCache.delete(e), t.stylesheetCache = null);
}
function gv(t, e) {
    let r = e.raws.tailwind.candidate;
    if (!!r) {
        for (let n of t.ruleCache)n[1].raws.tailwind.candidate === r && t.ruleCache.delete(n);
        Of(t, r);
    }
}
function _f(t, e = [], r = I.root()) {
    var s;
    let n = {
        disposables: [],
        ruleCache: new Set,
        candidateRuleCache: new Map,
        classCache: new Map,
        applyClassCache: new Map,
        notClassCache: new Set((s = t.blocklist) != null ? s : []),
        postCssNodeCache: new Map,
        candidateRuleMap: new Map,
        tailwindConfig: t,
        changedContent: e,
        variantMap: new Map,
        stylesheetCache: null,
        variantOptions: new Map,
        markInvalidUtilityCandidate: (a)=>Of(n, a),
        markInvalidUtilityNode: (a)=>gv(n, a)
    }, i = hv(n, r);
    return mv(i, n), n;
}
var yv = (0, yn.default)((t)=>t.first.filter(({ type: e })=>e === "class").pop().value);
function Us(t) {
    return yv.transformSync(t);
}
function* wv(t) {
    let e = 1 / 0;
    for(; e >= 0;){
        let r, n = !1;
        if (e === 1 / 0 && t.endsWith("]")) {
            let a = t.indexOf("[");
            t[a - 1] === "-" ? r = a - 1 : t[a - 1] === "/" ? (r = a - 1, n = !0) : r = -1;
        } else e === 1 / 0 && t.includes("/") ? (r = t.lastIndexOf("/"), n = !0) : r = t.lastIndexOf("-", e);
        if (r < 0) break;
        let i = t.slice(0, r), s = t.slice(n ? r : r + 1);
        e = r - 1, !(i === "" || s === "/") && (yield [
            i,
            s
        ]);
    }
}
function vv(t, e) {
    if (t.length === 0 || e.tailwindConfig.prefix === "") return t;
    for (let r of t){
        let [n] = r;
        if (n.options.respectPrefix) {
            let i = I.root({
                nodes: [
                    r[1].clone()
                ]
            }), s = r[1].raws.tailwind.classCandidate;
            i.walkRules((a)=>{
                let o = s.startsWith("-");
                a.selector = at(e.tailwindConfig.prefix, a.selector, o);
            }), r[1] = i.nodes[0];
        }
    }
    return t;
}
function bv(t, e) {
    if (t.length === 0) return t;
    let r = [];
    for (let [n, i] of t){
        let s = I.root({
            nodes: [
                i.clone()
            ]
        });
        s.walkRules((a)=>{
            let o = (0, yn.default)().astSync(a.selector);
            o.each((l)=>Ps(l, e)), af(o, (l)=>l === e ? `!${l}` : l), a.selector = o.toString(), a.walkDecls((l)=>l.important = !0);
        }), r.push([
            {
                ...n,
                important: !0
            },
            s.nodes[0]
        ]);
    }
    return r;
}
function xv(t, e, r) {
    var i;
    if (e.length === 0) return e;
    let n = {
        modifier: null,
        value: mt
    };
    {
        let [s, ...a] = te(t, "/");
        if (a.length > 1 && (s = s + "/" + a.slice(0, -1).join("/"), a = a.slice(-1)), a.length && !r.variantMap.has(t) && (t = s, n.modifier = a[0], !G(r.tailwindConfig, "generalizedModifiers"))) return [];
    }
    if (t.endsWith("]") && !t.startsWith("[")) {
        let s = /(.)(-?)\[(.*)\]/g.exec(t);
        if (s) {
            let [, a, o, l] = s;
            if (a === "@" && o === "-") return [];
            if (a !== "@" && o === "") return [];
            t = t.replace(`${o}[${l}]`, ""), n.value = l;
        }
    }
    if (zs(t) && !r.variantMap.has(t)) {
        let s = z(t.slice(1, -1));
        if (!hn(s)) return [];
        let a = lr(s), o = r.offsets.recordVariant(t);
        r.variantMap.set(t, [
            [
                o,
                a
            ]
        ]);
    }
    if (r.variantMap.has(t)) {
        let s = zs(t), a = r.variantMap.get(t).slice(), o = [];
        for (let [l, u] of e){
            if (l.layer === "user") continue;
            let f = I.root({
                nodes: [
                    u.clone()
                ]
            });
            for (let [p, c, d] of a){
                let m = function() {
                    h.raws.neededBackup || (h.raws.neededBackup = !0, h.walkRules((v)=>v.raws.originalSelector = v.selector));
                }, g = function(v) {
                    return m(), h.each((C)=>{
                        C.type === "rule" && (C.selectors = C.selectors.map((x)=>v({
                                get className () {
                                    return Us(x);
                                },
                                selector: x
                            })));
                    }), h;
                }, h = (d != null ? d : f).clone(), y = [], w = c({
                    get container () {
                        return m(), h;
                    },
                    separator: r.tailwindConfig.separator,
                    modifySelectors: g,
                    wrap (v) {
                        let C = h.nodes;
                        h.removeAll(), v.append(C), h.append(v);
                    },
                    format (v) {
                        y.push({
                            format: v,
                            isArbitraryVariant: s
                        });
                    },
                    args: n
                });
                if (Array.isArray(w)) {
                    for (let [v, C] of w.entries())a.push([
                        r.offsets.applyParallelOffset(p, v),
                        C,
                        h.clone()
                    ]);
                    continue;
                }
                if (typeof w == "string" && y.push({
                    format: w,
                    isArbitraryVariant: s
                }), w === null) continue;
                h.raws.neededBackup && (delete h.raws.neededBackup, h.walkRules((v)=>{
                    let C = v.raws.originalSelector;
                    if (!C || (delete v.raws.originalSelector, C === v.selector)) return;
                    let x = v.selector, O = (0, yn.default)((E)=>{
                        E.walkClasses((R)=>{
                            R.value = `${t}${r.tailwindConfig.separator}${R.value}`;
                        });
                    }).processSync(C);
                    y.push({
                        format: x.replace(O, "&"),
                        isArbitraryVariant: s
                    }), v.selector = C;
                })), h.nodes[0].raws.tailwind = {
                    ...h.nodes[0].raws.tailwind,
                    parentLayer: l.layer
                };
                let b = [
                    {
                        ...l,
                        sort: r.offsets.applyVariantOffset(l.sort, p, Object.assign(n, r.variantOptions.get(t))),
                        collectedFormats: ((i = l.collectedFormats) != null ? i : []).concat(y)
                    },
                    h.nodes[0]
                ];
                o.push(b);
            }
        }
        return o;
    }
    return [];
}
function js(t, e, r = {}) {
    return !X(t) && !Array.isArray(t) ? [
        [
            t
        ],
        r
    ] : Array.isArray(t) ? js(t[0], e, t[1]) : (e.has(t) || e.set(t, st(t)), [
        e.get(t),
        r
    ]);
}
var Sv = /^[a-z_-]/;
function kv(t) {
    return Sv.test(t);
}
function Cv(t) {
    if (!t.includes("://")) return !1;
    try {
        let e = new URL(t);
        return e.scheme !== "" && e.host !== "";
    } catch  {
        return !1;
    }
}
function Tf(t) {
    let e = !0;
    return t.walkDecls((r)=>{
        if (!Pf(r.prop, r.value)) return e = !1, !1;
    }), e;
}
function Pf(t, e) {
    if (Cv(`${t}:${e}`)) return !1;
    try {
        return I.parse(`a{${t}:${e}}`).toResult(), !0;
    } catch  {
        return !1;
    }
}
function Ev(t, e) {
    var a;
    let [, r, n] = (a = t.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? a : [];
    if (n === void 0 || !kv(r) || !ut(n)) return null;
    let i = z(n);
    return Pf(r, i) ? [
        [
            {
                sort: e.offsets.arbitraryProperty(),
                layer: "utilities"
            },
            ()=>({
                    [Rs(t)]: {
                        [r]: i
                    }
                })
        ]
    ] : null;
}
function* Av(t, e) {
    e.candidateRuleMap.has(t) && (yield [
        e.candidateRuleMap.get(t),
        "DEFAULT"
    ]), yield* function*(o) {
        o !== null && (yield [
            o,
            "DEFAULT"
        ]);
    }(Ev(t, e));
    let r = t, n = !1, i = e.tailwindConfig.prefix, s = i.length, a = r.startsWith(i) || r.startsWith(`-${i}`);
    r[s] === "-" && a && (n = !0, r = i + r.slice(s + 1)), n && e.candidateRuleMap.has(r) && (yield [
        e.candidateRuleMap.get(r),
        "-DEFAULT"
    ]);
    for (let [o, l] of wv(r))e.candidateRuleMap.has(o) && (yield [
        e.candidateRuleMap.get(o),
        n ? `-${l}` : l
    ]);
}
function Ov(t, e) {
    return t === Ce ? [
        Ce
    ] : te(t, e);
}
function* _v(t, e) {
    var r, n;
    for (let i of t)i[1].raws.tailwind = {
        ...i[1].raws.tailwind,
        classCandidate: e,
        preserveSource: (n = (r = i[0].options) == null ? void 0 : r.preserveSource) != null ? n : !1
    }, yield i;
}
function* wn(t, e, r = t) {
    var o, l, u, f;
    let n = e.tailwindConfig.separator, [i, ...s] = Ov(t, n).reverse(), a = !1;
    if (i.startsWith("!") && (a = !0, i = i.slice(1)), G(e.tailwindConfig, "variantGrouping") && i.startsWith("(") && i.endsWith(")")) {
        let p = s.slice().reverse().join(n);
        for (let c of te(i.slice(1, -1), ","))yield* wn(p + n + c, e, r);
    }
    for (let p of Av(i, e)){
        let c = [], d = new Map, [h, y] = p, m = h.length === 1;
        for (let [g, w] of h){
            let b = [];
            if (typeof w == "function") for (let v of [].concat(w(y, {
                isOnlyPlugin: m
            }))){
                let [C, x] = js(v, e.postCssNodeCache);
                for (let O of C)b.push([
                    {
                        ...g,
                        options: {
                            ...g.options,
                            ...x
                        }
                    },
                    O
                ]);
            }
            else if (y === "DEFAULT" || y === "-DEFAULT") {
                let v = w, [C, x] = js(v, e.postCssNodeCache);
                for (let O of C)b.push([
                    {
                        ...g,
                        options: {
                            ...g.options,
                            ...x
                        }
                    },
                    O
                ]);
            }
            if (b.length > 0) {
                let v = Array.from(Os((l = (o = g.options) == null ? void 0 : o.types) != null ? l : [], y, (u = g.options) != null ? u : {}, e.tailwindConfig)).map(([C, x])=>x);
                v.length > 0 && d.set(b, v), c.push(b);
            }
        }
        if (zs(y)) {
            if (c.length > 1) {
                let b = function(C) {
                    return C.length === 1 ? C[0] : C.find((x)=>{
                        let O = d.get(x);
                        return x.some(([{ options: E }, R])=>Tf(R) ? E.types.some(({ type: L, preferOnConflict: B })=>O.includes(L) && B) : !1);
                    });
                }, [g, w] = c.reduce((C, x)=>(x.some(([{ options: E }])=>E.types.some(({ type: R })=>R === "any")) ? C[0].push(x) : C[1].push(x), C), [
                    [],
                    []
                ]), v = (f = b(w)) != null ? f : b(g);
                if (v) c = [
                    v
                ];
                else {
                    let C = c.map((O)=>{
                        var E;
                        return new Set([
                            ...(E = d.get(O)) != null ? E : []
                        ]);
                    });
                    for (let O of C)for (let E of O){
                        let R = !1;
                        for (let L of C)O !== L && L.has(E) && (L.delete(E), R = !0);
                        R && O.delete(E);
                    }
                    let x = [];
                    for (let [O, E] of C.entries())for (let R of E){
                        let L = c[O].map(([, B])=>B).flat().map((B)=>B.toString().split(`
`).slice(1, -1).map((Q)=>Q.trim()).map((Q)=>`      ${Q}`).join(`
`)).join(`

`);
                        x.push(`  Use \`${t.replace("[", `[${R}:`)}\` for \`${L.trim()}\``);
                        break;
                    }
                    D.warn([
                        `The class \`${t}\` is ambiguous and matches multiple utilities.`,
                        ...x,
                        `If this is content and not a class, replace it with \`${t.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
                    ]);
                    continue;
                }
            }
            c = c.map((g)=>g.filter((w)=>Tf(w[1])));
        }
        c = c.flat(), c = Array.from(_v(c, i)), c = vv(c, e), a && (c = bv(c, i));
        for (let g of s)c = xv(g, c, e);
        for (let g of c)g[1].raws.tailwind = {
            ...g[1].raws.tailwind,
            candidate: t
        }, g = Tv(g, {
            context: e,
            candidate: t,
            original: r
        }), g !== null && (yield g);
    }
}
function Tv(t, { context: e, candidate: r, original: n }) {
    if (!t[0].collectedFormats) return t;
    let i = !0, s;
    try {
        s = lt(t[0].collectedFormats, {
            context: e,
            candidate: r
        });
    } catch  {
        return null;
    }
    let a = I.root({
        nodes: [
            t[1].clone()
        ]
    });
    return a.walkRules((o)=>{
        if (!gn(o)) try {
            o.selector = an(o.selector, s, {
                candidate: n,
                context: e
            });
        } catch  {
            return i = !1, !1;
        }
    }), i ? (t[1] = a.nodes[0], t) : null;
}
function gn(t) {
    return t.parent && t.parent.type === "atrule" && t.parent.name === "keyframes";
}
function Pv(t) {
    if (t === !0) return (e)=>{
        gn(e) || e.walkDecls((r)=>{
            r.parent.type === "rule" && !gn(r.parent) && (r.important = !0);
        });
    };
    if (typeof t == "string") return (e)=>{
        gn(e) || (e.selectors = e.selectors.map((r)=>`${t} ${r}`));
    };
}
function mn(t, e) {
    var i;
    let r = [], n = Pv(e.tailwindConfig.important);
    for (let s of t){
        if (e.notClassCache.has(s)) continue;
        if (e.candidateRuleCache.has(s)) {
            r = r.concat(Array.from(e.candidateRuleCache.get(s)));
            continue;
        }
        let a = Array.from(wn(s, e));
        if (a.length === 0) {
            e.notClassCache.add(s);
            continue;
        }
        e.classCache.set(s, a);
        let o = (i = e.candidateRuleCache.get(s)) != null ? i : new Set;
        e.candidateRuleCache.set(s, o);
        for (let l of a){
            let [{ sort: u, options: f }, p] = l;
            if (f.respectImportant && n) {
                let d = I.root({
                    nodes: [
                        p.clone()
                    ]
                });
                d.walkRules(n), p = d.nodes[0];
            }
            let c = [
                u,
                p
            ];
            o.add(c), e.ruleCache.add(c), r.push(c);
        }
    }
    return r;
}
function zs(t) {
    return t.startsWith("[") && t.endsWith("]");
}
function Ge(t, e = void 0, r = void 0) {
    return t.map((n)=>{
        var a;
        let i = n.clone(), s = ((a = n.raws.tailwind) == null ? void 0 : a.preserveSource) !== !0 || !i.source;
        return e !== void 0 && s && (i.source = e, "walk" in i && i.walk((o)=>{
            o.source = e;
        })), r !== void 0 && (i.raws.tailwind = {
            ...i.raws.tailwind,
            ...r
        }), i;
    });
}
var Rf = /[\\^$.*+?()[\]{}|]/g, Rv = RegExp(Rf.source);
function vn(t) {
    return t = Array.isArray(t) ? t : [
        t
    ], t = t.map((e)=>e instanceof RegExp ? e.source : e), t.join("");
}
function ce(t) {
    return new RegExp(vn(t), "g");
}
function ft(t) {
    return `(?:${t.map(vn).join("|")})`;
}
function Vs(t) {
    return `(?:${vn(t)})?`;
}
function If(t) {
    return `(?:${vn(t)})*`;
}
function Df(t) {
    return t && Rv.test(t) ? t.replace(Rf, "\\$&") : t || "";
}
function Mf(t) {
    let e = Array.from(Dv(t));
    return (r)=>{
        var i;
        let n = [];
        for (let s of e)n = [
            ...n,
            ...(i = r.match(s)) != null ? i : []
        ];
        return n.filter((s)=>s !== void 0).map(Fv);
    };
}
function* Dv(t) {
    let e = t.tailwindConfig.separator, r = G(t.tailwindConfig, "variantGrouping"), n = t.tailwindConfig.prefix !== "" ? Vs(ce([
        /-?/,
        Df(t.tailwindConfig.prefix)
    ])) : "", i = ft([
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/,
        ce([
            /-?(?:\w+)/,
            Vs(ft([
                ce([
                    /-(?:\w+-)*\[[^\s:]+\]/,
                    /(?![{([]])/,
                    /(?:\/[^\s'"`\\><$]*)?/
                ]),
                ce([
                    /-(?:\w+-)*\[[^\s]+\]/,
                    /(?![{([]])/,
                    /(?:\/[^\s'"`\\$]*)?/
                ]),
                /[-\/][^\s'"`\\$={><]*/
            ]))
        ])
    ]), s = [
        ft([
            ce([
                /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
                e
            ]),
            ce([
                /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
                e
            ]),
            ce([
                /[^\s"'`\[\\]+/,
                e
            ])
        ]),
        ft([
            ce([
                /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
                e
            ]),
            ce([
                /[^\s`\[\\]+/,
                e
            ])
        ])
    ];
    for (let a of s)yield ce([
        "((?=((",
        a,
        ")+))\\2)?",
        /!?/,
        n,
        r ? ft([
            ce([
                /\(/,
                i,
                If([
                    /,/,
                    i
                ]),
                /\)/
            ]),
            i
        ]) : i
    ]);
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Mv = /([\[\]'"`])([^\[\]'"`])?/g, Lv = /[^"'`\s<>\]]+/;
function Fv(t) {
    if (!t.includes("-[")) return t;
    let e = 0, r = [], n = t.matchAll(Mv);
    n = Array.from(n).flatMap((i)=>{
        let [, ...s] = i;
        return s.map((a, o)=>Object.assign([], i, {
                index: i.index + o,
                0: a
            }));
    });
    for (let i of n){
        let s = i[0], a = r[r.length - 1];
        if (s === a ? r.pop() : (s === "'" || s === '"' || s === "`") && r.push(s), !a) {
            if (s === "[") {
                e++;
                continue;
            } else if (s === "]") {
                e--;
                continue;
            }
            if (e < 0) return t.substring(0, i.index - 1);
            if (e === 0 && !Lv.test(s)) return t.substring(0, i.index);
        }
    }
    return t;
}
var me = Un, Nf = {
    DEFAULT: Mf
}, qf = {
    DEFAULT: (t)=>t,
    svelte: (t)=>t.replace(/(?:^|\s)class:/g, " ")
};
function qv(t, e) {
    let r = t.tailwindConfig.content.extract;
    return r[e] || r.DEFAULT || Nf[e] || Nf.DEFAULT(t);
}
function $v(t, e) {
    let r = t.content.transform;
    return r[e] || r.DEFAULT || qf[e] || qf.DEFAULT;
}
var ur = new WeakMap;
function Uv(t, e, r, n) {
    ur.has(e) || ur.set(e, new $f.default({
        maxSize: 25e3
    }));
    for (let i of t.split(`
`))if (i = i.trim(), !n.has(i)) if (n.add(i), ur.get(e).has(i)) for (let s of ur.get(e).get(i))r.add(s);
    else {
        let s = e(i).filter((o)=>o !== "!*"), a = new Set(s);
        for (let o of a)r.add(o);
        ur.get(e).set(i, a);
    }
}
function jv(t, e) {
    let r = e.offsets.sort(t), n = {
        base: new Set,
        defaults: new Set,
        components: new Set,
        utilities: new Set,
        variants: new Set
    };
    for (let [i, s] of r)n[i.layer].add(s);
    return n;
}
function Ws(t) {
    return (e)=>{
        var h;
        let r = {
            base: null,
            components: null,
            utilities: null,
            variants: null
        };
        if (e.walkAtRules((y)=>{
            y.name === "tailwind" && Object.keys(r).includes(y.params) && (r[y.params] = y);
        }), Object.values(r).every((y)=>y === null)) return e;
        let n = new Set([
            ...(h = t.candidates) != null ? h : [],
            Ce
        ]), i = new Set;
        if (me.DEBUG && console.time("Reading changed files"), me.OXIDE) for (let y of (Ff(), ke(Lf)).parseCandidateStringsFromFiles(t.changedContent))n.add(y);
        else for (let { file: y, content: m, extension: g } of t.changedContent){
            let w = $v(t.tailwindConfig, g), b = qv(t, g);
            m = y ? ht.readFileSync(y, "utf8") : m, Uv(w(m), b, n, i);
        }
        me.DEBUG && console.timeEnd("Reading changed files");
        let s = t.classCache.size;
        me.DEBUG && console.time("Generate rules"), me.DEBUG && console.time("Sorting candidates");
        let a = me.OXIDE ? n : new Set([
            ...n
        ].sort((y, m)=>y === m ? 0 : y < m ? -1 : 1));
        me.DEBUG && console.timeEnd("Sorting candidates"), mn(a, t), me.DEBUG && console.timeEnd("Generate rules"), me.DEBUG && console.time("Build stylesheet"), (t.stylesheetCache === null || t.classCache.size !== s) && (t.stylesheetCache = jv([
            ...t.ruleCache
        ], t)), me.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: o, base: l, components: u, utilities: f, variants: p } = t.stylesheetCache;
        r.base && (r.base.before(Ge([
            ...l,
            ...o
        ], r.base.source, {
            layer: "base"
        })), r.base.remove()), r.components && (r.components.before(Ge([
            ...u
        ], r.components.source, {
            layer: "components"
        })), r.components.remove()), r.utilities && (r.utilities.before(Ge([
            ...f
        ], r.utilities.source, {
            layer: "utilities"
        })), r.utilities.remove());
        let c = Array.from(p).filter((y)=>{
            var g;
            let m = (g = y.raws.tailwind) == null ? void 0 : g.parentLayer;
            return m === "components" ? r.components !== null : m === "utilities" ? r.utilities !== null : !0;
        });
        r.variants ? (r.variants.before(Ge(c, r.variants.source, {
            layer: "variants"
        })), r.variants.remove()) : c.length > 0 && e.append(Ge(c, e.source, {
            layer: "variants"
        }));
        let d = c.some((y)=>{
            var m;
            return ((m = y.raws.tailwind) == null ? void 0 : m.parentLayer) === "utilities";
        });
        r.utilities && f.size === 0 && !d && D.warn("content-problems", [
            "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
            "https://tailwindcss.com/docs/content-configuration"
        ]), me.DEBUG && (console.log("Potential classes: ", n.size), console.log("Active contexts: ", jn.size)), t.changedContent = [], e.walkAtRules("layer", (y)=>{
            Object.keys(r).includes(y.params) && y.remove();
        });
    };
}
var Gs = Y(Oe());
function bn(t) {
    let e = new Map;
    I.root({
        nodes: [
            t.clone()
        ]
    }).walkRules((s)=>{
        (0, Gs.default)((a)=>{
            a.walkClasses((o)=>{
                let l = o.parent.toString(), u = e.get(l);
                u || e.set(l, u = new Set), u.add(o.value);
            });
        }).processSync(s.selector);
    });
    let n = Array.from(e.values(), (s)=>Array.from(s)), i = n.flat();
    return Object.assign(i, {
        groups: n
    });
}
var zv = (0, Gs.default)();
function Bs(t) {
    return zv.astSync(t);
}
function Uf(t, e) {
    let r = new Set;
    for (let n of t)r.add(n.split(e).pop());
    return Array.from(r);
}
function jf(t, e) {
    let r = t.tailwindConfig.prefix;
    return typeof r == "function" ? r(e) : r + e;
}
function* Vf(t) {
    for(yield t; t.parent;)yield t.parent, t = t.parent;
}
function Vv(t, e = {}) {
    let r = t.nodes;
    t.nodes = [];
    let n = t.clone(e);
    return t.nodes = r, n;
}
function Wv(t) {
    for (let e of Vf(t))if (t !== e) {
        if (e.type === "root") break;
        t = Vv(e, {
            nodes: [
                t
            ]
        });
    }
    return t;
}
function Bv(t, e) {
    let r = new Map;
    return t.walkRules((n)=>{
        var a;
        for (let o of Vf(n))if (((a = o.raws.tailwind) == null ? void 0 : a.layer) !== void 0) return;
        let i = Wv(n), s = e.offsets.create("user");
        for (let o of bn(n)){
            let l = r.get(o) || [];
            r.set(o, l), l.push([
                {
                    layer: "user",
                    sort: s,
                    important: !1
                },
                i
            ]);
        }
    }), r;
}
function Gv(t, e) {
    for (let r of t){
        if (e.notClassCache.has(r) || e.applyClassCache.has(r)) continue;
        if (e.classCache.has(r)) {
            e.applyClassCache.set(r, e.classCache.get(r).map(([i, s])=>[
                    i,
                    s.clone()
                ]));
            continue;
        }
        let n = Array.from(wn(r, e));
        if (n.length === 0) {
            e.notClassCache.add(r);
            continue;
        }
        e.applyClassCache.set(r, n);
    }
    return e.applyClassCache;
}
function Yv(t) {
    let e = null;
    return {
        get: (r)=>(e = e || t(), e.get(r)),
        has: (r)=>(e = e || t(), e.has(r))
    };
}
function Hv(t) {
    return {
        get: (e)=>t.flatMap((r)=>r.get(e) || []),
        has: (e)=>t.some((r)=>r.has(e))
    };
}
function zf(t) {
    let e = t.split(/[\s\t\n]+/g);
    return e[e.length - 1] === "!important" ? [
        e.slice(0, -1),
        !0
    ] : [
        e,
        !1
    ];
}
function Wf(t, e, r) {
    let n = new Set, i = [];
    if (t.walkAtRules("apply", (l)=>{
        let [u] = zf(l.params);
        for (let f of u)n.add(f);
        i.push(l);
    }), i.length === 0) return;
    let s = Hv([
        r,
        Gv(n, e)
    ]);
    function a(l, u, f) {
        let p = Bs(l), c = Bs(u), h = Bs(`.${re(f)}`).nodes[0].nodes[0];
        return p.each((y)=>{
            let m = new Set;
            c.each((g)=>{
                let w = !1;
                g = g.clone(), g.walkClasses((b)=>{
                    b.value === h.value && (w || (b.replaceWith(...y.nodes.map((v)=>v.clone())), m.add(g), w = !0));
                });
            });
            for (let g of m){
                let w = [
                    []
                ];
                for (let b of g.nodes)b.type === "combinator" ? (w.push(b), w.push([])) : w[w.length - 1].push(b);
                g.nodes = [];
                for (let b of w)Array.isArray(b) && b.sort((v, C)=>v.type === "tag" && C.type === "class" ? -1 : v.type === "class" && C.type === "tag" ? 1 : v.type === "class" && C.type === "pseudo" && C.value.startsWith("::") ? -1 : v.type === "pseudo" && v.value.startsWith("::") && C.type === "class" ? 1 : 0), g.nodes = g.nodes.concat(b);
            }
            y.replaceWith(...m);
        }), p.toString();
    }
    let o = new Map;
    for (let l of i){
        let [u] = o.get(l.parent) || [
            [],
            l.source
        ];
        o.set(l.parent, [
            u,
            l.source
        ]);
        let [f, p] = zf(l.params);
        if (l.parent.type === "atrule") {
            if (l.parent.name === "screen") {
                let c = l.parent.params;
                throw l.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f.map((d)=>`${c}:${d}`).join(" ")} instead.`);
            }
            throw l.error(`@apply is not supported within nested at-rules like @${l.parent.name}. You can fix this by un-nesting @${l.parent.name}.`);
        }
        for (let c of f){
            if ([
                jf(e, "group"),
                jf(e, "peer")
            ].includes(c)) throw l.error(`@apply should not be used with the '${c}' utility`);
            if (!s.has(c)) throw l.error(`The \`${c}\` class does not exist. If \`${c}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
            let d = s.get(c);
            u.push([
                c,
                p,
                d
            ]);
        }
    }
    for (let [l, [u, f]] of o){
        let p = [];
        for (let [d, h, y] of u){
            let m = [
                d,
                ...Uf([
                    d
                ], e.tailwindConfig.separator)
            ];
            for (let [g, w] of y){
                let b = bn(l), v = bn(w);
                if (v = v.groups.filter((E)=>E.some((R)=>m.includes(R))).flat(), v = v.concat(Uf(v, e.tailwindConfig.separator)), b.some((E)=>v.includes(E))) throw w.error(`You cannot \`@apply\` the \`${d}\` utility here because it creates a circular dependency.`);
                let x = I.root({
                    nodes: [
                        w.clone()
                    ]
                });
                x.walk((E)=>{
                    E.source = f;
                }), (w.type !== "atrule" || w.type === "atrule" && w.name !== "keyframes") && x.walkRules((E)=>{
                    if (!bn(E).some((Q)=>Q === d)) {
                        E.remove();
                        return;
                    }
                    let R = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null, B = l.raws.tailwind !== void 0 && R && l.selector.indexOf(R) === 0 ? l.selector.slice(R.length) : l.selector;
                    E.selector = a(B, E.selector, d), R && B !== l.selector && (E.selector = `${R} ${E.selector}`), E.walkDecls((Q)=>{
                        Q.important = g.important || h;
                    });
                }), x.nodes[0] && p.push([
                    g.sort,
                    x.nodes[0]
                ]);
            }
        }
        let c = e.offsets.sort(p).map((d)=>d[1]);
        l.after(c);
    }
    for (let l of i)l.parent.nodes.length > 1 ? l.remove() : l.parent.remove();
    Wf(t, e, r);
}
function Ys(t) {
    return (e)=>{
        let r = Yv(()=>Bv(e, t));
        Wf(e, t, r);
    };
}
var fr = Y(Ms()), oc = Y(Bf());
var na = Y(sc());
function ta(t) {
    return typeof t == "object" && t !== null;
}
function n0(t, e) {
    let r = Ne(e);
    do if (r.pop(), (0, fr.default)(t, r) !== void 0) break;
    while (r.length);
    return r.length ? r : void 0;
}
function pt(t) {
    return typeof t == "string" ? t : t.reduce((e, r, n)=>r.includes(".") ? `${e}[${r}]` : n === 0 ? r : `${e}.${r}`, "");
}
function lc(t) {
    return t.map((e)=>`'${e}'`).join(", ");
}
function ac(t) {
    return lc(Object.keys(t));
}
function ra(t, e, r, n = {}) {
    let i = Array.isArray(e) ? pt(e) : e.replace(/^['"]+|['"]+$/g, ""), s = Array.isArray(e) ? e : Ne(i), a = (0, fr.default)(t.theme, s, r);
    if (a === void 0) {
        let l = `'${i}' does not exist in your theme config.`, u = s.slice(0, -1), f = (0, fr.default)(t.theme, u);
        if (ta(f)) {
            let p = Object.keys(f).filter((d)=>ra(t, [
                    ...u,
                    d
                ]).isValid), c = (0, oc.default)(s[s.length - 1], p);
            c ? l += ` Did you mean '${pt([
                ...u,
                c
            ])}'?` : p.length > 0 && (l += ` '${pt(u)}' has the following valid keys: ${lc(p)}`);
        } else {
            let p = n0(t.theme, i);
            if (p) {
                let c = (0, fr.default)(t.theme, p);
                ta(c) ? l += ` '${pt(p)}' has the following keys: ${ac(c)}` : l += ` '${pt(p)}' is not an object.`;
            } else l += ` Your theme has the following top-level keys: ${ac(t.theme)}`;
        }
        return {
            isValid: !1,
            error: l
        };
    }
    if (!(typeof a == "string" || typeof a == "number" || typeof a == "function" || a instanceof String || a instanceof Number || Array.isArray(a))) {
        let l = `'${i}' was found but does not resolve to a string.`;
        if (ta(a)) {
            let u = Object.keys(a).filter((f)=>ra(t, [
                    ...s,
                    f
                ]).isValid);
            u.length && (l += ` Did you mean something like '${pt([
                ...s,
                u[0]
            ])}'?`);
        }
        return {
            isValid: !1,
            error: l
        };
    }
    let [o] = s;
    return {
        isValid: !0,
        value: _e(o)(a, n)
    };
}
function i0(t, e, r) {
    e = e.map((i)=>uc(t, i, r));
    let n = [
        ""
    ];
    for (let i of e)i.type === "div" && i.value === "," ? n.push("") : n[n.length - 1] += na.default.stringify(i);
    return n;
}
function uc(t, e, r) {
    if (e.type === "function" && r[e.value] !== void 0) {
        let n = i0(t, e.nodes, r);
        e.type = "word", e.value = r[e.value](t, ...n);
    }
    return e;
}
function s0(t, e, r) {
    return (0, na.default)(e).walk((n)=>{
        uc(t, n, r);
    }).toString();
}
var a0 = {
    atrule: "params",
    decl: "value"
};
function* o0(t) {
    t = t.replace(/^['"]+|['"]+$/g, "");
    let e = t.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r;
    yield [
        t,
        void 0
    ], e && (t = e[1], r = e[2], yield [
        t,
        r
    ]);
}
function l0(t, e, r) {
    var i;
    let n = Array.from(o0(e)).map(([s, a])=>Object.assign(ra(t, s, r, {
            opacityValue: a
        }), {
            resolvedPath: s,
            alpha: a
        }));
    return (i = n.find((s)=>s.isValid)) != null ? i : n[0];
}
function fc(t) {
    let e = t.tailwindConfig, r = {
        theme: (n, i, ...s)=>{
            var c;
            let { isValid: a, value: o, error: l, alpha: u } = l0(e, i, s.length ? s : void 0);
            if (!a) {
                let d = n.parent, h = (c = d == null ? void 0 : d.raws.tailwind) == null ? void 0 : c.candidate;
                if (d && h !== void 0) {
                    t.markInvalidUtilityNode(d), d.remove(), D.warn("invalid-theme-key-in-class", [
                        `The utility \`${h}\` contains an invalid theme value and was not generated.`
                    ]);
                    return;
                }
                throw n.error(l);
            }
            let f = ot(o);
            return (u !== void 0 || f !== void 0 && typeof f == "function") && (u === void 0 && (u = 1), o = ve(f, u, f)), o;
        },
        screen: (n, i)=>{
            i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
            let a = Fe(e.theme.screens).find(({ name: o })=>o === i);
            if (!a) throw n.error(`The '${i}' screen does not exist in your theme.`);
            return Le(a);
        }
    };
    return (n)=>{
        n.walk((i)=>{
            let s = a0[i.type];
            s !== void 0 && (i[s] = s0(i, i[s], r));
        });
    };
}
function cc({ tailwindConfig: { theme: t } }) {
    return function(e) {
        e.walkAtRules("screen", (r)=>{
            let n = r.params, s = Fe(t.screens).find(({ name: a })=>a === n);
            if (!s) throw r.error(`No \`${n}\` screen found.`);
            r.name = "media", r.params = Le(s);
        });
    };
}
var An = Y(Oe());
var pc = {
    id (t) {
        return An.default.attribute({
            attribute: "id",
            operator: "=",
            value: t.value,
            quoteMark: '"'
        });
    }
};
function u0(t) {
    let e = t.filter((o)=>o.type !== "pseudo" || o.nodes.length > 0 ? !0 : o.value.startsWith("::") || [
            ":before",
            ":after",
            ":first-line",
            ":first-letter"
        ].includes(o.value)).reverse(), r = new Set([
        "tag",
        "class",
        "id",
        "attribute"
    ]), n = e.findIndex((o)=>r.has(o.type));
    if (n === -1) return e.reverse().join("").trim();
    let i = e[n], s = pc[i.type] ? pc[i.type](i) : i;
    e = e.slice(0, n);
    let a = e.findIndex((o)=>o.type === "combinator" && o.value === ">");
    return a !== -1 && (e.splice(0, a), e.unshift(An.default.universal())), [
        s,
        ...e.reverse()
    ].join("").trim();
}
var f0 = (0, An.default)((t)=>t.map((e)=>{
        let r = e.split((n)=>n.type === "combinator" && n.value === " ").pop();
        return u0(r);
    })), ia = new Map;
function c0(t) {
    return ia.has(t) || ia.set(t, f0.transformSync(t)), ia.get(t);
}
function sa({ tailwindConfig: t }) {
    return (e)=>{
        var i, s;
        let r = new Map, n = new Set;
        if (e.walkAtRules("defaults", (a)=>{
            if (a.nodes && a.nodes.length > 0) {
                n.add(a);
                return;
            }
            let o = a.params;
            r.has(o) || r.set(o, new Set), r.get(o).add(a.parent), a.remove();
        }), G(t, "optimizeUniversalDefaults")) for (let a of n){
            let o = new Map, l = (i = r.get(a.params)) != null ? i : [];
            for (let u of l)for (let f of c0(u.selector)){
                let p = f.includes(":-") || f.includes("::-") ? f : "__DEFAULT__", c = (s = o.get(p)) != null ? s : new Set;
                o.set(p, c), c.add(f);
            }
            if (G(t, "optimizeUniversalDefaults")) {
                if (o.size === 0) {
                    a.remove();
                    continue;
                }
                for (let [, u] of o){
                    let f = I.rule({
                        source: a.source
                    });
                    f.selectors = [
                        ...u
                    ], f.append(a.nodes.map((p)=>p.clone())), a.before(f);
                }
            }
            a.remove();
        }
        else if (n.size) {
            let a = I.rule({
                selectors: [
                    "*",
                    "::before",
                    "::after"
                ]
            });
            for (let l of n)a.append(l.nodes), a.parent || l.before(a), a.source || (a.source = l.source), l.remove();
            let o = a.clone({
                selectors: [
                    "::backdrop"
                ]
            });
            a.after(o);
        }
    };
}
var dc = {
    atrule: [
        "name",
        "params"
    ],
    rule: [
        "selector"
    ]
}, p0 = new Set(Object.keys(dc));
function aa() {
    function t(e) {
        let r = null;
        e.each((n)=>{
            if (!p0.has(n.type)) {
                r = null;
                return;
            }
            if (r === null) {
                r = n;
                return;
            }
            let i = dc[n.type];
            n.type === "atrule" && n.name === "font-face" ? r = n : i.every((s)=>{
                var a, o;
                return ((a = n[s]) != null ? a : "").replace(/\s+/g, " ") === ((o = r[s]) != null ? o : "").replace(/\s+/g, " ");
            }) ? (n.nodes && r.append(n.nodes), n.remove()) : r = n;
        }), e.each((n)=>{
            n.type === "atrule" && t(n);
        });
    }
    return (e)=>{
        t(e);
    };
}
function oa() {
    return (t)=>{
        t.walkRules((e)=>{
            let r = new Map, n = new Set([]), i = new Map;
            e.walkDecls((s)=>{
                if (s.parent === e) {
                    if (r.has(s.prop)) {
                        if (r.get(s.prop).value === s.value) {
                            n.add(r.get(s.prop)), r.set(s.prop, s);
                            return;
                        }
                        i.has(s.prop) || i.set(s.prop, new Set), i.get(s.prop).add(r.get(s.prop)), i.get(s.prop).add(s);
                    }
                    r.set(s.prop, s);
                }
            });
            for (let s of n)s.remove();
            for (let s of i.values()){
                let a = new Map;
                for (let o of s){
                    let l = h0(o.value);
                    l !== null && (a.has(l) || a.set(l, new Set), a.get(l).add(o));
                }
                for (let o of a.values()){
                    let l = Array.from(o).slice(0, -1);
                    for (let u of l)u.remove();
                }
            }
        });
    };
}
var d0 = Symbol("unitless-number");
function h0(t) {
    var r;
    let e = /^-?\d*.?\d+([\w%]+)?$/g.exec(t);
    return e ? (r = e[1]) != null ? r : d0 : null;
}
function m0(t) {
    if (!t.walkAtRules) return;
    let e = new Set;
    if (t.walkAtRules("apply", (r)=>{
        e.add(r.parent);
    }), e.size !== 0) for (let r of e){
        let n = [], i = [];
        for (let s of r.nodes)s.type === "atrule" && s.name === "apply" ? (i.length > 0 && (n.push(i), i = []), n.push([
            s
        ])) : i.push(s);
        if (i.length > 0 && n.push(i), n.length !== 1) {
            for (let s of [
                ...n
            ].reverse()){
                let a = r.clone({
                    nodes: []
                });
                a.append(s), r.after(a);
            }
            r.remove();
        }
    }
}
function On() {
    return (t)=>{
        m0(t);
    };
}
function g0(t) {
    return t.type === "root";
}
function y0(t) {
    return t.type === "atrule" && t.name === "layer";
}
function hc(t) {
    return (e, r)=>{
        let n = !1;
        e.walkAtRules("tailwind", (i)=>{
            if (n) return !1;
            if (i.parent && !(g0(i.parent) || y0(i.parent))) return n = !0, i.warn(r, [
                "Nested @tailwind rules were detected, but are not supported.",
                "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
                "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
            ].join(`
`)), !1;
        }), e.walkRules((i)=>{
            if (n) return !1;
            i.walkRules((s)=>(n = !0, s.warn(r, [
                    "Nested CSS was detected, but CSS nesting has not been configured correctly.",
                    "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
                    "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
                ].join(`
`)), !1));
        });
    };
}
function la(t) {
    return function(e, r) {
        let { tailwindDirectives: n, applyDirectives: i } = Nn(e);
        hc()(e, r), On()(e, r);
        let s = t({
            tailwindDirectives: n,
            applyDirectives: i,
            registerDependency (a) {
                r.messages.push({
                    plugin: "tailwindcss",
                    parent: r.opts.from,
                    ...a
                });
            },
            createContext (a, o) {
                return _f(a, o, e);
            }
        })(e, r);
        if (s.tailwindConfig.separator === "-") throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
        nf(s.tailwindConfig), Ws(s)(e, r), On()(e, r), Ys(s)(e, r), fc(s)(e, r), cc(s)(e, r), sa(s)(e, r), aa(s)(e, r), oa(s)(e, r);
    };
}
var mc = [
    "preflight",
    "container",
    "accessibility",
    "pointerEvents",
    "visibility",
    "position",
    "inset",
    "isolation",
    "zIndex",
    "order",
    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRow",
    "gridRowStart",
    "gridRowEnd",
    "float",
    "clear",
    "margin",
    "boxSizing",
    "display",
    "aspectRatio",
    "height",
    "maxHeight",
    "minHeight",
    "width",
    "minWidth",
    "maxWidth",
    "flex",
    "flexShrink",
    "flexGrow",
    "flexBasis",
    "tableLayout",
    "borderCollapse",
    "borderSpacing",
    "transformOrigin",
    "translate",
    "rotate",
    "skew",
    "scale",
    "transform",
    "animation",
    "cursor",
    "touchAction",
    "userSelect",
    "resize",
    "scrollSnapType",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollMargin",
    "scrollPadding",
    "listStylePosition",
    "listStyleType",
    "appearance",
    "columns",
    "breakBefore",
    "breakInside",
    "breakAfter",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridTemplateColumns",
    "gridTemplateRows",
    "flexDirection",
    "flexWrap",
    "placeContent",
    "placeItems",
    "alignContent",
    "alignItems",
    "justifyContent",
    "justifyItems",
    "gap",
    "space",
    "divideWidth",
    "divideStyle",
    "divideColor",
    "divideOpacity",
    "placeSelf",
    "alignSelf",
    "justifySelf",
    "overflow",
    "overscrollBehavior",
    "scrollBehavior",
    "textOverflow",
    "whitespace",
    "wordBreak",
    "borderRadius",
    "borderWidth",
    "borderStyle",
    "borderColor",
    "borderOpacity",
    "backgroundColor",
    "backgroundOpacity",
    "backgroundImage",
    "gradientColorStops",
    "boxDecorationBreak",
    "backgroundSize",
    "backgroundAttachment",
    "backgroundClip",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundOrigin",
    "fill",
    "stroke",
    "strokeWidth",
    "objectFit",
    "objectPosition",
    "padding",
    "textAlign",
    "textIndent",
    "verticalAlign",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "textTransform",
    "fontStyle",
    "fontVariantNumeric",
    "lineHeight",
    "letterSpacing",
    "textColor",
    "textOpacity",
    "textDecoration",
    "textDecorationColor",
    "textDecorationStyle",
    "textDecorationThickness",
    "textUnderlineOffset",
    "fontSmoothing",
    "placeholderColor",
    "placeholderOpacity",
    "caretColor",
    "accentColor",
    "opacity",
    "backgroundBlendMode",
    "mixBlendMode",
    "boxShadow",
    "boxShadowColor",
    "outlineStyle",
    "outlineWidth",
    "outlineOffset",
    "outlineColor",
    "ringWidth",
    "ringColor",
    "ringOpacity",
    "ringOffsetWidth",
    "ringOffsetColor",
    "blur",
    "brightness",
    "contrast",
    "dropShadow",
    "grayscale",
    "hueRotate",
    "invert",
    "saturate",
    "sepia",
    "filter",
    "backdropBlur",
    "backdropBrightness",
    "backdropContrast",
    "backdropGrayscale",
    "backdropHueRotate",
    "backdropInvert",
    "backdropOpacity",
    "backdropSaturate",
    "backdropSepia",
    "backdropFilter",
    "transitionProperty",
    "transitionDelay",
    "transitionDuration",
    "transitionTimingFunction",
    "willChange",
    "content"
];
function gc(t, e) {
    return t === void 0 ? e : Array.isArray(t) ? t : [
        ...new Set(e.filter((n)=>t !== !1 && t[n] !== !1).concat(Object.keys(t).filter((n)=>t[n] !== !1)))
    ];
}
function cr({ version: t, from: e, to: r }) {
    D.warn(`${e}-color-renamed`, [
        `As of Tailwind CSS ${t}, \`${e}\` has been renamed to \`${r}\`.`,
        "Update your configuration file to silence this warning."
    ]);
}
var yc = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a"
    },
    gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827"
    },
    zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b"
    },
    neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717"
    },
    stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917"
    },
    red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d"
    },
    orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12"
    },
    amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f"
    },
    yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12"
    },
    lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314"
    },
    green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d"
    },
    emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b"
    },
    teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a"
    },
    cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63"
    },
    sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e"
    },
    blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a"
    },
    indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81"
    },
    violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95"
    },
    purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87"
    },
    fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75"
    },
    pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843"
    },
    rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337"
    },
    get lightBlue () {
        return cr({
            version: "v2.2",
            from: "lightBlue",
            to: "sky"
        }), this.sky;
    },
    get warmGray () {
        return cr({
            version: "v3.0",
            from: "warmGray",
            to: "stone"
        }), this.stone;
    },
    get trueGray () {
        return cr({
            version: "v3.0",
            from: "trueGray",
            to: "neutral"
        }), this.neutral;
    },
    get coolGray () {
        return cr({
            version: "v3.0",
            from: "coolGray",
            to: "gray"
        }), this.gray;
    },
    get blueGray () {
        return cr({
            version: "v3.0",
            from: "blueGray",
            to: "slate"
        }), this.slate;
    }
};
function ua(t, ...e) {
    var r, n;
    for (let i of e){
        for(let s in i)(r = t == null ? void 0 : t.hasOwnProperty) != null && r.call(t, s) || (t[s] = i[s]);
        for (let s of Object.getOwnPropertySymbols(i))(n = t == null ? void 0 : t.hasOwnProperty) != null && n.call(t, s) || (t[s] = i[s]);
    }
    return t;
}
function wc(t) {
    var r;
    (()=>{
        if (t.purge || !t.content || !Array.isArray(t.content) && !(typeof t.content == "object" && t.content !== null)) return !1;
        if (Array.isArray(t.content)) return t.content.every((n)=>typeof n == "string" ? !0 : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string"));
        if (typeof t.content == "object" && t.content !== null) {
            if (Object.keys(t.content).some((n)=>![
                    "files",
                    "relative",
                    "extract",
                    "transform"
                ].includes(n))) return !1;
            if (Array.isArray(t.content.files)) {
                if (!t.content.files.every((n)=>typeof n == "string" ? !0 : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string"))) return !1;
                if (typeof t.content.extract == "object") {
                    for (let n of Object.values(t.content.extract))if (typeof n != "function") return !1;
                } else if (!(t.content.extract === void 0 || typeof t.content.extract == "function")) return !1;
                if (typeof t.content.transform == "object") {
                    for (let n of Object.values(t.content.transform))if (typeof n != "function") return !1;
                } else if (!(t.content.transform === void 0 || typeof t.content.transform == "function")) return !1;
                if (typeof t.content.relative != "boolean" && typeof t.content.relative < "u") return !1;
            }
            return !0;
        }
        return !1;
    })() || D.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]), t.safelist = (()=>{
        var a;
        let { content: n, purge: i, safelist: s } = t;
        return Array.isArray(s) ? s : Array.isArray(n == null ? void 0 : n.safelist) ? n.safelist : Array.isArray(i == null ? void 0 : i.safelist) ? i.safelist : Array.isArray((a = i == null ? void 0 : i.options) == null ? void 0 : a.safelist) ? i.options.safelist : [];
    })(), t.blocklist = (()=>{
        let { blocklist: n } = t;
        if (Array.isArray(n)) {
            if (n.every((i)=>typeof i == "string")) return n;
            D.warn("blocklist-invalid", [
                "The `blocklist` option must be an array of strings.",
                "https://tailwindcss.com/docs/content-configuration#discarding-classes"
            ]);
        }
        return [];
    })(), typeof t.prefix == "function" ? (D.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
    ]), t.prefix = "") : t.prefix = (r = t.prefix) != null ? r : "", t.content = {
        relative: (()=>{
            var i, s;
            let { content: n } = t;
            return n != null && n.relative ? n.relative : (s = (i = t.future) == null ? void 0 : i.relativeContentPathsByDefault) != null ? s : !1;
        })(),
        files: (()=>{
            let { content: n, purge: i } = t;
            return Array.isArray(i) ? i : Array.isArray(i == null ? void 0 : i.content) ? i.content : Array.isArray(n) ? n : Array.isArray(n == null ? void 0 : n.content) ? n.content : Array.isArray(n == null ? void 0 : n.files) ? n.files : [];
        })(),
        extract: (()=>{
            let n = (()=>{
                var a, o, l, u, f, p, c, d, h, y;
                return (a = t.purge) != null && a.extract ? t.purge.extract : (o = t.content) != null && o.extract ? t.content.extract : (u = (l = t.purge) == null ? void 0 : l.extract) != null && u.DEFAULT ? t.purge.extract.DEFAULT : (p = (f = t.content) == null ? void 0 : f.extract) != null && p.DEFAULT ? t.content.extract.DEFAULT : (d = (c = t.purge) == null ? void 0 : c.options) != null && d.extractors ? t.purge.options.extractors : (y = (h = t.content) == null ? void 0 : h.options) != null && y.extractors ? t.content.options.extractors : {};
            })(), i = {}, s = (()=>{
                var a, o, l, u;
                if ((o = (a = t.purge) == null ? void 0 : a.options) != null && o.defaultExtractor) return t.purge.options.defaultExtractor;
                if ((u = (l = t.content) == null ? void 0 : l.options) != null && u.defaultExtractor) return t.content.options.defaultExtractor;
            })();
            if (s !== void 0 && (i.DEFAULT = s), typeof n == "function") i.DEFAULT = n;
            else if (Array.isArray(n)) for (let { extensions: a, extractor: o } of n != null ? n : [])for (let l of a)i[l] = o;
            else typeof n == "object" && n !== null && Object.assign(i, n);
            return i;
        })(),
        transform: (()=>{
            let n = (()=>{
                var s, a, o, l, u, f;
                return (s = t.purge) != null && s.transform ? t.purge.transform : (a = t.content) != null && a.transform ? t.content.transform : (l = (o = t.purge) == null ? void 0 : o.transform) != null && l.DEFAULT ? t.purge.transform.DEFAULT : (f = (u = t.content) == null ? void 0 : u.transform) != null && f.DEFAULT ? t.content.transform.DEFAULT : {};
            })(), i = {};
            return typeof n == "function" && (i.DEFAULT = n), typeof n == "object" && n !== null && Object.assign(i, n), i;
        })()
    };
    for (let n of t.content.files)if (typeof n == "string" && /{([^,]*?)}/g.test(n)) {
        D.warn("invalid-glob-braces", [
            `The glob pattern ${n} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${n.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`
        ]);
        break;
    }
    return t;
}
function _n(t) {
    return Array.isArray(t) ? t.map((e)=>_n(e)) : typeof t == "object" && t !== null ? Object.fromEntries(Object.entries(t).map(([e, r])=>[
            e,
            _n(r)
        ])) : t;
}
function dt(t) {
    return typeof t == "function";
}
function pr(t, ...e) {
    let r = e.pop();
    for (let n of e)for(let i in n){
        let s = r(t[i], n[i]);
        s === void 0 ? X(t[i]) && X(n[i]) ? t[i] = pr({}, t[i], n[i], r) : t[i] = n[i] : t[i] = s;
    }
    return t;
}
var fa = {
    colors: yc,
    negative (t) {
        return Object.keys(t).filter((e)=>t[e] !== "0").reduce((e, r)=>{
            let n = De(t[r]);
            return n !== void 0 && (e[`-${r}`] = n), e;
        }, {});
    },
    breakpoints (t) {
        return Object.keys(t).filter((e)=>typeof t[e] == "string").reduce((e, r)=>({
                ...e,
                [`screen-${r}`]: t[r]
            }), {});
    }
};
function w0(t, ...e) {
    return dt(t) ? t(...e) : t;
}
function v0(t) {
    return t.reduce((e, { extend: r })=>pr(e, r, (n, i)=>n === void 0 ? [
                i
            ] : Array.isArray(n) ? [
                i,
                ...n
            ] : [
                i,
                n
            ]), {});
}
function b0(t) {
    return {
        ...t.reduce((e, r)=>ua(e, r), {}),
        extend: v0(t)
    };
}
function vc(t, e) {
    if (Array.isArray(t) && X(t[0])) return t.concat(e);
    if (Array.isArray(e) && X(e[0]) && X(t)) return [
        t,
        ...e
    ];
    if (Array.isArray(e)) return e;
}
function x0({ extend: t, ...e }) {
    return pr(e, t, (r, n)=>!dt(r) && !n.some(dt) ? pr({}, r, ...n, vc) : (i, s)=>pr({}, ...[
                r,
                ...n
            ].map((a)=>w0(a, i, s)), vc));
}
function* S0(t) {
    let e = Ne(t);
    if (e.length === 0 || (yield e, Array.isArray(t))) return;
    let r = /^(.*?)\s*\/\s*([^/]+)$/, n = t.match(r);
    if (n !== null) {
        let [, i, s] = n, a = Ne(i);
        a.alpha = s, yield a;
    }
}
function k0(t) {
    let e = (r, n)=>{
        for (let i of S0(r)){
            let s = 0, a = t;
            for(; a != null && s < i.length;)a = a[i[s++]], a = dt(a) && (i.alpha === void 0 || s <= i.length - 1) ? a(e, fa) : a;
            if (a !== void 0) {
                if (i.alpha !== void 0) {
                    let o = ot(a);
                    return ve(o, i.alpha, N(o));
                }
                return X(a) ? _n(a) : a;
            }
        }
        return n;
    };
    return Object.assign(e, {
        theme: e,
        ...fa
    }), Object.keys(t).reduce((r, n)=>(r[n] = dt(t[n]) ? t[n](e, fa) : t[n], r), {});
}
function bc(t) {
    let e = [];
    return t.forEach((r)=>{
        var i;
        e = [
            ...e,
            r
        ];
        let n = (i = r == null ? void 0 : r.plugins) != null ? i : [];
        n.length !== 0 && n.forEach((s)=>{
            var a;
            s.__isOptionsFunction && (s = s()), e = [
                ...e,
                ...bc([
                    (a = s == null ? void 0 : s.config) != null ? a : {}
                ])
            ];
        });
    }), e;
}
function C0(t) {
    return [
        ...t
    ].reduceRight((r, n)=>dt(n) ? n({
            corePlugins: r
        }) : gc(n, r), mc);
}
function E0(t) {
    return [
        ...t
    ].reduceRight((r, n)=>[
            ...r,
            ...n
        ], []);
}
function ca(t) {
    let e = [
        ...bc(t),
        {
            prefix: "",
            important: !1,
            separator: ":"
        }
    ];
    return wc(ua({
        theme: k0(x0(b0(e.map((r)=>{
            var n;
            return (n = r == null ? void 0 : r.theme) != null ? n : {};
        })))),
        corePlugins: C0(e.map((r)=>r.corePlugins)),
        plugins: E0(t.map((r)=>{
            var n;
            return (n = r == null ? void 0 : r.plugins) != null ? n : [];
        }))
    }, ...e));
}
var xc = {
    content: [],
    presets: [],
    darkMode: "media",
    theme: {
        accentColor: ({ theme: t })=>({
                ...t("colors"),
                auto: "auto"
            }),
        animation: {
            none: "none",
            spin: "spin 1s linear infinite",
            ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
            pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
            bounce: "bounce 1s infinite"
        },
        aria: {
            checked: 'checked="true"',
            disabled: 'disabled="true"',
            expanded: 'expanded="true"',
            hidden: 'hidden="true"',
            pressed: 'pressed="true"',
            readonly: 'readonly="true"',
            required: 'required="true"',
            selected: 'selected="true"'
        },
        aspectRatio: {
            auto: "auto",
            square: "1 / 1",
            video: "16 / 9"
        },
        backdropBlur: ({ theme: t })=>t("blur"),
        backdropBrightness: ({ theme: t })=>t("brightness"),
        backdropContrast: ({ theme: t })=>t("contrast"),
        backdropGrayscale: ({ theme: t })=>t("grayscale"),
        backdropHueRotate: ({ theme: t })=>t("hueRotate"),
        backdropInvert: ({ theme: t })=>t("invert"),
        backdropOpacity: ({ theme: t })=>t("opacity"),
        backdropSaturate: ({ theme: t })=>t("saturate"),
        backdropSepia: ({ theme: t })=>t("sepia"),
        backgroundColor: ({ theme: t })=>t("colors"),
        backgroundImage: {
            none: "none",
            "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
            "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
            "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
            "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
            "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
            "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
            "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
            "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: ({ theme: t })=>t("opacity"),
        backgroundPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
        },
        backgroundSize: {
            auto: "auto",
            cover: "cover",
            contain: "contain"
        },
        blur: {
            0: "0",
            none: "0",
            sm: "4px",
            DEFAULT: "8px",
            md: "12px",
            lg: "16px",
            xl: "24px",
            "2xl": "40px",
            "3xl": "64px"
        },
        borderColor: ({ theme: t })=>({
                ...t("colors"),
                DEFAULT: t("colors.gray.200", "currentColor")
            }),
        borderOpacity: ({ theme: t })=>t("opacity"),
        borderRadius: {
            none: "0px",
            sm: "0.125rem",
            DEFAULT: "0.25rem",
            md: "0.375rem",
            lg: "0.5rem",
            xl: "0.75rem",
            "2xl": "1rem",
            "3xl": "1.5rem",
            full: "9999px"
        },
        borderSpacing: ({ theme: t })=>({
                ...t("spacing")
            }),
        borderWidth: {
            DEFAULT: "1px",
            0: "0px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        boxShadow: {
            sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
            DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
            md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
            lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
            xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
            "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
            inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
            none: "none"
        },
        boxShadowColor: ({ theme: t })=>t("colors"),
        brightness: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5",
            200: "2"
        },
        caretColor: ({ theme: t })=>t("colors"),
        colors: ({ colors: t })=>({
                inherit: t.inherit,
                current: t.current,
                transparent: t.transparent,
                black: t.black,
                white: t.white,
                slate: t.slate,
                gray: t.gray,
                zinc: t.zinc,
                neutral: t.neutral,
                stone: t.stone,
                red: t.red,
                orange: t.orange,
                amber: t.amber,
                yellow: t.yellow,
                lime: t.lime,
                green: t.green,
                emerald: t.emerald,
                teal: t.teal,
                cyan: t.cyan,
                sky: t.sky,
                blue: t.blue,
                indigo: t.indigo,
                violet: t.violet,
                purple: t.purple,
                fuchsia: t.fuchsia,
                pink: t.pink,
                rose: t.rose
            }),
        columns: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            "3xs": "16rem",
            "2xs": "18rem",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem"
        },
        container: {},
        content: {
            none: "none"
        },
        contrast: {
            0: "0",
            50: ".5",
            75: ".75",
            100: "1",
            125: "1.25",
            150: "1.5",
            200: "2"
        },
        cursor: {
            auto: "auto",
            default: "default",
            pointer: "pointer",
            wait: "wait",
            text: "text",
            move: "move",
            help: "help",
            "not-allowed": "not-allowed",
            none: "none",
            "context-menu": "context-menu",
            progress: "progress",
            cell: "cell",
            crosshair: "crosshair",
            "vertical-text": "vertical-text",
            alias: "alias",
            copy: "copy",
            "no-drop": "no-drop",
            grab: "grab",
            grabbing: "grabbing",
            "all-scroll": "all-scroll",
            "col-resize": "col-resize",
            "row-resize": "row-resize",
            "n-resize": "n-resize",
            "e-resize": "e-resize",
            "s-resize": "s-resize",
            "w-resize": "w-resize",
            "ne-resize": "ne-resize",
            "nw-resize": "nw-resize",
            "se-resize": "se-resize",
            "sw-resize": "sw-resize",
            "ew-resize": "ew-resize",
            "ns-resize": "ns-resize",
            "nesw-resize": "nesw-resize",
            "nwse-resize": "nwse-resize",
            "zoom-in": "zoom-in",
            "zoom-out": "zoom-out"
        },
        divideColor: ({ theme: t })=>t("borderColor"),
        divideOpacity: ({ theme: t })=>t("borderOpacity"),
        divideWidth: ({ theme: t })=>t("borderWidth"),
        dropShadow: {
            sm: "0 1px 1px rgb(0 0 0 / 0.05)",
            DEFAULT: [
                "0 1px 2px rgb(0 0 0 / 0.1)",
                "0 1px 1px rgb(0 0 0 / 0.06)"
            ],
            md: [
                "0 4px 3px rgb(0 0 0 / 0.07)",
                "0 2px 2px rgb(0 0 0 / 0.06)"
            ],
            lg: [
                "0 10px 8px rgb(0 0 0 / 0.04)",
                "0 4px 3px rgb(0 0 0 / 0.1)"
            ],
            xl: [
                "0 20px 13px rgb(0 0 0 / 0.03)",
                "0 8px 5px rgb(0 0 0 / 0.08)"
            ],
            "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
            none: "0 0 #0000"
        },
        fill: ({ theme: t })=>({
                none: "none",
                ...t("colors")
            }),
        flex: {
            1: "1 1 0%",
            auto: "1 1 auto",
            initial: "0 1 auto",
            none: "none"
        },
        flexBasis: ({ theme: t })=>({
                auto: "auto",
                ...t("spacing"),
                "1/2": "50%",
                "1/3": "33.333333%",
                "2/3": "66.666667%",
                "1/4": "25%",
                "2/4": "50%",
                "3/4": "75%",
                "1/5": "20%",
                "2/5": "40%",
                "3/5": "60%",
                "4/5": "80%",
                "1/6": "16.666667%",
                "2/6": "33.333333%",
                "3/6": "50%",
                "4/6": "66.666667%",
                "5/6": "83.333333%",
                "1/12": "8.333333%",
                "2/12": "16.666667%",
                "3/12": "25%",
                "4/12": "33.333333%",
                "5/12": "41.666667%",
                "6/12": "50%",
                "7/12": "58.333333%",
                "8/12": "66.666667%",
                "9/12": "75%",
                "10/12": "83.333333%",
                "11/12": "91.666667%",
                full: "100%"
            }),
        flexGrow: {
            0: "0",
            DEFAULT: "1"
        },
        flexShrink: {
            0: "0",
            DEFAULT: "1"
        },
        fontFamily: {
            sans: [
                "ui-sans-serif",
                "system-ui",
                "-apple-system",
                "BlinkMacSystemFont",
                '"Segoe UI"',
                "Roboto",
                '"Helvetica Neue"',
                "Arial",
                '"Noto Sans"',
                "sans-serif",
                '"Apple Color Emoji"',
                '"Segoe UI Emoji"',
                '"Segoe UI Symbol"',
                '"Noto Color Emoji"'
            ],
            serif: [
                "ui-serif",
                "Georgia",
                "Cambria",
                '"Times New Roman"',
                "Times",
                "serif"
            ],
            mono: [
                "ui-monospace",
                "SFMono-Regular",
                "Menlo",
                "Monaco",
                "Consolas",
                '"Liberation Mono"',
                '"Courier New"',
                "monospace"
            ]
        },
        fontSize: {
            xs: [
                "0.75rem",
                {
                    lineHeight: "1rem"
                }
            ],
            sm: [
                "0.875rem",
                {
                    lineHeight: "1.25rem"
                }
            ],
            base: [
                "1rem",
                {
                    lineHeight: "1.5rem"
                }
            ],
            lg: [
                "1.125rem",
                {
                    lineHeight: "1.75rem"
                }
            ],
            xl: [
                "1.25rem",
                {
                    lineHeight: "1.75rem"
                }
            ],
            "2xl": [
                "1.5rem",
                {
                    lineHeight: "2rem"
                }
            ],
            "3xl": [
                "1.875rem",
                {
                    lineHeight: "2.25rem"
                }
            ],
            "4xl": [
                "2.25rem",
                {
                    lineHeight: "2.5rem"
                }
            ],
            "5xl": [
                "3rem",
                {
                    lineHeight: "1"
                }
            ],
            "6xl": [
                "3.75rem",
                {
                    lineHeight: "1"
                }
            ],
            "7xl": [
                "4.5rem",
                {
                    lineHeight: "1"
                }
            ],
            "8xl": [
                "6rem",
                {
                    lineHeight: "1"
                }
            ],
            "9xl": [
                "8rem",
                {
                    lineHeight: "1"
                }
            ]
        },
        fontWeight: {
            thin: "100",
            extralight: "200",
            light: "300",
            normal: "400",
            medium: "500",
            semibold: "600",
            bold: "700",
            extrabold: "800",
            black: "900"
        },
        gap: ({ theme: t })=>t("spacing"),
        gradientColorStops: ({ theme: t })=>t("colors"),
        grayscale: {
            0: "0",
            DEFAULT: "100%"
        },
        gridAutoColumns: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
        },
        gridColumn: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
        },
        gridColumnEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
        },
        gridColumnStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
        },
        gridRow: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-full": "1 / -1"
        },
        gridRowEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7"
        },
        gridRowStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7"
        },
        gridTemplateColumns: {
            none: "none",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
            none: "none",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))"
        },
        height: ({ theme: t })=>({
                auto: "auto",
                ...t("spacing"),
                "1/2": "50%",
                "1/3": "33.333333%",
                "2/3": "66.666667%",
                "1/4": "25%",
                "2/4": "50%",
                "3/4": "75%",
                "1/5": "20%",
                "2/5": "40%",
                "3/5": "60%",
                "4/5": "80%",
                "1/6": "16.666667%",
                "2/6": "33.333333%",
                "3/6": "50%",
                "4/6": "66.666667%",
                "5/6": "83.333333%",
                full: "100%",
                screen: "100vh",
                min: "min-content",
                max: "max-content",
                fit: "fit-content"
            }),
        hueRotate: {
            0: "0deg",
            15: "15deg",
            30: "30deg",
            60: "60deg",
            90: "90deg",
            180: "180deg"
        },
        inset: ({ theme: t })=>({
                auto: "auto",
                ...t("spacing"),
                "1/2": "50%",
                "1/3": "33.333333%",
                "2/3": "66.666667%",
                "1/4": "25%",
                "2/4": "50%",
                "3/4": "75%",
                full: "100%"
            }),
        invert: {
            0: "0",
            DEFAULT: "100%"
        },
        keyframes: {
            spin: {
                to: {
                    transform: "rotate(360deg)"
                }
            },
            ping: {
                "75%, 100%": {
                    transform: "scale(2)",
                    opacity: "0"
                }
            },
            pulse: {
                "50%": {
                    opacity: ".5"
                }
            },
            bounce: {
                "0%, 100%": {
                    transform: "translateY(-25%)",
                    animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
                },
                "50%": {
                    transform: "none",
                    animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
                }
            }
        },
        letterSpacing: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0em",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
        },
        lineHeight: {
            none: "1",
            tight: "1.25",
            snug: "1.375",
            normal: "1.5",
            relaxed: "1.625",
            loose: "2",
            3: ".75rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem"
        },
        listStyleType: {
            none: "none",
            disc: "disc",
            decimal: "decimal"
        },
        margin: ({ theme: t })=>({
                auto: "auto",
                ...t("spacing")
            }),
        maxHeight: ({ theme: t })=>({
                ...t("spacing"),
                none: "none",
                full: "100%",
                screen: "100vh",
                min: "min-content",
                max: "max-content",
                fit: "fit-content"
            }),
        maxWidth: ({ theme: t, breakpoints: e })=>({
                none: "none",
                0: "0rem",
                xs: "20rem",
                sm: "24rem",
                md: "28rem",
                lg: "32rem",
                xl: "36rem",
                "2xl": "42rem",
                "3xl": "48rem",
                "4xl": "56rem",
                "5xl": "64rem",
                "6xl": "72rem",
                "7xl": "80rem",
                full: "100%",
                min: "min-content",
                max: "max-content",
                fit: "fit-content",
                prose: "65ch",
                ...e(t("screens"))
            }),
        minHeight: {
            0: "0px",
            full: "100%",
            screen: "100vh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
        },
        minWidth: {
            0: "0px",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
        },
        objectPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
        },
        opacity: {
            0: "0",
            5: "0.05",
            10: "0.1",
            20: "0.2",
            25: "0.25",
            30: "0.3",
            40: "0.4",
            50: "0.5",
            60: "0.6",
            70: "0.7",
            75: "0.75",
            80: "0.8",
            90: "0.9",
            95: "0.95",
            100: "1"
        },
        order: {
            first: "-9999",
            last: "9999",
            none: "0",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12"
        },
        outlineColor: ({ theme: t })=>t("colors"),
        outlineOffset: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        outlineWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        padding: ({ theme: t })=>t("spacing"),
        placeholderColor: ({ theme: t })=>t("colors"),
        placeholderOpacity: ({ theme: t })=>t("opacity"),
        ringColor: ({ theme: t })=>({
                DEFAULT: t("colors.blue.500", "#3b82f6"),
                ...t("colors")
            }),
        ringOffsetColor: ({ theme: t })=>t("colors"),
        ringOffsetWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        ringOpacity: ({ theme: t })=>({
                DEFAULT: "0.5",
                ...t("opacity")
            }),
        ringWidth: {
            DEFAULT: "3px",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        rotate: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg",
            45: "45deg",
            90: "90deg",
            180: "180deg"
        },
        saturate: {
            0: "0",
            50: ".5",
            100: "1",
            150: "1.5",
            200: "2"
        },
        scale: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5"
        },
        screens: {
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1280px",
            "2xl": "1536px"
        },
        scrollMargin: ({ theme: t })=>({
                ...t("spacing")
            }),
        scrollPadding: ({ theme: t })=>t("spacing"),
        sepia: {
            0: "0",
            DEFAULT: "100%"
        },
        skew: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg"
        },
        space: ({ theme: t })=>({
                ...t("spacing")
            }),
        spacing: {
            px: "1px",
            0: "0px",
            .5: "0.125rem",
            1: "0.25rem",
            1.5: "0.375rem",
            2: "0.5rem",
            2.5: "0.625rem",
            3: "0.75rem",
            3.5: "0.875rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem",
            11: "2.75rem",
            12: "3rem",
            14: "3.5rem",
            16: "4rem",
            20: "5rem",
            24: "6rem",
            28: "7rem",
            32: "8rem",
            36: "9rem",
            40: "10rem",
            44: "11rem",
            48: "12rem",
            52: "13rem",
            56: "14rem",
            60: "15rem",
            64: "16rem",
            72: "18rem",
            80: "20rem",
            96: "24rem"
        },
        stroke: ({ theme: t })=>({
                none: "none",
                ...t("colors")
            }),
        strokeWidth: {
            0: "0",
            1: "1",
            2: "2"
        },
        supports: {},
        data: {},
        textColor: ({ theme: t })=>t("colors"),
        textDecorationColor: ({ theme: t })=>t("colors"),
        textDecorationThickness: {
            auto: "auto",
            "from-font": "from-font",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        textIndent: ({ theme: t })=>({
                ...t("spacing")
            }),
        textOpacity: ({ theme: t })=>t("opacity"),
        textUnderlineOffset: {
            auto: "auto",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
        },
        transformOrigin: {
            center: "center",
            top: "top",
            "top-right": "top right",
            right: "right",
            "bottom-right": "bottom right",
            bottom: "bottom",
            "bottom-left": "bottom left",
            left: "left",
            "top-left": "top left"
        },
        transitionDelay: {
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
        },
        transitionDuration: {
            DEFAULT: "150ms",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
        },
        transitionProperty: {
            none: "none",
            all: "all",
            DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
            colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
            opacity: "opacity",
            shadow: "box-shadow",
            transform: "transform"
        },
        transitionTimingFunction: {
            DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
            linear: "linear",
            in: "cubic-bezier(0.4, 0, 1, 1)",
            out: "cubic-bezier(0, 0, 0.2, 1)",
            "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: ({ theme: t })=>({
                ...t("spacing"),
                "1/2": "50%",
                "1/3": "33.333333%",
                "2/3": "66.666667%",
                "1/4": "25%",
                "2/4": "50%",
                "3/4": "75%",
                full: "100%"
            }),
        width: ({ theme: t })=>({
                auto: "auto",
                ...t("spacing"),
                "1/2": "50%",
                "1/3": "33.333333%",
                "2/3": "66.666667%",
                "1/4": "25%",
                "2/4": "50%",
                "3/4": "75%",
                "1/5": "20%",
                "2/5": "40%",
                "3/5": "60%",
                "4/5": "80%",
                "1/6": "16.666667%",
                "2/6": "33.333333%",
                "3/6": "50%",
                "4/6": "66.666667%",
                "5/6": "83.333333%",
                "1/12": "8.333333%",
                "2/12": "16.666667%",
                "3/12": "25%",
                "4/12": "33.333333%",
                "5/12": "41.666667%",
                "6/12": "50%",
                "7/12": "58.333333%",
                "8/12": "66.666667%",
                "9/12": "75%",
                "10/12": "83.333333%",
                "11/12": "91.666667%",
                full: "100%",
                screen: "100vw",
                min: "min-content",
                max: "max-content",
                fit: "fit-content"
            }),
        willChange: {
            auto: "auto",
            scroll: "scroll-position",
            contents: "contents",
            transform: "transform"
        },
        zIndex: {
            auto: "auto",
            0: "0",
            10: "10",
            20: "20",
            30: "30",
            40: "40",
            50: "50"
        }
    },
    plugins: []
};
function Tn(t) {
    var i;
    let e = ((i = t == null ? void 0 : t.presets) != null ? i : [
        xc
    ]).slice().reverse().flatMap((s)=>Tn(s instanceof Function ? s() : s)), r = {
        respectDefaultRingColorOpacity: {
            theme: {
                ringColor: ({ theme: s })=>({
                        DEFAULT: "#3b82f67f",
                        ...s("colors")
                    })
            }
        },
        disableColorOpacityUtilitiesByDefault: {
            corePlugins: {
                backgroundOpacity: !1,
                borderOpacity: !1,
                divideOpacity: !1,
                placeholderOpacity: !1,
                ringOpacity: !1,
                textOpacity: !1
            }
        }
    }, n = Object.keys(r).filter((s)=>G(t, s)).map((s)=>r[s]);
    return [
        t,
        ...n,
        ...e
    ];
}
function pa(...t) {
    let [, ...e] = Tn(t[0]);
    return ca([
        ...t,
        ...e
    ]);
}
var Sc = (t)=>{
    var n;
    let e = pa((n = t.config) != null ? n : {});
    return la((i)=>()=>i.createContext(e, [
                {
                    content: t.content
                }
            ]));
};
var yp = Y(gp());
var wp = (t)=>{
    let e = Sc({
        config: t.config,
        content: t.content
    });
    return I([
        e,
        (0, yp.default)()
    ]).process(vp, {
        from: void 0
    }).css;
};
var vp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
function bp(t) {
    let e = I.parse(t);
    return en.objectify(e);
}
var ob = (t, e)=>{
    var i, s;
    let r = (s = (i = e == null ? void 0 : e.corePlugins) == null ? void 0 : i.preflight) != null ? s : !1, n = (e == null ? void 0 : e.corePlugins) || {};
    return wp({
        config: {
            ...e,
            corePlugins: {
                ...n,
                preflight: r
            }
        },
        content: t
    });
}, Sa = ({ config: t, options: e })=>({
        twi: ka(t, e),
        twj: Sp(t, e)
    }), xp = (...t)=>{
    let e = "";
    return typeof t[0] == "string" ? e = t[0] : Array.isArray(t[0]) ? e = t.flat(1 / 0).map((r)=>xp(r)).join(" ") : typeof t[0] == "object" && (e = Object.entries(t[0]).filter((r)=>!!r[1]).map((r)=>r[0]).join(" ")), e = e.replace(/\s+/g, " "), e;
}, ka = (t, e)=>(...r)=>{
        let n = xp(r), { 1: i } = r || {}, a = {
            ...{
                merge: !0,
                minify: !0,
                ignoreMediaQueries: !0
            },
            ...e,
            ...i
        }, o = Pa(ob(n, t));
        return a != null && a.ignoreMediaQueries ? o.removeMediaQueries() : (o.removeUndefined(), o.combineMediaQueries()), o.fixRGB(), a != null && a.merge && o.merge(), a != null && a.minify && o.minify(), o.get();
    }, Sp = (t, e)=>(...r)=>bp(ka(t, e)(r)), xa = ka(), kp = Sp(), Cp = Sa; /*! https://mths.be/cssesc v3.0.0 by @mathias */ 


/***/ }),

/***/ 17038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */ module.exports = __webpack_require__(73837).deprecate;


/***/ }),

/***/ 49339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// Expose modern transport directly as the export
module.exports = __webpack_require__(33778);
// Expose legacy stream
module.exports.LegacyTransportStream = __webpack_require__(64447);


/***/ }),

/***/ 64447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
const { LEVEL } = __webpack_require__(68635);
const TransportStream = __webpack_require__(33778);
/**
 * Constructor function for the LegacyTransportStream. This is an internal
 * wrapper `winston >= 3` uses to wrap older transports implementing
 * log(level, message, meta).
 * @param {Object} options - Options for this TransportStream instance.
 * @param {Transpot} options.transport - winston@2 or older Transport to wrap.
 */ const LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    // Display our deprecation notice.
    this._deprecated();
    // Properly bubble up errors from the transport to the
    // LegacyTransportStream instance, but only once no matter how many times
    // this transport is shared.
    function transportError(err) {
        this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
    }
};
/*
 * Inherit from TransportStream using Node.js built-ins
 */ util.inherits(LegacyTransportStream, TransportStream);
/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */ LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
    }
    // Remark: This has to be handled in the base transport now because we
    // cannot conditionally write to our pipe targets as stream.
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
};
/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */ LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for(let i = 0; i < chunks.length; i++){
        if (this._accept(chunks[i])) {
            this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
            chunks[i].callback();
        }
    }
    return callback(null);
};
/**
 * Displays a deprecation notice. Defined as a function so it can be
 * overriden in tests.
 * @returns {undefined}
 */ LegacyTransportStream.prototype._deprecated = function _deprecated() {
    // eslint-disable-next-line no-console
    console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join("\n"));
};
/**
 * Clean up error handling state on the legacy transport associated
 * with this instance.
 * @returns {undefined}
 */ LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
        this.transport.close();
    }
    if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
    }
};


/***/ }),

/***/ 33778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
const Writable = __webpack_require__(62428);
const { LEVEL } = __webpack_require__(68635);
/**
 * Constructor function for the TransportStream. This is the base prototype
 * that all `winston >= 3` transports should inherit from.
 * @param {Object} options - Options for this TransportStream instance
 * @param {String} options.level - Highest level according to RFC5424.
 * @param {Boolean} options.handleExceptions - If true, info with
 * { exception: true } will be written.
 * @param {Function} options.log - Custom log function for simple Transport
 * creation
 * @param {Function} options.close - Called on "unpipe" from parent.
 */ const TransportStream = module.exports = function TransportStream(options = {}) {
    Writable.call(this, {
        objectMode: true,
        highWaterMark: options.highWaterMark
    });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log) this.log = options.log;
    if (options.logv) this.logv = options.logv;
    if (options.close) this.close = options.close;
    // Get the levels from the source we are piped from.
    this.once("pipe", (logger)=>{
        // Remark (indexzero): this bookkeeping can only support multiple
        // Logger parents with the same `levels`. This comes into play in
        // the `winston.Container` code in which `container.add` takes
        // a fully realized set of options with pre-constructed TransportStreams.
        this.levels = logger.levels;
        this.parent = logger;
    });
    // If and/or when the transport is removed from this instance
    this.once("unpipe", (src)=>{
        // Remark (indexzero): this bookkeeping can only support multiple
        // Logger parents with the same `levels`. This comes into play in
        // the `winston.Container` code in which `container.add` takes
        // a fully realized set of options with pre-constructed TransportStreams.
        if (src === this.parent) {
            this.parent = null;
            if (this.close) {
                this.close();
            }
        }
    });
};
/*
 * Inherit from Writeable using Node.js built-ins
 */ util.inherits(TransportStream, Writable);
/**
 * Writes the info object to our transport instance.
 * @param {mixed} info - TODO: add param description.
 * @param {mixed} enc - TODO: add param description.
 * @param {function} callback - TODO: add param description.
 * @returns {undefined}
 * @private
 */ TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
    }
    // Remark: This has to be handled in the base transport now because we
    // cannot conditionally write to our pipe targets as stream. We always
    // prefer any explicit level set on the Transport itself falling back to
    // any level set on the parent.
    const level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
            return this.log(info, callback);
        }
        let errState;
        let transformed;
        // We trap(and re-throw) any errors generated by the user-provided format, but also
        // guarantee that the streams callback is invoked so that we can continue flowing.
        try {
            transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
            errState = err;
        }
        if (errState || !transformed) {
            // eslint-disable-next-line callback-return
            callback();
            if (errState) throw errState;
            return;
        }
        return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
};
/**
 * Writes the batch of info objects (i.e. "object chunks") to our transport
 * instance after performing any necessary filtering.
 * @param {mixed} chunks - TODO: add params description.
 * @param {function} callback - TODO: add params description.
 * @returns {mixed} - TODO: add returns description.
 * @private
 */ TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
            return callback(null);
        }
        // Remark (indexzero): from a performance perspective if Transport
        // implementers do choose to implement logv should we make it their
        // responsibility to invoke their format?
        return this.logv(infos, callback);
    }
    for(let i = 0; i < chunks.length; i++){
        if (!this._accept(chunks[i])) continue;
        if (chunks[i].chunk && !this.format) {
            this.log(chunks[i].chunk, chunks[i].callback);
            continue;
        }
        let errState;
        let transformed;
        // We trap(and re-throw) any errors generated by the user-provided format, but also
        // guarantee that the streams callback is invoked so that we can continue flowing.
        try {
            transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
        } catch (err) {
            errState = err;
        }
        if (errState || !transformed) {
            // eslint-disable-next-line callback-return
            chunks[i].callback();
            if (errState) {
                // eslint-disable-next-line callback-return
                callback(null);
                throw errState;
            }
        } else {
            this.log(transformed, chunks[i].callback);
        }
    }
    return callback(null);
};
/**
 * Predicate function that returns true if the specfied `info` on the
 * WriteReq, `write`, should be passed down into the derived
 * TransportStream's I/O via `.log(info, callback)`.
 * @param {WriteReq} write - winston@3 Node.js WriteReq for the `info` object
 * representing the log message.
 * @returns {Boolean} - Value indicating if the `write` should be accepted &
 * logged.
 */ TransportStream.prototype._accept = function _accept(write) {
    const info = write.chunk;
    if (this.silent) {
        return false;
    }
    // We always prefer any explicit level set on the Transport itself
    // falling back to any level set on the parent.
    const level = this.level || this.parent && this.parent.level;
    // Immediately check the average case: log level filtering.
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        // Ensure the info object is valid based on `{ exception }`:
        // 1. { handleExceptions: true }: all `info` objects are valid
        // 2. { exception: false }: accepted by all transports.
        if (this.handleExceptions || info.exception !== true) {
            return true;
        }
    }
    return false;
};
/**
 * _nop is short for "No operation"
 * @returns {Boolean} Intentionally false.
 */ TransportStream.prototype._nop = function _nop() {
    // eslint-disable-next-line no-undefined
    return void undefined;
};


/***/ }),

/***/ 2752:
/***/ ((module) => {

"use strict";

const codes = {};
function createErrorType(code, message, Base) {
    if (!Base) {
        Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
            return message;
        } else {
            return message(arg1, arg2, arg3);
        }
    }
    class NodeError extends Base {
        constructor(arg1, arg2, arg3){
            super(getMessage(arg1, arg2, arg3));
        }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i)=>String(i));
        if (len > 2) {
            return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
            return `of ${thing} ${expected[0]}`;
        }
    } else {
        return `of ${thing} ${String(expected)}`;
    }
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") {
        start = 0;
    }
    if (start + search.length > str.length) {
        return false;
    } else {
        return str.indexOf(search, start) !== -1;
    }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else {
        determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
        // For cases like 'first argument'
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.q = codes;


/***/ }),

/***/ 32838:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = __webpack_require__(81638);
var Writable = __webpack_require__(62428);
__webpack_require__(41492)(Duplex, Readable);
{
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});


/***/ }),

/***/ 81638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(68084);
/*</replacement>*/ var Buffer = (__webpack_require__(14300).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function debug() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(41508);
var destroyImpl = __webpack_require__(11072);
var _require = __webpack_require__(9549), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(2752)/* .codes */ .q), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(41492)(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || __webpack_require__(32838);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(68166)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(32838);
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
                return false;
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], chunk);
    }
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(68166)/* .StringDecoder */ .s);
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
    } else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true;
    // crude way to check if we should resume
    } else if (self1.listenerCount("data") > 0) {
        self1.resume();
    }
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === undefined) {
            createReadableStreamAsyncIterator = __webpack_require__(64408);
        }
        return createReadableStreamAsyncIterator(this);
    };
}
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) {
            this._readableState.flowing = state;
        }
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
            }
        }
    }
}
if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
        if (from === undefined) {
            from = __webpack_require__(80941);
        }
        return from(Readable, iterable, opts);
    };
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 62428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(17038)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(68084);
/*</replacement>*/ var Buffer = (__webpack_require__(14300).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(11072);
var _require = __webpack_require__(9549), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(2752)/* .codes */ .q), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(41492)(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || __webpack_require__(32838);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function realHasInstance(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(32838);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer"
        ], chunk);
    }
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                }
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};


/***/ }),

/***/ 64408:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = __webpack_require__(837);
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) {
            return Promise.reject(error);
        }
        if (this[kEnded]) {
            return Promise.resolve(createIterResult(undefined, true));
        }
        if (this[kStream].destroyed) {
            // We need to defer via nextTick because if .destroy(err) is
            // called, the error will be emitted via nextTick, and
            // we cannot guarantee that there is no error lingering around
            // waiting to be emitted.
            return new Promise(function(resolve, reject) {
                process.nextTick(function() {
                    if (_this[kError]) {
                        reject(_this[kError]);
                    } else {
                        resolve(createIterResult(undefined, true));
                    }
                });
            });
        }
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
        } else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;


/***/ }),

/***/ 41508:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = __webpack_require__(14300), Buffer = _require.Buffer;
var _require2 = __webpack_require__(73837), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) {
                    // First chunk is a perfect match.
                    ret = this.shift();
                } else {
                    // Result spans more than one buffer.
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                }
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();


/***/ }),

/***/ 11072:
/***/ ((module) => {

"use strict";

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else {
                process.nextTick(emitCloseNT, _this);
            }
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else {
            process.nextTick(emitCloseNT, _this);
        }
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};


/***/ }),

/***/ 837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(2752)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE);
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;


/***/ }),

/***/ 80941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var ERR_INVALID_ARG_TYPE = (__webpack_require__(2752)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE);
function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", [
        "Iterable"
    ], iterable);
    var readable = new Readable(_objectSpread({
        objectMode: true
    }, opts));
    // Reading boolean to protect against _read
    // being called before last iteration completion.
    var reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    function next() {
        return _next2.apply(this, arguments);
    }
    function _next2() {
        _next2 = _asyncToGenerator(function*() {
            try {
                var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
                if (done) {
                    readable.push(null);
                } else if (readable.push((yield value))) {
                    next();
                } else {
                    reading = false;
                }
            } catch (err) {
                readable.destroy(err);
            }
        });
        return _next2.apply(this, arguments);
    }
    return readable;
}
module.exports = from;


/***/ }),

/***/ 9549:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ERR_INVALID_OPT_VALUE = (__webpack_require__(2752)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE);
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};


/***/ }),

/***/ 68084:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 68166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(14698).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "�";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 22299:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * winston.js: Top-level include defining Winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const logform = __webpack_require__(57030);
const { warn } = __webpack_require__(40488);
/**
 * Expose version. Use `require` method for `webpack` support.
 * @type {string}
 */ exports.version = __webpack_require__(16311).version;
/**
 * Include transports defined by default by winston
 * @type {Array}
 */ exports.transports = __webpack_require__(23249);
/**
 * Expose utility methods
 * @type {Object}
 */ exports.config = __webpack_require__(44047);
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */ exports.addColors = logform.levels;
/**
 * Hoist format-related functionality from logform.
 * @type {Object}
 */ exports.format = logform.format;
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */ exports.createLogger = __webpack_require__(60081);
/**
 * Expose core Logging-related prototypes.
 * @type {function}
 */ exports.Logger = __webpack_require__(53133);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */ exports.ExceptionHandler = __webpack_require__(24972);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */ exports.RejectionHandler = __webpack_require__(46851);
/**
 * Expose core Logging-related prototypes.
 * @type {Container}
 */ exports.Container = __webpack_require__(60304);
/**
 * Expose core Logging-related prototypes.
 * @type {Object}
 */ exports.Transport = __webpack_require__(49339);
/**
 * We create and expose a default `Container` to `winston.loggers` so that the
 * programmer may manage multiple `winston.Logger` instances without any
 * additional overhead.
 * @example
 *   // some-file1.js
 *   const logger = require('winston').loggers.get('something');
 *
 *   // some-file2.js
 *   const logger = require('winston').loggers.get('something');
 */ exports.loggers = new exports.Container();
/**
 * We create and expose a 'defaultLogger' so that the programmer may do the
 * following without the need to create an instance of winston.Logger directly:
 * @example
 *   const winston = require('winston');
 *   winston.log('info', 'some message');
 *   winston.error('some error');
 */ const defaultLogger = exports.createLogger();
// Pass through the target methods onto `winston.
Object.keys(exports.config.npm.levels).concat([
    "log",
    "query",
    "stream",
    "add",
    "remove",
    "clear",
    "profile",
    "startTimer",
    "handleExceptions",
    "unhandleExceptions",
    "handleRejections",
    "unhandleRejections",
    "configure",
    "child"
]).forEach((method)=>exports[method] = (...args)=>defaultLogger[method](...args));
/**
 * Define getter / setter for the default logger level which need to be exposed
 * by winston.
 * @type {string}
 */ Object.defineProperty(exports, "level", ({
    get () {
        return defaultLogger.level;
    },
    set (val) {
        defaultLogger.level = val;
    }
}));
/**
 * Define getter for `exceptions` which replaces `handleExceptions` and
 * `unhandleExceptions`.
 * @type {Object}
 */ Object.defineProperty(exports, "exceptions", ({
    get () {
        return defaultLogger.exceptions;
    }
}));
/**
 * Define getter for `rejections` which replaces `handleRejections` and
 * `unhandleRejections`.
 * @type {Object}
 */ Object.defineProperty(exports, "rejections", ({
    get () {
        return defaultLogger.rejections;
    }
}));
/**
 * Define getters / setters for appropriate properties of the default logger
 * which need to be exposed by winston.
 * @type {Logger}
 */ [
    "exitOnError"
].forEach((prop)=>{
    Object.defineProperty(exports, prop, {
        get () {
            return defaultLogger[prop];
        },
        set (val) {
            defaultLogger[prop] = val;
        }
    });
});
/**
 * The default transports and exceptionHandlers for the default winston logger.
 * @type {Object}
 */ Object.defineProperty(exports, "default", ({
    get () {
        return {
            exceptionHandlers: defaultLogger.exceptionHandlers,
            rejectionHandlers: defaultLogger.rejectionHandlers,
            transports: defaultLogger.transports
        };
    }
}));
// Have friendlier breakage notices for properties that were exposed by default
// on winston < 3.0.
warn.deprecated(exports, "setLevels");
warn.forFunctions(exports, "useFormat", [
    "cli"
]);
warn.forProperties(exports, "useFormat", [
    "padLevels",
    "stripColors"
]);
warn.forFunctions(exports, "deprecated", [
    "addRewriter",
    "addFilter",
    "clone",
    "extend"
]);
warn.forProperties(exports, "deprecated", [
    "emitErrs",
    "levelLength"
]);


/***/ }),

/***/ 40488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * common.js: Internal helper and utility functions for winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const { format } = __webpack_require__(73837);
/**
 * Set of simple deprecation notices and a way to expose them for a set of
 * properties.
 * @type {Object}
 * @private
 */ exports.warn = {
    deprecated (prop) {
        return ()=>{
            throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
        };
    },
    useFormat (prop) {
        return ()=>{
            throw new Error([
                format("{ %s } was removed in winston@3.0.0.", prop),
                "Use a custom winston.format = winston.format(function) instead."
            ].join("\n"));
        };
    },
    forFunctions (obj, type, props) {
        props.forEach((prop)=>{
            obj[prop] = exports.warn[type](prop);
        });
    },
    forProperties (obj, type, props) {
        props.forEach((prop)=>{
            const notice = exports.warn[type](prop);
            Object.defineProperty(obj, prop, {
                get: notice,
                set: notice
            });
        });
    }
};


/***/ }),

/***/ 44047:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const logform = __webpack_require__(57030);
const { configs } = __webpack_require__(68635);
/**
 * Export config set for the CLI.
 * @type {Object}
 */ exports.cli = logform.levels(configs.cli);
/**
 * Export config set for npm.
 * @type {Object}
 */ exports.npm = logform.levels(configs.npm);
/**
 * Export config set for the syslog.
 * @type {Object}
 */ exports.syslog = logform.levels(configs.syslog);
/**
 * Hoist addColors from logform where it was refactored into in winston@3.
 * @type {Object}
 */ exports.addColors = logform.levels;


/***/ }),

/***/ 60304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * container.js: Inversion of control container for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const createLogger = __webpack_require__(60081);
/**
 * Inversion of control container for winston logger instances.
 * @type {Container}
 */ module.exports = class Container {
    /**
   * Constructor function for the Container object responsible for managing a
   * set of `winston.Logger` instances based on string ids.
   * @param {!Object} [options={}] - Default pass-thru options for Loggers.
   */ constructor(options = {}){
        this.loggers = new Map();
        this.options = options;
    }
    /**
   * Retrieves a `winston.Logger` instance for the specified `id`. If an
   * instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */ add(id, options) {
        if (!this.loggers.has(id)) {
            // Remark: Simple shallow clone for configuration options in case we pass
            // in instantiated protoypal objects
            options = Object.assign({}, options || this.options);
            const existing = options.transports || this.options.transports;
            // Remark: Make sure if we have an array of transports we slice it to
            // make copies of those references.
            if (existing) {
                options.transports = Array.isArray(existing) ? existing.slice() : [
                    existing
                ];
            } else {
                options.transports = [];
            }
            const logger = createLogger(options);
            logger.on("close", ()=>this._delete(id));
            this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
    }
    /**
   * Retreives a `winston.Logger` instance for the specified `id`. If
   * an instance does not exist, one is created.
   * @param {!string} id - The id of the Logger to get.
   * @param {?Object} [options] - Options for the Logger instance.
   * @returns {Logger} - A configured Logger instance with a specified id.
   */ get(id, options) {
        return this.add(id, options);
    }
    /**
   * Check if the container has a logger with the id.
   * @param {?string} id - The id of the Logger instance to find.
   * @returns {boolean} - Boolean value indicating if this instance has a
   * logger with the specified `id`.
   */ has(id) {
        return !!this.loggers.has(id);
    }
    /**
   * Closes a `Logger` instance with the specified `id` if it exists.
   * If no `id` is supplied then all Loggers are closed.
   * @param {?string} id - The id of the Logger instance to close.
   * @returns {undefined}
   */ close(id) {
        if (id) {
            return this._removeLogger(id);
        }
        this.loggers.forEach((val, key)=>this._removeLogger(key));
    }
    /**
   * Remove a logger based on the id.
   * @param {!string} id - The id of the logger to remove.
   * @returns {undefined}
   * @private
   */ _removeLogger(id) {
        if (!this.loggers.has(id)) {
            return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
    }
    /**
   * Deletes a `Logger` instance with the specified `id`.
   * @param {!string} id - The id of the Logger instance to delete from
   * container.
   * @returns {undefined}
   * @private
   */ _delete(id) {
        this.loggers.delete(id);
    }
};


/***/ }),

/***/ 60081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * create-logger.js: Logger factory for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const { LEVEL } = __webpack_require__(68635);
const config = __webpack_require__(44047);
const Logger = __webpack_require__(53133);
const debug = __webpack_require__(6355)("winston:create-logger");
function isLevelEnabledFunctionName(level) {
    return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
}
/**
 * Create a new instance of a winston Logger. Creates a new
 * prototype for each instance.
 * @param {!Object} opts - Options for the created logger.
 * @returns {Logger} - A newly created logger instance.
 */ module.exports = function(opts = {}) {
    //
    // Default levels: npm
    //
    opts.levels = opts.levels || config.npm.levels;
    /**
   * DerivedLogger to attach the logs level methods.
   * @type {DerivedLogger}
   * @extends {Logger}
   */ class DerivedLogger extends Logger {
        /**
     * Create a new class derived logger for which the levels can be attached to
     * the prototype of. This is a V8 optimization that is well know to increase
     * performance of prototype functions.
     * @param {!Object} options - Options for the created logger.
     */ constructor(options){
            super(options);
        }
    }
    const logger = new DerivedLogger(opts);
    //
    // Create the log level methods for the derived logger.
    //
    Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
            // eslint-disable-next-line no-console
            console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
            return;
        }
        //
        // Define prototype methods for each log level e.g.:
        // logger.log('info', msg) implies these methods are defined:
        // - logger.info(msg)
        // - logger.isInfoEnabled()
        //
        // Remark: to support logger.child this **MUST** be a function
        // so it'll always be called on the instance instead of a fixed
        // place in the prototype chain.
        //
        DerivedLogger.prototype[level] = function(...args) {
            // Prefer any instance scope, but default to "root" logger
            const self = this || logger;
            // Optimize the hot-path which is the single object.
            if (args.length === 1) {
                const [msg] = args;
                const info = msg && msg.message && msg || {
                    message: msg
                };
                info.level = info[LEVEL] = level;
                self._addDefaultMeta(info);
                self.write(info);
                return this || logger;
            }
            // When provided nothing assume the empty string
            if (args.length === 0) {
                self.log(level, "");
                return self;
            }
            // Otherwise build argument list which could potentially conform to
            // either:
            // . v3 API: log(obj)
            // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])
            return self.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
            return (this || logger).isLevelEnabled(level);
        };
    });
    return logger;
};


/***/ }),

/***/ 24972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const os = __webpack_require__(22037);
const asyncForEach = __webpack_require__(12236);
const debug = __webpack_require__(6355)("winston:exception");
const once = __webpack_require__(56061);
const stackTrace = __webpack_require__(69165);
const ExceptionStream = __webpack_require__(39430);
/**
 * Object for handling uncaughtException events.
 * @type {ExceptionHandler}
 */ module.exports = class ExceptionHandler {
    /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */ constructor(logger){
        if (!logger) {
            throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = new Map();
    }
    /**
   * Handles `uncaughtException` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */ handle(...args) {
        args.forEach((arg)=>{
            if (Array.isArray(arg)) {
                return arg.forEach((handler)=>this._addHandler(handler));
            }
            this._addHandler(arg);
        });
        if (!this.catcher) {
            this.catcher = this._uncaughtException.bind(this);
            process.on("uncaughtException", this.catcher);
        }
    }
    /**
   * Removes any handlers to `uncaughtException` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */ unhandle() {
        if (this.catcher) {
            process.removeListener("uncaughtException", this.catcher);
            this.catcher = false;
            Array.from(this.handlers.values()).forEach((wrapper)=>this.logger.unpipe(wrapper));
        }
    }
    /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */ getAllInfo(err) {
        let message = null;
        if (err) {
            message = typeof err === "string" ? err : err.message;
        }
        return {
            error: err,
            // TODO (indexzero): how do we configure this?
            level: "error",
            message: [
                `uncaughtException: ${message || "(no error message)"}`,
                err && err.stack || "  No stack trace"
            ].join("\n"),
            stack: err && err.stack,
            exception: true,
            date: new Date().toString(),
            process: this.getProcessInfo(),
            os: this.getOsInfo(),
            trace: this.getTrace(err)
        };
    }
    /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */ getProcessInfo() {
        return {
            pid: process.pid,
            uid: process.getuid ? process.getuid() : null,
            gid: process.getgid ? process.getgid() : null,
            cwd: process.cwd(),
            execPath: process.execPath,
            version: process.version,
            argv: process.argv,
            memoryUsage: process.memoryUsage()
        };
    }
    /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */ getOsInfo() {
        return {
            loadavg: os.loadavg(),
            uptime: os.uptime()
        };
    }
    /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */ getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site)=>{
            return {
                column: site.getColumnNumber(),
                file: site.getFileName(),
                function: site.getFunctionName(),
                line: site.getLineNumber(),
                method: site.getMethodName(),
                native: site.isNative()
            };
        });
    }
    /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */ _addHandler(handler) {
        if (!this.handlers.has(handler)) {
            handler.handleExceptions = true;
            const wrapper = new ExceptionStream(handler);
            this.handlers.set(handler, wrapper);
            this.logger.pipe(wrapper);
        }
    }
    /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */ _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        // Calculate if we should exit on this error
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
            // eslint-disable-next-line no-console
            console.warn("winston: exitOnError cannot be true with no exception handlers.");
            // eslint-disable-next-line no-console
            console.warn("winston: not exiting process.");
            doExit = false;
        }
        function gracefulExit() {
            debug("doExit", doExit);
            debug("process._exiting", process._exiting);
            if (doExit && !process._exiting) {
                // Remark: Currently ignoring any exceptions from transports when
                // catching uncaught exceptions.
                if (timeout) {
                    clearTimeout(timeout);
                }
                // eslint-disable-next-line no-process-exit
                process.exit(1);
            }
        }
        if (!handlers || handlers.length === 0) {
            return process.nextTick(gracefulExit);
        }
        // Log to all transports attempting to listen for when they are completed.
        asyncForEach(handlers, (handler, next)=>{
            const done = once(next);
            const transport = handler.transport || handler;
            // Debug wrapping so that we can inspect what's going on under the covers.
            function onDone(event) {
                return ()=>{
                    debug(event);
                    done();
                };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
        }, ()=>doExit && gracefulExit());
        this.logger.log(info);
        // If exitOnError is true, then only allow the logging of exceptions to
        // take up to `3000ms`.
        if (doExit) {
            timeout = setTimeout(gracefulExit, 3000);
        }
    }
    /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */ _getExceptionHandlers() {
        // Remark (indexzero): since `logger.transports` returns all of the pipes
        // from the _readableState of the stream we actually get the join of the
        // explicit handlers and the implicit transports with
        // `handleExceptions: true`
        return this.logger.transports.filter((wrap)=>{
            const transport = wrap.transport || wrap;
            return transport.handleExceptions;
        });
    }
};


/***/ }),

/***/ 39430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const { Writable } = __webpack_require__(92219);
/**
 * TODO: add class description.
 * @type {ExceptionStream}
 * @extends {Writable}
 */ module.exports = class ExceptionStream extends Writable {
    /**
   * Constructor function for the ExceptionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.exception` set to true.
   * @param {!TransportStream} transport - Stream to filter to exceptions
   */ constructor(transport){
        super({
            objectMode: true
        });
        if (!transport) {
            throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        // Remark (indexzero): we set `handleExceptions` here because it's the
        // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers
        this.handleExceptions = true;
        this.transport = transport;
    }
    /**
   * Writes the info object to our transport instance if (and only if) the
   * `exception` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */ _write(info, enc, callback) {
        if (info.exception) {
            return this.transport.log(info, callback);
        }
        callback();
        return true;
    }
};


/***/ }),

/***/ 53133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * logger.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const { Stream, Transform } = __webpack_require__(92219);
const asyncForEach = __webpack_require__(12236);
const { LEVEL, SPLAT } = __webpack_require__(68635);
const isStream = __webpack_require__(99130);
const ExceptionHandler = __webpack_require__(24972);
const RejectionHandler = __webpack_require__(46851);
const LegacyTransportStream = __webpack_require__(64447);
const Profiler = __webpack_require__(53563);
const { warn } = __webpack_require__(40488);
const config = __webpack_require__(44047);
/**
 * Captures the number of format (i.e. %s strings) in a given string.
 * Based on `util.format`, see Node.js source:
 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
 * @type {RegExp}
 */ const formatRegExp = /%[scdjifoO%]/g;
/**
 * TODO: add class description.
 * @type {Logger}
 * @extends {Transform}
 */ class Logger extends Transform {
    /**
   * Constructor function for the Logger object responsible for persisting log
   * messages and metadata to one or more transports.
   * @param {!Object} options - foo
   */ constructor(options){
        super({
            objectMode: true
        });
        this.configure(options);
    }
    child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
            write: {
                value: function(info) {
                    const infoClone = Object.assign({}, defaultRequestMetadata, info);
                    // Object.assign doesn't copy inherited Error
                    // properties so we have to do that explicitly
                    //
                    // Remark (indexzero): we should remove this
                    // since the errors format will handle this case.
                    //
                    if (info instanceof Error) {
                        infoClone.stack = info.stack;
                        infoClone.message = info.message;
                    }
                    logger.write(infoClone);
                }
            }
        });
    }
    /**
   * This will wholesale reconfigure this instance by:
   * 1. Resetting all transports. Older transports will be removed implicitly.
   * 2. Set all other options including levels, colors, rewriters, filters,
   *    exceptionHandlers, etc.
   * @param {!Object} options - TODO: add param description.
   * @returns {undefined}
   */ configure({ silent, format, defaultMeta, levels, level = "info", exitOnError = true, transports, colors, emitErrs, formatters, padLevels, rewriters, stripColors, exceptionHandlers, rejectionHandlers } = {}) {
        // Reset transports if we already have them
        if (this.transports.length) {
            this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || __webpack_require__(53781)();
        this.defaultMeta = defaultMeta || null;
        // Hoist other options onto this instance.
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
            this.exceptions.unhandle();
        }
        if (this.rejections) {
            this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        // Add all transports we have been provided.
        if (transports) {
            transports = Array.isArray(transports) ? transports : [
                transports
            ];
            transports.forEach((transport)=>this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
            throw new Error([
                "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
                "Use a custom winston.format(function) instead.",
                "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n"));
        }
        if (exceptionHandlers) {
            this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
            this.rejections.handle(rejectionHandlers);
        }
    }
    isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
            return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
            return false;
        }
        if (!this.transports || this.transports.length === 0) {
            return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport)=>{
            let transportLevelValue = getLevelValue(this.levels, transport.level);
            if (transportLevelValue === null) {
                transportLevelValue = configuredLevelValue;
            }
            return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
    }
    /* eslint-disable valid-jsdoc */ /**
   * Ensure backwards compatibility with a `log` method
   * @param {mixed} level - Level the log message is written at.
   * @param {mixed} msg - TODO: add param description.
   * @param {mixed} meta - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   *
   * @example
   *    // Supports the existing API:
   *    logger.log('info', 'Hello world', { custom: true });
   *    logger.log('info', new Error('Yo, it\'s on fire'));
   *
   *    // Requires winston.format.splat()
   *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
   *
   *    // And the new API with a single JSON literal:
   *    logger.log({ level: 'info', message: 'Hello world', custom: true });
   *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
   *
   *    // Also requires winston.format.splat()
   *    logger.log({
   *      level: 'info',
   *      message: '%s %d%%',
   *      [SPLAT]: ['A string', 50],
   *      meta: { thisIsMeta: true }
   *    });
   *
   */ /* eslint-enable valid-jsdoc */ log(level, msg, ...splat) {
        // eslint-disable-line max-params
        // Optimize for the hotpath of logging JSON literals
        if (arguments.length === 1) {
            // Yo dawg, I heard you like levels ... seriously ...
            // In this context the LHS `level` here is actually the `info` so read
            // this as: info[LEVEL] = info.level;
            level[LEVEL] = level.level;
            this._addDefaultMeta(level);
            this.write(level);
            return this;
        }
        // Slightly less hotpath, but worth optimizing for.
        if (arguments.length === 2) {
            if (msg && typeof msg === "object") {
                msg[LEVEL] = msg.level = level;
                this._addDefaultMeta(msg);
                this.write(msg);
                return this;
            }
            msg = {
                [LEVEL]: level,
                level,
                message: msg
            };
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
            // Extract tokens, if none available default to empty array to
            // ensure consistancy in expected results
            const tokens = msg && msg.match && msg.match(formatRegExp);
            if (!tokens) {
                const info = Object.assign({}, this.defaultMeta, meta, {
                    [LEVEL]: level,
                    [SPLAT]: splat,
                    level,
                    message: msg
                });
                if (meta.message) info.message = `${info.message} ${meta.message}`;
                if (meta.stack) info.stack = meta.stack;
                this.write(info);
                return this;
            }
        }
        this.write(Object.assign({}, this.defaultMeta, {
            [LEVEL]: level,
            [SPLAT]: splat,
            level,
            message: msg
        }));
        return this;
    }
    /**
   * Pushes data so that it can be picked up by all of our pipe targets.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - Continues stream processing.
   * @returns {undefined}
   * @private
   */ _transform(info, enc, callback) {
        if (this.silent) {
            return callback();
        }
        // [LEVEL] is only soft guaranteed to be set here since we are a proper
        // stream. It is likely that `info` came in through `.log(info)` or
        // `.info(info)`. If it is not defined, however, define it.
        // This LEVEL symbol is provided by `triple-beam` and also used in:
        // - logform
        // - winston-transport
        // - abstract-winston-transport
        if (!info[LEVEL]) {
            info[LEVEL] = info.level;
        }
        // Remark: really not sure what to do here, but this has been reported as
        // very confusing by pre winston@2.0.0 users as quite confusing when using
        // custom levels.
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
            // eslint-disable-next-line no-console
            console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        // Remark: not sure if we should simply error here.
        if (!this._readableState.pipes) {
            // eslint-disable-next-line no-console
            console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
        }
        // Here we write to the `format` pipe-chain, which on `readable` above will
        // push the formatted `info` Object onto the buffer for this instance. We trap
        // (and re-throw) any errors generated by the user-provided format, but also
        // guarantee that the streams callback is invoked so that we can continue flowing.
        try {
            this.push(this.format.transform(info, this.format.options));
        } finally{
            this._writableState.sync = false;
            // eslint-disable-next-line callback-return
            callback();
        }
    }
    /**
   * Delays the 'finish' event until all transport pipe targets have
   * also emitted 'finish' or are already finished.
   * @param {mixed} callback - Continues stream processing.
   */ _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(transports, (transport, next)=>{
            if (!transport || transport.finished) return setImmediate(next);
            transport.once("finish", next);
            transport.end();
        }, callback);
    }
    /**
   * Adds the transport to this logger instance by piping to it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */ add(transport) {
        // Support backwards compatibility with all existing `winston < 3.x.x`
        // transports which meet one of two criteria:
        // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.
        // 2. They expose a log method which has a length greater than 2 (i.e. more then
        //    just `log(info, callback)`.
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({
            transport
        }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
            throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
        }
        // Listen for the `error` event and the `warn` event on the new Transport.
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
            this.exceptions.handle();
        }
        if (transport.handleRejections) {
            this.rejections.handle();
        }
        return this;
    }
    /**
   * Removes the transport from this logger instance by unpiping from it.
   * @param {mixed} transport - TODO: add param description.
   * @returns {Logger} - TODO: add return description.
   */ remove(transport) {
        if (!transport) return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
            target = this.transports.filter((match)=>match.transport === transport)[0];
        }
        if (target) {
            this.unpipe(target);
        }
        return this;
    }
    /**
   * Removes all transports from this logger instance.
   * @returns {Logger} - TODO: add return description.
   */ clear() {
        this.unpipe();
        return this;
    }
    /**
   * Cleans up resources (streams, event listeners) for all transports
   * associated with this instance (if necessary).
   * @returns {Logger} - TODO: add return description.
   */ close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
    }
    /**
   * Sets the `target` levels specified on this instance.
   * @param {Object} Target levels to use on this instance.
   */ setLevels() {
        warn.deprecated("setLevels");
    }
    /**
   * Queries the all transports for this instance with the specified `options`.
   * This will aggregate each transport's results into one object containing
   * a property per transport.
   * @param {Object} options - Query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   */ query(options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        // Helper function to query a single transport
        function queryTransport(transport, next) {
            if (options.query && typeof transport.formatQuery === "function") {
                options.query = transport.formatQuery(queryObject);
            }
            transport.query(options, (err, res)=>{
                if (err) {
                    return next(err);
                }
                if (typeof transport.formatResults === "function") {
                    res = transport.formatResults(res, options.format);
                }
                next(null, res);
            });
        }
        // Helper function to accumulate the results from `queryTransport` into
        // the `results`.
        function addResults(transport, next) {
            queryTransport(transport, (err, result)=>{
                // queryTransport could potentially invoke the callback multiple times
                // since Transport code can be unpredictable.
                if (next) {
                    result = err || result;
                    if (result) {
                        results[transport.name] = result;
                    }
                    // eslint-disable-next-line callback-return
                    next();
                }
                next = null;
            });
        }
        // Iterate over the transports in parallel setting the appropriate key in
        // the `results`.
        asyncForEach(this.transports.filter((transport)=>!!transport.query), addResults, ()=>callback(null, results));
    }
    /**
   * Returns a log stream for all transports. Options object is optional.
   * @param{Object} options={} - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   */ stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = ()=>{
            let i = streams.length;
            while(i--){
                streams[i].destroy();
            }
        };
        // Create a list of all transports for this instance.
        this.transports.filter((transport)=>!!transport.stream).forEach((transport)=>{
            const str = transport.stream(options);
            if (!str) {
                return;
            }
            streams.push(str);
            str.on("log", (log)=>{
                log.transport = log.transport || [];
                log.transport.push(transport.name);
                out.emit("log", log);
            });
            str.on("error", (err)=>{
                err.transport = err.transport || [];
                err.transport.push(transport.name);
                out.emit("error", err);
            });
        });
        return out;
    }
    /**
   * Returns an object corresponding to a specific timing. When done is called
   * the timer will finish and log the duration. e.g.:
   * @returns {Profile} - TODO: add return description.
   * @example
   *    const timer = winston.startTimer()
   *    setTimeout(() => {
   *      timer.done({
   *        message: 'Logging message'
   *      });
   *    }, 1000);
   */ startTimer() {
        return new Profiler(this);
    }
    /**
   * Tracks the time inbetween subsequent calls to this method with the same
   * `id` parameter. The second call to this method will log the difference in
   * milliseconds along with the message.
   * @param {string} id Unique id of the profiler
   * @returns {Logger} - TODO: add return description.
   */ profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
            const timeEnd = this.profilers[id];
            delete this.profilers[id];
            // Attempt to be kind to users if they are still using older APIs.
            if (typeof args[args.length - 2] === "function") {
                // eslint-disable-next-line no-console
                console.warn("Callback function no longer supported as of winston@3.0.0");
                args.pop();
            }
            // Set the duration property of the metadata
            const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
            info.level = info.level || "info";
            info.durationMs = time - timeEnd;
            info.message = info.message || id;
            return this.write(info);
        }
        this.profilers[id] = time;
        return this;
    }
    /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */ handleExceptions(...args) {
        // eslint-disable-next-line no-console
        console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
        this.exceptions.handle(...args);
    }
    /**
   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
   * @returns {undefined}
   * @deprecated
   */ unhandleExceptions(...args) {
        // eslint-disable-next-line no-console
        console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
        this.exceptions.unhandle(...args);
    }
    /**
   * Throw a more meaningful deprecation notice
   * @throws {Error} - TODO: add throws description.
   */ cli() {
        throw new Error([
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
    }
    /**
   * Bubbles the `event` that occured on the specified `transport` up
   * from this instance.
   * @param {string} event - The event that occured
   * @param {Object} transport - Transport on which the event occured
   * @private
   */ _onEvent(event, transport) {
        function transportEvent(err) {
            // https://github.com/winstonjs/winston/issues/1364
            if (event === "error" && !this.transports.includes(transport)) {
                this.add(transport);
            }
            this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
            transport["__winston" + event] = transportEvent.bind(this);
            transport.on(event, transport["__winston" + event]);
        }
    }
    _addDefaultMeta(msg) {
        if (this.defaultMeta) {
            Object.assign(msg, this.defaultMeta);
        }
    }
}
function getLevelValue(levels, level) {
    const value = levels[level];
    if (!value && value !== 0) {
        return null;
    }
    return value;
}
/**
 * Represents the current readableState pipe targets for this Logger instance.
 * @type {Array|Object}
 */ Object.defineProperty(Logger.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get () {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [
            pipes
        ].filter(Boolean) : pipes;
    }
});
module.exports = Logger;


/***/ }),

/***/ 53563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * profiler.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * TODO: add class description.
 * @type {Profiler}
 * @private
 */ class Profiler {
    /**
   * Constructor function for the Profiler instance used by
   * `Logger.prototype.startTimer`. When done is called the timer will finish
   * and log the duration.
   * @param {!Logger} logger - TODO: add param description.
   * @private
   */ constructor(logger){
        const Logger = __webpack_require__(53133);
        if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
            throw new Error("Logger is required for profiling");
        } else {
            this.logger = logger;
            this.start = Date.now();
        }
    }
    /**
   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
   * with the duration since creation.
   * @returns {mixed} - TODO: add return description.
   * @private
   */ done(...args) {
        if (typeof args[args.length - 1] === "function") {
            // eslint-disable-next-line no-console
            console.warn("Callback function no longer supported as of winston@3.0.0");
            args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
    }
}
;
module.exports = Profiler;


/***/ }),

/***/ 46851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const os = __webpack_require__(22037);
const asyncForEach = __webpack_require__(12236);
const debug = __webpack_require__(6355)("winston:rejection");
const once = __webpack_require__(56061);
const stackTrace = __webpack_require__(69165);
const RejectionStream = __webpack_require__(49087);
/**
 * Object for handling unhandledRejection events.
 * @type {RejectionHandler}
 */ module.exports = class RejectionHandler {
    /**
   * TODO: add contructor description
   * @param {!Logger} logger - TODO: add param description
   */ constructor(logger){
        if (!logger) {
            throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = new Map();
    }
    /**
   * Handles `unhandledRejection` events for the current process by adding any
   * handlers passed in.
   * @returns {undefined}
   */ handle(...args) {
        args.forEach((arg)=>{
            if (Array.isArray(arg)) {
                return arg.forEach((handler)=>this._addHandler(handler));
            }
            this._addHandler(arg);
        });
        if (!this.catcher) {
            this.catcher = this._unhandledRejection.bind(this);
            process.on("unhandledRejection", this.catcher);
        }
    }
    /**
   * Removes any handlers to `unhandledRejection` events for the current
   * process. This does not modify the state of the `this.handlers` set.
   * @returns {undefined}
   */ unhandle() {
        if (this.catcher) {
            process.removeListener("unhandledRejection", this.catcher);
            this.catcher = false;
            Array.from(this.handlers.values()).forEach((wrapper)=>this.logger.unpipe(wrapper));
        }
    }
    /**
   * TODO: add method description
   * @param {Error} err - Error to get information about.
   * @returns {mixed} - TODO: add return description.
   */ getAllInfo(err) {
        let message = null;
        if (err) {
            message = typeof err === "string" ? err : err.message;
        }
        return {
            error: err,
            // TODO (indexzero): how do we configure this?
            level: "error",
            message: [
                `unhandledRejection: ${message || "(no error message)"}`,
                err && err.stack || "  No stack trace"
            ].join("\n"),
            stack: err && err.stack,
            rejection: true,
            date: new Date().toString(),
            process: this.getProcessInfo(),
            os: this.getOsInfo(),
            trace: this.getTrace(err)
        };
    }
    /**
   * Gets all relevant process information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */ getProcessInfo() {
        return {
            pid: process.pid,
            uid: process.getuid ? process.getuid() : null,
            gid: process.getgid ? process.getgid() : null,
            cwd: process.cwd(),
            execPath: process.execPath,
            version: process.version,
            argv: process.argv,
            memoryUsage: process.memoryUsage()
        };
    }
    /**
   * Gets all relevant OS information for the currently running process.
   * @returns {mixed} - TODO: add return description.
   */ getOsInfo() {
        return {
            loadavg: os.loadavg(),
            uptime: os.uptime()
        };
    }
    /**
   * Gets a stack trace for the specified error.
   * @param {mixed} err - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */ getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site)=>{
            return {
                column: site.getColumnNumber(),
                file: site.getFileName(),
                function: site.getFunctionName(),
                line: site.getLineNumber(),
                method: site.getMethodName(),
                native: site.isNative()
            };
        });
    }
    /**
   * Helper method to add a transport as an exception handler.
   * @param {Transport} handler - The transport to add as an exception handler.
   * @returns {void}
   */ _addHandler(handler) {
        if (!this.handlers.has(handler)) {
            handler.handleRejections = true;
            const wrapper = new RejectionStream(handler);
            this.handlers.set(handler, wrapper);
            this.logger.pipe(wrapper);
        }
    }
    /**
   * Logs all relevant information around the `err` and exits the current
   * process.
   * @param {Error} err - Error to handle
   * @returns {mixed} - TODO: add return description.
   * @private
   */ _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        // Calculate if we should exit on this error
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
            // eslint-disable-next-line no-console
            console.warn("winston: exitOnError cannot be true with no rejection handlers.");
            // eslint-disable-next-line no-console
            console.warn("winston: not exiting process.");
            doExit = false;
        }
        function gracefulExit() {
            debug("doExit", doExit);
            debug("process._exiting", process._exiting);
            if (doExit && !process._exiting) {
                // Remark: Currently ignoring any rejections from transports when
                // catching unhandled rejections.
                if (timeout) {
                    clearTimeout(timeout);
                }
                // eslint-disable-next-line no-process-exit
                process.exit(1);
            }
        }
        if (!handlers || handlers.length === 0) {
            return process.nextTick(gracefulExit);
        }
        // Log to all transports attempting to listen for when they are completed.
        asyncForEach(handlers, (handler, next)=>{
            const done = once(next);
            const transport = handler.transport || handler;
            // Debug wrapping so that we can inspect what's going on under the covers.
            function onDone(event) {
                return ()=>{
                    debug(event);
                    done();
                };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
        }, ()=>doExit && gracefulExit());
        this.logger.log(info);
        // If exitOnError is true, then only allow the logging of exceptions to
        // take up to `3000ms`.
        if (doExit) {
            timeout = setTimeout(gracefulExit, 3000);
        }
    }
    /**
   * Returns the list of transports and exceptionHandlers for this instance.
   * @returns {Array} - List of transports and exceptionHandlers for this
   * instance.
   * @private
   */ _getRejectionHandlers() {
        // Remark (indexzero): since `logger.transports` returns all of the pipes
        // from the _readableState of the stream we actually get the join of the
        // explicit handlers and the implicit transports with
        // `handleRejections: true`
        return this.logger.transports.filter((wrap)=>{
            const transport = wrap.transport || wrap;
            return transport.handleRejections;
        });
    }
};


/***/ }),

/***/ 49087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * rejection-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const { Writable } = __webpack_require__(92219);
/**
 * TODO: add class description.
 * @type {RejectionStream}
 * @extends {Writable}
 */ module.exports = class RejectionStream extends Writable {
    /**
   * Constructor function for the RejectionStream responsible for wrapping a
   * TransportStream; only allowing writes of `info` objects with
   * `info.rejection` set to true.
   * @param {!TransportStream} transport - Stream to filter to rejections
   */ constructor(transport){
        super({
            objectMode: true
        });
        if (!transport) {
            throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
    }
    /**
   * Writes the info object to our transport instance if (and only if) the
   * `rejection` property is set on the info.
   * @param {mixed} info - TODO: add param description.
   * @param {mixed} enc - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   * @private
   */ _write(info, enc, callback) {
        if (info.rejection) {
            return this.transport.log(info, callback);
        }
        callback();
        return true;
    }
};


/***/ }),

/***/ 33581:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * tail-file.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const fs = __webpack_require__(57147);
const { StringDecoder } = __webpack_require__(71576);
const { Stream } = __webpack_require__(92219);
/**
 * Simple no-op function.
 * @returns {undefined}
 */ function noop() {}
/**
 * TODO: add function description.
 * @param {Object} options - Options for tail.
 * @param {function} iter - Iterator function to execute on every line.
* `tail -f` a file. Options must include file.
 * @returns {mixed} - TODO: add return description.
 */ module.exports = (options, iter)=>{
    const buffer = Buffer.alloc(64 * 1024);
    const decode = new StringDecoder("utf8");
    const stream = new Stream();
    let buff = "";
    let pos = 0;
    let row = 0;
    if (options.start === -1) {
        delete options.start;
    }
    stream.readable = true;
    stream.destroy = ()=>{
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
    };
    fs.open(options.file, "a+", "0644", (err, fd)=>{
        if (err) {
            if (!iter) {
                stream.emit("error", err);
            } else {
                iter(err);
            }
            stream.destroy();
            return;
        }
        (function read() {
            if (stream.destroyed) {
                fs.close(fd, noop);
                return;
            }
            return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes)=>{
                if (error) {
                    if (!iter) {
                        stream.emit("error", error);
                    } else {
                        iter(error);
                    }
                    stream.destroy();
                    return;
                }
                if (!bytes) {
                    if (buff) {
                        // eslint-disable-next-line eqeqeq
                        if (options.start == null || row > options.start) {
                            if (!iter) {
                                stream.emit("line", buff);
                            } else {
                                iter(null, buff);
                            }
                        }
                        row++;
                        buff = "";
                    }
                    return setTimeout(read, 1000);
                }
                let data = decode.write(buffer.slice(0, bytes));
                if (!iter) {
                    stream.emit("data", data);
                }
                data = (buff + data).split(/\n+/);
                const l = data.length - 1;
                let i = 0;
                for(; i < l; i++){
                    // eslint-disable-next-line eqeqeq
                    if (options.start == null || row > options.start) {
                        if (!iter) {
                            stream.emit("line", data[i]);
                        } else {
                            iter(null, data[i]);
                        }
                    }
                    row++;
                }
                buff = data[l];
                pos += bytes;
                return read();
            });
        })();
    });
    if (!iter) {
        return stream;
    }
    return stream.destroy;
};


/***/ }),

/***/ 32322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable no-console */ /*
 * console.js: Transport for outputting to the console.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const os = __webpack_require__(22037);
const { LEVEL, MESSAGE } = __webpack_require__(68635);
const TransportStream = __webpack_require__(49339);
/**
 * Transport for outputting to the console.
 * @type {Console}
 * @extends {TransportStream}
 */ module.exports = class Console extends TransportStream {
    /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */ constructor(options = {}){
        super(options);
        // Expose the name of this Transport on the prototype
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.setMaxListeners(30);
    }
    /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */ log(info, callback) {
        setImmediate(()=>this.emit("logged", info));
        // Remark: what if there is no raw...?
        if (this.stderrLevels[info[LEVEL]]) {
            if (console._stderr) {
                // Node.js maps `process.stderr` to `console._stderr`.
                console._stderr.write(`${info[MESSAGE]}${this.eol}`);
            } else {
                // console.error adds a newline
                console.error(info[MESSAGE]);
            }
            if (callback) {
                callback(); // eslint-disable-line callback-return
            }
            return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
            if (console._stderr) {
                // Node.js maps `process.stderr` to `console._stderr`.
                // in Node.js console.warn is an alias for console.error
                console._stderr.write(`${info[MESSAGE]}${this.eol}`);
            } else {
                // console.warn adds a newline
                console.warn(info[MESSAGE]);
            }
            if (callback) {
                callback(); // eslint-disable-line callback-return
            }
            return;
        }
        if (console._stdout) {
            // Node.js maps `process.stdout` to `console._stdout`.
            console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
            // console.log adds a newline.
            console.log(info[MESSAGE]);
        }
        if (callback) {
            callback(); // eslint-disable-line callback-return
        }
    }
    /**
   * Returns a Set-like object with strArray's elements as keys (each with the
   * value true).
   * @param {Array} strArray - Array of Set-elements as strings.
   * @param {?string} [errMsg] - Custom error message thrown on invalid input.
   * @returns {Object} - TODO: add return description.
   * @private
   */ _stringArrayToSet(strArray, errMsg) {
        if (!strArray) return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
            throw new Error(errMsg);
        }
        return strArray.reduce((set, el)=>{
            if (typeof el !== "string") {
                throw new Error(errMsg);
            }
            set[el] = true;
            return set;
        }, {});
    }
};


/***/ }),

/***/ 94065:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable complexity,max-statements */ /**
 * file.js: Transport for outputting to a local log file.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const fs = __webpack_require__(57147);
const path = __webpack_require__(71017);
const asyncSeries = __webpack_require__(39563);
const zlib = __webpack_require__(59796);
const { MESSAGE } = __webpack_require__(68635);
const { Stream, PassThrough } = __webpack_require__(92219);
const TransportStream = __webpack_require__(49339);
const debug = __webpack_require__(6355)("winston:file");
const os = __webpack_require__(22037);
const tailFile = __webpack_require__(33581);
/**
 * Transport for outputting to a local log file.
 * @type {File}
 * @extends {TransportStream}
 */ module.exports = class File extends TransportStream {
    /**
   * Constructor function for the File transport object responsible for
   * persisting log messages and metadata to one or more files.
   * @param {Object} options - Options for this instance.
   */ constructor(options = {}){
        super(options);
        // Expose the name of this Transport on the prototype.
        this.name = options.name || "file";
        // Helper function which throws an `Error` in the event that any of the
        // rest of the arguments is present in `options`.
        function throwIf(target, ...args) {
            args.slice(1).forEach((name)=>{
                if (options[name]) {
                    throw new Error(`Cannot set ${name} and ${target} together`);
                }
            });
        }
        // Setup the base stream that always gets piped to to handle buffering.
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        // Bind this context for listener methods.
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
            throwIf("filename or dirname", "stream");
            this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
            this.dirname = options.dirname || path.dirname(options.filename);
            this.options = options.options || {
                flags: "a"
            };
        } else if (options.stream) {
            // eslint-disable-next-line no-console
            console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
            throwIf("stream", "filename", "maxsize");
            this._dest = this._stream.pipe(this._setupStream(options.stream));
            this.dirname = path.dirname(this._dest.path);
        // We need to listen for drain events when write() returns false. This
        // can make node mad at times.
        } else {
            throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        // Internal state variables representing the number of files this instance
        // has created and the current size (in bytes) of the current logfile.
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname) this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy) this.open();
    }
    finishIfEnding() {
        if (this._ending) {
            if (this._opening) {
                this.once("open", ()=>{
                    this._stream.once("finish", ()=>this.emit("finish"));
                    setImmediate(()=>this._stream.end());
                });
            } else {
                this._stream.once("finish", ()=>this.emit("finish"));
                setImmediate(()=>this._stream.end());
            }
        }
    }
    /**
   * Core logging method exposed to Winston. Metadata is optional.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */ log(info, callback = ()=>{}) {
        // Remark: (jcrugzz) What is necessary about this callback(null, true) now
        // when thinking about 3.x? Should silent be handled in the base
        // TransportStream _write method?
        if (this.silent) {
            callback();
            return true;
        }
        // Output stream buffer is full and has asked us to wait for the drain event
        if (this._drain) {
            this._stream.once("drain", ()=>{
                this._drain = false;
                this.log(info, callback);
            });
            return;
        }
        if (this._rotate) {
            this._stream.once("rotate", ()=>{
                this._rotate = false;
                this.log(info, callback);
            });
            return;
        }
        if (this.lazy) {
            if (!this._fileExist) {
                if (!this._opening) {
                    this.open();
                }
                this.once("open", ()=>{
                    this._fileExist = true;
                    this.log(info, callback);
                    return;
                });
                return;
            }
            if (this._needsNewFile(this._pendingSize)) {
                this._dest.once("close", ()=>{
                    if (!this._opening) {
                        this.open();
                    }
                    this.once("open", ()=>{
                        this.log(info, callback);
                        return;
                    });
                    return;
                });
                return;
            }
        }
        // Grab the raw string and append the expected EOL.
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        // After we have written to the PassThrough check to see if we need
        // to rotate to the next file.
        //
        // Remark: This gets called too early and does not depict when data
        // has been actually flushed to disk.
        function logged() {
            this._size += bytes;
            this._pendingSize -= bytes;
            debug("logged %s %s", this._size, output);
            this.emit("logged", info);
            // Do not attempt to rotate files while rotating
            if (this._rotate) {
                return;
            }
            // Do not attempt to rotate files while opening
            if (this._opening) {
                return;
            }
            // Check to see if we need to end the stream and create a new one.
            if (!this._needsNewFile()) {
                return;
            }
            if (this.lazy) {
                this._endStream(()=>{
                    this.emit("fileclosed");
                });
                return;
            }
            // End the current stream, ensure it flushes and create a new one.
            // This could potentially be optimized to not run a stat call but its
            // the safest way since we are supporting `maxFiles`.
            this._rotate = true;
            this._endStream(()=>this._rotateFile());
        }
        // Keep track of the pending bytes being written while files are opening
        // in order to properly rotate the PassThrough this._stream when the file
        // eventually does open.
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
            this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
            this._drain = true;
            this._stream.once("drain", ()=>{
                this._drain = false;
                callback();
            });
        } else {
            callback(); // eslint-disable-line callback-return
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
    }
    /**
   * Query the transport. Options object is optional.
   * @param {Object} options - Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * TODO: Refactor me.
   */ query(options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
            encoding: "utf8"
        });
        stream.on("error", (err)=>{
            if (stream.readable) {
                stream.destroy();
            }
            if (!callback) {
                return;
            }
            return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data)=>{
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for(; i < l; i++){
                if (!options.start || row >= options.start) {
                    add(data[i]);
                }
                row++;
            }
            buff = data[l];
        });
        stream.on("close", ()=>{
            if (buff) {
                add(buff, true);
            }
            if (options.order === "desc") {
                results = results.reverse();
            }
            // eslint-disable-next-line callback-return
            if (callback) callback(null, results);
        });
        function add(buff, attempt) {
            try {
                const log = JSON.parse(buff);
                if (check(log)) {
                    push(log);
                }
            } catch (e) {
                if (!attempt) {
                    stream.emit("error", e);
                }
            }
        }
        function push(log) {
            if (options.rows && results.length >= options.rows && options.order !== "desc") {
                if (stream.readable) {
                    stream.destroy();
                }
                return;
            }
            if (options.fields) {
                log = options.fields.reduce((obj, key)=>{
                    obj[key] = log[key];
                    return obj;
                }, {});
            }
            if (options.order === "desc") {
                if (results.length >= options.rows) {
                    results.shift();
                }
            }
            results.push(log);
        }
        function check(log) {
            if (!log) {
                return;
            }
            if (typeof log !== "object") {
                return;
            }
            const time = new Date(log.timestamp);
            if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
                return;
            }
            return true;
        }
        function normalizeQuery(options) {
            options = options || {};
            // limit
            options.rows = options.rows || options.limit || 10;
            // starting row offset
            options.start = options.start || 0;
            // now
            options.until = options.until || new Date();
            if (typeof options.until !== "object") {
                options.until = new Date(options.until);
            }
            // now - 24
            options.from = options.from || options.until - 24 * 60 * 60 * 1000;
            if (typeof options.from !== "object") {
                options.from = new Date(options.from);
            }
            // 'asc' or 'desc'
            options.order = options.order || "desc";
            return options;
        }
    }
    /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description.
   * TODO: Refactor me.
   */ stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
            file,
            start: options.start
        };
        stream.destroy = tailFile(tail, (err, line)=>{
            if (err) {
                return stream.emit("error", err);
            }
            try {
                stream.emit("data", line);
                line = JSON.parse(line);
                stream.emit("log", line);
            } catch (e) {
                stream.emit("error", e);
            }
        });
        return stream;
    }
    /**
   * Checks to see the filesize of.
   * @returns {undefined}
   */ open() {
        // If we do not have a filename then we were passed a stream and
        // don't need to keep track of size.
        if (!this.filename) return;
        if (this._opening) return;
        this._opening = true;
        // Stat the target file to get the size and create the stream.
        this.stat((err, size)=>{
            if (err) {
                return this.emit("error", err);
            }
            debug("stat done: %s { size: %s }", this.filename, size);
            this._size = size;
            this._dest = this._createStream(this._stream);
            this._opening = false;
            this.once("open", ()=>{
                if (this._stream.eventNames().includes("rotate")) {
                    this._stream.emit("rotate");
                } else {
                    this._rotate = false;
                }
            });
        });
    }
    /**
   * Stat the file and assess information in order to create the proper stream.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */ stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat)=>{
            if (err && err.code === "ENOENT") {
                debug("ENOENT\xa0ok", fullpath);
                // Update internally tracked filename with the new target name.
                this.filename = target;
                return callback(null, 0);
            }
            if (err) {
                debug(`err ${err.code} ${fullpath}`);
                return callback(err);
            }
            if (!stat || this._needsNewFile(stat.size)) {
                // If `stats.size` is greater than the `maxsize` for this
                // instance then try again.
                return this._incFile(()=>this.stat(callback));
            }
            // Once we have figured out what the filename is, set it
            // and return the size.
            this.filename = target;
            callback(null, stat.size);
        });
    }
    /**
   * Closes the stream associated with this instance.
   * @param {function} cb - TODO: add param description.
   * @returns {undefined}
   */ close(cb) {
        if (!this._stream) {
            return;
        }
        this._stream.end(()=>{
            if (cb) {
                cb(); // eslint-disable-line callback-return
            }
            this.emit("flush");
            this.emit("closed");
        });
    }
    /**
   * TODO: add method description.
   * @param {number} size - TODO: add param description.
   * @returns {undefined}
   */ _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
    }
    /**
   * TODO: add method description.
   * @param {Error} err - TODO: add param description.
   * @returns {undefined}
   */ _onError(err) {
        this.emit("error", err);
    }
    /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */ _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
    }
    /**
   * TODO: add method description.
   * @param {Stream} stream - TODO: add param description.
   * @returns {mixed} - TODO: add return description.
   */ _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
    }
    /**
   * TODO: add method description.
   */ _rotateFile() {
        this._incFile(()=>this.open());
    }
    /**
   * Unpipe from the stream that has been marked as full and end it so it
   * flushes to disk.
   *
   * @param {function} callback - Callback for when the current file has closed.
   * @private
   */ _endStream(callback = ()=>{}) {
        if (this._dest) {
            this._stream.unpipe(this._dest);
            this._dest.end(()=>{
                this._cleanupStream(this._dest);
                callback();
            });
        } else {
            callback(); // eslint-disable-line callback-return
        }
    }
    /**
   * Returns the WritableStream for the active file on this instance. If we
   * should gzip the file then a zlib stream is returned.
   *
   * @param {ReadableStream} source –PassThrough to pipe to the file when open.
   * @returns {WritableStream} Stream that writes to disk for the active file.
   */ _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options)// TODO: What should we do with errors here?
        .on("error", (err)=>debug(err)).on("close", ()=>debug("close", dest.path, dest.bytesWritten)).on("open", ()=>{
            debug("file open ok", fullpath);
            this.emit("open", fullpath);
            source.pipe(dest);
            // If rotation occured during the open operation then we immediately
            // start writing to a new PassThrough, begin opening the next file
            // and cleanup the previous source and dest once the source has drained.
            if (this.rotatedWhileOpening) {
                this._stream = new PassThrough();
                this._stream.setMaxListeners(30);
                this._rotateFile();
                this.rotatedWhileOpening = false;
                this._cleanupStream(dest);
                source.end();
            }
        });
        debug("create stream ok", fullpath);
        return dest;
    }
    /**
   * TODO: add method description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */ _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
            tasks.push((function(cb) {
                const num = this._created > 0 && !this.tailable ? this._created : "";
                this._compressFile(path.join(this.dirname, `${basename}${num}${ext}`), path.join(this.dirname, `${basename}${num}${ext}.gz`), cb);
            }).bind(this));
        }
        tasks.push((function(cb) {
            if (!this.tailable) {
                this._created += 1;
                this._checkMaxFilesIncrementing(ext, basename, cb);
            } else {
                this._checkMaxFilesTailable(ext, basename, cb);
            }
        }).bind(this));
        asyncSeries(tasks, callback);
    }
    /**
   * Gets the next filename to use for this instance in the case that log
   * filesizes are being capped.
   * @returns {string} - TODO: add return description.
   * @private
   */ _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        // Caveat emptor (indexzero): rotationFormat() was broken by design When
        // combined with max files because the set of files to unlink is never
        // stored.
        return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
    }
    /**
   * Increment the number of files created or checked by this instance.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */ _checkMaxFilesIncrementing(ext, basename, callback) {
        // Check for maxFiles option and delete file.
        if (!this.maxFiles || this._created < this.maxFiles) {
            return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
    }
    /**
   * Roll files forward based on integer, up to maxFiles. e.g. if base if
   * file.log and it becomes oversized, roll to file1.log, and allow file.log
   * to be re-used. If file is oversized again, roll file1.log to file2.log,
   * roll file.log to file1.log, and so on.
   * @param {mixed} ext - TODO: add param description.
   * @param {mixed} basename - TODO: add param description.
   * @param {mixed} callback - TODO: add param description.
   * @returns {undefined}
   * @private
   */ _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
            return;
        }
        // const isZipped = this.zippedArchive ? '.gz' : '';
        const isZipped = this.zippedArchive ? ".gz" : "";
        for(let x = this.maxFiles - 1; x > 1; x--){
            tasks.push((function(i, cb) {
                let fileName = `${basename}${i - 1}${ext}${isZipped}`;
                const tmppath = path.join(this.dirname, fileName);
                fs.exists(tmppath, (exists)=>{
                    if (!exists) {
                        return cb(null);
                    }
                    fileName = `${basename}${i}${ext}${isZipped}`;
                    fs.rename(tmppath, path.join(this.dirname, fileName), cb);
                });
            }).bind(this, x));
        }
        asyncSeries(tasks, ()=>{
            fs.rename(path.join(this.dirname, `${basename}${ext}${isZipped}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);
        });
    }
    /**
   * Compresses src to dest with gzip and unlinks src
   * @param {string} src - path to source file.
   * @param {string} dest - path to zipped destination file.
   * @param {Function} callback - callback called after file has been compressed.
   * @returns {undefined}
   * @private
   */ _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, (err)=>{
            if (err) {
                return callback();
            }
            var gzip = zlib.createGzip();
            var inp = fs.createReadStream(src);
            var out = fs.createWriteStream(dest);
            out.on("finish", ()=>{
                fs.unlink(src, callback);
            });
            inp.pipe(gzip).pipe(out);
        });
    }
    _createLogDirIfNotExist(dirPath) {
        /* eslint-disable no-sync */ if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, {
                recursive: true
            });
        }
    /* eslint-enable no-sync */ }
};


/***/ }),

/***/ 30473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * http.js: Transport for outputting to a json-rpcserver.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const http = __webpack_require__(13685);
const https = __webpack_require__(95687);
const { Stream } = __webpack_require__(92219);
const TransportStream = __webpack_require__(49339);
const { configure } = __webpack_require__(69380);
/**
 * Transport for outputting to a json-rpc server.
 * @type {Stream}
 * @extends {TransportStream}
 */ module.exports = class Http extends TransportStream {
    /**
   * Constructor function for the Http transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */ // eslint-disable-next-line max-statements
    constructor(options = {}){
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5000;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
            this.port = this.ssl ? 443 : 80;
        }
    }
    /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {function} callback - TODO: add param description.
   * @returns {undefined}
   */ log(info, callback) {
        this._request(info, null, null, (err, res)=>{
            if (res && res.statusCode !== 200) {
                err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
            }
            if (err) {
                this.emit("warn", err);
            } else {
                this.emit("logged", info);
            }
        });
        // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering
        // and block more requests from happening?
        if (callback) {
            setImmediate(callback);
        }
    }
    /**
   * Query the transport. Options object is optional.
   * @param {Object} options -  Loggly-like query options for this instance.
   * @param {function} callback - Continuation to respond to when complete.
   * @returns {undefined}
   */ query(options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }
        options = {
            method: "query",
            params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body)=>{
            if (res && res.statusCode !== 200) {
                err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
            }
            if (err) {
                return callback(err);
            }
            if (typeof body === "string") {
                try {
                    body = JSON.parse(body);
                } catch (e) {
                    return callback(e);
                }
            }
            callback(null, body);
        });
    }
    /**
   * Returns a log stream for this transport. Options object is optional.
   * @param {Object} options - Stream options for this instance.
   * @returns {Stream} - TODO: add return description
   */ stream(options = {}) {
        const stream = new Stream();
        options = {
            method: "stream",
            params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = ()=>req.destroy();
        req.on("data", (data)=>{
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for(; i < l; i++){
                try {
                    stream.emit("log", JSON.parse(data[i]));
                } catch (e) {
                    stream.emit("error", e);
                }
            }
            buff = data[l];
        });
        req.on("error", (err)=>stream.emit("error", err));
        return stream;
    }
    /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   * @param {function} callback - Continuation to respond to when complete.
   */ _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
            this._doBatch(options, callback, auth, path);
        } else {
            this._doRequest(options, callback, auth, path);
        }
    }
    /**
   * Send or memorize the options according to batch configuration
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */ _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
            // First message stored, it's time to start the timeout!
            const me = this;
            this.batchCallback = callback;
            this.batchTimeoutID = setTimeout(function() {
                // timeout is reached, send all messages to endpoint
                me.batchTimeoutID = -1;
                me._doBatchRequest(me.batchCallback, auth, path);
            }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
            // max batch count is reached, send all messages to endpoint
            this._doBatchRequest(this.batchCallback, auth, path);
        }
    }
    /**
   * Initiate a request with the memorized batch options, stop the batch timeout
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */ _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
            clearTimeout(this.batchTimeoutID);
            this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
    }
    /**
   * Make a request to a winstond server or any http server which can
   * handle json-rpc.
   * @param {function} options - Options to sent the request.
   * @param {function} callback - Continuation to respond to when complete.
   * @param {Object?} auth - authentication options
   * @param {string} path - request path
   */ _doRequest(options, callback, auth, path) {
        // Prepare options for outgoing HTTP request
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
            headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
            ...this.options,
            method: "POST",
            host: this.host,
            port: this.port,
            path: `/${path.replace(/^\//, "")}`,
            headers: headers,
            auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
            agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res)=>res.on("end", ()=>callback(null, res)).resume());
        const jsonStringify = configure({
            ...this.maximumDepth && {
                maximumDepth: this.maximumDepth
            }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
    }
};


/***/ }),

/***/ 23249:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * transports.js: Set of all transports Winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
/**
 * TODO: add property description.
 * @type {Console}
 */ Object.defineProperty(exports, "Console", ({
    configurable: true,
    enumerable: true,
    get () {
        return __webpack_require__(32322);
    }
}));
/**
 * TODO: add property description.
 * @type {File}
 */ Object.defineProperty(exports, "File", ({
    configurable: true,
    enumerable: true,
    get () {
        return __webpack_require__(94065);
    }
}));
/**
 * TODO: add property description.
 * @type {Http}
 */ Object.defineProperty(exports, "Http", ({
    configurable: true,
    enumerable: true,
    get () {
        return __webpack_require__(30473);
    }
}));
/**
 * TODO: add property description.
 * @type {Stream}
 */ Object.defineProperty(exports, "Stream", ({
    configurable: true,
    enumerable: true,
    get () {
        return __webpack_require__(21334);
    }
}));


/***/ }),

/***/ 21334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * stream.js: Transport for outputting to any arbitrary stream.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */ 
const isStream = __webpack_require__(99130);
const { MESSAGE } = __webpack_require__(68635);
const os = __webpack_require__(22037);
const TransportStream = __webpack_require__(49339);
/**
 * Transport for outputting to any arbitrary stream.
 * @type {Stream}
 * @extends {TransportStream}
 */ module.exports = class Stream extends TransportStream {
    /**
   * Constructor function for the Console transport object responsible for
   * persisting log messages and metadata to a terminal or TTY.
   * @param {!Object} [options={}] - Options for this instance.
   */ constructor(options = {}){
        super(options);
        if (!options.stream || !isStream(options.stream)) {
            throw new Error("options.stream is required.");
        }
        // We need to listen for drain events when write() returns false. This can
        // make node mad at times.
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
    }
    /**
   * Core logging method exposed to Winston.
   * @param {Object} info - TODO: add param description.
   * @param {Function} callback - TODO: add param description.
   * @returns {undefined}
   */ log(info, callback) {
        setImmediate(()=>this.emit("logged", info));
        if (this.isObjectMode) {
            this._stream.write(info);
            if (callback) {
                callback(); // eslint-disable-line callback-return
            }
            return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
            callback(); // eslint-disable-line callback-return
        }
        return;
    }
};


/***/ }),

/***/ 82555:
/***/ ((module) => {

"use strict";

const codes = {};
function createErrorType(code, message, Base) {
    if (!Base) {
        Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
            return message;
        } else {
            return message(arg1, arg2, arg3);
        }
    }
    class NodeError extends Base {
        constructor(arg1, arg2, arg3){
            super(getMessage(arg1, arg2, arg3));
        }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
}
// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i)=>String(i));
        if (len > 2) {
            return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
            return `of ${thing} ${expected[0]}`;
        }
    } else {
        return `of ${thing} ${String(expected)}`;
    }
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") {
        start = 0;
    }
    if (start + search.length > str.length) {
        return false;
    } else {
        return str.indexOf(search, start) !== -1;
    }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else {
        determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
        // For cases like 'first argument'
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.q = codes;


/***/ }),

/***/ 30538:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = __webpack_require__(11027);
var Writable = __webpack_require__(53655);
__webpack_require__(41492)(Duplex, Readable);
{
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});


/***/ }),

/***/ 42992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __webpack_require__(2504);
__webpack_require__(41492)(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 11027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(58335);
/*</replacement>*/ var Buffer = (__webpack_require__(14300).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function debug() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(89725);
var destroyImpl = __webpack_require__(61874);
var _require = __webpack_require__(68006), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(82555)/* .codes */ .q), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(41492)(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || __webpack_require__(30538);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(19914)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(30538);
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
                return false;
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], chunk);
    }
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(19914)/* .StringDecoder */ .s);
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
    } else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true;
    // crude way to check if we should resume
    } else if (self1.listenerCount("data") > 0) {
        self1.resume();
    }
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === undefined) {
            createReadableStreamAsyncIterator = __webpack_require__(80510);
        }
        return createReadableStreamAsyncIterator(this);
    };
}
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) {
            this._readableState.flowing = state;
        }
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
            }
        }
    }
}
if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
        if (from === undefined) {
            from = __webpack_require__(19118);
        }
        return from(Readable, iterable, opts);
    };
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 2504:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var _require$codes = (__webpack_require__(82555)/* .codes */ .q), ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(30538);
__webpack_require__(41492)(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}


/***/ }),

/***/ 53655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(17038)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(58335);
/*</replacement>*/ var Buffer = (__webpack_require__(14300).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(61874);
var _require = __webpack_require__(68006), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(82555)/* .codes */ .q), ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(41492)(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || __webpack_require__(30538);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function realHasInstance(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(30538);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer"
        ], chunk);
    }
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                }
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};


/***/ }),

/***/ 80510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = __webpack_require__(34217);
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) {
            return Promise.reject(error);
        }
        if (this[kEnded]) {
            return Promise.resolve(createIterResult(undefined, true));
        }
        if (this[kStream].destroyed) {
            // We need to defer via nextTick because if .destroy(err) is
            // called, the error will be emitted via nextTick, and
            // we cannot guarantee that there is no error lingering around
            // waiting to be emitted.
            return new Promise(function(resolve, reject) {
                process.nextTick(function() {
                    if (_this[kError]) {
                        reject(_this[kError]);
                    } else {
                        resolve(createIterResult(undefined, true));
                    }
                });
            });
        }
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
        } else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;


/***/ }),

/***/ 89725:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = __webpack_require__(14300), Buffer = _require.Buffer;
var _require2 = __webpack_require__(73837), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) {
                    // First chunk is a perfect match.
                    ret = this.shift();
                } else {
                    // Result spans more than one buffer.
                    ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                }
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();


/***/ }),

/***/ 61874:
/***/ ((module) => {

"use strict";

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else {
                process.nextTick(emitCloseNT, _this);
            }
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else {
            process.nextTick(emitCloseNT, _this);
        }
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};


/***/ }),

/***/ 34217:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(82555)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE);
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;


/***/ }),

/***/ 19118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var ERR_INVALID_ARG_TYPE = (__webpack_require__(82555)/* .codes.ERR_INVALID_ARG_TYPE */ .q.ERR_INVALID_ARG_TYPE);
function from(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", [
        "Iterable"
    ], iterable);
    var readable = new Readable(_objectSpread({
        objectMode: true
    }, opts));
    // Reading boolean to protect against _read
    // being called before last iteration completion.
    var reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    function next() {
        return _next2.apply(this, arguments);
    }
    function _next2() {
        _next2 = _asyncToGenerator(function*() {
            try {
                var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
                if (done) {
                    readable.push(null);
                } else if (readable.push((yield value))) {
                    next();
                } else {
                    reading = false;
                }
            } catch (err) {
                readable.destroy(err);
            }
        });
        return _next2.apply(this, arguments);
    }
    return readable;
}
module.exports = from;


/***/ }),

/***/ 35334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = (__webpack_require__(82555)/* .codes */ .q), ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = __webpack_require__(34217);
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++){
        streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;


/***/ }),

/***/ 68006:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ERR_INVALID_OPT_VALUE = (__webpack_require__(82555)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE);
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};


/***/ }),

/***/ 58335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 92219:
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
} else {
    exports = module.exports = __webpack_require__(11027);
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(53655);
    exports.Duplex = __webpack_require__(30538);
    exports.Transform = __webpack_require__(2504);
    exports.PassThrough = __webpack_require__(42992);
    exports.finished = __webpack_require__(34217);
    exports.pipeline = __webpack_require__(35334);
}


/***/ }),

/***/ 19914:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(14698).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "�";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "�";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "�";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 83923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var domhandler = __webpack_require__(95951);
var selderee = __webpack_require__(76305);
function hp2Builder(nodes) {
    return new selderee.Picker(handleArray(nodes));
}
function handleArray(nodes) {
    const matchers = nodes.map(handleNode);
    return (el, ...tail)=>matchers.flatMap((m)=>m(el, ...tail));
}
function handleNode(node) {
    switch(node.type){
        case "terminal":
            {
                const result = [
                    node.valueContainer
                ];
                return (el, ...tail)=>result;
            }
        case "tagName":
            return handleTagName(node);
        case "attrValue":
            return handleAttrValueName(node);
        case "attrPresence":
            return handleAttrPresenceName(node);
        case "pushElement":
            return handlePushElementNode(node);
        case "popElement":
            return handlePopElementNode(node);
    }
}
function handleTagName(node) {
    const variants = {};
    for (const variant of node.variants){
        variants[variant.value] = handleArray(variant.cont);
    }
    return (el, ...tail)=>{
        const continuation = variants[el.name];
        return continuation ? continuation(el, ...tail) : [];
    };
}
function handleAttrPresenceName(node) {
    const attrName = node.name;
    const continuation = handleArray(node.cont);
    return (el, ...tail)=>Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node) {
    const callbacks = [];
    for (const matcher of node.matchers){
        const predicate = matcher.predicate;
        const continuation = handleArray(matcher.cont);
        callbacks.push((attr, el, ...tail)=>predicate(attr) ? continuation(el, ...tail) : []);
    }
    const attrName = node.name;
    return (el, ...tail)=>{
        const attr = el.attribs[attrName];
        return attr || attr === "" ? callbacks.flatMap((cb)=>cb(attr, el, ...tail)) : [];
    };
}
function handlePushElementNode(node) {
    const continuation = handleArray(node.cont);
    const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
    return (el, ...tail)=>{
        const next = leftElementGetter(el);
        if (next === null) {
            return [];
        }
        return continuation(next, el, ...tail);
    };
}
const getPrecedingElement = (el)=>{
    const prev = el.prev;
    if (prev === null) {
        return null;
    }
    return domhandler.isTag(prev) ? prev : getPrecedingElement(prev);
};
const getParentElement = (el)=>{
    const parent = el.parent;
    return parent && domhandler.isTag(parent) ? parent : null;
};
function handlePopElementNode(node) {
    const continuation = handleArray(node.cont);
    return (el, next, ...tail)=>continuation(next, ...tail);
}
exports.hp2Builder = hp2Builder;


/***/ }),

/***/ 41612:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var pluginHtmlparser2 = __webpack_require__(83923);
var htmlparser2 = __webpack_require__(16572);
var selderee = __webpack_require__(76305);
var merge = __webpack_require__(27186);
var domSerializer = __webpack_require__(82856);
function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {
        "default": e
    };
}
var merge__default = /*#__PURE__*/ _interopDefaultLegacy(merge);
/**
 * Make a recursive function that will only run to a given depth
 * and switches to an alternative function at that depth. \
 * No limitation if `n` is `undefined` (Just wraps `f` in that case).
 *
 * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.
 * @param   { Function }           f   Function that accepts recursive callback as the first argument.
 * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.
 * @returns { Function }
 */ function limitedDepthRecursive(n, f, g = ()=>undefined) {
    if (n === undefined) {
        const f1 = function(...args) {
            return f(f1, ...args);
        };
        return f1;
    }
    if (n >= 0) {
        return function(...args) {
            return f(limitedDepthRecursive(n - 1, f, g), ...args);
        };
    }
    return g;
}
/**
 * Return the same string or a substring with
 * the given character occurrences removed from each side.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */ function trimCharacter(str, char) {
    let start = 0;
    let end = str.length;
    while(start < end && str[start] === char){
        ++start;
    }
    while(end > start && str[end - 1] === char){
        --end;
    }
    return start > 0 || end < str.length ? str.substring(start, end) : str;
}
/**
 * Return the same string or a substring with
 * the given character occurrences removed from the end only.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */ function trimCharacterEnd(str, char) {
    let end = str.length;
    while(end > 0 && str[end - 1] === char){
        --end;
    }
    return end < str.length ? str.substring(0, end) : str;
}
/**
 * Return a new string will all characters replaced with unicode escape sequences.
 * This extreme kind of escaping can used to be safely compose regular expressions.
 *
 * @param { string } str A string to escape.
 * @returns { string } A string of unicode escape sequences.
 */ function unicodeEscape(str) {
    return str.replace(/[\s\S]/g, (c)=>"\\u" + c.charCodeAt().toString(16).padStart(4, "0"));
}
/**
 * Deduplicate an array by a given key callback.
 * Item properties are merged recursively and with the preference for last defined values.
 * Of items with the same key, merged item takes the place of the last item,
 * others are omitted.
 *
 * @param { any[] } items An array to deduplicate.
 * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.
 * @returns { any[] }
 */ function mergeDuplicatesPreferLast(items, getKey) {
    const map = new Map();
    for(let i = items.length; i-- > 0;){
        const item = items[i];
        const key = getKey(item);
        map.set(key, map.has(key) ? merge__default["default"](item, map.get(key), {
            arrayMerge: overwriteMerge$1
        }) : item);
    }
    return [
        ...map.values()
    ].reverse();
}
const overwriteMerge$1 = (acc, src, options)=>[
        ...src
    ];
/**
 * Get a nested property from an object.
 *
 * @param   { object }   obj  The object to query for the value.
 * @param   { string[] } path The path to the property.
 * @returns { any }
 */ function get(obj, path) {
    for (const key of path){
        if (!obj) {
            return undefined;
        }
        obj = obj[key];
    }
    return obj;
}
/**
 * Convert a number into alphabetic sequence representation (Sequence without zeroes).
 *
 * For example: `a, ..., z, aa, ..., zz, aaa, ...`.
 *
 * @param   { number } num              Number to convert. Must be >= 1.
 * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.
 * @param   { number } [base = 26]      Number of characters in the sequence.
 * @returns { string }
 */ function numberToLetterSequence(num, baseChar = "a", base = 26) {
    const digits = [];
    do {
        num -= 1;
        digits.push(num % base);
        num = num / base >> 0; // quick `floor`
    }while (num > 0);
    const baseCode = baseChar.charCodeAt(0);
    return digits.reverse().map((n)=>String.fromCharCode(baseCode + n)).join("");
}
const I = [
    "I",
    "X",
    "C",
    "M"
];
const V = [
    "V",
    "L",
    "D"
];
/**
 * Convert a number to it's Roman representation. No large numbers extension.
 *
 * @param   { number } num Number to convert. `0 < num <= 3999`.
 * @returns { string }
 */ function numberToRoman(num) {
    return [
        ...num + ""
    ].map((n)=>+n).reverse().map((v, i)=>v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
}
/**
 * Helps to build text from words.
 */ class InlineTextBuilder {
    /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */ constructor(options, maxLineLength = undefined){
        /** @type { string[][] } */ this.lines = [];
        /** @type { string[] }   */ this.nextLineWords = [];
        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
        this.nextLineAvailableChars = this.maxLineLength;
        this.wrapCharacters = get(options, [
            "longWordSplit",
            "wrapCharacters"
        ]) || [];
        this.forceWrapOnLimit = get(options, [
            "longWordSplit",
            "forceWrapOnLimit"
        ]) || false;
        this.stashedSpace = false;
        this.wordBreakOpportunity = false;
    }
    /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */ pushWord(word, noWrap = false) {
        if (this.nextLineAvailableChars <= 0 && !noWrap) {
            this.startNewLine();
        }
        const isLineStart = this.nextLineWords.length === 0;
        const cost = word.length + (isLineStart ? 0 : 1);
        if (cost <= this.nextLineAvailableChars || noWrap) {
            this.nextLineWords.push(word);
            this.nextLineAvailableChars -= cost;
        } else {
            // The word is moved to a new line - prefer to wrap between words.
            const [first, ...rest] = this.splitLongWord(word);
            if (!isLineStart) {
                this.startNewLine();
            }
            this.nextLineWords.push(first);
            this.nextLineAvailableChars -= first.length;
            for (const part of rest){
                this.startNewLine();
                this.nextLineWords.push(part);
                this.nextLineAvailableChars -= part.length;
            }
        }
    }
    /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */ popWord() {
        const lastWord = this.nextLineWords.pop();
        if (lastWord !== undefined) {
            const isLineStart = this.nextLineWords.length === 0;
            const cost = lastWord.length + (isLineStart ? 0 : 1);
            this.nextLineAvailableChars += cost;
        }
        return lastWord;
    }
    /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */ concatWord(word, noWrap = false) {
        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
            this.pushWord(word, noWrap);
            this.wordBreakOpportunity = false;
        } else {
            const lastWord = this.popWord();
            this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
        }
    }
    /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */ startNewLine(n = 1) {
        this.lines.push(this.nextLineWords);
        if (n > 1) {
            this.lines.push(...Array.from({
                length: n - 1
            }, ()=>[]));
        }
        this.nextLineWords = [];
        this.nextLineAvailableChars = this.maxLineLength;
    }
    /**
   * No words in this builder.
   *
   * @returns { boolean }
   */ isEmpty() {
        return this.lines.length === 0 && this.nextLineWords.length === 0;
    }
    clear() {
        this.lines.length = 0;
        this.nextLineWords.length = 0;
        this.nextLineAvailableChars = this.maxLineLength;
    }
    /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */ toString() {
        return [
            ...this.lines,
            this.nextLineWords
        ].map((words)=>words.join(" ")).join("\n");
    }
    /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */ splitLongWord(word) {
        const parts = [];
        let idx = 0;
        while(word.length > this.maxLineLength){
            const firstLine = word.substring(0, this.maxLineLength);
            const remainingChars = word.substring(this.maxLineLength);
            const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
            if (splitIndex > -1) {
                word = firstLine.substring(splitIndex + 1) + remainingChars;
                parts.push(firstLine.substring(0, splitIndex + 1));
            } else {
                idx++;
                if (idx < this.wrapCharacters.length) {
                    word = firstLine + remainingChars;
                } else {
                    if (this.forceWrapOnLimit) {
                        parts.push(firstLine);
                        word = remainingChars;
                        if (word.length > this.maxLineLength) {
                            continue;
                        }
                    } else {
                        word = firstLine + remainingChars;
                    }
                    break;
                }
            }
        }
        parts.push(word); // Add remaining part to array
        return parts;
    }
}
/* eslint-disable max-classes-per-file */ class StackItem {
    constructor(next = null){
        this.next = next;
    }
    getRoot() {
        return this.next ? this.next : this;
    }
}
class BlockStackItem extends StackItem {
    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined){
        super(next);
        this.leadingLineBreaks = leadingLineBreaks;
        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
        this.rawText = "";
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
    }
}
class ListStackItem extends BlockStackItem {
    constructor(options, next = null, { interRowLineBreaks = 1, leadingLineBreaks = 2, maxLineLength = undefined, maxPrefixLength = 0, prefixAlign = "left" } = {}){
        super(options, next, leadingLineBreaks, maxLineLength);
        this.maxPrefixLength = maxPrefixLength;
        this.prefixAlign = prefixAlign;
        this.interRowLineBreaks = interRowLineBreaks;
    }
}
class ListItemStackItem extends BlockStackItem {
    constructor(options, next = null, { leadingLineBreaks = 1, maxLineLength = undefined, prefix = "" } = {}){
        super(options, next, leadingLineBreaks, maxLineLength);
        this.prefix = prefix;
    }
}
class TableStackItem extends StackItem {
    constructor(next = null){
        super(next);
        this.rows = [];
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
    }
}
class TableRowStackItem extends StackItem {
    constructor(next = null){
        super(next);
        this.cells = [];
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
    }
}
class TableCellStackItem extends StackItem {
    constructor(options, next = null, maxColumnWidth = undefined){
        super(next);
        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
        this.rawText = "";
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
        this.isNoWrap = next && next.isNoWrap;
    }
}
class TransformerStackItem extends StackItem {
    constructor(next = null, transform){
        super(next);
        this.transform = transform;
    }
}
function charactersToCodes(str) {
    return [
        ...str
    ].map((c)=>"\\u" + c.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}
/**
 * Helps to handle HTML whitespaces.
 *
 * @class WhitespaceProcessor
 */ class WhitespaceProcessor {
    /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */ constructor(options){
        this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
        const whitespaceCodes = charactersToCodes(this.whitespaceChars);
        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
        this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
        this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
        if (options.preserveNewlines) {
            const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
            /**
       * Shrink whitespaces and wrap text, add to the builder.
       *
       * @param { string }                  text              Input text.
       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.
       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.
       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.
       */ this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {
                if (!text) {
                    return;
                }
                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
                let anyMatch = false;
                let m = wordOrNewlineRe.exec(text);
                if (m) {
                    anyMatch = true;
                    if (m[0] === "\n") {
                        inlineTextBuilder.startNewLine();
                    } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);
                    } else {
                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);
                    }
                    while((m = wordOrNewlineRe.exec(text)) !== null){
                        if (m[0] === "\n") {
                            inlineTextBuilder.startNewLine();
                        } else {
                            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
                        }
                    }
                }
                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
            // No need to stash a space in case last added item was a new line,
            // but that won't affect anything later anyway.
            };
        } else {
            const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
            this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {
                if (!text) {
                    return;
                }
                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
                let anyMatch = false;
                let m = wordRe.exec(text);
                if (m) {
                    anyMatch = true;
                    if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);
                    } else {
                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);
                    }
                    while((m = wordRe.exec(text)) !== null){
                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);
                    }
                }
                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
            };
        }
    }
    /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */ addLiteral(text, inlineTextBuilder, noWrap = true) {
        if (!text) {
            return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = this.newlineOrNonNewlineStringRe.exec(text);
        if (m) {
            anyMatch = true;
            if (m[0] === "\n") {
                inlineTextBuilder.startNewLine();
            } else if (previouslyStashedSpace) {
                inlineTextBuilder.pushWord(m[0], noWrap);
            } else {
                inlineTextBuilder.concatWord(m[0], noWrap);
            }
            while((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null){
                if (m[0] === "\n") {
                    inlineTextBuilder.startNewLine();
                } else {
                    inlineTextBuilder.pushWord(m[0], noWrap);
                }
            }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
    }
    /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */ testLeadingWhitespace(text) {
        return this.leadingWhitespaceRe.test(text);
    }
    /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */ testTrailingWhitespace(text) {
        return this.trailingWhitespaceRe.test(text);
    }
    /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */ testContainsWords(text) {
        return !this.allWhitespaceOrEmptyRe.test(text);
    }
    /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */ countNewlinesNoWords(text) {
        this.newlineOrNonWhitespaceRe.lastIndex = 0;
        let counter = 0;
        let match;
        while((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null){
            if (match[0] === "\n") {
                counter++;
            } else {
                return 0;
            }
        }
        return counter;
    }
}
/**
 * Helps to build text from inline and block elements.
 *
 * @class BlockTextBuilder
 */ class BlockTextBuilder {
    /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */ constructor(options, picker, metadata = undefined){
        this.options = options;
        this.picker = picker;
        this.metadata = metadata;
        this.whitespaceProcessor = new WhitespaceProcessor(options);
        /** @type { StackItem } */ this._stackItem = new BlockStackItem(options);
        /** @type { TransformerStackItem } */ this._wordTransformer = undefined;
    }
    /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */ pushWordTransform(wordTransform) {
        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
    }
    /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */ popWordTransform() {
        if (!this._wordTransformer) {
            return undefined;
        }
        const transform = this._wordTransformer.transform;
        this._wordTransformer = this._wordTransformer.next;
        return transform;
    }
    /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */ startNoWrap() {
        this._stackItem.isNoWrap = true;
    }
    /**
   * Return automatic wrapping to behavior defined by options.
   */ stopNoWrap() {
        this._stackItem.isNoWrap = false;
    }
    /** @returns { (str: string) => string } */ _getCombinedWordTransformer() {
        const wt = this._wordTransformer ? (str)=>applyTransformer(str, this._wordTransformer) : undefined;
        const ce = this.options.encodeCharacters;
        return wt ? ce ? (str)=>ce(wt(str)) : wt : ce;
    }
    _popStackItem() {
        const item = this._stackItem;
        this._stackItem = item.next;
        return item;
    }
    /**
   * Add a line break into currently built block.
   */ addLineBreak() {
        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
            return;
        }
        if (this._stackItem.isPre) {
            this._stackItem.rawText += "\n";
        } else {
            this._stackItem.inlineTextBuilder.startNewLine();
        }
    }
    /**
   * Allow to break line in case directly following text will not fit.
   */ addWordBreakOpportunity() {
        if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
            this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
        }
    }
    /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */ addInline(str, { noWordTransform = false } = {}) {
        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
            return;
        }
        if (this._stackItem.isPre) {
            this._stackItem.rawText += str;
            return;
        }
        if (str.length === 0 || // empty string
        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
        !this.whitespaceProcessor.testContainsWords(str) // no words to add
        ) {
            return;
        }
        if (this.options.preserveNewlines) {
            const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
            if (newlinesNumber > 0) {
                this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
                // keep stashedLineBreaks unchanged
                return;
            }
        }
        if (this._stackItem.stashedLineBreaks) {
            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks
    }
    /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */ addLiteral(str) {
        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
            return;
        }
        if (str.length === 0) {
            return;
        }
        if (this._stackItem.isPre) {
            this._stackItem.rawText += str;
            return;
        }
        if (this._stackItem.stashedLineBreaks) {
            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
        this._stackItem.stashedLineBreaks = 0;
    }
    /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */ openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
        this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
        if (isPre) {
            this._stackItem.isPre = true;
        }
    }
    /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */ closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
        const block = this._popStackItem();
        const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
    }
    /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */ openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
        this._stackItem = new ListStackItem(this.options, this._stackItem, {
            interRowLineBreaks: interRowLineBreaks,
            leadingLineBreaks: leadingLineBreaks,
            maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
            maxPrefixLength: maxPrefixLength,
            prefixAlign: prefixAlign
        });
    }
    /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */ openListItem({ prefix = "" } = {}) {
        if (!(this._stackItem instanceof ListStackItem)) {
            throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
        }
        const list = this._stackItem;
        const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
        const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
        this._stackItem = new ListItemStackItem(this.options, list, {
            prefix: prefix,
            maxLineLength: maxLineLength,
            leadingLineBreaks: list.interRowLineBreaks
        });
    }
    /**
   * Finalize currently built list item, add it's content to the parent list.
   */ closeListItem() {
        const listItem = this._popStackItem();
        const list = listItem.next;
        const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
        const spacing = "\n" + " ".repeat(prefixLength);
        const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
        const text = prefix + getText(listItem).replace(/\n/g, spacing);
        addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
    }
    /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */ closeList({ trailingLineBreaks = 2 } = {}) {
        const list = this._popStackItem();
        const text = getText(list);
        if (text) {
            addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
        }
    }
    /**
   * Start building a table.
   */ openTable() {
        this._stackItem = new TableStackItem(this._stackItem);
    }
    /**
   * Start building a table row.
   */ openTableRow() {
        if (!(this._stackItem instanceof TableStackItem)) {
            throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
        }
        this._stackItem = new TableRowStackItem(this._stackItem);
    }
    /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */ openTableCell({ maxColumnWidth = undefined } = {}) {
        if (!(this._stackItem instanceof TableRowStackItem)) {
            throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
        }
        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
    }
    /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */ closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
        const cell = this._popStackItem();
        const text = trimCharacter(getText(cell), "\n");
        cell.next.cells.push({
            colspan: colspan,
            rowspan: rowspan,
            text: text
        });
    }
    /**
   * Finalize currently built table row and add it to parent table's rows.
   */ closeTableRow() {
        const row = this._popStackItem();
        row.next.rows.push(row.cells);
    }
    /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */ closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
        const table = this._popStackItem();
        const output = tableToString(table.rows);
        if (output) {
            addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
        }
    }
    /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */ toString() {
        return getText(this._stackItem.getRoot());
    // There should only be the root item if everything is closed properly.
    }
}
function getText(stackItem) {
    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
        throw new Error("Only blocks, list items and table cells can be requested for text contents.");
    }
    return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
        throw new Error("Only blocks, list items and table cells can contain text.");
    }
    const parentText = getText(stackItem);
    const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
    stackItem.inlineTextBuilder.clear();
    if (parentText) {
        stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
    } else {
        stackItem.rawText = text;
        stackItem.leadingLineBreaks = lineBreaks;
    }
    stackItem.stashedLineBreaks = trailingLineBreaks;
}
/**
 * @param { string } str A string to transform.
 * @param { TransformerStackItem } transformer A transformer item (with possible continuation).
 * @returns { string }
 */ function applyTransformer(str, transformer) {
    return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
/**
 * Compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */ function compile$1(options = {}) {
    const selectorsWithoutFormat = options.selectors.filter((s)=>!s.format);
    if (selectorsWithoutFormat.length) {
        throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s)=>`\`${s.selector}\``).join(", "));
    }
    const picker = new selderee.DecisionTree(options.selectors.map((s)=>[
            s.selector,
            s
        ])).build(pluginHtmlparser2.hp2Builder);
    if (typeof options.encodeCharacters !== "function") {
        options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
    }
    const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s, i)=>[
            s,
            i + 1
        ])).build(pluginHtmlparser2.hp2Builder);
    function findBaseElements(dom) {
        return findBases(dom, options, baseSelectorsPicker);
    }
    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
        builder.addInline(options.limits.ellipsis || "");
    });
    return function(html, metadata = undefined) {
        return process(html, metadata, options, picker, findBaseElements, limitedWalk);
    };
}
/**
 * Convert given HTML according to preprocessed options.
 *
 * @param { string } html HTML content to convert.
 * @param { any } metadata Optional metadata for HTML document, for use in formatters.
 * @param { Options } options HtmlToText options (preprocessed).
 * @param { import('selderee').Picker<DomNode, TagDefinition> } picker
 * Tag definition picker for DOM nodes processing.
 * @param { (dom: DomNode[]) => DomNode[] } findBaseElements
 * Function to extract elements from HTML DOM
 * that will only be present in the output text.
 * @param { RecursiveCallback } walk Recursive callback.
 * @returns { string }
 */ function process(html, metadata, options, picker, findBaseElements, walk) {
    const maxInputLength = options.limits.maxInputLength;
    if (maxInputLength && html && html.length > maxInputLength) {
        console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
        html = html.substring(0, maxInputLength);
    }
    const document = htmlparser2.parseDocument(html, {
        decodeEntities: options.decodeEntities
    });
    const bases = findBaseElements(document.children);
    const builder = new BlockTextBuilder(options, picker, metadata);
    walk(bases, builder);
    return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
    const results = [];
    function recursiveWalk(walk, /** @type { DomNode[] } */ dom) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        for (const elem of dom){
            if (elem.type !== "tag") {
                continue;
            }
            const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
            if (pickedSelectorIndex > 0) {
                results.push({
                    selectorIndex: pickedSelectorIndex,
                    element: elem
                });
            } else if (elem.children) {
                walk(elem.children);
            }
            if (results.length >= options.limits.maxBaseElements) {
                return;
            }
        }
    }
    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
    limitedWalk(dom);
    if (options.baseElements.orderBy !== "occurrence") {
        results.sort((a, b)=>a.selectorIndex - b.selectorIndex);
    }
    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x)=>x.element);
}
/**
 * Function to walk through DOM nodes and accumulate their string representations.
 *
 * @param   { RecursiveCallback } walk    Recursive callback.
 * @param   { DomNode[] }         [dom]   Nodes array to process.
 * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.
 * @private
 */ function recursiveWalk(walk, dom, builder) {
    if (!dom) {
        return;
    }
    const options = builder.options;
    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
    if (tooManyChildNodes) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        dom.push({
            data: options.limits.ellipsis,
            type: "text"
        });
    }
    for (const elem of dom){
        switch(elem.type){
            case "text":
                {
                    builder.addInline(elem.data);
                    break;
                }
            case "tag":
                {
                    const tagDefinition = builder.picker.pick1(elem);
                    const format = options.formatters[tagDefinition.format];
                    format(elem, walk, builder, tagDefinition.options || {});
                    break;
                }
        }
    }
    return;
}
/**
 * @param { Object<string,string | false> } dict
 * A dictionary where keys are characters to replace
 * and values are replacement strings.
 *
 * First code point from dict keys is used.
 * Compound emojis with ZWJ are not supported (not until Node 16).
 *
 * @returns { ((str: string) => string) | undefined }
 */ function makeReplacerFromDict(dict) {
    if (!dict || Object.keys(dict).length === 0) {
        return undefined;
    }
    /** @type { [string, string][] } */ const entries = Object.entries(dict).filter(([, v])=>v !== false);
    const regex = new RegExp(entries.map(([c])=>`(${unicodeEscape([
            ...c
        ][0])})`).join("|"), "g");
    const values = entries.map(([, v])=>v);
    const replacer = (m, ...cgs)=>values[cgs.findIndex((cg)=>cg)];
    return (str)=>str.replace(regex, replacer);
}
/**
 * Dummy formatter that discards the input and does nothing.
 *
 * @type { FormatCallback }
 */ function formatSkip(elem, walk, builder, formatOptions) {
/* do nothing */ }
/**
 * Insert the given string literal inline instead of a tag.
 *
 * @type { FormatCallback }
 */ function formatInlineString(elem, walk, builder, formatOptions) {
    builder.addLiteral(formatOptions.string || "");
}
/**
 * Insert a block with the given string literal instead of a tag.
 *
 * @type { FormatCallback }
 */ function formatBlockString(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    builder.addLiteral(formatOptions.string || "");
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process an inline-level element.
 *
 * @type { FormatCallback }
 */ function formatInline(elem, walk, builder, formatOptions) {
    walk(elem.children, builder);
}
/**
 * Process a block-level container.
 *
 * @type { FormatCallback }
 */ function formatBlock$1(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
function renderOpenTag(elem) {
    const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k, v])=>v === "" ? k : `${k}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
    return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
    return `</${elem.name}>`;
}
/**
 * Render an element as inline HTML tag, walk through it's children.
 *
 * @type { FormatCallback }
 */ function formatInlineTag(elem, walk, builder, formatOptions) {
    builder.startNoWrap();
    builder.addLiteral(renderOpenTag(elem));
    builder.stopNoWrap();
    walk(elem.children, builder);
    builder.startNoWrap();
    builder.addLiteral(renderCloseTag(elem));
    builder.stopNoWrap();
}
/**
 * Render an element as HTML block bag, walk through it's children.
 *
 * @type { FormatCallback }
 */ function formatBlockTag(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    builder.startNoWrap();
    builder.addLiteral(renderOpenTag(elem));
    builder.stopNoWrap();
    walk(elem.children, builder);
    builder.startNoWrap();
    builder.addLiteral(renderCloseTag(elem));
    builder.stopNoWrap();
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Render an element with all it's children as inline HTML.
 *
 * @type { FormatCallback }
 */ function formatInlineHtml(elem, walk, builder, formatOptions) {
    builder.startNoWrap();
    builder.addLiteral(domSerializer.render(elem, {
        decodeEntities: builder.options.decodeEntities
    }));
    builder.stopNoWrap();
}
/**
 * Render an element with all it's children as HTML block.
 *
 * @type { FormatCallback }
 */ function formatBlockHtml(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    builder.startNoWrap();
    builder.addLiteral(domSerializer.render(elem, {
        decodeEntities: builder.options.decodeEntities
    }));
    builder.stopNoWrap();
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Render inline element wrapped with given strings.
 *
 * @type { FormatCallback }
 */ function formatInlineSurround(elem, walk, builder, formatOptions) {
    builder.addLiteral(formatOptions.prefix || "");
    walk(elem.children, builder);
    builder.addLiteral(formatOptions.suffix || "");
}
var genericFormatters = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    block: formatBlock$1,
    blockHtml: formatBlockHtml,
    blockString: formatBlockString,
    blockTag: formatBlockTag,
    inline: formatInline,
    inlineHtml: formatInlineHtml,
    inlineString: formatInlineString,
    inlineSurround: formatInlineSurround,
    inlineTag: formatInlineTag,
    skip: formatSkip
});
function getRow(matrix, j) {
    if (!matrix[j]) {
        matrix[j] = [];
    }
    return matrix[j];
}
function findFirstVacantIndex(row, x = 0) {
    while(row[x]){
        x++;
    }
    return x;
}
function transposeInPlace(matrix, maxSize) {
    for(let i = 0; i < maxSize; i++){
        const rowI = getRow(matrix, i);
        for(let j = 0; j < i; j++){
            const rowJ = getRow(matrix, j);
            const temp = rowI[j];
            rowI[j] = rowJ[i];
            rowJ[i] = temp;
        }
    }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
    for(let r = 0; r < cell.rowspan; r++){
        const layoutRow = getRow(layout, baseRow + r);
        for(let c = 0; c < cell.colspan; c++){
            layoutRow[baseCol + c] = cell;
        }
    }
}
function updateOffset(offsets, base, span, value) {
    offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);
}
/**
 * Render a table into a string.
 * Cells can contain multiline text and span across multiple rows and columns.
 *
 * Modifies cells to add lines array.
 *
 * @param { TablePrinterCell[][] } tableRows Table to render.
 * @param { number } rowSpacing Number of spaces between columns.
 * @param { number } colSpacing Number of empty lines between rows.
 * @returns { string }
 */ function tableToString(tableRows, rowSpacing, colSpacing) {
    const layout = [];
    let colNumber = 0;
    const rowNumber = tableRows.length;
    const rowOffsets = [
        0
    ];
    // Fill the layout table and row offsets row-by-row.
    for(let j = 0; j < rowNumber; j++){
        const layoutRow = getRow(layout, j);
        const cells = tableRows[j];
        let x = 0;
        for(let i = 0; i < cells.length; i++){
            const cell = cells[i];
            x = findFirstVacantIndex(layoutRow, x);
            putCellIntoLayout(cell, layout, j, x);
            x += cell.colspan;
            cell.lines = cell.text.split("\n");
            const cellHeight = cell.lines.length;
            updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
        }
        colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
    }
    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
    const outputLines = [];
    const colOffsets = [
        0
    ];
    // Fill column offsets and output lines column-by-column.
    for(let x = 0; x < colNumber; x++){
        let y = 0;
        let cell;
        while(y < rowNumber && (cell = layout[x][y])){
            if (!cell.rendered) {
                let cellWidth = 0;
                for(let j = 0; j < cell.lines.length; j++){
                    const line = cell.lines[j];
                    const lineOffset = rowOffsets[y] + j;
                    outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
                    cellWidth = line.length > cellWidth ? line.length : cellWidth;
                }
                updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
                cell.rendered = true;
            }
            y += cell.rowspan;
        }
    }
    return outputLines.join("\n");
}
/**
 * Process a line-break.
 *
 * @type { FormatCallback }
 */ function formatLineBreak(elem, walk, builder, formatOptions) {
    builder.addLineBreak();
}
/**
 * Process a `wbr` tag (word break opportunity).
 *
 * @type { FormatCallback }
 */ function formatWbr(elem, walk, builder, formatOptions) {
    builder.addWordBreakOpportunity();
}
/**
 * Process a horizontal line.
 *
 * @type { FormatCallback }
 */ function formatHorizontalLine(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process a paragraph.
 *
 * @type { FormatCallback }
 */ function formatParagraph(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process a preformatted content.
 *
 * @type { FormatCallback }
 */ function formatPre(elem, walk, builder, formatOptions) {
    builder.openBlock({
        isPre: true,
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process a heading.
 *
 * @type { FormatCallback }
 */ function formatHeading(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    if (formatOptions.uppercase !== false) {
        builder.pushWordTransform((str)=>str.toUpperCase());
        walk(elem.children, builder);
        builder.popWordTransform();
    } else {
        walk(elem.children, builder);
    }
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process a blockquote.
 *
 * @type { FormatCallback }
 */ function formatBlockquote(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
        reservedLineLength: 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
        blockTransform: (str)=>(formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line)=>"> " + line).join("\n")
    });
}
function withBrackets(str, brackets) {
    if (!brackets) {
        return str;
    }
    const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
    const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
    return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
    const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
    return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
/**
 * Process an image.
 *
 * @type { FormatCallback }
 */ function formatImage(elem, walk, builder, formatOptions) {
    const attribs = elem.attribs || {};
    const alt = attribs.alt ? attribs.alt : "";
    const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
    builder.addInline(text, {
        noWordTransform: true
    });
}
/**
 * Process an anchor.
 *
 * @type { FormatCallback }
 */ function formatAnchor(elem, walk, builder, formatOptions) {
    function getHref() {
        if (formatOptions.ignoreHref) {
            return "";
        }
        if (!elem.attribs || !elem.attribs.href) {
            return "";
        }
        let href = elem.attribs.href.replace(/^mailto:/, "");
        if (formatOptions.noAnchorUrl && href[0] === "#") {
            return "";
        }
        href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
        return href;
    }
    const href = getHref();
    if (!href) {
        walk(elem.children, builder);
    } else {
        let text = "";
        builder.pushWordTransform((str)=>{
            if (str) {
                text += str;
            }
            return str;
        });
        walk(elem.children, builder);
        builder.popWordTransform();
        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
        if (!hideSameLink) {
            builder.addInline(!text ? href : " " + withBrackets(href, formatOptions.linkBrackets), {
                noWordTransform: true
            });
        }
    }
}
/**
 * @param { DomNode }           elem               List items with their prefixes.
 * @param { RecursiveCallback } walk               Recursive callback to process child nodes.
 * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.
 * @param { FormatOptions }     formatOptions      Options specific to a formatter.
 * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.
 */ function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
    const isNestedList = get(elem, [
        "parent",
        "name"
    ]) === "li";
    // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,
    // so the dumb length comparison is the most robust way to get the correct value.
    let maxPrefixLength = 0;
    const listItems = (elem.children || [])// it might be more accurate to check only for html spaces here, but no significant benefit
    .filter((child)=>child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
        if (child.name !== "li") {
            return {
                node: child,
                prefix: ""
            };
        }
        const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
        if (prefix.length > maxPrefixLength) {
            maxPrefixLength = prefix.length;
        }
        return {
            node: child,
            prefix: prefix
        };
    });
    if (!listItems.length) {
        return;
    }
    builder.openList({
        interRowLineBreaks: 1,
        leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
        maxPrefixLength: maxPrefixLength,
        prefixAlign: "left"
    });
    for (const { node, prefix } of listItems){
        builder.openListItem({
            prefix: prefix
        });
        walk([
            node
        ], builder);
        builder.closeListItem();
    }
    builder.closeList({
        trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2
    });
}
/**
 * Process an unordered list.
 *
 * @type { FormatCallback }
 */ function formatUnorderedList(elem, walk, builder, formatOptions) {
    const prefix = formatOptions.itemPrefix || " * ";
    return formatList(elem, walk, builder, formatOptions, ()=>prefix);
}
/**
 * Process an ordered list.
 *
 * @type { FormatCallback }
 */ function formatOrderedList(elem, walk, builder, formatOptions) {
    let nextIndex = Number(elem.attribs.start || "1");
    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
    const nextPrefixCallback = ()=>" " + indexFunction(nextIndex++) + ". ";
    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
/**
 * Return a function that can be used to generate index markers of a specified format.
 *
 * @param   { string } [olType='1'] Marker type.
 * @returns { (i: number) => string }
 */ function getOrderedListIndexFunction(olType = "1") {
    switch(olType){
        case "a":
            return (i)=>numberToLetterSequence(i, "a");
        case "A":
            return (i)=>numberToLetterSequence(i, "A");
        case "i":
            return (i)=>numberToRoman(i).toLowerCase();
        case "I":
            return (i)=>numberToRoman(i);
        case "1":
        default:
            return (i)=>i.toString();
    }
}
/**
 * Given a list of class and ID selectors (prefixed with '.' and '#'),
 * return them as separate lists of names without prefixes.
 *
 * @param { string[] } selectors Class and ID selectors (`[".class", "#id"]` etc).
 * @returns { { classes: string[], ids: string[] } }
 */ function splitClassesAndIds(selectors) {
    const classes = [];
    const ids = [];
    for (const selector of selectors){
        if (selector.startsWith(".")) {
            classes.push(selector.substring(1));
        } else if (selector.startsWith("#")) {
            ids.push(selector.substring(1));
        }
    }
    return {
        classes: classes,
        ids: ids
    };
}
function isDataTable(attr, tables) {
    if (tables === true) {
        return true;
    }
    if (!attr) {
        return false;
    }
    const { classes, ids } = splitClassesAndIds(tables);
    const attrClasses = (attr["class"] || "").split(" ");
    const attrIds = (attr["id"] || "").split(" ");
    return attrClasses.some((x)=>classes.includes(x)) || attrIds.some((x)=>ids.includes(x));
}
/**
 * Process a table (either as a container or as a data table, depending on options).
 *
 * @type { FormatCallback }
 */ function formatTable(elem, walk, builder, formatOptions) {
    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
    builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks
    });
    walk(elem.children, builder);
    builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks
    });
}
/**
 * Process a data table.
 *
 * @type { FormatCallback }
 */ function formatDataTable(elem, walk, builder, formatOptions) {
    builder.openTable();
    elem.children.forEach(walkTable);
    builder.closeTable({
        tableToString: (rows)=>tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
        leadingLineBreaks: formatOptions.leadingLineBreaks,
        trailingLineBreaks: formatOptions.trailingLineBreaks
    });
    function formatCell(cellNode) {
        const colspan = +get(cellNode, [
            "attribs",
            "colspan"
        ]) || 1;
        const rowspan = +get(cellNode, [
            "attribs",
            "rowspan"
        ]) || 1;
        builder.openTableCell({
            maxColumnWidth: formatOptions.maxColumnWidth
        });
        walk(cellNode.children, builder);
        builder.closeTableCell({
            colspan: colspan,
            rowspan: rowspan
        });
    }
    function walkTable(elem) {
        if (elem.type !== "tag") {
            return;
        }
        const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode)=>{
            builder.pushWordTransform((str)=>str.toUpperCase());
            formatCell(cellNode);
            builder.popWordTransform();
        } : formatCell;
        switch(elem.name){
            case "thead":
            case "tbody":
            case "tfoot":
            case "center":
                elem.children.forEach(walkTable);
                return;
            case "tr":
                {
                    builder.openTableRow();
                    for (const childOfTr of elem.children){
                        if (childOfTr.type !== "tag") {
                            continue;
                        }
                        switch(childOfTr.name){
                            case "th":
                                {
                                    formatHeaderCell(childOfTr);
                                    break;
                                }
                            case "td":
                                {
                                    formatCell(childOfTr);
                                    break;
                                }
                        }
                    }
                    builder.closeTableRow();
                    break;
                }
        }
    }
}
var textFormatters = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    anchor: formatAnchor,
    blockquote: formatBlockquote,
    dataTable: formatDataTable,
    heading: formatHeading,
    horizontalLine: formatHorizontalLine,
    image: formatImage,
    lineBreak: formatLineBreak,
    orderedList: formatOrderedList,
    paragraph: formatParagraph,
    pre: formatPre,
    table: formatTable,
    unorderedList: formatUnorderedList,
    wbr: formatWbr
});
/**
 * Default options.
 *
 * @constant
 * @type { Options }
 * @default
 * @private
 */ const DEFAULT_OPTIONS = {
    baseElements: {
        selectors: [
            "body"
        ],
        orderBy: "selectors",
        returnDomByDefault: true
    },
    decodeEntities: true,
    encodeCharacters: {},
    formatters: {},
    limits: {
        ellipsis: "...",
        maxBaseElements: undefined,
        maxChildNodes: undefined,
        maxDepth: undefined,
        maxInputLength: 1 << 24 // 16_777_216
    },
    longWordSplit: {
        forceWrapOnLimit: false,
        wrapCharacters: []
    },
    preserveNewlines: false,
    selectors: [
        {
            selector: "*",
            format: "inline"
        },
        {
            selector: "a",
            format: "anchor",
            options: {
                baseUrl: null,
                hideLinkHrefIfSameAsText: false,
                ignoreHref: false,
                linkBrackets: [
                    "[",
                    "]"
                ],
                noAnchorUrl: true
            }
        },
        {
            selector: "article",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "aside",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "blockquote",
            format: "blockquote",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2,
                trimEmptyLines: true
            }
        },
        {
            selector: "br",
            format: "lineBreak"
        },
        {
            selector: "div",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "footer",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "form",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "h1",
            format: "heading",
            options: {
                leadingLineBreaks: 3,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "h2",
            format: "heading",
            options: {
                leadingLineBreaks: 3,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "h3",
            format: "heading",
            options: {
                leadingLineBreaks: 3,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "h4",
            format: "heading",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "h5",
            format: "heading",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "h6",
            format: "heading",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2,
                uppercase: true
            }
        },
        {
            selector: "header",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "hr",
            format: "horizontalLine",
            options: {
                leadingLineBreaks: 2,
                length: undefined,
                trailingLineBreaks: 2
            }
        },
        {
            selector: "img",
            format: "image",
            options: {
                baseUrl: null,
                linkBrackets: [
                    "[",
                    "]"
                ]
            }
        },
        {
            selector: "main",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "nav",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "ol",
            format: "orderedList",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2
            }
        },
        {
            selector: "p",
            format: "paragraph",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2
            }
        },
        {
            selector: "pre",
            format: "pre",
            options: {
                leadingLineBreaks: 2,
                trailingLineBreaks: 2
            }
        },
        {
            selector: "section",
            format: "block",
            options: {
                leadingLineBreaks: 1,
                trailingLineBreaks: 1
            }
        },
        {
            selector: "table",
            format: "table",
            options: {
                colSpacing: 3,
                leadingLineBreaks: 2,
                maxColumnWidth: 60,
                rowSpacing: 0,
                trailingLineBreaks: 2,
                uppercaseHeaderCells: true
            }
        },
        {
            selector: "ul",
            format: "unorderedList",
            options: {
                itemPrefix: " * ",
                leadingLineBreaks: 2,
                trailingLineBreaks: 2
            }
        },
        {
            selector: "wbr",
            format: "wbr"
        }
    ],
    tables: [],
    whitespaceCharacters: " 	\r\n\f​",
    wordwrap: 80
};
const concatMerge = (acc, src, options)=>[
        ...acc,
        ...src
    ];
const overwriteMerge = (acc, src, options)=>[
        ...src
    ];
const selectorsMerge = (acc, src, options)=>acc.some((s)=>typeof s === "object") ? concatMerge(acc, src) // selectors
     : overwriteMerge(acc, src) // baseElements.selectors
;
/**
 * Preprocess options, compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options.
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */ function compile(options = {}) {
    options = merge__default["default"](DEFAULT_OPTIONS, options, {
        arrayMerge: overwriteMerge,
        customMerge: (key)=>key === "selectors" ? selectorsMerge : undefined
    });
    options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);
    handleDeprecatedOptions(options);
    return compile$1(options);
}
/**
 * Convert given HTML content to plain text string.
 *
 * @param   { string }  html           HTML content to convert.
 * @param   { Options } [options = {}] HtmlToText options.
 * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.
 * @returns { string }                 Plain text string.
 * @static
 *
 * @example
 * const { convert } = require('html-to-text');
 * const text = convert('<h1>Hello World</h1>', {
 *   wordwrap: 130
 * });
 * console.log(text); // HELLO WORLD
 */ function convert(html, options = {}, metadata = undefined) {
    return compile(options)(html, metadata);
}
/**
 * Map previously existing and now deprecated options to the new options layout.
 * This is a subject for cleanup in major releases.
 *
 * @param { Options } options HtmlToText options.
 */ function handleDeprecatedOptions(options) {
    if (options.tags) {
        const tagDefinitions = Object.entries(options.tags).map(([selector, definition])=>({
                ...definition,
                selector: selector || "*"
            }));
        options.selectors.push(...tagDefinitions);
        options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);
    }
    function set(obj, path, value) {
        const valueKey = path.pop();
        for (const key of path){
            let nested = obj[key];
            if (!nested) {
                nested = {};
                obj[key] = nested;
            }
            obj = nested;
        }
        obj[valueKey] = value;
    }
    if (options["baseElement"]) {
        const baseElement = options["baseElement"];
        set(options, [
            "baseElements",
            "selectors"
        ], Array.isArray(baseElement) ? baseElement : [
            baseElement
        ]);
    }
    if (options["returnDomByDefault"] !== undefined) {
        set(options, [
            "baseElements",
            "returnDomByDefault"
        ], options["returnDomByDefault"]);
    }
    for (const definition of options.selectors){
        if (definition.format === "anchor" && get(definition, [
            "options",
            "noLinkBrackets"
        ])) {
            set(definition, [
                "options",
                "linkBrackets"
            ], false);
        }
    }
}
exports.compile = compile;
exports.convert = convert;
exports.htmlToText = convert;


/***/ }),

/***/ 78654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: !0
}));
const e = /\n/g;
function t(t) {
    const o = [
        ...t.matchAll(e)
    ].map((e)=>e.index || 0);
    o.unshift(-1);
    const s = n(o, 0, o.length);
    return (e)=>r(s, e);
}
function n(e, t, r) {
    if (r - t == 1) return {
        offset: e[t],
        index: t + 1
    };
    const o = Math.ceil((t + r) / 2), s = n(e, t, o), l = n(e, o, r);
    return {
        offset: s.offset,
        low: s,
        high: l
    };
}
function r(e, t) {
    return function(e) {
        return Object.prototype.hasOwnProperty.call(e, "index");
    }(e) ? {
        line: e.index,
        column: t - e.offset
    } : r(e.high.offset < t ? e.high : e.low, t);
}
function o(e, t) {
    return {
        ...e,
        regex: s(e, t)
    };
}
function s(e, t) {
    if (0 === e.name.length) throw new Error(`Rule #${t} has empty name, which is not allowed.`);
    if (function(e) {
        return Object.prototype.hasOwnProperty.call(e, "regex");
    }(e)) return function(e) {
        if (e.global) throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);
        return e.sticky ? e : new RegExp(e.source, e.flags + "y");
    }(e.regex);
    if (function(e) {
        return Object.prototype.hasOwnProperty.call(e, "str");
    }(e)) {
        if (0 === e.str.length) throw new Error(`Rule #${t} ("${e.name}") has empty "str" property, which is not allowed.`);
        return new RegExp(l(e.str), "y");
    }
    return new RegExp(l(e.name), "y");
}
function l(e) {
    return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
exports.createLexer = function(e, n = "", r = {}) {
    const s = "string" != typeof n ? n : r, l = "string" == typeof n ? n : "", c = e.map(o), i = !!s.lineNumbers;
    return function(e, n = 0) {
        const r = i ? t(e) : ()=>({
                line: 0,
                column: 0
            });
        let o = n;
        const s = [];
        e: for(; o < e.length;){
            let t = !1;
            for (const n of c){
                n.regex.lastIndex = o;
                const c = n.regex.exec(e);
                if (c && c[0].length > 0) {
                    if (!n.discard) {
                        const e = r(o), t = "string" == typeof n.replace ? c[0].replace(new RegExp(n.regex.source, n.regex.flags), n.replace) : c[0];
                        s.push({
                            state: l,
                            name: n.name,
                            text: t,
                            offset: o,
                            len: c[0].length,
                            line: e.line,
                            column: e.column
                        });
                    }
                    if (o = n.regex.lastIndex, t = !0, n.push) {
                        const t = n.push(e, o);
                        s.push(...t.tokens), o = t.offset;
                    }
                    if (n.pop) break e;
                    break;
                }
            }
            if (!t) break;
        }
        return {
            tokens: s,
            offset: o,
            complete: e.length <= o
        };
    };
};


/***/ }),

/***/ 40895:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var leac = __webpack_require__(78654);
var p = __webpack_require__(15100);
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== "default") {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}
var p__namespace = /*#__PURE__*/ _interopNamespace(p);
var ast = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
const lex = leac.createLexer([
    {
        name: "ws",
        regex: /[ \t\r\n\f]+/
    },
    {
        name: "idn",
        regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/
    },
    {
        name: "#id",
        regex: /#[a-zA-Z0-9_-]+/
    },
    {
        name: "str1",
        regex: /'(?:\\['\\]|[^\n'\\])*'/
    },
    {
        name: "str2",
        regex: /"(?:\\["\\]|[^\n"\\])*"/
    },
    {
        name: "*"
    },
    {
        name: "."
    },
    {
        name: ","
    },
    {
        name: "["
    },
    {
        name: "]"
    },
    {
        name: "="
    },
    {
        name: ">"
    },
    {
        name: "|"
    },
    {
        name: "+"
    },
    {
        name: "~"
    },
    {
        name: "^"
    },
    {
        name: "$"
    }
]);
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
    return [
        a0 + b0,
        a1 + b1,
        a2 + b2
    ];
}
function sumAllSpec(ss) {
    return ss.reduce(sumSpec, [
        0,
        0,
        0
    ]);
}
function literal(name) {
    return p__namespace.token((t)=>t.name === name ? true : undefined);
}
const whitespace_ = p__namespace.token((t)=>t.name === "ws" ? null : undefined);
const optionalWhitespace_ = p__namespace.option(whitespace_, null);
function optionallySpaced(parser) {
    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);
}
const identifier_ = p__namespace.token((t)=>t.name === "idn" ? t.text : undefined);
const hashId_ = p__namespace.token((t)=>t.name === "#id" ? t.text.slice(1) : undefined);
const string_ = p__namespace.token((t)=>t.name.startsWith("str") ? t.text.slice(1, -1) : undefined);
const namespace_ = p__namespace.left(p__namespace.option(identifier_, ""), literal("|"));
const qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name)=>({
        name: name,
        namespace: ns
    })), p__namespace.map(identifier_, (name)=>({
        name: name,
        namespace: null
    })));
const uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal("*"), (ns)=>({
        type: "universal",
        namespace: ns,
        specificity: [
            0,
            0,
            0
        ]
    })), p__namespace.map(literal("*"), ()=>({
        type: "universal",
        namespace: null,
        specificity: [
            0,
            0,
            0
        ]
    })));
const tagSelector_ = p__namespace.map(qualifiedName_, ({ name, namespace })=>({
        type: "tag",
        name: name,
        namespace: namespace,
        specificity: [
            0,
            0,
            1
        ]
    }));
const classSelector_ = p__namespace.ab(literal("."), identifier_, (fullstop, name)=>({
        type: "class",
        name: name,
        specificity: [
            0,
            1,
            0
        ]
    }));
const idSelector_ = p__namespace.map(hashId_, (name)=>({
        type: "id",
        name: name,
        specificity: [
            1,
            0,
            0
        ]
    }));
const attrModifier_ = p__namespace.token((t)=>{
    if (t.name === "idn") {
        if (t.text === "i" || t.text === "I") {
            return "i";
        }
        if (t.text === "s" || t.text === "S") {
            return "s";
        }
    }
    return undefined;
});
const attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod)=>({
        value: v,
        modifier: mod
    })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod)=>({
        value: v,
        modifier: mod
    })));
const attrMatcher_ = p__namespace.choice(p__namespace.map(literal("="), ()=>"="), p__namespace.ab(literal("~"), literal("="), ()=>"~="), p__namespace.ab(literal("|"), literal("="), ()=>"|="), p__namespace.ab(literal("^"), literal("="), ()=>"^="), p__namespace.ab(literal("$"), literal("="), ()=>"$="), p__namespace.ab(literal("*"), literal("="), ()=>"*="));
const attrPresenceSelector_ = p__namespace.abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name, namespace })=>({
        type: "attrPresence",
        name: name,
        namespace: namespace,
        specificity: [
            0,
            1,
            0
        ]
    }));
const attrValueSelector_ = p__namespace.middle(literal("["), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier })=>({
        type: "attrValue",
        name: name,
        namespace: namespace,
        matcher: matcher,
        value: value,
        modifier: modifier,
        specificity: [
            0,
            1,
            0
        ]
    })), literal("]"));
const attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);
const typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);
const subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);
const compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss)=>{
    return {
        type: "compound",
        list: ss,
        specificity: sumAllSpec(ss.map((s)=>s.specificity))
    };
});
const combinator_ = p__namespace.choice(p__namespace.map(literal(">"), ()=>">"), p__namespace.map(literal("+"), ()=>"+"), p__namespace.map(literal("~"), ()=>"~"), p__namespace.ab(literal("|"), literal("|"), ()=>"||"));
const combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, ()=>" "));
const complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c)=>(left, right)=>({
            type: "compound",
            list: [
                ...right.list,
                {
                    type: "combinator",
                    combinator: c,
                    left: left,
                    specificity: left.specificity
                }
            ],
            specificity: sumSpec(left.specificity, right.specificity)
        })), compoundSelector_);
const listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s)=>({
        type: "list",
        list: [
            s
        ]
    })), p__namespace.map(optionallySpaced(literal(",")), ()=>(acc, next)=>({
            type: "list",
            list: [
                ...acc.list,
                next
            ]
        })), complexSelector_);
function parse_(parser, str) {
    const lexerResult = lex(str);
    if (!lexerResult.complete) {
        throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` + prettyPrintPosition(str, lexerResult.offset));
    }
    const result = optionallySpaced(parser)({
        tokens: lexerResult.tokens,
        options: undefined
    }, 0);
    if (!result.matched) {
        throw new Error(`No match for "${str}" input!`);
    }
    if (result.position < lexerResult.tokens.length) {
        const token = lexerResult.tokens[result.position];
        throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!\n` + prettyPrintPosition(str, token.offset, token.len));
    }
    return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
    return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r)=>t ? "␉" : r ? "␍" : "␊")}\n${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse(str) {
    return parse_(listSelector_, str);
}
function parse1(str) {
    return parse_(complexSelector_, str);
}
function serialize(selector) {
    if (!selector.type) {
        throw new Error("This is not an AST node.");
    }
    switch(selector.type){
        case "universal":
            return _serNs(selector.namespace) + "*";
        case "tag":
            return _serNs(selector.namespace) + selector.name;
        case "class":
            return "." + selector.name;
        case "id":
            return "#" + selector.name;
        case "attrPresence":
            return `[${_serNs(selector.namespace)}${selector.name}]`;
        case "attrValue":
            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : ""}]`;
        case "combinator":
            return serialize(selector.left) + selector.combinator;
        case "compound":
            return selector.list.reduce((acc, node)=>{
                if (node.type === "combinator") {
                    return serialize(node) + acc;
                } else {
                    return acc + serialize(node);
                }
            }, "");
        case "list":
            return selector.list.map(serialize).join(",");
    }
}
function _serNs(ns) {
    return ns || ns === "" ? ns + "|" : "";
}
function _serStr(str) {
    if (str.indexOf('"') === -1) {
        return `"${str}"`;
    } else if (str.indexOf("'") === -1) {
        return `'${str}'`;
    } else {
        return `"${str.replace('"', '\\"')}"`;
    }
}
function normalize(selector) {
    if (!selector.type) {
        throw new Error("This is not an AST node.");
    }
    switch(selector.type){
        case "compound":
            {
                selector.list.forEach(normalize);
                selector.list.sort((a, b)=>_compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
                break;
            }
        case "combinator":
            {
                normalize(selector.left);
                break;
            }
        case "list":
            {
                selector.list.forEach(normalize);
                selector.list.sort((a, b)=>serialize(a) < serialize(b) ? -1 : 1);
                break;
            }
    }
    return selector;
}
function _getSelectorPriority(selector) {
    switch(selector.type){
        case "universal":
            return [
                1
            ];
        case "tag":
            return [
                1
            ];
        case "id":
            return [
                2
            ];
        case "class":
            return [
                3,
                selector.name
            ];
        case "attrPresence":
            return [
                4,
                serialize(selector)
            ];
        case "attrValue":
            return [
                5,
                serialize(selector)
            ];
        case "combinator":
            return [
                15,
                serialize(selector)
            ];
    }
}
function compareSelectors(a, b) {
    return _compareArrays(a.specificity, b.specificity);
}
function compareSpecificity(a, b) {
    return _compareArrays(a, b);
}
function _compareArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
        throw new Error("Arguments must be arrays.");
    }
    const shorter = a.length < b.length ? a.length : b.length;
    for(let i = 0; i < shorter; i++){
        if (a[i] === b[i]) {
            continue;
        }
        return a[i] < b[i] ? -1 : 1;
    }
    return a.length - b.length;
}
exports.Ast = ast;
exports.compareSelectors = compareSelectors;
exports.compareSpecificity = compareSpecificity;
exports.normalize = normalize;
exports.parse = parse;
exports.parse1 = parse1;
exports.serialize = serialize;


/***/ }),

/***/ 15100:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util = __webpack_require__(96912);
function emit(value) {
    return (data, i)=>({
            matched: true,
            position: i,
            value: value
        });
}
function make(f) {
    return (data, i)=>({
            matched: true,
            position: i,
            value: f(data, i)
        });
}
function action(f) {
    return (data, i)=>{
        f(data, i);
        return {
            matched: true,
            position: i,
            value: null
        };
    };
}
function fail(data, i) {
    return {
        matched: false
    };
}
function error(message) {
    return (data, i)=>{
        throw new Error(message instanceof Function ? message(data, i) : message);
    };
}
function token(onToken, onEnd) {
    return (data, i)=>{
        let position = i;
        let value = undefined;
        if (i < data.tokens.length) {
            value = onToken(data.tokens[i], data, i);
            if (value !== undefined) {
                position++;
            }
        } else {
            onEnd?.(data, i);
        }
        return value === undefined ? {
            matched: false
        } : {
            matched: true,
            position: position,
            value: value
        };
    };
}
function any(data, i) {
    return i < data.tokens.length ? {
        matched: true,
        position: i + 1,
        value: data.tokens[i]
    } : {
        matched: false
    };
}
function satisfy(test) {
    return (data, i)=>i < data.tokens.length && test(data.tokens[i], data, i) ? {
            matched: true,
            position: i + 1,
            value: data.tokens[i]
        } : {
            matched: false
        };
}
function mapInner(r, f) {
    return r.matched ? {
        matched: true,
        position: r.position,
        value: f(r.value, r.position)
    } : r;
}
function mapOuter(r, f) {
    return r.matched ? f(r) : r;
}
function map(p, mapper) {
    return (data, i)=>mapInner(p(data, i), (v, j)=>mapper(v, data, i, j));
}
function map1(p, mapper) {
    return (data, i)=>mapOuter(p(data, i), (m)=>mapper(m, data, i));
}
function peek(p, f) {
    return (data, i)=>{
        const r = p(data, i);
        f(r, data, i);
        return r;
    };
}
function option(p, def) {
    return (data, i)=>{
        const r = p(data, i);
        return r.matched ? r : {
            matched: true,
            position: i,
            value: def
        };
    };
}
function not(p) {
    return (data, i)=>{
        const r = p(data, i);
        return r.matched ? {
            matched: false
        } : {
            matched: true,
            position: i,
            value: true
        };
    };
}
function choice(...ps) {
    return (data, i)=>{
        for (const p of ps){
            const result = p(data, i);
            if (result.matched) {
                return result;
            }
        }
        return {
            matched: false
        };
    };
}
function otherwise(pa, pb) {
    return (data, i)=>{
        const r1 = pa(data, i);
        return r1.matched ? r1 : pb(data, i);
    };
}
function longest(...ps) {
    return (data, i)=>{
        let match = undefined;
        for (const p of ps){
            const result = p(data, i);
            if (result.matched && (!match || match.position < result.position)) {
                match = result;
            }
        }
        return match || {
            matched: false
        };
    };
}
function takeWhile(p, test) {
    return (data, i)=>{
        const values = [];
        let success = true;
        do {
            const r = p(data, i);
            if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {
                values.push(r.value);
                i = r.position;
            } else {
                success = false;
            }
        }while (success);
        return {
            matched: true,
            position: i,
            value: values
        };
    };
}
function takeUntil(p, test) {
    return takeWhile(p, (value, n, data, i, j)=>!test(value, n, data, i, j));
}
function takeWhileP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i)=>pTest(data, i).matched);
}
function takeUntilP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i)=>!pTest(data, i).matched);
}
function many(p) {
    return takeWhile(p, ()=>true);
}
function many1(p) {
    return ab(p, many(p), (head, tail)=>[
            head,
            ...tail
        ]);
}
function ab(pa, pb, join) {
    return (data, i)=>mapOuter(pa(data, i), (ma)=>mapInner(pb(data, ma.position), (vb, j)=>join(ma.value, vb, data, i, j)));
}
function left(pa, pb) {
    return ab(pa, pb, (va)=>va);
}
function right(pa, pb) {
    return ab(pa, pb, (va, vb)=>vb);
}
function abc(pa, pb, pc, join) {
    return (data, i)=>mapOuter(pa(data, i), (ma)=>mapOuter(pb(data, ma.position), (mb)=>mapInner(pc(data, mb.position), (vc, j)=>join(ma.value, mb.value, vc, data, i, j))));
}
function middle(pa, pb, pc) {
    return abc(pa, pb, pc, (ra, rb)=>rb);
}
function all(...ps) {
    return (data, i)=>{
        const result = [];
        let position = i;
        for (const p of ps){
            const r1 = p(data, position);
            if (r1.matched) {
                result.push(r1.value);
                position = r1.position;
            } else {
                return {
                    matched: false
                };
            }
        }
        return {
            matched: true,
            position: position,
            value: result
        };
    };
}
function skip(...ps) {
    return map(all(...ps), ()=>null);
}
function flatten(...ps) {
    return flatten1(all(...ps));
}
function flatten1(p) {
    return map(p, (vs)=>vs.flatMap((v)=>v));
}
function sepBy1(pValue, pSep) {
    return ab(pValue, many(right(pSep, pValue)), (head, tail)=>[
            head,
            ...tail
        ]);
}
function sepBy(pValue, pSep) {
    return otherwise(sepBy1(pValue, pSep), emit([]));
}
function chainReduce(acc, f) {
    return (data, i)=>{
        let loop = true;
        let acc1 = acc;
        let pos = i;
        do {
            const r = f(acc1, data, pos)(data, pos);
            if (r.matched) {
                acc1 = r.value;
                pos = r.position;
            } else {
                loop = false;
            }
        }while (loop);
        return {
            matched: true,
            position: pos,
            value: acc1
        };
    };
}
function reduceLeft(acc, p, reducer) {
    return chainReduce(acc, (acc)=>map(p, (v, data, i, j)=>reducer(acc, v, data, i, j)));
}
function reduceRight(p, acc, reducer) {
    return map(many(p), (vs, data, i, j)=>vs.reduceRight((acc, v)=>reducer(v, acc, data, i, j), acc));
}
function leftAssoc1(pLeft, pOper) {
    return chain(pLeft, (v0)=>reduceLeft(v0, pOper, (acc, f)=>f(acc)));
}
function rightAssoc1(pOper, pRight) {
    return ab(reduceRight(pOper, (y)=>y, (f, acc)=>(y)=>f(acc(y))), pRight, (f, v)=>f(v));
}
function leftAssoc2(pLeft, pOper, pRight) {
    return chain(pLeft, (v0)=>reduceLeft(v0, ab(pOper, pRight, (f, y)=>[
                f,
                y
            ]), (acc, [f, y])=>f(acc, y)));
}
function rightAssoc2(pLeft, pOper, pRight) {
    return ab(reduceRight(ab(pLeft, pOper, (x, f)=>[
            x,
            f
        ]), (y)=>y, ([x, f], acc)=>(y)=>f(x, acc(y))), pRight, (f, v)=>f(v));
}
function condition(cond, pTrue, pFalse) {
    return (data, i)=>cond(data, i) ? pTrue(data, i) : pFalse(data, i);
}
function decide(p) {
    return (data, i)=>mapOuter(p(data, i), (m1)=>m1.value(data, m1.position));
}
function chain(p, f) {
    return (data, i)=>mapOuter(p(data, i), (m1)=>f(m1.value, data, i, m1.position)(data, m1.position));
}
function ahead(p) {
    return (data, i)=>mapOuter(p(data, i), (m1)=>({
                matched: true,
                position: i,
                value: m1.value
            }));
}
function recursive(f) {
    return function(data, i) {
        return f()(data, i);
    };
}
function start(data, i) {
    return i !== 0 ? {
        matched: false
    } : {
        matched: true,
        position: i,
        value: true
    };
}
function end(data, i) {
    return i < data.tokens.length ? {
        matched: false
    } : {
        matched: true,
        position: i,
        value: true
    };
}
function remainingTokensNumber(data, i) {
    return data.tokens.length - i;
}
function parserPosition(data, i, formatToken, contextTokens = 3) {
    const len = data.tokens.length;
    const lowIndex = util.clamp(0, i - contextTokens, len - contextTokens);
    const highIndex = util.clamp(contextTokens, i + 1 + contextTokens, len);
    const tokensSlice = data.tokens.slice(lowIndex, highIndex);
    const lines = [];
    const indexWidth = String(highIndex - 1).length + 1;
    if (i < 0) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    if (0 < lowIndex) {
        lines.push("...".padStart(indexWidth + 6));
    }
    for(let j = 0; j < tokensSlice.length; j++){
        const index = lowIndex + j;
        lines.push(`${String(index).padStart(indexWidth)} ${index === i ? ">" : " "} ${util.escapeWhitespace(formatToken(tokensSlice[j]))}`);
    }
    if (highIndex < len) {
        lines.push("...".padStart(indexWidth + 6));
    }
    if (len <= i) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    return lines.join("\n");
}
function parse(parser, tokens, options, formatToken = JSON.stringify) {
    const data = {
        tokens: tokens,
        options: options
    };
    const result = parser(data, 0);
    if (!result.matched) {
        throw new Error("No match");
    }
    if (result.position < data.tokens.length) {
        throw new Error(`Partial match. Parsing stopped at:\n${parserPosition(data, result.position, formatToken)}`);
    }
    return result.value;
}
function tryParse(parser, tokens, options) {
    const result = parser({
        tokens: tokens,
        options: options
    }, 0);
    return result.matched ? result.value : undefined;
}
function match(matcher, tokens, options) {
    const result = matcher({
        tokens: tokens,
        options: options
    }, 0);
    return result.value;
}
exports.ab = ab;
exports.abc = abc;
exports.action = action;
exports.ahead = ahead;
exports.all = all;
exports.and = all;
exports.any = any;
exports.chain = chain;
exports.chainReduce = chainReduce;
exports.choice = choice;
exports.condition = condition;
exports.decide = decide;
exports.discard = skip;
exports.eitherOr = otherwise;
exports.emit = emit;
exports.end = end;
exports.eof = end;
exports.error = error;
exports.fail = fail;
exports.flatten = flatten;
exports.flatten1 = flatten1;
exports.left = left;
exports.leftAssoc1 = leftAssoc1;
exports.leftAssoc2 = leftAssoc2;
exports.longest = longest;
exports.lookAhead = ahead;
exports.make = make;
exports.many = many;
exports.many1 = many1;
exports.map = map;
exports.map1 = map1;
exports.match = match;
exports.middle = middle;
exports.not = not;
exports.of = emit;
exports.option = option;
exports.or = choice;
exports.otherwise = otherwise;
exports.parse = parse;
exports.parserPosition = parserPosition;
exports.peek = peek;
exports.recursive = recursive;
exports.reduceLeft = reduceLeft;
exports.reduceRight = reduceRight;
exports.remainingTokensNumber = remainingTokensNumber;
exports.right = right;
exports.rightAssoc1 = rightAssoc1;
exports.rightAssoc2 = rightAssoc2;
exports.satisfy = satisfy;
exports.sepBy = sepBy;
exports.sepBy1 = sepBy1;
exports.skip = skip;
exports.some = many1;
exports.start = start;
exports.takeUntil = takeUntil;
exports.takeUntilP = takeUntilP;
exports.takeWhile = takeWhile;
exports.takeWhileP = takeWhileP;
exports.token = token;
exports.tryParse = tryParse;


/***/ }),

/***/ 96912:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function clamp(left, x, right) {
    return Math.max(left, Math.min(x, right));
}
function escapeWhitespace(str) {
    return str.replace(/(\t)|(\r)|(\n)/g, (m, t, r)=>t ? "\\t" : r ? "\\r" : "\\n");
}
exports.clamp = clamp;
exports.escapeWhitespace = escapeWhitespace;


/***/ }),

/***/ 76305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var parseley = __webpack_require__(40895);
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== "default") {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}
var parseley__namespace = /*#__PURE__*/ _interopNamespace(parseley);
var Ast = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
var Types = /*#__PURE__*/ Object.freeze({
    __proto__: null
});
const treeify = (nodes)=>"▽\n" + treeifyArray(nodes, thinLines);
const thinLines = [
    [
        "├─",
        "│ "
    ],
    [
        "└─",
        "  "
    ]
];
const heavyLines = [
    [
        "┠─",
        "┃ "
    ],
    [
        "┖─",
        "  "
    ]
];
const doubleLines = [
    [
        "╟─",
        "║ "
    ],
    [
        "╙─",
        "  "
    ]
];
function treeifyArray(nodes, tpl = heavyLines) {
    return prefixItems(tpl, nodes.map((n)=>treeifyNode(n)));
}
function treeifyNode(node) {
    switch(node.type){
        case "terminal":
            {
                const vctr = node.valueContainer;
                return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
            }
        case "tagName":
            return `◻ Tag name\n${treeifyArray(node.variants, doubleLines)}`;
        case "attrValue":
            return `▣ Attr value: ${node.name}\n${treeifyArray(node.matchers, doubleLines)}`;
        case "attrPresence":
            return `◨ Attr presence: ${node.name}\n${treeifyArray(node.cont)}`;
        case "pushElement":
            return `◉ Push element: ${node.combinator}\n${treeifyArray(node.cont, thinLines)}`;
        case "popElement":
            return `◌ Pop element\n${treeifyArray(node.cont, thinLines)}`;
        case "variant":
            return `◇ = ${node.value}\n${treeifyArray(node.cont)}`;
        case "matcher":
            return `◈ ${node.matcher} "${node.value}"${node.modifier || ""}\n${treeifyArray(node.cont)}`;
    }
}
function prefixItems(tpl, items) {
    return items.map((item, i, { length })=>prefixItem(tpl, item, i === length - 1)).join("\n");
}
function prefixItem(tpl, item, tail = true) {
    const tpl1 = tpl[tail ? 1 : 0];
    return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
}
var TreeifyBuilder = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    treeify: treeify
});
class DecisionTree {
    constructor(input){
        this.branches = weave(toAstTerminalPairs(input));
    }
    build(builder) {
        return builder(this.branches);
    }
}
function toAstTerminalPairs(array) {
    const len = array.length;
    const results = new Array(len);
    for(let i = 0; i < len; i++){
        const [selectorString, val] = array[i];
        const ast = preprocess(parseley__namespace.parse1(selectorString));
        results[i] = {
            ast: ast,
            terminal: {
                type: "terminal",
                valueContainer: {
                    index: i,
                    value: val,
                    specificity: ast.specificity
                }
            }
        };
    }
    return results;
}
function preprocess(ast) {
    reduceSelectorVariants(ast);
    parseley__namespace.normalize(ast);
    return ast;
}
function reduceSelectorVariants(ast) {
    const newList = [];
    ast.list.forEach((sel)=>{
        switch(sel.type){
            case "class":
                newList.push({
                    matcher: "~=",
                    modifier: null,
                    name: "class",
                    namespace: null,
                    specificity: sel.specificity,
                    type: "attrValue",
                    value: sel.name
                });
                break;
            case "id":
                newList.push({
                    matcher: "=",
                    modifier: null,
                    name: "id",
                    namespace: null,
                    specificity: sel.specificity,
                    type: "attrValue",
                    value: sel.name
                });
                break;
            case "combinator":
                reduceSelectorVariants(sel.left);
                newList.push(sel);
                break;
            case "universal":
                break;
            default:
                newList.push(sel);
                break;
        }
    });
    ast.list = newList;
}
function weave(items) {
    const branches = [];
    while(items.length){
        const topKind = findTopKey(items, (sel)=>true, getSelectorKind);
        const { matches, nonmatches, empty } = breakByKind(items, topKind);
        items = nonmatches;
        if (matches.length) {
            branches.push(branchOfKind(topKind, matches));
        }
        if (empty.length) {
            branches.push(...terminate(empty));
        }
    }
    return branches;
}
function terminate(items) {
    const results = [];
    for (const item of items){
        const terminal = item.terminal;
        if (terminal.type === "terminal") {
            results.push(terminal);
        } else {
            const { matches, rest } = partition(terminal.cont, (node)=>node.type === "terminal");
            matches.forEach((node)=>results.push(node));
            if (rest.length) {
                terminal.cont = rest;
                results.push(terminal);
            }
        }
    }
    return results;
}
function breakByKind(items, selectedKind) {
    const matches = [];
    const nonmatches = [];
    const empty = [];
    for (const item of items){
        const simpsels = item.ast.list;
        if (simpsels.length) {
            const isMatch = simpsels.some((node)=>getSelectorKind(node) === selectedKind);
            (isMatch ? matches : nonmatches).push(item);
        } else {
            empty.push(item);
        }
    }
    return {
        matches,
        nonmatches,
        empty
    };
}
function getSelectorKind(sel) {
    switch(sel.type){
        case "attrPresence":
            return `attrPresence ${sel.name}`;
        case "attrValue":
            return `attrValue ${sel.name}`;
        case "combinator":
            return `combinator ${sel.combinator}`;
        default:
            return sel.type;
    }
}
function branchOfKind(kind, items) {
    if (kind === "tag") {
        return tagNameBranch(items);
    }
    if (kind.startsWith("attrValue ")) {
        return attrValueBranch(kind.substring(10), items);
    }
    if (kind.startsWith("attrPresence ")) {
        return attrPresenceBranch(kind.substring(13), items);
    }
    if (kind === "combinator >") {
        return combinatorBranch(">", items);
    }
    if (kind === "combinator +") {
        return combinatorBranch("+", items);
    }
    throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
    const groups = spliceAndGroup(items, (x)=>x.type === "tag", (x)=>x.name);
    const variants = Object.entries(groups).map(([name, group])=>({
            type: "variant",
            value: name,
            cont: weave(group.items)
        }));
    return {
        type: "tagName",
        variants: variants
    };
}
function attrPresenceBranch(name, items) {
    for (const item of items){
        spliceSimpleSelector(item, (x)=>x.type === "attrPresence" && x.name === name);
    }
    return {
        type: "attrPresence",
        name: name,
        cont: weave(items)
    };
}
function attrValueBranch(name, items) {
    const groups = spliceAndGroup(items, (x)=>x.type === "attrValue" && x.name === name, (x)=>`${x.matcher} ${x.modifier || ""} ${x.value}`);
    const matchers = [];
    for (const group of Object.values(groups)){
        const sel = group.oneSimpleSelector;
        const predicate = getAttrPredicate(sel);
        const continuation = weave(group.items);
        matchers.push({
            type: "matcher",
            matcher: sel.matcher,
            modifier: sel.modifier,
            value: sel.value,
            predicate: predicate,
            cont: continuation
        });
    }
    return {
        type: "attrValue",
        name: name,
        matchers: matchers
    };
}
function getAttrPredicate(sel) {
    if (sel.modifier === "i") {
        const expected = sel.value.toLowerCase();
        switch(sel.matcher){
            case "=":
                return (actual)=>expected === actual.toLowerCase();
            case "~=":
                return (actual)=>actual.toLowerCase().split(/[ \t]+/).includes(expected);
            case "^=":
                return (actual)=>actual.toLowerCase().startsWith(expected);
            case "$=":
                return (actual)=>actual.toLowerCase().endsWith(expected);
            case "*=":
                return (actual)=>actual.toLowerCase().includes(expected);
            case "|=":
                return (actual)=>{
                    const lower = actual.toLowerCase();
                    return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
                };
        }
    } else {
        const expected = sel.value;
        switch(sel.matcher){
            case "=":
                return (actual)=>expected === actual;
            case "~=":
                return (actual)=>actual.split(/[ \t]+/).includes(expected);
            case "^=":
                return (actual)=>actual.startsWith(expected);
            case "$=":
                return (actual)=>actual.endsWith(expected);
            case "*=":
                return (actual)=>actual.includes(expected);
            case "|=":
                return (actual)=>expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
        }
    }
}
function combinatorBranch(combinator, items) {
    const groups = spliceAndGroup(items, (x)=>x.type === "combinator" && x.combinator === combinator, (x)=>parseley__namespace.serialize(x.left));
    const leftItems = [];
    for (const group of Object.values(groups)){
        const rightCont = weave(group.items);
        const leftAst = group.oneSimpleSelector.left;
        leftItems.push({
            ast: leftAst,
            terminal: {
                type: "popElement",
                cont: rightCont
            }
        });
    }
    return {
        type: "pushElement",
        combinator: combinator,
        cont: weave(leftItems)
    };
}
function spliceAndGroup(items, predicate, keyCallback) {
    const groups = {};
    while(items.length){
        const bestKey = findTopKey(items, predicate, keyCallback);
        const bestKeyPredicate = (sel)=>predicate(sel) && keyCallback(sel) === bestKey;
        const hasBestKeyPredicate = (item)=>item.ast.list.some(bestKeyPredicate);
        const { matches, rest } = partition1(items, hasBestKeyPredicate);
        let oneSimpleSelector = null;
        for (const item of matches){
            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
            if (!oneSimpleSelector) {
                oneSimpleSelector = splicedNode;
            }
        }
        if (oneSimpleSelector == null) {
            throw new Error("No simple selector is found.");
        }
        groups[bestKey] = {
            oneSimpleSelector: oneSimpleSelector,
            items: matches
        };
        items = rest;
    }
    return groups;
}
function spliceSimpleSelector(item, predicate) {
    const simpsels = item.ast.list;
    const matches = new Array(simpsels.length);
    let firstIndex = -1;
    for(let i = simpsels.length; i-- > 0;){
        if (predicate(simpsels[i])) {
            matches[i] = true;
            firstIndex = i;
        }
    }
    if (firstIndex == -1) {
        throw new Error(`Couldn't find the required simple selector.`);
    }
    const result = simpsels[firstIndex];
    item.ast.list = simpsels.filter((sel, i)=>!matches[i]);
    return result;
}
function findTopKey(items, predicate, keyCallback) {
    const candidates = {};
    for (const item of items){
        const candidates1 = {};
        for (const node of item.ast.list.filter(predicate)){
            candidates1[keyCallback(node)] = true;
        }
        for (const key of Object.keys(candidates1)){
            if (candidates[key]) {
                candidates[key]++;
            } else {
                candidates[key] = 1;
            }
        }
    }
    let topKind = "";
    let topCounter = 0;
    for (const entry of Object.entries(candidates)){
        if (entry[1] > topCounter) {
            topKind = entry[0];
            topCounter = entry[1];
        }
    }
    return topKind;
}
function partition(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src){
        if (predicate(x)) {
            matches.push(x);
        } else {
            rest.push(x);
        }
    }
    return {
        matches,
        rest
    };
}
function partition1(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src){
        if (predicate(x)) {
            matches.push(x);
        } else {
            rest.push(x);
        }
    }
    return {
        matches,
        rest
    };
}
class Picker {
    constructor(f){
        this.f = f;
    }
    pickAll(el) {
        return this.f(el);
    }
    pick1(el, preferFirst = false) {
        const results = this.f(el);
        const len = results.length;
        if (len === 0) {
            return null;
        }
        if (len === 1) {
            return results[0].value;
        }
        const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
        let result = results[0];
        for(let i = 1; i < len; i++){
            const next = results[i];
            if (comparator(result, next)) {
                result = next;
            }
        }
        return result.value;
    }
}
function comparatorPreferFirst(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || diff === 0 && next.index > acc.index;
}
exports.Ast = Ast;
exports.DecisionTree = DecisionTree;
exports.Picker = Picker;
exports.Treeify = TreeifyBuilder;
exports.Types = Types;


/***/ }),

/***/ 73718:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _react_email_body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22294);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_body__WEBPACK_IMPORTED_MODULE_0__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_body__WEBPACK_IMPORTED_MODULE_0__.Text; } });
/* harmony import */ var _react_email_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32969);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_button__WEBPACK_IMPORTED_MODULE_1__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_button__WEBPACK_IMPORTED_MODULE_1__.Text; } });
/* harmony import */ var _react_email_column__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23703);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_column__WEBPACK_IMPORTED_MODULE_2__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_column__WEBPACK_IMPORTED_MODULE_2__.Text; } });
/* harmony import */ var _react_email_container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20142);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_container__WEBPACK_IMPORTED_MODULE_3__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_container__WEBPACK_IMPORTED_MODULE_3__.Text; } });
/* harmony import */ var _react_email_font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11493);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_font__WEBPACK_IMPORTED_MODULE_4__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_font__WEBPACK_IMPORTED_MODULE_4__.Text; } });
/* harmony import */ var _react_email_head__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(83229);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_head__WEBPACK_IMPORTED_MODULE_5__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_head__WEBPACK_IMPORTED_MODULE_5__.Text; } });
/* harmony import */ var _react_email_heading__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(80554);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_heading__WEBPACK_IMPORTED_MODULE_6__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_heading__WEBPACK_IMPORTED_MODULE_6__.Text; } });
/* harmony import */ var _react_email_hr__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(35526);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_hr__WEBPACK_IMPORTED_MODULE_7__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_hr__WEBPACK_IMPORTED_MODULE_7__.Text; } });
/* harmony import */ var _react_email_html__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(66240);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_html__WEBPACK_IMPORTED_MODULE_8__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_html__WEBPACK_IMPORTED_MODULE_8__.Text; } });
/* harmony import */ var _react_email_img__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98388);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_img__WEBPACK_IMPORTED_MODULE_9__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_img__WEBPACK_IMPORTED_MODULE_9__.Text; } });
/* harmony import */ var _react_email_link__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(24533);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_link__WEBPACK_IMPORTED_MODULE_10__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_link__WEBPACK_IMPORTED_MODULE_10__.Text; } });
/* harmony import */ var _react_email_preview__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(20908);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_preview__WEBPACK_IMPORTED_MODULE_11__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_preview__WEBPACK_IMPORTED_MODULE_11__.Text; } });
/* harmony import */ var _react_email_render__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(74449);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_render__WEBPACK_IMPORTED_MODULE_12__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_render__WEBPACK_IMPORTED_MODULE_12__.Text; } });
/* harmony import */ var _react_email_row__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(74549);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_row__WEBPACK_IMPORTED_MODULE_13__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_row__WEBPACK_IMPORTED_MODULE_13__.Text; } });
/* harmony import */ var _react_email_section__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(57353);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_section__WEBPACK_IMPORTED_MODULE_14__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_section__WEBPACK_IMPORTED_MODULE_14__.Text; } });
/* harmony import */ var _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(97026);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_tailwind__WEBPACK_IMPORTED_MODULE_15__.Text; } });
/* harmony import */ var _react_email_text__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(68763);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Body")) __webpack_require__.d(__webpack_exports__, { Body: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Body; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Button")) __webpack_require__.d(__webpack_exports__, { Button: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Button; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Column")) __webpack_require__.d(__webpack_exports__, { Column: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Column; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Container")) __webpack_require__.d(__webpack_exports__, { Container: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Container; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Head")) __webpack_require__.d(__webpack_exports__, { Head: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Head; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Heading")) __webpack_require__.d(__webpack_exports__, { Heading: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Heading; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Hr")) __webpack_require__.d(__webpack_exports__, { Hr: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Hr; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Html")) __webpack_require__.d(__webpack_exports__, { Html: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Html; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Img")) __webpack_require__.d(__webpack_exports__, { Img: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Img; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Link")) __webpack_require__.d(__webpack_exports__, { Link: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Link; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Preview")) __webpack_require__.d(__webpack_exports__, { Preview: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Preview; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Row")) __webpack_require__.d(__webpack_exports__, { Row: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Row; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Section")) __webpack_require__.d(__webpack_exports__, { Section: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Section; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_email_text__WEBPACK_IMPORTED_MODULE_16__, "Text")) __webpack_require__.d(__webpack_exports__, { Text: function() { return _react_email_text__WEBPACK_IMPORTED_MODULE_16__.Text; } });
// src/index.ts



















/***/ }),

/***/ 90432:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"126":{"host":"smtp.126.com","port":465,"secure":true},"163":{"host":"smtp.163.com","port":465,"secure":true},"1und1":{"host":"smtp.1und1.de","port":465,"secure":true,"authMethod":"LOGIN"},"Aliyun":{"domains":["aliyun.com"],"host":"smtp.aliyun.com","port":465,"secure":true},"AOL":{"domains":["aol.com"],"host":"smtp.aol.com","port":587},"Bluewin":{"host":"smtpauths.bluewin.ch","domains":["bluewin.ch"],"port":465},"DebugMail":{"host":"debugmail.io","port":25},"DynectEmail":{"aliases":["Dynect"],"host":"smtp.dynect.net","port":25},"Ethereal":{"aliases":["ethereal.email"],"host":"smtp.ethereal.email","port":587},"FastMail":{"domains":["fastmail.fm"],"host":"smtp.fastmail.com","port":465,"secure":true},"Forward Email":{"aliases":["FE","ForwardEmail"],"domains":["forwardemail.net"],"host":"smtp.forwardemail.net","port":465,"secure":true},"Feishu Mail":{"aliases":["Feishu","FeishuMail"],"domains":["www.feishu.cn"],"host":"smtp.feishu.cn","port":465,"secure":true},"GandiMail":{"aliases":["Gandi","Gandi Mail"],"host":"mail.gandi.net","port":587},"Gmail":{"aliases":["Google Mail"],"domains":["gmail.com","googlemail.com"],"host":"smtp.gmail.com","port":465,"secure":true},"Godaddy":{"host":"smtpout.secureserver.net","port":25},"GodaddyAsia":{"host":"smtp.asia.secureserver.net","port":25},"GodaddyEurope":{"host":"smtp.europe.secureserver.net","port":25},"hot.ee":{"host":"mail.hot.ee"},"Hotmail":{"aliases":["Outlook","Outlook.com","Hotmail.com"],"domains":["hotmail.com","outlook.com"],"host":"smtp-mail.outlook.com","port":587},"iCloud":{"aliases":["Me","Mac"],"domains":["me.com","mac.com"],"host":"smtp.mail.me.com","port":587},"Infomaniak":{"host":"mail.infomaniak.com","domains":["ik.me","ikmail.com","etik.com"],"port":587},"Loopia":{"host":"mailcluster.loopia.se","port":465},"mail.ee":{"host":"smtp.mail.ee"},"Mail.ru":{"host":"smtp.mail.ru","port":465,"secure":true},"Mailcatch.app":{"host":"sandbox-smtp.mailcatch.app","port":2525},"Maildev":{"port":1025,"ignoreTLS":true},"Mailgun":{"host":"smtp.mailgun.org","port":465,"secure":true},"Mailjet":{"host":"in.mailjet.com","port":587},"Mailosaur":{"host":"mailosaur.io","port":25},"Mailtrap":{"host":"live.smtp.mailtrap.io","port":587},"Mandrill":{"host":"smtp.mandrillapp.com","port":587},"Naver":{"host":"smtp.naver.com","port":587},"One":{"host":"send.one.com","port":465,"secure":true},"OpenMailBox":{"aliases":["OMB","openmailbox.org"],"host":"smtp.openmailbox.org","port":465,"secure":true},"Outlook365":{"host":"smtp.office365.com","port":587,"secure":false},"OhMySMTP":{"host":"smtp.ohmysmtp.com","port":587,"secure":false},"Postmark":{"aliases":["PostmarkApp"],"host":"smtp.postmarkapp.com","port":2525},"qiye.aliyun":{"host":"smtp.mxhichina.com","port":"465","secure":true},"QQ":{"domains":["qq.com"],"host":"smtp.qq.com","port":465,"secure":true},"QQex":{"aliases":["QQ Enterprise"],"domains":["exmail.qq.com"],"host":"smtp.exmail.qq.com","port":465,"secure":true},"SendCloud":{"host":"smtp.sendcloud.net","port":2525},"SendGrid":{"host":"smtp.sendgrid.net","port":587},"SendinBlue":{"aliases":["Brevo"],"host":"smtp-relay.brevo.com","port":587},"SendPulse":{"host":"smtp-pulse.com","port":465,"secure":true},"SES":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-EAST-1":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-WEST-2":{"host":"email-smtp.us-west-2.amazonaws.com","port":465,"secure":true},"SES-EU-WEST-1":{"host":"email-smtp.eu-west-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTH-1":{"host":"email-smtp.ap-south-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-1":{"host":"email-smtp.ap-northeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-2":{"host":"email-smtp.ap-northeast-2.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-3":{"host":"email-smtp.ap-northeast-3.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-1":{"host":"email-smtp.ap-southeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-2":{"host":"email-smtp.ap-southeast-2.amazonaws.com","port":465,"secure":true},"Sparkpost":{"aliases":["SparkPost","SparkPost Mail"],"domains":["sparkpost.com"],"host":"smtp.sparkpostmail.com","port":587,"secure":false},"Tipimail":{"host":"smtp.tipimail.com","port":587},"Yahoo":{"domains":["yahoo.com"],"host":"smtp.mail.yahoo.com","port":465,"secure":true},"Yandex":{"domains":["yandex.ru"],"host":"smtp.yandex.ru","port":465,"secure":true},"Zoho":{"host":"smtp.zoho.com","port":465,"secure":true,"authMethod":"LOGIN"}}');

/***/ }),

/***/ 60983:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"nodemailer","version":"6.9.14","description":"Easy as cake e-mail sending from your Node.js applications","main":"lib/nodemailer.js","scripts":{"test":"node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","test:coverage":"c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","lint":"eslint .","update":"rm -rf node_modules/ package-lock.json && ncu -u && npm install"},"repository":{"type":"git","url":"https://github.com/nodemailer/nodemailer.git"},"keywords":["Nodemailer"],"author":"Andris Reinman","license":"MIT-0","bugs":{"url":"https://github.com/nodemailer/nodemailer/issues"},"homepage":"https://nodemailer.com/","devDependencies":{"@aws-sdk/client-ses":"3.600.0","bunyan":"1.8.15","c8":"10.1.2","eslint":"8.57.0","eslint-config-nodemailer":"1.2.0","eslint-config-prettier":"9.1.0","libbase64":"1.3.0","libmime":"5.3.5","libqp":"2.1.0","nodemailer-ntlm-auth":"1.0.4","proxy":"1.0.2","proxy-test-server":"1.0.0","smtp-server":"3.13.4"},"engines":{"node":">=6.0.0"}}');

/***/ }),

/***/ 16311:
/***/ ((module) => {

"use strict";
module.exports = {"version":"3.13.0"};

/***/ })

};
;